//encoding: utf-8
include::global_attr.adoc[]
= Weboberfläche mit HTTPS absichern
:revdate: :draft
:title: Weboberfläche mit HTTPS absichern
:description: Es gibt viele Gründe, Weboberflächen nur über HTTPS zu betreiben. In diesem Artikel erfahren Sie, wie Sie die Verschlüsselung für eine {CMK}-Instanz aktivieren.
// MFS: Ähem: Gründe? Sicherheit ist wohl am wichtigsten, oder? Evtl. sollten das hervorheben.

{related-start}
xref:web_api#[Konfiguration via HTTP-API]
xref:kerberos#[Single Sign-On mit Kerberos]
xref:ldap#[Benutzerverwaltung mit LDAP/Active Directory]
{related-end}
//SP: Umstellung auf xref-Verweise?
// TK: done
// TK: Aber Links überprüfen: Die 3 haben doch gar nix mit dem Thema zu tun.

//SP: Allgemein: extrem komplexes Thema, vieles musste ich mehrfach lesen (und etliches googlen), um es ohne ausgeprägtes Hintergrundwissen halbwegs verstehen zu können.
// TK: Meine generellen Kommentare stehen im Ticket


== Einleitung

Wenn Sie die Weboberfläche von {CMK} über HTTPS einsetzen möchten, dann müssen Sie auf Ihrem Monitoring-Server -- unabhängig von Ihren Instanzen -- folgende Voraussetzungen schaffen:

* Sie besitzen ein gültiges Server-Zertifikat.
* Das Apache-Modul `mod_ssl` ist installiert und aktiviert.
* Der Server ist über HTTPS erreichbar.
* Das Rewrite- und das Headers-Modul für den Webserver sind vorhanden und geladen.

Was dafür zu tun ist, erklärt dieser Artikel.

== Apache-Module aktivieren

Die HTTPS-Absicherung der {CMK}-Oberfläche benötigt das Apache-Modul `mod_ssl`, wir gehen im weiteren Verlauf der Einrichtung zudem davon aus, dass eine eingehende Verbindung auf den unverschlüsselten Port 80 auf den SSL verschlüsselten Port 443 weitergeleitet werden soll. Hierfür sind die Module `mod_headers` und `mod_rewrite` nötig. 

Verwenden Sie das Kommando `apachectl` (alte CentOS- und RHEL-Versionen benötigen möglicherweise stattdessen `httpd`), um die geladenen Module anzuzeigen. Mit `grep` prüfen Sie gleich, ob alle drei benötigten Module vorhanden sind:

[{shell}]
----
{c-root} *apachectl -M | grep -E 'headers|rewrite|ssl'*
 headers_module (shared)
 rewrite_module (shared)
----

Die Aktivierung fehlender Module gelingt auf den meisten Distributionen mit dem Script `a2enmod`. Es legt Softlinks im Ordner `/etc/apache2/mods-enabled` an. Die Datei mit Endung `.load` enthält dabei Anweisungen zum Laden des Moduls, `.conf` die eigentliche Konfiguration des Moduls:

// MA: Ich würde erst die Erläuterung reinsetzen und danach das Kommando. So ist es
// MA: dann auch näher am Beispiel, was direkt nach dem Absatz folgt. Generell kann
// MA: man mit a2enmod auch mehrere Module gleichzeitig aktivieren. Also sozusagen
// MA: alle, die benötigt werden. Damit würde man sich auch die Prüfung aus
// MA: Abschnitt 2.1 sparen.
// MFS: Didaktik - der Nutzer soll wissen, was neu zu aktivieren ist, hilft mglw. beim Troubleshooting

[{shell}]
----
{c-root} *a2enmod ssl*
Enabling module ssl.
To activate the new configuration, you need to run:
  systemctl restart apache2
----

// MFS: Getestet mit CentOS 7, alles davor solle irrelevat sein, globale /etc/httpd/conf/httpd.conf nur nach Update früherer Versionen
Bei älteren Versionen von RHEL und darauf basierenden Distributionen ist `mod_ssl` ein eigenes Paket, das Sie separat installieren müssen:

[{shell}]
----
{c-root} *yum install -y httpd mod_ssl*
----

Ist das Kommando `a2enmod` nicht vorhanden, arbeiten Sie mit einer Distribution, welche die Apache-Konfiguration statt auf Verzeichnisse und viele Einzeldateien aufzuteilen in einer einzigen Konfigurationsdatei vorhält.
In solch einem Fall muss in der Konfigurationsdatei `/etc/httpd/conf/httpd.conf` die auskommentierte Zeile `LoadModule ssl_module [...]` vom `#` befreit werden.
Analog ist für die beiden anderen Module vorzugehen.

Ob der Apache-Webserver bereits jetzt oder erst später neu gestartet werden kann, entscheidet sich an der Frage, ob bei der Installation von Apache einfache, selbst signierte Zertifikate automatisch erzeugt wurden.

Dies erfahren Sie, indem Sie zunächst nach der Konfigurationsdatei suchen, welche die Pfade zu Zertifikat und Schlüsseln enthält und dann prüfen, ob diese Dateien existieren (bei RHEL ist als Startverzeichnis der Suche `/etc/httpd` anzugeben):

[{shell}]
----
{c-root} find /etc/apache2/ -type f -exec grep -Hn '^\s*SSLCertificate.*File' {} \;
/etc/apache2/sites-available/default-ssl.conf:32: SSLCertificateFile	/etc/ssl/certs/ssl-cert-snakeoil.pem
/etc/apache2/sites-available/default-ssl.conf:33: SSLCertificateKeyFile /etc/ssl/private/ssl-cert-snakeoil.key
----

Prüfen Sie, ob die in der Konfigurationsdatei angegebenen Dateinamen existieren.
Falls kein automatisch erstelltes Zertifikat vorhanden ist, warten Sie mit dem Neustart des Apache-Webservers, bis Sie ein Zertifikat erhalten oder selbst erstellt haben – sonst schlägt der Neustart fehl.

// MA: Warum? Mache ich etwas kaputt, wenn ich die Module schon lade, obwohl ich keine Zertifikate eingestellt habe?
// MFS: Ergänzt.

Wurden Schlüssel und Start automatisch erzeugt, starten Sie den Apache-Webserver neu, beim mittlerweile standardmäßig verwendeten `systemd` ist der erste Befehl zu verwenden:

[{shell}]
----
{c-root} systemctl restart apache2
----

Wieder gilt: Einige Distributionen verwenden als Name des Dienstes nicht `apache2`, sondern das etwas generischere `httpd`.
Passen Sie in diesem Fall den Befehl an.

// MA: Sehr unübersichtlich. Pro Kommandozeilenbeispiel immer nur ein Kommando
// MA: verwenden. Da es hier normalerweise keine Ausgabe gibt, könnte man sich ein
// MA: Shell-Beispiel vielleicht sogar ganz sparen. Ich würde hier auch generell
// MA: nur ein Beispiel nennen. Systemd bietet sich da schon sehr an - der Verweis
// MA: auf apache2/httpd ist aber ganz gut.


== Zertifikate erhalten

// MA: Ich finde den gesamten Abschnitt an den meisten Stellen doch zu spezifisch. Aus meiner Sicht gibt es genau die drei Szenarien, die Du beschrieben hast: Zertifkate über eine csr, letsencrypt und selbstsignierte. Bei ersterem und letzterem habe ich Bauchschmerzen dabei, wenn wir hier ausführlich beschreiben:
// MA: * CSR: Hier sind die Vorgehen von Unternehmen zu Unternehmen sehr unterschiedlich. Einzige Gemeinsamkeit: Es braucht eine CSR. Wie die erstellt wird, ist aber wieder unternehmensbedingt sehr unterschiedlich. Aus meiner Sicht lässt sich das nicht sinnvoll generisch beschreiben.
// MA: * Letsencrypt: Keine Einwände, da wesentlicher Punkt in der Open-Source-Szene und auch darüber hinaus. Geht natürlich nur, wenn der Checkmk-Server im Internet steht - das trifft hoffentlich auf nicht besonders viele Fälle zu.
// MA: * selbstsignierte Zertifikate: Schwierig. Da gibt es tausende Anleitungen. Welche zu einem passt, sollten wir dem User überlassen und nicht hier beschreiben. Schließlich geht es ja am Ende darum, wie man HTTPS bei Checkmk aktiviert. Da finde ich es legitim zu schreiben, dass es selbstsignierte Zertifikate gibt und man sich im Internet umschauen kann, wie man sich so eins erstellt.


Im Wesentlichen existieren die folgenden Methoden, um an ein Server-Zertifikat zu gelangen:
// TK: Ich würde die Reihenfolge umstellen, ist logischer und ausserdem kommt der Riemen dann am Schluss: 1. oldschoolcsr 2. letsencrypt 3. becomeca

* Sie greifen auf einen externen Dienstleister für die xref:oldschoolcsr[Zertifikatsausstellung mittels CSR] (_Certificate Signing Request_) zurück, dessen Root-Zertifikat von Browser- und Betriebssystemherstellern vertraut wird.
Dieses Verfahren erlaubt auch Organisations-Validierung und höher, wie sie in einigen Branchen aus regulatorischen Gründen verpflichtend ist.
// Je nach Stufe der Validierung wird nur geprüft, ob Sie Webmaster einer Domain sind oder es müssen Handelsregisterauszüge eingereicht werden.
// Nachteil: das Verfahren kostet Geld und verursacht Verwaltungsaufwand.
// TK: Registergericht problematisch: als Info für D kennzeichnen
// MFS: Das prinzipielle Vorgehen ist in jeder Jurisdiktion gleich, Englisch: trade register, oder commercial register
// MA: Generell ziemlich wertend. Der Nachteil mit dem Geld betrifft aus meiner Sicht nur Privatpersonen.
// MFS: Weg der Validierung hier nicht mehr, stattdessen 
* Sie nutzen xref:letsencrypt[kostenlose Zertifikate von _Letsencrypt_].
Dieses Verfahren erlaubt nur Validierung auf Domain-Ebene.
Um Zertifikate anfordern zu können, muss der abzusichernde Server von außen erreichbar sein oder Sie müssen die Möglichkeit haben, (automatisiert) Einträge im öffentlichen DNS der verwendeten Domain anzulegen.
// Nachteil: Sie müssen entweder Zugriff auf den Server haben, dessen Zertifikate Sie ausstellen wollen (und der muss von außen erreichbar sein), oder Sie müssen im Nameserver Ihrer Domain Einträge anlegen und ändern können.
* Sie werden Ihre xref:becomeca[eigene _Certificate Authority_ (CA)] und erzeugen Zertifikate selbst.
Das Root-Zertifikat der eigenen CA muss auf allen Rechnern vorhanden sein, die mit Servern kommunizieren, die mit dem CA-Schlüssel signierte Zertifikate verwenden.
Zudem sollten im Umgang mit der eigenen CA hohe Sicherheitsstandards eingehalten werden, da mit ihr Zertifikate für beliebige Domains ausgestellt werden können.
// Nachteil: Sie müssen strikte Sicherheitsregeln einhalten und die CA in die Browser der Nutzer importieren, die {CMK} verwenden sollen.
// MA: Wir wollen eigentlich "müssen" vermeiden. Was sind das für Sicherheitsregeln? Was passiert, wenn ich sie nicht einhalte? Der Punkt ist sehr unkonkret.
// MFS: "sollten" und konkreter. In dem Fall ist "sollten" aber eigentlich "müssen", weil bei Nichteinhaltung Schaden droht.

[#oldschoolcsr]
=== Zertifikate per CSR erhalten

Zertifikate bei einer kommerziellen Certificate Authority signieren zu lassen, war lange Zeit der einzige Weg, von allen Browsern und Betriebssystemen akzeptierte Zertifikate zu erhalten. 
Dieses Verfahren ist heute insbesondere dann noch üblich, wenn lange Gültigkeitszeiträume erwünscht ist.
Es ist erforderlich, wenn Validierung auf Organisationsebene (Organization Validation, kurz OV) oder höher (Extended Validation, kurz EV) benötigt wird.
// TK: "Organisationsebene oder höher": ?
//  MFS: bspw. Bestätigtung, dass die Domain checkmk-topsupport.com auch wirklich tribe29 GmbH gehört, ist OV
// MA: Da das eher Insiderwissen ist, hätte ich eher auf einfache Beispiele verwiesen. Der Fokus des Artikels ist ja u.a.: "Ich hab jetzt einen CMK-Server. Was muss ich tun, damit der nur noch über HTTPS erreichbar ist?" Hilft die Einleitung, besser zu vertehen, weshalb ich eine CSR benötige und was eine CSR ist? Bisher ist mir nur gezeigt worden, was hinter der Abkürzung steht.

Die Abfolge ist, dass Sie zunächst den privaten Serverschlüssel erzeugen und dann für diesen ein _Certificate Signing Request_ erstellen, welches Sie an den ausgewählten Anbieter übertragen.
Der prüft dann die Inhaberschaft der Domain, bestätigt das CSR mit seinem Schlüssel und schickt Ihnen das resultierende Serverzertifikat.

[#createcsr]
==== Schlüssel und CSR erzeugen

Zunächst erzeugen Sie den privaten Server-Schlüssel.
Diesen Schritt können Sie direkt auf dem Server durchführen, auf dem die abzusichernde {CMK}-Instanz läuft.

Der Ordner `/etc/certs` entspricht dem Standard vieler Distributionen, Sie können aber jeden beliebigen Ordner verwenden, auf den der Apache-Prozess lesend zugreifen kann.
Den Schlüssel nach dem primären Domainnamen zu benennen, für den er verwendet wird, dient hier der besseren Übersicht.
Insbesondere wenn später weitere Hostnamen hinzukommen sollten, für die eigene Schlüssel/Zertifikate verwendet werden, erleichtert dieses Namensschema die Zuordnung:

[{shell}]
----
{c-root} *openssl genrsa -out /etc/certs/checkmk.mydomain.com.key 2048*
Generating RSA private key, 2048 bit long modulus (2 primes)
.....+++++
...............................................................+++++
e is 65537 (0x010001)
----
// TK: Kommandoausgabe sagt, dass ich einen "RSA private key" erzeuge: siehe Frage von oben?
// MFS: Das ist korrekt, dieser Schlüssel dient später dazu, den TLS-Verkehr zu verschlüsseln
// MA: Auch hier wieder mehrere Kommandos in einem prompt-Beispiel. Diesmal sogar ohne Ausgabe, damit ich nachprüfen kann, ob es bei mir ähnlich aussieht. Hier fehlt mir einiges: Eine Erläuterung, weshalb ich ein Verzeichnis unter /etc erzeugen soll, was das openssl-Kommando denn nun mit genau diesen Optionen macht und warum ich das eigentlich mache. TK hatte ja dasselbe Problem. Dem Leser wird nicht zwangsläufig klar, was er und warum er es tut. Wofür benötigt er einen privaten Server-Schlüssel? Was macht der? Wir sollten auch midnestens einmal pro Artikel erwähnen, dass "checkmk.mydomain.com.key" ein Beispiel ist, welches wir hier verwenden.

Im nächsten Schritt erstellen Sie das _Certificate Signing Request_:
// MA: Was genau ist denn nun ein "Certificate Signing Request"? Das sollte direkt am Anfang kurz geklärt werden, damit man dem Rest besser folgen kann.

[{shell}]
----
{c-root} *openssl req -new -key checkmk.mydomain.com.key -out checkmk.mydomain.com.csr*
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
---
Country Name (2 letter code) [AU]: *DE*
State or Province Name (full name) [Some-State]: *Bavaria*
Locality Name (eg, city) []: *Munich*
Organization Name (eg, company) [Internet Widgits Pty Ltd]: *Yoyodyne Inc.*
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []: *checkmk.mydomain.com*
Email Address []: *webmaster@mydomain.com*

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
----

Achten Sie darauf, die Angaben zum Unternehmen korrekt anzugeben und als `Common Name` den Server-Namen einzutragen. Die eingetragene E-Mail-Adresse sollte in derselben Domain liegen und zu einem existierenden und gelesenen Postfach gehören.

==== Extension-Datei erstellen

Moderne Browser erfordern Zertifikate, welche die Erweiterung für _Alternate Hostnames_ nutzen, selbst wenn sie nur für einen Hostnamen ausgestellt werden. Dies erfordert eine Extension-Datei, welche manche Anbieter automatisch erstellen und integrieren. Ist das nicht der Fall oder Sie sind unsicher, erstellen Sie eine solche Datei:

./tmp/checkmk.mydomain.com.ext
[source]
----
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = checkmk.mydomain.com
----

==== Unterlagen einreichen

Je nach angestrebtem Validierungslevel kann es erforderlich sein, weitere Unterlagen wie Handelsregisterauszüge oder Bankdaten zusammenzustellen.
Da die angeforderten Unterlagen, die Wege der Einreichung und die Wege der Bestätigung von Anbieter zu Anbieter verschieden sind, kann hier keine allgemein gültige Anleitung gegeben werden.
So kann Extended Validation beispielsweise auch bedeuten, dass per Einschreiben ein Code an Geschäftsführer oder Prokurist verschickt wird, der über ein Webformular eingegeben werden muss.

Im einfachsten Fall einer Validierung nur auf Domain-Ebene wird die CSR-Datei und gegebenenfalls die EXT-Datei über ein Webinterface hochgeladen.
Sie erhalten dann die Möglichkeit, eine E-Mail-Adresse aus den für Admin-C (Inhaber) oder Tech-C (technisch verantwortlicher) der Domain hinterlegten oder generischen E-Mail-Adressen wie `webmaster@domain.tld` auszuwählen.
An diese Adresse wird dann ein Bestätigungslink verschickt.

==== Erhalten des Zertifikates

Der Prüfungsvorgang selbst dauert bei Validierung auf Domainebene maximal einige Minuten, bei EV-Validierung mehrere Tage.
Sobald dieser abgeschlossen ist, erhalten Sie das zu Ihrem Schlüssel gehörende Zertifikat per E-Mail oder Download.
Neben dem Zertifikat erhalten Sie auch einen Downloadlink zur _Zertifikatskette_ (_Certificate Chain File_).
Speichern Sie diese unbedingt mit ab. 

[#letsencrypt]
=== Letsencrypt

// MA: Warum finde ich es in Ordnung, wenn man letsencrypt explizit erwähnt und
// MA: andere nicht? Weil ersteres der defacto-Standard für kostenfreie, offizielle
// MA: Zertifikate ist. Zudem ist er kostenfrei und damit bewerben kein kommerzielles Angebot.


Ist ein Server von außen erreichbar oder haben Sie Zugriff auf den Nameserver, können Sie automatisiert Zertifikate über den zu der Electronic Frontier Foundation (EFF) gehörenden Non-Profit-Dienstleister link:https://letsencrypt.org/#[Letsencrypt] erstellen lassen.
// TK: Hier Letsencrypt nochmal verlinken
//SP: Bei der ersten Erwähnung einer Bezeichnung (hier: Electronic Frontier Foundation) sollte die Abkürzung in Klammern eingeführt werden. Danach kann dann die Abkürzung eigenständig verwendet werden.
Es entstehen keine Kosten.
Per DNS validierte Zertifikate erfordern alle 90 Tage wenige Minuten Aufmerksamkeit, per Server-Verzeichnis validierte Zertifikate können Jahre lang automatisch neu erzeugt werden.

// MA: Liest sich eher wie ein Werbetext. ;)

Für Letsencrypt-Zertifikate stellt die EFF das Python-Programm _Certbot_ in vielen verschiedenen Paketformaten bereit.
Der Certbot übernimmt die Erstellung des Schlüssels, den Versand der CSR und die Prüfung der Inhaberschaft von Server oder Domain.
Er kommuniziert hierfür über das Protokoll link:https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment#[_Automatic Certificate Management Environment_ (ACME)^] mit den Servern der EFF.

==== Installation des Certbot-Scriptes

Es existieren drei Möglichkeiten, Certbot zu installieren. Welche Sie wählen, dürfte vor allem vom Alter der eingesetzten Distribution und den Policies in Ihrem Unternehmen zur Installation aus fremden Paketquellen abhängen:

* Wenn das Paketmanagement Ihrer Linux-Distribution Certbot-Version 1.10 oder höher bereitstellt, kann diese verwendet werden.
* Certbot ist über das Python-Paketinstallationstool `pip3` aus dem link:https://pypi.org/project/certbot/#[Python Package Index] installierbar. Der Befehl `pip3 install certbot` installiert alle abhängig benötigten Python-Module. 
* Die EFF bevorzugt auf ihrer link:https://certbot.eff.org/instructions#[Certbot-Dokumentationsseite] die Installation aus einem Snap-Image. Es gelten die bekannten Vor- und Nachteile des Snap-Paketformates.



// MA: Ich würde eigentlich nur die dritte Variante erwähnen. Die Installation wirkt jetzt sehr kompliziert und abschreckend.
// MFS: Deutlich verkürzt
// *Hinweis:* Certbot 0.40 aus Ubuntu 20.04 war die früheste Certbot-Version, mit der wir Stand März 2022 ohne Änderung der Konfiguration Letsencrypt-Zertifikate anfordern konnten. Ältere Versionen mögen ACME v2 fähig sein, decken aber unter Umständen nicht den kompletten Funktionsumfang von ACME v2, lassen DNS-Plugins vermissen oder erfordern teils manuelle Konfiguration.

// MA: Wenn der Hinweis eine Relevanz in einem späteren Abschnitt hat, sollte der
// MA: Abschnitt hier schon verlinkt werden. Ansonsten sehe ich den Mehrwert nicht.

==== Vollautomatische Konfiguration

Falls der {CMK}-Server aus dem Internet erreichbar ist und Sie an der Konfiguration des systemweiten Apache Webservers seit der Installation von {CMK} keine Änderung vorgenommen haben, können Sie den "Apache-Automatismus" von Certbot verwenden, um Schlüssel zu erzeugen, Zertifikate anzufordern, die Apache-Konfiguration automatisch anzupassen und schließlich einen Cronjob einzurichten, um regelmäßig die 90 Tage laufenden Zertifikate zu erneuern.

[{shell}]
----
{c-root} certbot --apache
----

Das Script fragt nun interaktiv einige Informationen zu Kontaktdaten (E-Mail-Kontakt für zusätzliche Informationen wie notwendige Zertifikatsrückrufe) und Installationspfaden ab, am Ende steht die funktionsfähige SSL-Konfiguration.

// Da die Parameter des Scriptes gelegentlichen Änderungen unterworfen sind, empfehlen wir, der jeweils aktuellen Anleitung in der Certbot-Dokumentation (link:https://certbot.eff.org/instructions?ws=apache&os=ubuntufocal[hier für Ubuntu 20.04, andere Betriebssysteme per Dropdown auswählbar^]) zu folgen.

==== Teilautomatische Konfiguration

Falls Sie wie im letzten Abschnitt beschrieben Zertifikate anfordern, aber die Apache-Konfiguration selbst anpassen wollen, verwenden Sie den Befehl:

[{shell}]
----
{c-root} certbot certonly --apache
----

Die Konfiguration schließen Sie dann wie unten beschrieben in der Konfigurationsdatei für `mod_ssl` ab.

==== Weitere Möglichkeiten

Ist der {CMK}-Server beispielsweise nur aus dem Intranet oder per VPN erreichbar, aber der DNS-Server öffentlich, können Sie die Validierung über eine _DNS-Challenge_ vornehmen.
Hier wird die Inhaberschaft einer Domain nicht darüber geprüft, Dateien auf dem Webserver ablegen zu können, sondern darüber, dass Sie Einträge im DNS hinzufügen können.
Dabei kommen keine Einträge zur Anwendung, die einen Hostnamen zu einer IP-Adresse auflösen, sondern sogenannte TXT-Einträge, die beliebige Zeichenketten enthalten können.
TXT-Einträge werden beispielsweise auch verwendet, um anzugeben, welche Server Mail für eine Domain versenden dürfen.

DNS-Challenges können manuell durchgeführt werden, was bei 90 Tagen Gültigkeit meist nur für einzelne Testsysteme praktikabel ist.
Verfügt Ihr DNS-Anbieter über ein von Letsencrypt unterstütztes API, kann auch automatische Erneuerung durchgeführt werden.
Lesen Sie hierfür die link:https://letsencrypt.org/de/docs/challenge-types/[Übersicht der Challenge Typen] bei Letsencrypt.

[#becomeca]
=== Interne CA verwenden

Sie können sich selbst in die Rolle einer CA versetzen und Zertifikate für beliebige Domains (Ihre Domains, fremde Domains und Phantasie-Domains) ausstellen.
Der Weg über die eigene CA ist vor allem für Testumgebungen oder abgeschottete {CMK}-Server mit überschaubarer Nutzerzahl sinnvoll.
Dies ist zudem die einzige Möglichkeit, Zertifikate zu erhalten, wenn Sie intern eine der fünf reservierten TLDs `.example`, `.invalid`, `.local`, `.localhost`, oder `.test` verwenden.
Für diese Domains gibt es keine Registrare, folglich kann keine Inhaberschaft bestätigt werden.

Dieses Kapitel erklärt die Ausstellung von Zertifikaten mit solch einer internen CA.
Als Voraussetzungen werden angenommen, dass Sie bereits über den privaten CA-Root- oder CA-Intermediate-Schlüssel verfügen und diesen nun verwenden sollen, um Zertifikate zur Absicherung eines {CMK}-Servers auszustellen. 
Die Erstellung der CA-Schlüssel, des CA-Zertifikats und der dazugehörigen Konfigurationsdatei ist nicht Bestandteil der Anleitung.

==== Schlüssel und CSR erzeugen

Gehen Sie für die Erstellung von Serverschlüssel, Certificate Signing Request und Extension-Datei wie im Abschnitt xref:createcsr[Schlüssel und CSR erzeugen] erklärt vor.
Die Vorgehensweise und die benötigten Dateien sind identisch.

[#signyourself]
==== CSR signieren

Um selbst Zertifikate zu signieren, haben Sie wenigstens einen privaten Schlüssel (hier `intermediate.key.pem`) und das dazugehörige Intermediate-Zertifikat `intermediate.pem` erhalten.
Falls Sie zudem über eine Konfigurationsdatei verfügen, ist der Pfad zu dieser mit dem Parameter `--config` anzugeben.

Die Signatur auf Basis der CSR-Datei `checkmk.mydomain.com.csr`, Extensiondatei `checkmk.mydomain.com.ext` und der Ausgabedatei `checkmk.mydomain.com.crt` erledigen Sie dann mit dem Befehl:

[{shell}]
----
bob@pc:~$ openssl x509 -CAcreateserial -req \
    -in checkmk.mydomain.com.csr \
    -CA intermediate.pem -CAkey intermediate.key.pem \
    -out checkmk.mydomain.com.crt -days 365 \
    -sha256 -extfile checkmk.mydomain.com.ext
----

Neben dem Zertifikat müssen Sie Ihr CA-Zertifikat `intermediate.pem` und gegebenenfalls (Sie sind nicht Root-CA) auch das Root-Zertifikat weitergeben.



==== Importieren der CA
// TK: Ist das nicht ein Thema, *nachdem* der Webserver konfiguriert wurde?
// TK: Ich hab leider kein klares Bild, was ich wo und wann tun muss.
// MFS: Ab hier ist die Reihenfolge eigentlich egal: Man kann auch zuerst Schlüssel/Zertifikat im Apache einrichten. Der Punkt ist halt, dass ein erster Verbindungsaufbau halt scheitert, bevor die CA als vertrauenswürdig bekannt ist.

Die Wege, ein CA Zertifikat als vertrauenswürdig zu importieren, unterscheiden sich von Browser zu Browser.
// TK: oder: eine vertrauenswürdige CA hinzuzufügen durch Import eines von der CA ausgestellten Zertifikats?
// MFS: Fixed it.
Meist genügt es, das Zertifikat `ca.cert.pem` unter  [.guihint]#Einstellungen > Datenschutz und Sicherheit > Zertifikate > Importieren# hinzuzufügen. 

// MFS: Screenshot Import ? 
// MFS: Screenshot Sicherheitshinweis ?

Damit die Zertifikatsverwaltung kein Stolperstein beim automatischen Agenten-Update darstellt, haben wir in der Agentenbäckerei die Möglichkeit vorgesehen, ein xref:agent_deployment#certificates_for_https[eigenes CA-Zertifikat] zu übergeben, das nur für Agenten-Updates benutzt wird.
// TK: Wie? Per Regel? Global Setting? Wo beschrieben?
// MFS: Link hinzu.
Die Systemzertifikate werden hierbei nicht angetastet, Agenten-Updates sind dennoch möglich.
// TK: Was meinst Du hier mit Systemzertifikaten? Kommt auch nochmal etwas später für Windows.

Alternativ zur Verteilung per Agenten-Update können Sie das Root-Zertifikat in der lokalen CA-Datenbank des Hosts integrieren.
// TK: Alternativ wozu? Zum Import in den Browser?
Kopieren Sie dafür die Datei `ca.cert.pem` nach `/usr/local/share/ca-certificates/starkindustries.crt`.
Anschließend generieren Sie den Cache neu:

[{shell}]
----
{c-root} *update-ca-certificates*
----

Unter Windows ist es möglich, die Systemzertifikate über das MMC-Snap-In "Certificates" zu verwalten.
//SP: Weiß (außer mir) jeder Leser was ein MMC-Snap-In ist?
// MFS: Wer Windows administriert, kennt den Begriff. Für den Sonderfall, dass jemand Windows zur CMK-Administration nutzt, der Admin Zertifikate aber nicht netzwerkweit verteilt, muss eine Suchmaschine bemüht werden.  
// TK: Dann aber auch hinschreiben, dass das Snap-In Certificates heisst.
// MFS: Done.
Dies ist beispielsweise nötig, wenn Sie einen Microsoft-Browser verwenden wollen, um auf ein mit eigener CA abgesichertes {CMK} zuzugreifen.
Das genaue Vorgehen können Sie im link:https://docs.microsoft.com/de-de/troubleshoot/windows-server/windows-security/import-third-party-ca-to-enterprise-ntauth-store#method-1---import-a-certificate-by-using-the-pki-health-tool[Microsofts Knowledge Base Artikel PKI^] nachlesen.
Alternativ können Sie Zertifikate per link:https://docs.microsoft.com/de-de/mem/intune/protect/certificates-configure[Intune^] verteilen.

[#configsample]
== Konfiguration der HTTPS-Verbindung für eine Instanz
// TK: Hier den Zusammenhang zu den 3 Optionen von oben deutlicher machen, d.h. z.B. im Fall becomeca muss ich die folgenden Einträge machen...
// TK: Reihenfolge von oben auch hier beibehalten.
// MA: Puh.... jetzt hab ich ganz schön lange lesen müssen, um meine eigentliche Aufgabe angehen zu können: Checkmk mit SSL absichern. Das Kapitel kommt mir etwas sehr spät. Eventuell hab ich es weiter oben schon einmal erwähnt: Man muss durch sehr viele optionale Punkte, um endlich zu den notwendigen zu kommen. Die Struktur sollte einladen, Checmk über HTTPS zu betreiben und klarmachen, weshalb wir das nicht so bequem machen, wie andere Tools (z.B., weil wir einen Apache-Webserber als Instanznutzer laufen lassen, aber auf dem System-Apache aufbauen). 

// New
Zunächst müssen Sie in der SSL-Konfigurationsdatei die korrekten Pfade zu Schlüssel, Zertifikat und Intermediate-Zertifikat angeben. Die Konfigurationsdatei ist in der Regel `/etc/apache2/sites-enabled/default-ssl.conf`, der Pfad kann jedoch bei älteren Distributionen abweichen.

Im Beispiel bezeichnet das `SSLCertificateKeyFile` den eingangs erzeugten privaten Schlüssel für diesen Server.
`SSLCertificateChainFile`  enthält das Intermediate Certificate oder gegebenenfalls aneinandergereihte Intermediate Certificates.
Lediglich bei einer internen CA, wo direkt mit dem CA-Schlüssel signiert wird, fällt dieses weg.

Viele kommerzielle Anbieter verwenden eher generische Dateinamen, wenn Sie diese übernehmen, mag die Konfiguration wie folgt aussehen:

./etc/apache2/sites-enabled/default-ssl.conf
[source,apache]
----
SSLEngine on
SSLCertificateKeyFile /etc/certs/checkmk.mydomain.com.key
SSLCertificateChainFile /etc/certs/ca_bundle.crt
SSLCertificateFile /etc/certs/certificate.crt
----

Wenn Sie Letsencrypt verwendet haben, um Zertifikate zu generieren, aber Certbot die Konfiguration nicht aktualisieren haben lassen, finden Sie die Pfade unterhalb `/etc/letsencrypt/live` heraus und tragen Sie diese ein:

./etc/apache2/sites-enabled/default-ssl.conf
[source,apache]
----
SSLEngine on
SSLCertificateKeyFile /etc/letsencrypt/live/checkmk.starkindustries.test/privkey.pem
SSLCertificateChainFile /etc/letsencrypt/live/checkmk.starkindustries.test/chain.pem
SSLCertificateFile /etc/letsencrypt/live/checkmk.starkindustries.test/cert.pem
----

[#apachedefaultconfig]
=== Konfiguration der Apache Default Site 

// Small change in wording
Die `VirtualHost`-Konfiguration befindet sich -- je nach eingesetzter Distribution -- in einer dieser Dateien:

[cols=2]
|===

|Debian, Ubuntu |/etc/apache2/sites-enabled/000-default(.conf)
|RHEL, CentOS |/etc/httpd/conf.d/ssl.conf
|SLES |/etc/apache2/httpd.conf
|===

Das folgende Beispiel geht davon aus, dass Sie eine einzige Konfigurationsdatei füt unverschlüsselte Verbindungen auf Port 80 und verschlüsselte Verbindungen auf 443 nutzen.
In diesem Fall ergänzen Sie im Abschnitt für den `VirtualHost` folgende Zeilen:
// TK: Umstellen: Zuerst beschreiben, dass die Datei in den Distros unterschiedlich ist und dann das Bsp. für Debian/Ubuntu
// Lines and comments added.
// MFS: Done.
// MFS: Für eine bessere Lösung sollte der Block  <IfModule headers_module>
// mit unserer Konfiguration ausgeliefert werden. Siehe auch:
// https://forum.checkmk.com/t/include-apache-config-for-x-forwarded-proto/29869

./etc/apache2/sites-enabled/000-default
[source,apache]
----
RewriteEngine On
# Never forward request for .well-known (important when using LetsEncrypt)
RewriteCond %{REQUEST_URI} !^/.well-known
# Next 2 lines: Force redirection if incoming request is not on 443
RewriteCond %{SERVER_PORT} !^443$
RewriteRule (.*) https://%{HTTP_HOST}$1 [L]
# This section passes the system Apaches connection mode to the 
# instance Apache. Make sure mod_headers is enabled, otherwise it
# will be ignored and "Analyze configuration" will issue "WARN".
<IfModule headers_module>
    RequestHeader set X-Forwarded-Proto expr=%{REQUEST_SCHEME}
    RequestHeader set X-Forwarded-SSL expr=%{HTTPS}
</IfModule>
----

Nach der Konfigurationsänderung muss der Webserver neu gestartet werden:

[{shell}]
----
{c-root} systemctl restart apache2
----

Erneut gilt: Einige Distributionen verwenden als Name des Dienstes nicht `apache2`, sondern das etwas generischere `httpd`.
Passen Sie in diesem Fall den Befehl an.


== Zusätzliche Optionen

// Das da muss Mattias alles nochmal durchspielen, das ganze Perfect Forward Security Kapitel braucht Aufmerksamkeit
// TK: Dieses Kapitel ist merkwürdig aufgebaut: Warum der Titel "Zusätzliche Optionen", wenn wir nur eine (HSTS) beschreiben? 
// MFS: Das hieß schon so, als ich mit der Bearbeitung angefangen habe. Da ich weitere Ergänzungen plane, sollten wir den Namen belassen.
// TK: Die Besonderheiten sollten nach vorne, damit man zuerst die möglichen Auswirkungen anschauen kann, bevor man die Konfig durchzieht.

=== HSTS einrichten

Den {CMK}-Server nur noch mittels HTTPS erreichbar zu machen, ist der erste und wichtigste Schritt, um Verbindungen zum Monitoring abzusichern.
Erhöhen kann man die Sicherheit aber mit zusätzlichen, optionalen Einstellungen.
So kann der Webserver dem Browser mitteilen, dass er in Zukunft bitte nur noch über HTTPS angesprochen werden soll und eine ungesicherte Verbindung über HTTP immer abgelehnt wird.

Diese Technik nennt sich HTTP Strict Transport Security (HSTS) und wird für einen bestimmten Zeitraum in Sekunden gesetzt.
Ist dieser Zeitraum abgelaufen, prüft der Browser erneut, ob die Limitierung über HSTS weiterhin gültig ist.

[#hsts_specifics]
==== Besonderheiten

Die Einrichtung von HSTS hat nicht nur den Vorteil der Sicherstellung, dass nur sichere Verbindungen genutzt werden.
Der Einsatz bringt auch bestimmte Besonderheiten mit sich, derer man sich _vor_ der Umstellung bewusst sein muss:

* Ist der Eintrag zu dem HSTS einmal vom Browser des Benutzers angelegt, kann er -- zumindest vor Ablauf der Zeit -- nur mit entsprechendem Detailwissen zu dem jeweiligen Browser entfernt werden. Beachten Sie, dass viele Benutzer dieses Wissen nicht haben.
* Die Verbindung wird u.a. dann abgelehnt, wenn das Zertifikat abgelaufen ist oder durch ein selbst-signiertes ausgetauscht wurde.
Solche Seiten können auch nicht mit einer Ausnahme zum temporären Vertrauen eines Zertifikates aufgerufen werden.
// SP: Was heißt "die Seite kann nicht umgangen werden"? Was ist hier mit Ausnahmen gemeint?
// MFS: Die Ausnahme, die Du bspw. manchmal setzen kannst, wenn ein Zertifikat abgelaufen oder selbst signiert ist. So besser?
* HSTS wird umgekehrt nur dann berücksichtigt, wenn dem Zertifikat beim ersten Verbindungsaufbau *vertraut* wird.
Ansonsten legt der Browser keinen Eintrag zum HSTS an, so dass der zusätzliche Schutzmechanismus nicht benutzt wird.

==== Konfiguration des Apache-Webservers

// MFS: Ich habe die Zeiträume massiv verkürzt: 12 Stunden zwischen Neuaushandlung und 10 Minuten für den Start sind weit pragmatischer.

Um die Option zu setzen, fügen Sie den folgenden Eintrag der HTTPS-Konfiguration hinzu.
Unter Debian/Ubuntu ist das standardmäßig die Datei `default-ssl.conf`:

./etc/apache2/sites-enabled/default-ssl.conf
[source,apache]
----
Header always set Strict-Transport-Security "max-age=43200"
----

*Wichtig*: Setzen Sie zunächst einen kurzen Zeitraum -- z.B. 600 Sekunden --, um die Einstellung zu testen, da es sein kann, dass ansonsten die Verbindung im Fehlerfall für einen sehr langen Zeitraum abgelehnt wird!
Mehr dazu auch bei den xref:hsts_specifics[Besonderheiten].

Um zu sehen, ob die neue Einstellung funktioniert, können Sie mit Hilfe des Programms `curl` den Server abrufen.
Hier in der Ausgabe nur die ersten 4 Zeilen:

[{shell}]
----
{c-root} curl -I \https://myHost/mySite/check_mk/login.py
HTTP/1.1 200 OK
pass:q[*Date*]: Tue, 01 Jun 2021 09:30:20 GMT
pass:q[*Server*]: Apache
pass:q[*Strict-Transport-Security*]: max-age=3600
----

