include::global_attr.adoc[]
= Lokale Checks
:revdate: draft
:title: Lokale Checks
:description: {CMK} kann auch ohne große Programmierkenntnis sehr einfach erweitert werden. Erfahren Sie hier, wie Sie dem Agenten ein eigenes Skript übergeben.

{related-start}
link:wato_monitoringagents.html[Monitoringagenten]
link:datasource_programs.html[Datenquellenprogramme]
link:check_plugins_catalog.html[Katalog der Checkplugins]
{related-end}


== Warum eigene Checks?

{CMK} überwacht durch die große Anzahl an mitgelieferten Check-Plugins
bereits sehr viele relevante Daten. 
Dennoch ist jede IT-Umgebung einzigartig, so dass sich oft sehr individuelle Anforderungen ergeben. 
Mit den *lokalen Checks* (_local checks_) sind Sie in der Lage, den Agenten auf dem Ziel-Host zu erweitern, indem Sie schnell und einfach eigene Services erstellen.

Diese lokalen Plugins unterscheiden sich dabei in einem wesentlichen Punkt
von anderen Checks: 
Die Berechnung des Status erfolgt direkt auf dem Host, auf dem die Daten auch abgerufen werden. 
Dadurch entfällt die komplexe Erstellung von Checks in Python und Sie sind bei der Wahl der Skriptsprache völlig frei.


[#simple_check]
== Einen einfachen lokalen Check schreiben


[#syntax]
=== Skript erstellen

Sie können einen lokalen Check in jeder beliebigen Programmiersprache schreiben, die der Zielhost unterstützt. 
Das Skript muss so konstruiert sein, dass es pro Check eine Statuszeile ausgibt, die aus vier Teilen besteht.
Hier ist ein Beispiel:

[{shell}]
----
0 "My service" myvalue=73;80;90 My output text who may contain spaces
----

Die vier Teile sind durch Leerzeichen getrennt und haben folgende Bedeutung:

[cols="25,20,~"]
|===
|Beispielwert |Bedeutung |Beschreibung

|`0` |Status |Der Zustand des Services wird als Ziffer angegeben: `0` für {OK}, `1` für {WARN}, `2` für {CRIT} und `3` für {UNKNOWN}. Alternativ ist es möglich, den xref:localchecks#dynamic_state[Status dynamisch berechnen] zu lassen: dann wird die Ziffer durch ein `P` ersetzt.
|`My service` |Service-Name |Der Name des Services, wie er in {CMK} angezeigt wird, in der Ausgabe des Checks in doppelten Anführungszeichen. Falls der Service-Name keine Leerzeichen enthält, können Sie sich die Anführungszeichen sparen.
|`myvalue=73;80;90` |Metriken |Metrikwerte zu den Daten. Sie finden im Kapitel zu den xref:localchecks#metrics[Metriken] näheres zum Aufbau. Alternativ können Sie ein Minuszeichen setzen, wenn der Check keine Metriken ausgibt.
|`My output text who may contain spaces` |Statusdetail |Details zum Status, wie sie in {CMK} angezeigt werden. Dieser Teil kann auch Leerzeichen enthalten.
|===

Zwischen den einzelnen Teilen der Ausgabe und dem ersten Text des Statusdetails muss immer ein Leerzeichen stehen. 
Alles danach wird dann zum Statusdetail gezählt, weswegen dort auch Leerzeichen erlaubt sind.

Wenn Sie wegen einer möglichen Ausgabe unsicher sind, können Sie diese einfach testen, indem Sie ein kleines Skript mit dem Kommando `echo` schreiben. 
Fügen Sie in das `echo`-Kommando Ihre Ausgabe ein, die Sie testen möchten und achten Sie dabei darauf, die Anführungszeichen für den Service-Namen mit `\` zu maskieren:

.mylocalcheck
[{file}]
----
#!/bin/bash
echo "0 \"My 1st service\" - This static service is always OK"
----

Für Windows-Hosts sieht so ein Testskript sehr ähnlich aus:

.mylocalcheck.bat
[{file}]
----
@echo off
echo 0 "My 1st service" - This static service is always OK
----

Sie können übrigens beliebig viele Ausgaben in einem Skript erzeugen. 
Für jede ausgegebene Zeile wird dann ein eigener Service in {CMK} erstellt.
Daher sind in der Ausgabe auch keine Zeilenumbruchzeichen erlaubt -- es sei denn, sie sind maskiert, zum Beispiel für eine xref:localchecks#multi-line[mehrzeilige Ausgabe] in {CMK}.

Wie Sie prüfen, ob das lokale Skript vom Agenten richtig aufgerufen wird, sehen Sie in der xref:localchecks#diagnose[Fehleranalyse].


[#distribute]
=== Skript verteilen

Nachdem das Skript geschrieben ist, können Sie es an die entsprechenden Hosts verteilen. 
Der Pfad unterscheidet sich je nach Betriebssystem. 
Eine Liste der Pfade finden Sie in xref:localchecks#folders_script[Dateien und Verzeichnisse] weiter unten.

Vergessen Sie nicht, das Skript auf unixoiden Systemen ausführbar zu machen. 
Der Pfad in dem Beispiel bezieht sich auf Linux:

[{shell}]
----
{c-root} chmod +x /usr/lib/check_mk_agent/local/mylocalcheck
----

Wenn Sie die xref:wato_monitoringagents#bakery[Agentenbäckerei] nutzen, können Sie das Skript auch regelbasiert verteilen. 
Mehr zur Regelerstellung erfahren Sie im Kapitel xref:localchecks#bakery[Verteilung über die Agentenbäckerei].


[#add_service]
=== Den Service ins Monitoring aufnehmen

Bei jedem Aufruf des {CMK}-Agenten wird auch der im Skript enthaltene lokale Check ausgeführt und an die Ausgabe des Agenten angehängt. 
Die xref:wato_services#discovery[Serviceerkennung] funktioniert also wie bei anderen Services auch automatisch:

image::localchecks_services.png[]

Nachdem Sie den Service ins Monitoring übernommen und die Änderungen aktiviert haben, ist die Einrichtung eines selbsterstellten Services mit Hilfe eines lokalen Checks bereits abgeschlossen. 
Falls es bei der Serviceerkennung zu Problemen kommen sollte, kann Ihnen die xref:localchecks#diagnose[Fehleranalyse] weiterhelfen.


[#extended_functions]
== Erweiterte Funktionen


[#metrics]
=== Metriken

Sie können in einem lokalen Check auch Metriken festlegen. 
Die allgemeine Syntax für diese Daten ist:

[{shell}]
----
metricname=value;warn;crit;min;max
----

wobei `value` der aktuelle Wert ist, `warn` und `crit` die (oberen) Schwellwerte festlegen sowie `min` und `max` den Wertebereich fixieren -- zum Beispiel so:


[{shell}]
----
count=73;80;90;0;100
----

Die Werte werden mit einem Semikolon getrennt. 
Alle Werte mit Ausnahme von `value` sind optional. 
Wird ein Wert nicht benötigt, so bleibt das Feld leer bzw. wird am Ende weggelassen, wie im folgenden für `warn`, `crit` und `max`:

[{shell}]
----
count=42;;;0
----

*Hinweis:* In den {CEE} können die Werte für `min` und `max` zwar gesetzt werden -- aber nur aus Kompatibilitätsgründen. 
Die Begrenzung des zugehörigen Graphen auf einen bestimmten Wertebereich hat in den {EE} keine Auswirkungen.


[#multiple_metrics]
=== Mehrere Metriken

Sie können auch mehrere Metriken ausgeben lassen.
Diese werden dann durch das "Pipe"-Zeichen `|` getrennt, zum Beispiel so:

[{shell}]
----
count1=42|count2=21;23;27|count3=73
----

Eine komplette Ausgabe mit zwei Metriken sieht dann etwa so aus:

[{shell}]
----
{c-root} /usr/lib/check_mk_agent/local/mylocalcheck
0 "My 2nd service" count1=42|count2=21;23;27 A service with 2 graphs
----

Nachdem Sie auch den neuen Service ins Monitoring aufgenommen haben, werden die Service-Graphen in {CMK} automatisch erzeugt und können aus der Service-Liste des Hosts aufgerufen werden:

image::localchecks_graphs2.png[]


[#dynamic_state]
=== Status dynamisch berechnen lassen

In den vorherigen Kapiteln haben Sie erfahren, wie man für Metriken Schwellwerte festlegen und diese auch in den Graphen anzeigen lassen kann. 
Der nächste naheliegende Schritt ist es nun, diese Schwellwerte für eine dynamische Berechnung des Service-Zustands zu nutzen. 
{CMK} bietet genau diese Möglichkeit, um einen lokalen Check auszubauen.

Wenn Sie im ersten Feld der Ausgabe, das den Status bestimmt, statt einer Ziffer den Buchstaben `P` übergeben, wird der Service-Zustand anhand der übergebenen Schwellwerte berechnet.

Eine Ausgabe würde dann so aussehen:

[{shell}]
----
{c-root} /usr/lib/check_mk_agent/local/mylocalcheck
P "My 1st dynamic service" count=40;30;50 Result is computed from two threshold values
P "My 2nd dynamic service" - Result is computed with no values
----

&#8230; und die Anzeige in einer Service-Ansicht so:

image::localchecks_dynsrv.png[]

Die Anzeige unterscheidet sich in zwei Punkten von derjenigen, wie sie bisher zu sehen war:

* In der [.guihint]#Summary# des Services werden alle wichtigen Informationen der Metriken angezeigt (Name, Wert, Schwellwerte). 
So können Sie immer nachvollziehen, wie der Zustand aus einem Wert berechnet wurde.
* Wenn keine Metriken übergeben werden, ist der Service-Zustand immer {OK}.


[#upper_lower_thresholds]
=== Obere und untere Schwellwerte

Manche Parameter haben nicht nur obere, sondern auch untere Schwellwerte. 
Ein Beispiel dafür ist die Luftfeuchtigkeit. 
Für solche Fälle bietet der lokale Check die Möglichkeit, jeweils zwei Schwellwerte für die Zustände {WARN} und {CRIT} zu übergeben. 
Sie werden durch einen Doppelpunkt getrennt und stellen jeweils den unteren und den oberen Schwellwert dar

In der allgemeinen Syntax sieht das so aus:

[{shell}]
----
parameter=value;warn_lower:warn_upper;crit_lower:crit_upper
----

&#8230; und im Beispiel so:

[{shell}]
----
{c-root} /usr/lib/check_mk_agent/local/mylocalcheck
0 "My 3rd service" humidity=27;40:60;30:70 A service with lower and upper thesholds
----

&#8230; und in der Anzeige einer Service-Ansicht so:

image::localchecks_lower.png[]


[#multi-line]
=== Mehrzeilige Ausgaben

Auch die Option, die Ausgabe über mehrere Zeilen zu verteilen, steht Ihnen
zur Verfügung. 
Da {CMK} unter Linux läuft, können Sie mit der Escape-Sequenz `\n` arbeiten, um einen Zeilenumbruch zu erzwingen. 
Auch wenn Sie bedingt durch die Skriptsprache den Backslash selbst maskieren müssen, wird das von {CMK} korrekt interpretiert:

[{shell}]
----
{c-root} /usr/lib/check_mk_agent/local/mylocalcheck
P "My service" humidity=37;40:60;30:70 My service output\\nA line with details\\nAnother line with details
----

In den Details des Services können Sie dann diese zusätzlichen Zeilen unter der [.guihint]#Summary# sehen:

image::localchecks_srv_details.png[]


[#cache]
=== Asynchron ausführen und Ausgabe zwischenspeichern

Die Ausgabe lokaler Checks kann, wie auch die von Agenten-Plugins, zwischengespeichert werden (_caching_). 
Das kann nützlich sein, wenn Skripte längere Zeit zur Ausführung benötigen. 
Ein solches Skript wird dann asynchron und nur in einem definierten Zeitintervall ausgeführt und die letzte Ausgabe zwischengespeichert. 
Wird der Agent vor Ablauf der Zeit erneut abgefragt, verwendet er für den lokalen Check diesen Cache und liefert ihn in der Agentenausgabe zurück.

*Hinweis*: Das Caching steht nur für AIX, FreeBSD, Linux, OpenWRT und Windows zur Verfügung.


==== Konfiguration unter Linux

Unter Linux oder einem anderen unixoiden Betriebssystem kann jedes Plugin asynchron ausgeführt werden. 
Für einen lokalen Check ist die notwendige Konfiguration sehr ähnlich zu der eines xref:agent_linux#async_plugins[Plugins]. 
Legen Sie dazu ein Unterverzeichnis an, das so heißt, wie die Anzahl der Sekunden, die die Ausgabe zwischengespeichert werden soll und legen Sie Ihr Skript in diesem Unterverzeichnis ab.

In folgenden Beispiel wird der lokale Check nur alle 10 Minuten (600 Sekunden) ausgeführt:

[{shell}]
----
{c-root} /usr/lib/check_mk_agent/local/600/mylocalcheck
2 "My cached service" count=4 Some output of a long running script
----

Die zwischengespeicherten Daten werden in ein xref:localchecks#folders_cache[Cache-Verzeichnis] geschrieben.

Für einen Service, der zwischengespeicherte Daten liefert, werden die Cache-spezifischen Informationen in der Service-Ansicht hinzugefügt:

image::localchecks_srv_cached.png[]


==== Konfiguration unter Windows

Unter Windows erfolgt die Konfiguration ebenfalls analog zu der eines xref:agent_windows#customizeexecution[Plugins]. 
Statt mit einem speziellen Unterverzeichnis wie bei Linux & Co werden die Optionen in einer Konfigurationsdatei gesetzt:

// TK: In der 2.0.0p1 habe ich das Windows-Caching nicht erfolgreich testen können: Änderungen in der check_mk.user.yml wurden mal in die Agentenausgabe übernommen, am nächsten Tag nicht mehr. Die Anzeige in der Service-Ansicht enthielt mal die Caching-Information, mal nicht (und passte dann nicht mal zur aktuellen Agentenausgabe). Enthielt die Service-Ansicht die Caching-Information, wurde diese nicht korrekt aktualisiert. Das Windows-Caching muss nochmal neu getestet werden.

.C:ProgramData\checkmk\agent\check_mk.user.yml
[{file}]
----
local:
    enabled: yes
    execution:
        - pattern     : $CUSTOM_LOCAL_PATH$\mylocalcheck.bat
          async       : yes
          run         : yes
          cache_age   : 600
----

Wie Sie oben sehen, können Sie unter Windows die asynchrone Ausführung (mit `async`) und das Zeitintervall (mit `cache_age`) getrennt konfigurieren.

Alternativ können Sie die Konfiguration unter Windows auch in der xref:localchecks#bakery[Agentenbäckerei] durchführen.


[#bakery]
== Verteilung über die Agentenbäckerei

{cee-only}
Wenn Sie die xref:wato_monitoringagents#bakery[Agentenbäckerei] bereits nutzen, können Sie die Skripte mit lokalen Checks auch über diesen Weg an mehrere Hosts verteilen.

Erstellen Sie dazu auf dem {CMK}-Server als Instanzbenutzer unterhalb von `~/local/share/check_mk/agents/` zuerst das Verzeichnis `custom` und darin für jedes Paket von lokalen Checks einen Unterverzeichnisbaum:

[{shell}]
----
{c-omd} cd ~/local/share/check_mk/agents
{c-omd} ~/local/share/check_mk/agents$ mkdir -p custom/mycustompackage/lib/local/
----

Das Paketverzeichnis im obigen Beispiel ist `mycustompackage`. 
Darunter markiert das `lib`-Verzeichnis das Skript als Plugin oder lokalen Check. 
Das nachfolgende Verzeichnis `local` ordnet die Datei dann eindeutig zu.
Legen Sie in dieses Verzeichnis das Skript mit dem lokalen Check ab.

// TK: Nicht getestet 
*Wichtig:* Unter Linux können Sie die asynchrone Ausführung analog konfigurieren wie im xref:localchecks#cache[vorherigen Kapitel] beschrieben, indem Sie nun unter `custom/mycustompackage/lib/local/` ein Verzeichnis mit der Sekundenzahl des Ausführungsintervalls erzeugen und dort das Skript ablegen. 
Unter Windows können Sie dafür (und für weitere Optionen) Regelsätze nutzen, die Sie in der Agentenbäckerei unter [.guihint]#Agent rules > Windows Agent# finden.

In der Konfigurationsumgebung von {CMK} wird dann das Paketverzeichnis  `mycustompackage` als neue Option angezeigt: 
Öffnen Sie [.guihint]#Setup > Agents > Windows, Linux, Solaris, AIX#, erstellen Sie eine neue Regel mit [.guihint]#Agents > Agent rules > Generic options > Deploy custom files with agent# und wählen Sie das eben erstellte Paket aus:

image::localchecks_custom.png[]

{CMK} wird nun selbstständig den lokalen Check im Installationspaket der jeweiligen Betriebssysteme richtig einordnen. 
Nachdem Sie die Änderungen aktiviert und die Agenten gebacken haben, sind Sie mit der Konfiguration auch schon fertig. 
Die Agenten müssen nun nur noch neu verteilt werden.


[#diagnose]
== Fehleranalyse


=== Skript testen

Wenn Sie bei einem selbstgeschriebenen Skript auf Probleme stoßen, sollten Sie
die folgenden potentiellen Fehlerquellen prüfen:

* Liegt das Skript im richtigen xref:localchecks#folders_script[Verzeichnis]?

* Ist das Skript ausführbar und stimmen die Zugriffsberechtigungen? 
Das ist vor allem relevant, wenn Sie den Agenten oder das Skript nicht als root/System-Benutzer ausführen.

* Ist die Ausgabe konform zur vorgegebenen Syntax? 
Die Ausgabe des lokalen Checks muss der Syntax entsprechen, wie sie in den Kapiteln xref:localchecks#syntax[Skript erstellen] und xref:localchecks#extended_functions[Erweiterte Funktionen] beschrieben ist. 
Andernfalls kann die fehlerfreie Ausführung nicht garantiert werden. 
+
Probleme und Fehler können insbesondere dann entstehen, wenn ein lokaler Check eine Aufgabe erfüllen soll, die ein vollwertiges xref:devel_check_plugins[Check-Plugin] erfordert, beispielsweise, wenn die Ausgabe des lokalen Checks selbst einen Sektionskopf (_section header_) enthält oder die Definition eines Host-Namens, wie er beim Transport von xref:piggyback[Piggyback-Daten] verwendet wird.


=== Agentenausgabe auf dem Ziel-Host testen

Wenn das Skript selbst korrekt ist, können Sie den Agenten auf dem Host
ausführen.
Bei unixoiden Betriebssystemen, wie Linux, BSD und so weiter, bietet sich
folgender Befehl an.
Mit der Option `-A` bestimmen Sie die Anzahl der zusätzlichen Zeilen, die nach einem Treffer angezeigt werden sollen. 
Sie können diese Zahl entsprechend der Anzahl der erwarteten Ausgabezeilen anpassen:

[{shell-raw}]
----
{c-root} check_mk_agent | grep -v grep | grep -A2 "<<<local"
<<<local:sep(0)>>>
P "My service" humidity=37;40:60;30:70 My service output\\nA line with details\\nAnother line with details
cached(1618580356,600) 2 "My cached service" count=4 Some output of a long running script
----

In der letzten Zeile erkennen Sie einen zwischengespeicherten Service an der vorangestellten `cache`-Information mit der aktuellen Unixzeit und dem Ausführungsintervall in Sekunden.

Unter Windows können Sie die Agentenausgabe in eine Textdatei umleiten, diese dann z.B. mit Notepad ebenfalls nach der `local`-Sektion durchsuchen und
schauen, ob die erwarteten Ausgaben dabei sind:

[{shell}]
----
C:\Program Files (x86)\checkmk\service>check_mk_agent.exe test > out.txt
----


=== Agentenausgabe auf dem {CMK}-Server testen

Zuletzt können Sie die Verarbeitung der Skriptausgaben auch auf dem {CMK}-Server mit dem Befehl `cmk` testen -- einmal für die Serviceerkennung:

[{shell}]
----
{c-omd} cmk -IIv --detect-plugins=local mycmkserver
Discovering services and host labels on: mycmkserver
...
+ EXECUTING DISCOVERY PLUGINS (1)
  [green]#2# local
[green]#SUCCESS# - Found 2 services, no host labels
----

&#8230; und mit einem ähnlichen Befehl auch die Verarbeitung der Serviceausgabe:

[{shell}]
----
{c-omd} cmk -nv --detect-plugins=local mycmkserver
Checkmk version 2.0.0p2
...
+ FETCHING DATA
...
+ PARSE FETCHER RESULTS
Received no piggyback data
My cached service    [red]#Some output of a long running script(!!), Cache generated 6 minutes 52 seconds ago, Cache interval: 10 minutes 0 seconds, Elapsed cache lifespan: 68.71%#
My service           [yellow]#My service output\, humidity: 37.00 (warn/crit below 40.00/30.00)(!)#
----

Wenn es in den lokalen Checks Fehler gibt, wird {CMK} Sie in der
Serviceausgabe darauf hinweisen.
Das gilt sowohl für fehlerhafte Metriken, als auch für falsche, unvollständige Informationen in der Skriptausgabe oder einen ungültigen Status.
Diese Fehlermeldungen sollen Ihnen helfen, die Fehler in den Skripten schnell zu identifizieren.


[#folders]
== Dateien und Verzeichnisse
// TK: Ich hab die Skripts unter git/check_mk/agents überprüft und die Verzeichnisinfos aktualisiert.


[#folders_script]
=== Skript-Verzeichnis auf dem Ziel-Host

[cols="65,~"]
|===
|Pfad |Betriebssystem 

|`/usr/check_mk/lib/local/` |AIX
|`/usr/local/lib/check_mk_agent/local/` |FreeBSD
|`/usr/lib/check_mk_agent/local/` |HP-UX, Linux OpenBSD, OpenWRT und Solaris
// |`%ProgramFiles(X86)%\check_mk\local` |Windows (Agent bis Version {v15})
|`%ProgramData%\checkmk\agent\local` |Windows
|===


[#folders_cache]
=== Cache-Verzeichnis auf dem Ziel-Host

Hier werden zwischengespeicherte Daten einzelner Sektionen, u.a. der `local` Sektion, abgelegt und dem Agenten, solange die Daten gültig sind, bei jeder Ausführung wieder angehängt.

[cols="65,~"]
|===
|Pfad |Betriebssystem 

|`/tmp/check_mk/cache/` |AIX
|`/var/run/check_mk/cache/` |FreeBSD
|`/var/lib/check_mk_agent/cache/` |Linux, OpenWRT und Solaris
|===
