include::global_attr.adoc[]
= Eigene Checkplugins schreiben
:revdate: draft
:title: 
:description: 

{related-start}
link:localchecks.html[Lokale Checks]
link:agent_linux.html[Linux überwachen]
link:agent_windows.html[Windows überwachen]
link:cmk_commandline.html[Checkmk auf der Kommandozeile]
link:mkps.html[Checkmk Erweiterungspakete (MKPs)]
link:simulation_mode.html[Der Simulationsmodus]
link:snmp.html[Überwachen via SNMP]
link:wato_monitoringagents.html[Monitoringagenten]
link:wato_services.html[Services verstehen und konfigurieren]
{related-end}



== Einleitung

{CMK} umfasst fast 2.000 fertige Checkplugins für alle nur denkbare Hardware und Software.
Diese werden vom {CMK}-Team gepflegt, und jede Woche kommen neue dazu.
Daneben gibt es auf der
link:https://exchange.checkmk.com[{CMK}-Exchange] weitere Plugins, die von unseren
Anwendern beigesteuert werden.

Und trotzdem gibt es immer wieder Situationen, in denen ein Gerät, eine
Anwendung oder einfach nur eine bestimmte Metrik, die für Sie wichtig ist,
noch von keinem dieser Plugins erfasst ist -- vielleicht auch einfach
deshalb, weil es sich dabei um etwas handelt, dass in Ihrer Firma entwickelt
wurde und es daher niemand anders haben kann.

=== Muss es immer ein echtes Plugin sein?

Welche Möglichkeiten haben Sie also, hier dennoch eine sinnvolle Überwachung
zu implementieren? Nun -- natürlich können Sie sich an unseren
link:https://checkmk.de/support.html[Support] wenden und ein geeignetes
Plugin entwickeln lassen. Aber Sie können sich auch
selbst helfen. Dabei haben Sie erstmal vier Möglichkeiten:

[cols=4]
|===
|Methode |So geht's |Vorteile |Nachteile 

|link:localchecks.html[Localcheck] |{CMK}-Agent um einfaches Skript erweitern |Geht sehr einfach, ist in allen Programmiersprachen möglich, welche das Betriebssystem des überwachten Hosts anbietet, unterstützt sogar Serviceerkennung |Konfiguration der Schwellwerte nur beim Agenten selbst, für komplexere Dinge unkomfortabel, keine Unterstützung für link:snmp.html[SNMP].
|Nagios-kompatibles Checkplugin |Plugin per _MRPE_ vom link:agent_windows.html#mrpe[Windows-] oder link:agent_linux.html#mrpe[Linux-]Agenten aufrufen lassen. |Zugriff auf alle vorhandenen Nagios-Plugins, auch hier freie Wahl der Programmiersprache |Konfiguration der Schwellwerte nur beim Agenten selbst, Keine link:snmp.html[SNMP]-Unterstützung durch {CMK}, keine Serviceerkennung möglich
|Logmeldungen auswerten |_Meldungen_ überwachen per link:ec.html[Event Console] |Keine Entwicklung notwendig sondern nur aufstellen von Regeln in der Event Console |Geht nur, wenn passende Logmeldungen vorhanden sind, kein gesichterter aktueller Status, kein Erfassen von Metriken, keine konfigurierbaren Schwellwerte
|Echtes {CMK}-Plugin |Wird link:devel_check_plugins.html#agentbased[in diesem Artikel] erklärt |Fügt sich zu 100% in {CMK} ein, automatische Serviceerkennung, zentrale Konfiguration der Schwellwerte über die grafische Oberfläche, sehr performant, unterstützt link:snmp.html[SNMP], automatische Host- und Servicelabels möglich, unterstützt link:inventory.html[HW/SW-Inventur], Unterstützung durch Standardbibliothken von {CMK}. |Erfordert mehr Einarbeitungszeit sowie Kenntnisse in der Programmsprache Python
|===


Dieser Artikel zeigt Ihnen, wie Sie echte {CMK}-Checkplugins entwickeln
können -- mit allem was dazugehört. Dabei zeigen wir Ihnen, wie Sie
die in Version VERSION[2.0] von {CMK} *neu entwickelte API* für die
Pluginprogrammierung nutzen.

=== Was hat sich seit der alten API geändert?

Haben Sie schon Erfahrung mit dem Entwickeln von Checkplugins für die
{CMK}-Version VERSION[1.6.0] oder früher?  Dann finden Sie hier eine knappe
Übersicht über alle Änderungen, welche die ab VERSION[2.0] verfügbare neue
Check-API mit sich bringt:

* Plugins sind jetzt Python-3-Module und die Dateien müssen mit `.py` enden.
* Die eigenen Plugins liegen jetzt im Verzeichnis `local/lib/check_mk/base/plugins/agent_based`.
* Am Anfang der Datei brauchen Sie nun mindestens eine spezielle `import`-Anweisung.
* Die Sektionen und die eigentlichen Checks werden getrennt registiert. Dazu gibt es die neuen Funktionen `register.agent_section` und `register.check_plugin`.
* Etliche Funktions- und Argumentnamen wurden umbenannt. Unter anderem wird jetzt immer konsequent von _Discovery_ gesprochen (früher: _Inventory_).
* Die Discovery-Funktion (vormals Inventory-Funktion) und auch die Check-Funktion müssen nun _immer_ als Generatoren arbeiten (also `yield` verwenden).
* Die Namen der Argumente der deklarierten Funktionen sind jetzt fest vorgegeben.
* Anstelle der SNMP-Scanfunktion schreiben Sie eine _Deklaration_, welche OIDs mit welchen Werten erwartet werden.
* Die Funktionen zum Darstellen von Zahlen wurden neu strukturiert (z.B. wird `get_bytes_human_readable` zu `render.bytes`).
* Es gibt nun eine eigene Methode, mit der Checks andere ausschließen können (`superseeds`). Das wird nicht mehr in der SNMP-Scanfunktion gemacht.
* Die Hilfsfunktionen für die Arbeit mit Countern, Raten und Durchschnitten haben sich geändert.
* Anstelle von magischen Rückgabewerten wie z.B. `2` für {CRIT} gibt es jetzt Konstanten (z.B. `State.CRIT`).
* Viele mögliche Programmierfehler in Ihrem Plugin erkennt {CMK} jetzt sehr früh und kann Sie gleich darauf hinweisen.

=== Wird die alte API noch unterstützt

Ja, die bis zu Version VERSION[1.6.0] von {CMK} gültige API für die
Entwicklung von Checkplugins wird mit einigen kleinen Einschränkunen noch
etliche Jahre unterstützt werden, da mit dieser sehr sehr viele Plugins
entwickelt wurden. Während dieser Zeit wird {CMK} bei APIs parallel anbieten.
Einzelheiten erfahren Sie in Werk link:https://checkmk.com/check_mk-werks.php?werk_id=11759[#10601].

Trotzdem empfehlen wir für die Enwicklung von neuen Plugins die neue API,
da diese konsistenter und logischer ist, besser dokumentiert und langfristig
am zukunftssichersten.

=== Verschiedene Arten von Agenten

Checkplugins werten die Daten der {CMK}-Agenten aus. Und deswegen sollten wir,
bevor wir uns in Geschehen stürzen, uns zunächst einen Überblick
darüber verschaffen, welche Arten von Agenten {CMK} eigentlich kennt:

// Artikel zu Spezialagent und Aktiven Check muss geschrieben werden

[cols="20,~"]
|===

|{CMK}-Agent |Hier werten die Plugins Daten aus, welcher der {CMK}-Agent für Linux, Windows oder andere Betriebssysteme sendet. Damit werden Betriebssystemparameter und Anwendungen überwacht und teilweise auch Serverhardware. Jedes neue Checkplugin erfordert eine Erweiterung des Agenten in Form eines Agent-Plugins, damit dieser die nötigen Daten bereitstellt.
|Spezialagent / API-Integration |Einen Spezialagenten benötigen Sie, wenn Sie weder mit dem normalen {CMK}-Agenten noch per link:snmp.html[SNMP] an die Daten kommen, welche für das Monitoring relevant sind. Der häufigste Fall ist das Abfragen von HTTP-basierten APIs. Beispiele sind die Überwachung von link:monitoring_aws.html[AWS], link:monitoring_azure.html[Azure] oder link:monitoring_vmware.html[VMware]. Hier schreiben Sie ein Skript, welches direkt auf dem {CMK}-Server läuft, sich mit der API verbindet, und Daten im gleichen Format ausgibt, wie dies ein Agentenplugin tun würde.
|link:devel_check_plugins.html#snmp[SNMP] |Bei der Überwachung via link:snmp.html[SNMP] benötigen Sie keine Erweiterung eines Agenten sondern werten Daten aus, welche {CMK} von dem zu überwachenden Gerät per link:snmp.html[SNMP] abruft, welche dieses standardmäßig bereitstellt. {CMK} unterstützt Sie dabei und übernimmt sämtliche Details und Sonderheiten des SNMP-Protokolls. Eigentlich gibt es auch hier einen Agenten: nämlich den auf dem überwachten System vorinstallierten SNMP-Agenten.
|Aktiver Check |Dieser Checktyp bildet eine Sonderrolle. Hier schreiben Sie zunächst ein klassisches Nagios-kompatibles Plugin, welches für die Ausführung _auf dem {CMK}-Server_ bestimmt ist und von dort aus mit einem Netzwerkprotokoll direkt einen Dienst auf dem Zielgerät abfragt. Das prominenteste Beispiel ist das Plugin `check_http`, mit welchem Sie Webserver und Webseiten überwachen können. Dieses Plugin können Sie dann so in {CMK} integrieren, dass man es wie gewohnt per Regeln einrichten kann.
|===


=== Voraussetzungen

Wenn Sie Lust haben, sich mit dem Programmieren von Checkplugins zu befassen,
benötigen Sie folgendes:

* Kenntnisse in der Programmiersprache Python
* Erfahrung mit {CMK}, vor allem was das Thema Agenten und Checks betrifft
* etwas Übung mit Linux auf der Kommandozeile

Als Vorbereitung sind außerdem folgende Artikel gut:

- link:wato_services.html[Services verstehen und konfigurieren]
- link:wato_monitoringagents.html[Monitoringagenten]
- link:agent_windows.html[Windows überwachen]
- link:agent_linux.html[Linux überwachen]
- link:snmp.html[Überwachen via SNMP]
- link:cmk_commandline.html[Checkmk auf der Kommandozeile]
- link:mkps.html[Checkmk Erweiterungspakete (MKPs)]
- link:simulation_mode.html[Der Simulationsmodus]


[#agentbased]
== Ein erstes einfaches Checkplugin

Nach dieser langen Einleitung wird es Zeit, dass wir unser erstes einfaches
Checkplugin programmieren. Als Beispiel nehmen wir eine einfache Überwachung
für Linux. Denn da {CMK} selbst auf Linux läuft, ist es sehr wahrscheinlich,
dass Sie auch auf ein Linuxsystem Zugriff haben.

Das Checkplugin soll einen neuen Service anlegen, welcher erkennt, ob auf einem
Linuxserver jemand einen USB-Stick eingesteckt hat. In diesem Fall soll er
kritisch werden. Vielleicht werden Sie sowas sogar nützlich finden, aber
es ist wirklich nur ein vereinfachtes Beispiel und möglicherweise auch
nicht ganz wasserdicht programmiert. Denn darum geht es hier erstmal nicht.

Das Ganze läuft in zwei Schritten:

. Wir finden heraus, mit welchem Linuxbefehl man sehen kann, ob ein USB-Stick eingesteckt ist, und erweitern den Linux-Agenten um ein kleines Skript, welches diesen Befehl aufruft.
. Wir schreiben in der {CMK}-Instanz ein Checkplugin, welches diese Daten auswertet.

Und los geht's...

=== Den richtigen Befehl finden

Am Anfang jeder Checkprogrammierung steht: die Recherche! Das bedeutet, dass
wir herausfinden, wie wir überhaupt an die Informationen kommen, die wie für
die Überwachung brauchen. Bei Linux sind das oft Kommandozeilenbefehle, bei
Windows hilft die PowerShell, VBScript oder WMI und bei link:snmp.html[SNMP] müssen wir die
richtigen OIDs finden (dazu gibt es einen link:devel_check_plugins.html#snmp[eigenen Abschnitt]).

Für das Herausfinden des richtigen Befehls gibt es leider kein allgemeines
Vorgehen und so will ich mich auch nicht allzulange mit dem Thema aufhalten,
erkläre aber kurz, wie das mit dem USB-Stick funktioniert.

Zunächst loggen wir uns also auf dem zu überwachenden Host ein.  Unter Linux
läuft der Agent per Default als `root`-Benutzer. Deswegen machen
wir auch alle unsere Tests einfach als `root`.  Für unsere Aufgabe
mit dem USB-Stick gibt es praktischerweise symbolische Links im Verzeichnis
`/dev/disk/by-id`. Diese zeigen auf alle Linux-Block-Devices.  Und ein
solches ist auch ein eingesteckter USB-Stick. Außerdem kann man an der ID
am Präfix `usb-` erkennen, wenn ein Block-Device ein USB-Gerät ist.
Folgender Befehl listet alle Einträge in diesem Verzeichnis auf:

[{shell}]
----
{c-root} ls -l /dev/disk/by-id/
total 0
lrwxrwxrwx 1 root root  9 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191 -> ../../sda
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5 -> ../../sda5
lrwxrwxrwx 1 root root  9 May 14 11:21 wwn-0x5002538655584d30 -> ../../sda
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part5 -> ../../sda5
----

So. Und das Ganze jetzt mit eingestecktem USB-Stick:

[{shell}]
----
{c-root} ls -l /dev/disk/by-id/
total 0
lrwxrwxrwx 1 root root  9 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191 -> ../../sda
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5 -> ../../sda5
[hilite]#lrwxrwxrwx 1 root root  9 Mai 14 12:15 usb-SCSI_DISK-0:0 -> ../../sdc#
[hilite]#lrwxrwxrwx 1 root root 10 Mai 14 12:15 usb-SCSI_DISK-0:0-part1 -> ../../sdc1#
[hilite]#lrwxrwxrwx 1 root root 10 Mai 14 12:15 usb-SCSI_DISK-0:0-part2 -> ../../sdc2#
lrwxrwxrwx 1 root root  9 Mai 14 11:21 wwn-0x5002538655584d30 -> ../../sda
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part5 -> ../../sda5
----

=== Die Daten entschlacken

Eigentlich wären wir damit fertig und könnten diese ganze Ausgabe per {CMK}-Agent
zum {CMK}-Server transportieren und dort analysieren lassen. Denn im {CMK} gilt
immer folgende Empfehlung: lassen Sie die komplexe Arbeit immer den Server erledigen.
Halten Sie das Agentenplugin so einfach wie möglich.

Aber: Hier ist trotzdem noch zuviel heiße Luft drin. Es ist immer gut,
unnötige Daten nicht zu übertragen. Das spart Netzwerkverkehr, Speicher,
Rechenzeit und macht alles auch übersichtlicher. Das geht besser!

Als erstes können wir das `-l` weglassen. Damit ist die Ausgabe von
`ls` schon deutlich schlanker:

[{shell}]
----
{c-root} ls /dev/disk/by-id/
ata-APPLE_SSD_SM0512F_S1K5NYBF810191        ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5  wwn-0x5002538655584d30-part3
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1  wwn-0x5002538655584d30-part4                ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2
wwn-0x5002538655584d30                      wwn-0x5002538655584d30-part5                ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3
wwn-0x5002538655584d30-part1                ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4  wwn-0x5002538655584d30-part2
----

Jetzt wiederum stört der mehrspaltige Aufbau. Dieser ist aber nur deswegen, weil der `ls`-Befehl erkennt,
dass er in einem interaktiven Terminal läuft. Später als Teil vom Agenten wird er die Daten einspaltig ausgeben.
Das können wir aber auch ganz einfach hier mit der Option `-1` erzwingen:

[{shell}]
----
{c-root} ls -1 /dev/disk/by-id/
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5
wwn-0x5002538655584d30
wwn-0x5002538655584d30-part1
wwn-0x5002538655584d30-part2
wwn-0x5002538655584d30-part3
wwn-0x5002538655584d30-part4
wwn-0x5002538655584d30-part5
----

Wenn Sie genau hinsehen, werden Sie nicht nur die Blockgeräte selbst sehen,
sondern auch dort vorhandene Partitionen. Dies sind die Einträge, die
auf `-part1`, `-part2` usw. enden. Diese brauchen wir für unseren
Check nicht und bekommen sie ganz einfach mit einem `grep`. Dort
nehmen wir die Option `-v` für eine negative Logik. Hier sieht man
jetzt auch viel deutlicher, dass es in meinem Beispiel eigentlich genau vier Geräte sind,
falls der USB-Stick eingesteckt ist:


[{shell}]
----
{c-root} ls /dev/disk/by-id/ | grep -v -- -part
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
[hilite]#usb-SCSI_DISK-0:0#
wwn-0x5002538655584d30
----

Perfekt! Jetzt haben wir eine übersichtliche Liste aller Blockgeräte, die
mit einem einfachen Befehl ermittelt wird. Mehr brauchen wir nicht.

Das `-1` hab ich jetzt hier wieder weggelassen, weil `ls`
jetzt in eine Pipe schreibt und von sich aus einspaltig ausgibt. Und
`grep` braucht das `--`, da es sonst das Wort `-part`
als die vier Optionen `-p`, `-a`, `-r` und `-t`
interpretieren würde.

Übrigens: Warum greppen wir nicht gleich noch nach `usb`? So dass
nur noch USB-Geräte übertragen werden? Nun, natürlich könnten wir
das tun. Aber zum Einen wird dann unser Beispiel zunehmend langweilig und
außerdem ist es irgendwie beruhigender, im Normalfall _irgendeinen_
Inhalt in der Sektion zu bekommen und nicht einfach nur nichts. So kann
man auf dem {CMK}-Server sofort erkennen, dass das Agentenplugin korrekt
funktioniert.


=== Den Befehl in den Agenten einbauen

Damit wir vom {CMK}-Server aus diese Daten abrufen können, müssen wir den
neuen Befehl Teil vom {CMK}-Agenten auf dem überwachten System machen. Wir
könnten dazu natürlich einfach dort die Datei `/bin/bin/check_mk_agent` editieren
und das einbauen. Das hätte dann aber den Nachteil, dass bei einem Softwareupdate
des Agenten unser Befehl wieder verschwindet, weil die Datei ersetzt wird.

Besser ist daher, wenn wir ein *Agentenplugin* machen. Das ist sogar
noch einfacher. Alles was wir brauchen, ist eine ausführbare Datei mit unserem
Befehl im Verzeichnis `/usr/lib/check_mk_agent/plugins`.

Und noch eins ist wichtig: Wir können unsere Daten nicht einfach so
ausgeben. Was wir noch brauchen, ist eine *Sektionskopf* (_section header_).
Das ist eine speziell formatierte Zeile, in der der Name unseres
neuen Checks steht. An diesen Sektionsköpfen kann {CMK} später erkennen, wo die
Daten des Plugins beginnen und die des vorherigen aufhören.

Also brauchen wir jetzt erstmal einen sinnvollen Namen für unseren neuen
Check. Dieser Name muss aus Kleinbuchstaben, Unterstrichen und Ziffern
bestehen und eindeutig sein. Es darf also nicht schon ein Checkplugin mit
diesem Namen geben.
Wenn Sie neugierig sind, welche Namen es schon gibt,
können Sie diese in einer {CMK}-Instanz auf der Kommandozeile mit `cmk -L`
auflisten lassen:

[{shell}]
----
{c-omd} cmk -L | head -n 20
3par_capacity                 auto migrated    HPE 3PAR: Capacity
3par_cpgs                     auto migrated    HPE 3PAR: CPGs
3par_cpgs_usage               auto migrated    HPE 3PAR: CPGs Usage
3par_hosts                    auto migrated    HPE 3PAR: Hosts
3par_ports                    auto migrated    HPE 3PAR: Ports
3par_remotecopy               auto migrated    HPE 3PAR: Remote Copy
3par_system                   auto migrated    HPE 3PAR: System
3par_volumes                  auto migrated    HPE 3PAR: Volumes
3ware_disks                   auto migrated    3ware ATA RAID Controller: State of Disks
3ware_info                    auto migrated    3ware ATA RAID Controller: General Information
3ware_units                   auto migrated    3ware ATA RAID Controller: State of Units
acme_agent_sessions           auto migrated    ACME Devices: Agent Sessions
acme_certificates             auto migrated    ACME Devices: Certificates
acme_fan                      auto migrated    ACME Devices: Fans
acme_powersupply              auto migrated    ACME Devices: Power Supplies
acme_realm                    auto migrated    ACME Devices: Realm
acme_sbc                      auto migrated    ACME SBC: Health
acme_sbc_settings             auto migrated    ACME SBC: Health Settings
acme_sbc_snmp                 auto migrated    ACME SBC: Health (via SNMP)
acme_temp                     auto migrated    ACME Devices: Temperature
----



„auto migrated“ zeigt an, dass es sich hier um Checkplugins handelt, die noch
gegen die alte API programmiert wurden.

Wählen wir für unser Beispiel den Namen `linux_usbstick`. In diesem
Fall muss der Sektionskopf so aussehen:

.
[{file}]
----
<<<linux_usbstick>>>
----

Den können wir einfach mit `echo` ausgeben. Wenn wir dann noch den
„Shabang“ nicht vergessen (das ist kein giftiger Stachel aus dem Wüstenplaneten
sondern eine Abkürzung für _sharp_ und _bang_, wobei letzteres
eine Abkürzung für das Ausrufezeichen ist!), an dem Linux erkennt, dass es
das Skript mit der Shell ausführen soll, dann sieht unser Plugin
so aus:

./usr/lib/check_mk_agent/plugins/linux_usbstick
[{file}]
----
#!/bin/sh
echo '<<<linux_usbstick>>>'
ls /dev/disk/by-id/ | grep -v -- -part
----

Als Dateiname hab ich jetzt einfach auch `linux_usbstick` verwendet,
auch wenn der eigentlich egal ist. Aber eines ist noch sehr wichtig: Machen
Sie die Datei ausführbar!

[{shell}]
----
{c-root} chmod +x /usr/lib/check_mk_agent/plugins/linux_usbstick
----

Natürlich können Sie das Plugin ganz einfach von Hand ausprobieren, indem Sie den
kompletten Pfad als Befehl eingeben:

[{shell}]
----
{c-root} /usr/lib/check_mk_agent/plugins/linux_usbstick
<<<linux_usbstick>>>
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
wwn-0x5002538655584d30
----

=== Agent ausprobieren

Wie immer ist am wichtigsten Test und Fehlersuche. Am besten gehen Sie in drei Schritten vor:

. Plugin solo ausprobieren. Das haben wir gerade gemacht.
. Agent aus ganzes lokal testen.
. Agent vom {CMK}-Server aus abrufen.

Das lokale Testen des Agenten ist sehr einfach. Rufen Sie einfach als `root`
den Befehl `check_mk_agent` auf. Irgendwo in der Ausgabe muss die neue
Sektion erscheinen:

[{shell}]
----
{c-root} check_mk_agent
----

Hier ist ein Ausschnitt der Ausgabe, welcher die neue Sektion enthält:

[{shell}]
----
<<<lnx_thermal:sep(124)>>>
thermal_zone0|-|BAT0|35600
thermal_zone1|-|x86_pkg_temp|81000|0|passive|0|passive
<<<local>>>
[hilite]#<<<linux_usbstick>>>#
[hilite]#ata-APPLE_SSD_SM0512F_S1K5NYBF810191#
[hilite]#wwn-0x5002538655584d30#
<<<lnx_packages:sep(124):persist(1589463274)>>>
accountsservice|0.6.45-1ubuntu1|amd64|deb|-||install ok installed
acl|2.2.52-3build1|amd64|deb|-||install ok installed
acpi|1.7-1.1|amd64|deb|-||install ok installed
----


Durch Anhängen von `less` können Sie in der Ausgabe blättern
(drücken Sie die Leertaste zum Blättern,
`/` zum Suchen und `Q` zum Beenden ):

[{shell}]
----
{c-root} check_mk_agent | less
----

Der dritte Test ist dann direkt von der {CMK}-Instanz aus. Nehmen Sie den Host ins Monitoring
auf (z.B. als `myserver01`) und rufen Sie die Agentendaten dann mit `cmk -d` ab.
Hier sollte die gleiche Ausgabe kommen:

[{shell}]
----
{c-omd} cmk -d myserver01 | less
----

Übrigens: `grep` hat mit `-A` eine Option, nach jedem Treffer
noch einige Zeilen mehr auszugeben.  Damit können Sie bequem die Sektion
suchen und ausgeben:

[{shell}]
----
{c-root} cmk -d heute | grep -A5 '^&lt;&lt;&lt;linux_usbstick'
<<<linux_usbstick>>>
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
wwn-0x5002538655584d30
<<<lnx_packages:sep(124):persist(1589463559)>>>
accountsservice|0.6.45-1ubuntu1|amd64|deb|-||install ok installed
----

Wenn das funktioniert, ist Ihr Agent vorbereitet! Und was haben wir
dafür gemacht? Wir haben lediglich ein dreizeiliges Skript mit dem Pfad
`/usr/lib/check_mk_agent/plugins/usbstick` erzeugt und ausführbar
gemacht!

Alles was nun folgt, geschieht nur noch auf dem {CMK}-Server: Dort schreiben
wir das eigentliche Checkplugin.

=== Die Sektion deklarieren

Das Vorbereiten des Agenten ist zwar der komplizierteste Teil, aber nur die
halbe Miete. Jetzt müssen wir {CMK} noch beibringen, wie es mit den Informationen
und der neuen Agentensektion umgehen soll, welches Services es erzeugen soll,
wann diese auf {OK} oder {CRIT} gehen sollen usw. All dies machen wir durch
die Programmierung eines Checkplugins in Python.

Für Ihre eigenen Checkplugins finden Sie ein Verzeichnis vorbereitet
in der `local`-Hierarchie des
link:cmk_commandline.html#sitedir[Instanzverzeichnisses]. Dieses lautet
`local/lib/check_mk/base/plugins/agent_based/`. Hier im Pfad
bedeutet `base` den Teil von {CMK}, der für das eigentlich Monitoring
und die Alarmierung zuständig ist. Das `agent_based` ist
für alle Plugins, die sich auf den {CMK}-Agenten
beziehen (also z.B. nicht Alarmierungsplugins). Am einfachsten, Sie wechseln
zum Arbeiten dort hinein:

[{shell}]
----
{c-omd} cd local/lib/check_mk/base/plugins/agent_based
----

Das Verzeichnis gehört dem Instanzbenutzer und ist daher für Sie schreibbar.
Sie können Ihr Plugin mit jedem auf dem Linuxsystem installierten Texteditor
bearbeiten.

Legen wir also unser Plugin hier an. Konvention ist, dass der Dateiname
den Namen der Agentensektion wiedergibt. _Pflicht_ ist, dass die Datei
mit `.py` endet, denn ab Version VERSION[2.0] von {CMK} handelt es
sich bei den Plugins immer um echte Pythonmodule.

Als erstes müssen wir die für die Plugins nötigen Funktionen aus
anderen Pythonmodulen importieren. Die einfachste Methode dafür ist die
mit einem `pass:[*]`. Wie Sie vielleicht ahnen können, steckt hier auch
eine Versionsnummer der API für die Pluginprogrammierung. Diese ist bis
auf weiteres Version 1, was hier durch `v1` abgekürzt ist:

.local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
[{file}]
----
from .agent_based_api.v1 import *
----

Diese Versionierung ermöglicht es uns in Zukunft eventuell neue
Versionen der API _parallel_ zu den bisherigen bereitzustellen,
so dass bestehende Checkplugins weiterhin problemlos funktionieren.


=== Den Check deklarieren

Damit {CMK} weiß, dass es den neuen Check gibt, muss dieser
registriert werden. Dies geschieht durch den Aufruf
der Funktion `register.check_plugin`.
Dabei müssen Sie immer mindestens vier Dinge angeben:

. `name`: Der Name des Checkplugins. Wenn Sie keinen Ärger bekommen möchten, nehmen Sie hier den gleichen Namen wie bei Ihrer neuen Agentensektion. Damit weiß der Check automatisch, welche Sektion er auswerten soll.
. `service_name`: Der Name des Services wie er dann im Monitoring erscheinen soll.
. `discovery_function`: Die Funktion zum Erkennen von Services dieses Typs (dazu gleich mehr).
. `check_funktion`: Die Funktion zum Durchführen des eigentlichen Checks (auch dazu gleich mehr).

Für unseren Check sieht das dann also so aus:

.
[{file}]
----
register.check_plugin(
    name="linux_usbstick",
    service_name="USB stick",
    discovery_function=discover_linux_usbstick,
    check_function=check_linux_usbstick,
)
----

Versuchen Sie am besten noch nicht, das gleich auszuprobieren, denn natürlich
müssen wir die Funktionen `discovery_linux_usbstick` und `check_linux_usbstick`
vorher noch schreiben. Und diese müssen im Quellcode _vor_ obiger Deklaration
erscheinen.


=== Die Discovery-Funktion schreiben

Eine Besonderheit von {CMK} ist die automatische Erkennung von zu
überwachenden Services. Damit dies klappt, muss jedes Checkplugin eine
Funktion definieren, welche anhand der Agentenausgaben erkennt, _ob_ ein Service
dieses Typs bzw. _welche_ Services des Typs für den betreffenden Host
angelegt werden sollen.

Die Discovery-Funktion wird immer dann aufgerufen, wenn für einen Host
die Serviceerkennung durchgeführt wird. Sie entscheidet dann ob, bzw.
welche Services angelegt werden sollen. In Standardfall bekommt sie genau
ein Argument mit dem Namen `section`. Dieses enthält die Daten
der Agentensektion in einem geparsten Format (dazu später mehr).

Wir implementieren folgende simple Logik: _Wenn_ die Agentensektion
`linux_usbstick` vorhanden ist, dann legen wir auch einen passenden
Service an. Dann erscheint dieser automatisch auf allen Hosts, wo unser
Agentenplugin ausgerollt ist. Das Vorhandensein der Sektion erkennen wir
ganz einfach daran, dass unsere Discovery überhaupt aufgerufen wird!

Die Discovery-Funktion muss Für jeden anzulegenden Service mittels
`yield` ein Objekt vom Typ `Service` zurückgeben (nicht mit
`return`). Bei Checks, die pro Host nur einmal auftreten können,
benötigt man keine weitere Angaben:

.
[{file}]
----
def discovery_linux_usbstick(section):
    yield Service()
----

=== Die Check-Funktion schreiben

Somit können wir nun zur eigentlichen Check-Funktion kommen, welche anhand
aktueller Agentenausgaben endlich entscheidet, welchen Zustand ein Service
annehmen soll. Da unser Check keine Parameter hat und es auch immer nur
einen pro Host gibt, wird unsere Funktion ebenfalls mit dem einzigen
Argument `section` aufgerufen.

Da wir diesmal den Inhalt auch wirklich brauchen, müssen wir uns
mit dem Format dieses Arguments befassen. Solange Sie keine explizite
link:devel_check_plugins.html#parsefunction[Parse-Funktion] definiert haben, zerlegt
{CMK} jede Zeile der Sektion anhand von Leerzeichen in eine _Liste von
Worten_. Das Ganze wird dann wiederum eine Liste dieser Wortlisten. Als
Endergebnis haben wir also immer eine Liste von Listen.

Im einfachen Fall, dass unserer Agentenplugin nur zwei Devices findet,
sieht das dann z.B. so aus (hier gibt es pro Zeile nur ein Wort):

.
[{file}]
----
[['ata-APPLE_SSD_SM0512F_S1K5NYBF810191'], ['wwn-0x5002538655584d30']]
----

Die Checkfunktion geht nun Zeile für Zeile durch und sucht nach
einer Zeile, deren erstes (und einziges) Wort mit `usb-SCSI_DISK` beginnt.
Wenn das der Falll ist, wird der Zustand {CRIT}.
Hier ist die Implementierung:

.
[{file}]
----
def check_linux_usbstick(section):
    for line in section:
        if line[0].startswith("usb-SCSI_DISK"):
            yield Result(state=State.CRIT, summary="Found USB stick")
            return
    yield Result(state=State.OK, summary="No USB stick found")
----

Und hier die Erklärung:
* Mit `for line in section` gehen wir in einer Schleife alle Zeilen der Agentenausgabe durch.
* Dann prüfen wir, ob das erste Wort der Zeile -- das jeweilige Gerät -- mit `usb-SCSI_DISK` beginnt.
* Falls ja, erzeugen wir ein Check-Resultat mit dem Status {CRIT} und dem Text `Found USB stick`. Und wir beenden dann die Funktion mit einem `return`.
* Falls die Schleife durchlaufen wird, ohne etwas zu finden, erzeugen wir den Status {OK} und den Text `No USB stick found`.

=== Die Discovery testen



=== Den Check testen



=== Das ganze Plugin auf einen Blick

Und hier ist das ganze Plugin nochmal komplett:

.local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
[{file}]
----
from .agent_based_api.v1 import *

def discover_linux_usbstick(section):
    yield Service()

def check_linux_usbstick(section):
    for line in section:
        if line[0].startswith("usb-SCSI_DISK"):
            yield Result(state=State.CRIT, summary="Found USB stick")
            return
    yield Result(state=State.OK, summary="No USB stick found")

register.check_plugin(
    name = "linux_usbstick",
    service_name = "USB stick",
    discovery_function = discover_linux_usbstick,
    check_function = check_linux_usbstick,
)
----

Und das hier war das Plugin für den Linuxagenten:

./usr/lib/check_mk_agent/plugins/linux_usbstick
[{file}]
----
#!/bin/sh
echo '<<<linux_usbstick>>>'
ls /dev/disk/by-id/ | grep -v -- -part
----

== Checks mit mehr als einem Service pro Host (Items)

=== Grundprinzip

In unserem Beispiel haben wir einen sehr einfachen Check gebaut, der auf
einem Host einen Service erzeugt -- oder eben nicht. Ein sehr üblicher Fall
ist aber natürlich auch, dass es von einem Check mehrere Services auf einem
Host geben kann.

Das häufigste Beispiel dafür sind die Dateisysteme eines Hosts. Das Plugin
mit dem Namen `df` legt pro Dateisystem auf dem Host einen Service
an. Um diese Services zu unterscheiden, wird der Mountpunkt des Dateisystems
(z.B. `/var`) bzw. der Laufwerksbuchstabe (z.B. `C:`)
in den Namen des Services eingebaut.  Das ergibt dann als Servicename
z.B. `Filesystem /var` oder `Filesystem C:`. Das Wort
`/var` bzw. `C:` wird hier als _Item_ bezeichnet. Wir
sprechen also auch von einem Check _mit Items_.

Wenn Sie einen Check mit Items bauen möchten, müssen Sie folgende
Dinge umsetzen:

* Die Discovery-Funktion muss die für jedes der Items, die auf dem Host sinnvollerweise überwacht werden sollen, einen Service generieren.
* Im Servicenamen müssen Sie das Item mithilfe des Platzhalters `%s` einbauen (also z.B. `"Filesystem %s"`).
* Die Check-Funktion wird pro Item einmal separat aufgerufen und bekommt dieses als Argument. Sie muss dann aus den Agentendaten die für dieses Item relevanten Daten herausfischen.

=== Ein einfaches Beispiel

Um das ganze praktisch ausprobieren zu können, bauen wir uns einfach
eine weitere Agentensektion, die nur Spieldaten ausgibt. Dazu genügt ein
kleines Shellskript. Die Sektion soll hier im Beispiel `foobar` heißen:

./usr/lib/check_mk_agent/plugins/foobar
[{file}]
----
#!/bin/sh
echo "<<<foobar>>>"
echo "West 100 100"
echo "East 197 200"
echo "North 0 50"
----

Von _Foobar_ gibt es hier drei Sektoren: `West`, `East`
und `North` (was immer auch das bedeuten mag). In jedem Sektor gibt
es eine Anzahl von _Plätzen_ von denen einige belegt sind (z.B. sind
in `East` 197 von 200 Plätzen belegt).

Nun legen wir dazu ein passendes Checkplugin an. Die Registrierung ist wie
gehabt, allerdings mit dem wichtigen Unterschied, dass der Servicename jetzt
genau einmal ein `%s` enthält. An dieser Stelle wird später dann von
{CMK} der Name des Items eingesetzt:

.
[{file}]
----
register.check_plugin(
    name = "foobar",
    service_name = "Foobar Sector [hilite]#%s#",
    discovery_function = discover_foobar,
    check_function = check_foobar,
)
----

Die Discovery-Funktion hat jetzt die Aufgabe, die zu überwachenden Items zu
ermitteln. Wie gehabt bekommt sie das Argument `section`.  Und auch hier
handelt es sich um eine Liste von Zeilen, welche ihrerseits wiederum Listen
von Worten sind. Diese sieht in unserem Beispiel aus aus:

.
[{file}]
----
[['West', '100', '100'], ['East', '197', '200'], ['North', '0', '50']]
----

So eine Liste kann man mit Python prima in einer Schleife
durchlaufen und den drei Worten pro Zeile gleich sinnvolle Namen geben:

.
[{file}]
----
for sector, _used, _slots in section:
    ...
----

In jeder Zeile ist das erste Wort -- hier der Sektor -- unser Item.  Immer wenn
wir ein Item gefunden haben, geben wir das mit `yield` zurück, wobei
wir ein Objekt vom Typ `Service` erzeugen, welches den Sektornamen als
Item bekommt. Der Unterstrich zeigt an, dass uns die beiden andere Spalten
in der Ausgabe erstmal egal sind, denn bei der Discovery ist es schließlich
unerheblich, wieviele Slots belegt sind. Insgesamt sieht das dann so aus:

.
[{file}]
----
def discover_foobar(section):
    for sector, _used, _slots in section:
        yield Service(item=sector)
----

Es wäre natürlich ein Leichtes, hier anhand von beliebigen Kriterien manche
Zeilen auszulassen. Vielleicht gibt es ja Sektoren, welche die Größe 0 haben
und die man grundsätzlich nie überwachen möchte? Lassen Sie solche Zeilen
einfach aus und yielden Sie dafür kein Item.

Wenn dann später der Host überwacht wird, dann wird die Check-Funktion
für jeden Service -- und damit für jedes Item -- separat aufgerufen. Sie
bekommt deswegen zusätzlich zur Sektion das Argment `item` mit dem
jeweils gesuchten Item. Jetzt gehen wir wieder alle Zeilen der Reihe nach
durch. Dabei suchen diejenige Zeile heraus, die zum gewünschten Item gehört:

.
[{file}]
----
def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            ...
----

Jetzt fehlt nur noch die eigentliche Logik, welche festlegt, wann das Ding denn überhaupt {OK},
{WARN} oder {CRIT} sein soll. Wir machen es hier so:

* Wenn alle Slots belegt sind, soll das Ding {CRIT} werden.
* Wenn weniger als 10 Slots frei sind, dann wird es {WARN}.
* Ansonsten {OK}

Die belegten und insgesamten Slots kommen ja immer als Wort zwei und drei
in jeder Zeile. Aber: es handelt sich hier um Strings, nicht um Zahlen.
Diese brauchen wir aber, um vergleichen und rechnen zu können. Daher
wandeln wir die Strings mit `int()` in Zahlen um.

Das Checkergebnis liefern wir dann, indem wir ein Objekt vom Typ `Result`
per `yield` liefern. Dieses benötigt die Parameter `state` und
`summary`:

.
[{file}]
----
def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            used = int(used)   # convert string to int
            slots = int(slots)   # convert string to int
            if used == slots:
                s = State.CRIT
            elif slots - used < 10:
                s = State.WARN
            else:
                s = State.OK
            yield Result(
                state = s,
                summary = f"used {used} out of {slots} slots")
            return
----

Dazu noch folgende Hinweise:

. Der Befehl `return` sorgt dafür, dass die Check-Funktion nach dem Bearbeiten des gefundenen Items sofort abgebrochen wird. Es gibt schließlich auch nichts mehr weiter zu tun.
. Wird die Schleife durchlaufen, ohne das gesuchte Item zu finden, so erzeugt {CMK} _automatisch_ das Resultat `UNKNOWN - Item not found in monitoring data`. Das ist so gewollt und gut so. Behandeln Sie diesen Fall nicht selbst. Wenn sie ein gesuchtes Item nicht finden, so lassen sie Python einfach aus der Funktion rauslaufen und {CMK} seine Arbeit erledigen.
. Mit dem Argument `summary` definieren Sie den Text, den der Service aus Statusausgabe produziert. Er ist rein informell und wird von {CMK} nicht weiter ausgewertet.

Übrigens gibt es für den häufigen Fall, dass Sie eine einfache Metrik auf Schwellwerte
prüfen wollen, die Hilfsfunktion `check_levels`. Diese wird in einem eigenen
link:devel_check_plugins.html#check_levels[Abschnitt] erklärt.



Probieren wir jetzt zunächst die Discovery aus. Der Übersicht halber beschränke ich das
ganze mit der Option `--detect-plugins=foobar` auf unser Plugin:

[{shell}]
----
{c-omd} cmk --detect-plugins=foobar -vI myhost123
  [green]#3# foobar
SUCCESS - Found 3 services, 1 host labels
----

Und jetzt können wir auch gleich das Checken ausprobieren (ebenfalls auf
`foobar` begrenzt):

[{shell}]
----
{c-omd} cmk --detect-plugins=foobar -v myhost123
Foobar Sector East   [yellow]#WARN - used 197 out of 200 slots#
Foobar Sector North  [green]#OK - used 0 out of 50 slots#
Foobar Sector West   [red]#CRIT - used 100 out of 100 slots#
----


=== Beispiel komplett

Und hier nochmal das ganze Beispiel komplett. Damit es keine Fehler wegen nicht definierter Funktionsnamen gibt,
müssen die Funktionen immer vor dem Registrieren definiert werden.


.local/lib/check_mk/base/plugins/agent_based/foobar.py
[{file}]
----
from .agent_based_api.v1 import *
import pprint

def discover_foobar(section):
    for sector, used, slots in section:
        yield Service(item=sector)

def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            used = int(used)    # convert string to int
            slots = int(slots)  # convert string to int
            if used == slots:
                s = State.CRIT
            elif slots - used < 10:
                s = State.WARN
            else:
                s = State.OK
            yield Result(
                state = s,
                summary = f"used {used} out of {slots} slots")
            return

register.check_plugin(
    name = "foobar",
    service_name = "Foobar Sector %s",
    discovery_function = discover_foobar,
    check_function = check_foobar,
)
----

== Messwerte

=== Werte in der Checkfunktion ermitteln

Nicht immer, aber oft befassen sich Checks mit Zahlen. Mit seinem link:graphing.html[Graphingsystem]
hat {CMK} eine Komponente, um solche Zahlen zu speichern, auszuwerten und darzustellen. Das
geht dabei völlig unabhängig von der Berechnung der Zuständige {OK}, {WARN} und {CRIT}.

Solche Messwerte -- oder auch Metriken genannt -- werden von der Checkfunktion ermittelt
und einfach als zusätzliches Ergebnis zurückgegeben. Dazu dient das Objekt `Metrik`,
welches mindestens die beiden Argument `name` und `value` benötigt.
Hier ist ein Beispiel:

.
[{file}]
----
    yield Metrik("fooslots", used)
----

=== Informationen zu den Schwellwerten

Weiterhin gibt es noch zwei optionale Argumente. Mit dem Argument `levels` können Sie eine Information
zu Schwellwerten für {WARN} und {CRIT} mitgeben, und zwar in Form eines Paares von zwei Zahlen.
Diese wird dann üblicherweise im Graphen als gelbe und rote Linie eingezeichnet. Die erste Zahl
steht für die Warnschwelle, die zweite für die kritische.
Dabei gilt die Konvention, dass der Check beim Erreichen der Warnschwelle
bereits auf {WARN} geht (bei {CRIT} analog).

Das sieht dann z.B. so aus (hier mit hartkodierten Schwellwerten):

.
[{file}]
----
    yield Metrik("fooslots", used, levels=(190,200))
----

Hinweise:

* Falls nur eine der beiden Schwellen definiert ist, tragen Sie für die andere einfach `None` ein, also z.B. `levels=(None, 200)`.
* Es sind auch Fließkommazahlen erlaubt, aber keine Strings.
* Achtung: für die _Überprüfung_ der Schwellwerte ist die Checkfunktion selbst verantwortlich.  Die Angabe von `levels` dient lediglich als Randinformation für das Graphingsystem!


=== Der Wertebereich

Analog zu den Schwellwerten können Sie dem Graphingsystem auch die Information über
den möglichen Wertebereich mitgeben. Damit ist der kleinste und größte mögliche Wert
gemeint. Das geschieht im Argument `boundaries`, wobei auch hier optional
für eine der beiden Grenzen `None` eingesetzt werden kann. Beispiel:

.
[{file}]
----
    yield Metrik(name="fooslots", value=used, boundaries=(0, 200))
----

Und jetzt unsere Checkfunktion aus dem obigen Beispiel nochmal, aber
diesmal mit der Rückgabe von Metrikinformation inklusive Schwellwerte und
Wertebereich (diesmal natürlich nicht mit fixen sondern mit berechneten Werten):

.
[{file}]
----
def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            used = int(used)    # convert string to int
            slots = int(slots)  # convert string to int

*            yield Metric(*
*                "fooslots",*
*                used,*
*                levels=(slots-10, slots),*
*                boundaries=(0, slots))*

            if used == slots:
                s = State.CRIT
            elif slots - used < 10:
                s = State.WARN
            else:
                s = State.OK
            yield Result(
                state = s,
                summary = f"used {used} out of {slots} slots")
            return
----






== Checks mit mehreren Teilresultaten

Um die Anzahl der Services auf einem Host nicht ins Unermessliche steigen zu
lassen, sind in einem Service oft mehrere Teilresultate zusammengefasst. So
prüft z.B. der Service [.guihint]#Memory used# unter Linux nicht nur den RAM- und Swapverbrauch,
sondern auch Shared memory, Pagetabellen und alles mögliche Andere.

Die API von {CMK} bietet dafür eine sehr komfortable Schnittstelle. So darf eine
Checkfunktion einfach beliebig oft ein Ergebnis mit `yield` erzeugen. Der
Gesamtstatus des Services richtet sich dann nach dem „schlechtsten“ Teilergebnis
nach dem Schema {OK} → {WARN} → {UNKNOWN} → {CRIT}.

Hier ist ein gekürztes fingiertes Beispiel:

.
[{file}]
----
def check_foobar(section):
    yield Result(state=State.OK, summary="Knulf rate optimal")
    # ...
    yield Result(state=State.WARN, summary="Gnarz required")
    # ...
    yield Result(state=State.OK, summary="Last Szork was good")
----

Die Summary des Services in der GUI sieht dann so aus:
„{{Knulf rate optimal, Gnarz required {WARN}, Last Szork was good}}“.
Und der Gesamtstatus ist {WARN}.

Auf die gleiche Art können Sie auch mehrere Metriken zurückgeben.
Rufen Sie einfach für jede Metrik einmal `yield Metrik(...)`
auf.

== Summary und Details

In der Monitoringansicht im {CMK} hat jeder Service neben dem Status {OK},
{WARN}, usw. auch eine Zeile Text. Diese hieß bis zur Version VERSION[1.6.0]
[.guihint]#Output of check plugin#. Ab VERSION[2.0] heißt diese [.guihint]#Summary# --
hat also die Aufgabe einer knappen Zusammenfassung des Zustandes. Die Idee
ist, dass dieser Text eine _Länge von 60 Zeichen nicht überschreitet_.
Das sorgt dann immer für eine übersichtliche Tabellendarstellung ohne
störende Zeilenumbrüche.

Daneben gibt es noch das Feld [.guihint]#Details#, welches früher
[.guihint]#Long output of check plugin (multiline)# hieß. Hier werden alle Details des Zustandes
angezeigt, wobei die Idee ist, dass alle Informationen des Summary hier auch
enthalten sind.

Beim Aufruf von `yield Result(...)` können Sie bestimmen, welche
Informationen so wichtig sind, dass sie in der Summary angezeigt werden
sollen und bei welchen es genügt, dass diese in den Details erscheinen.
Dabei gilt die Regel, dass Teilergebnisse, die zu einem {WARN}/{CRIT}
führen, _immer_ in der Summary sichtbar werden.

In unseren Beispiele bisher haben wir immer folgenden Aufruf
verwendet:

.
[{file}]
----
    yield Result(state=State.OK, summary="some important text")
----

Dieser führt dazu, dass `some important text` immer in der [.guihint]#Summary#
erscheint -- und zusätlich auch in den [.guihint]#Details#. Dies sollten sie
also nur für wichtige Informationen verwenden. Ist ein Teilergebnis eher
untergeordnet, so ersetzen Sie `summary` durch `notice` und
der Text erscheint -- falls es {OK} ist _nur_ in den Details.

.
[{file}]
----
    yield Result(state=State.OK, notice="some additional text")
----

Falls der Zustand {WARN} oder {CRIT} ist, taucht der Text dann automatisch
zusätzlich in der Summary auf:

.
[{file}]
----
    yield Result(state=State.CRIT, notice="some additional text")
----

Somit wird aus der Summary dann sofort klar, warum der Service nicht {OK}
ist.

Zu guter Letzt haben Sie noch -- sowohl bei `summary` als auch bei
`notice` die Möglichkeit, für die Details einen _alternativen_
Text anzugeben, der evtl. mehr Informationen zu dem Teilergebnis enthält:

.
[{file}]
----
    yield Result(state=State.OK,
                 summary="55% used space",
                 details="55.2% of 160 GB used (82 GB)")
----

Zusammengefasst bedeutet das:

* Der Gesamttext für die Summary sollte (bei Services die {OK} sind) nicht länger als 60 Zeichen sein.
* verwenden Sie immer entweder `summary` oder `notice` -- nicht beides und nicht keines davon.
* Fügen Sie bei Bedarf `details` hinzu, wenn der Text für die Details ein alternativer sein soll.

[#errors]
== Fehlerbehandlung

=== Exceptions und Crashreports

Die korrekte Behandlung von Fehlern nimmt (leider) einen großen Teil der
Programmierabeit ein. Die gute Nachricht ist: die API von {CMK} erledigt dabei
bereits die meiste Arbeit. Meistens ist für Sie daher wichtig, dass Sie Fehler
einfach *garnicht* behandeln.

Wenn Python in eine Situation kommt, die in irgendeiner Form _unerwartet_ ist,
reagiert es mit einer sogenannten _Exception_. Hier sind ein paar Beispiele:

* Sie konvertieren mit `int(...)` einen String in eine Zahl, aber der String enthält keine Zahl, z.B. `int("foo")`
* Sie greifen mit `bar[4]` auf das fünfte Element von `bar` zu, aber das hat nur vier Elemente.
* Sie rufen eine Funktion auf, die es nicht gibt.

Hier gilt die generelle wichtige Regel: *Fangen Sie Exceptions nicht selbst ab!* Denn {CMK} übernimmt das für
Sie in einer sinnvollen immer gleichen Art und Weise. Und zwar meist mit einem _Crashreport_. Das sieht
dann z.B. so aus:

image::crash_report_1.png[]

Durch einen Klick auf das Icon icon:icon_crash[] gelangt der User dann auf eine Seite, auf der er

* Die Datei angezeigt bekommt, in der der Crash stattgefunden hat.
* Alle Informationen über den Crash angezeigt bekommt (wie Fehlermeldung, Aufrufstack, Agentenausgabe, aktuelle Werte von lokalen Variablen und vieles mehr).
* Den Report zu uns als Feedback einsenden kann.

Das Einsenden des Reports macht natürlich nur Sinn für Checkplugins,
welche offiziell Teil von {CMK} sind. Aber Sie können Ihre Anwender bitten,
Ihnen die Daten einfach zukommen zu lassen. Diese werden Ihnen beim Finden
des Fehlers helfen. Oft ist es ja so, dass das Checkplugin bei Ihnen selbst
funktioniert, aber es bei anderen Anwendern vielleicht sehr sporadisch zu
Fehlern kommt. Diese können Sie dann so meist sehr leicht finden.

Falls Sie aber die Exception selbst abfangen würden, wären diese ganzen
Informationen plötzlich nicht verfügbar. Sie würden vielleicht den Service
auf {UNKNOWN} setzen und eine Fehlermeldung ausgeben. Aber die ganzen Umstände,
wie es dazu kam (z.B. die Daten vom Agenten), wäre verschleiert.

=== Exceptions auf der Kommandozeile ansehen

Falls Sie ihr Plugin auf der Kommandozeile ausführen, werden keine Crashreports
erzeugt. Sie sehen nur die zusammengefasste Fehlermeldung:

[{shell}]
----
{c-omd} cmk -II --detect-plugins=foobar myhost123
  WARNING: Exception in discovery function of check plugin 'foobar': invalid literal for int() with base 10: 'foo'
----

Aber: hängen Sie einfach die Option `--debug` dran. Dann bekommt Sie den
Python-Stacktrace:

[{shell}]
----
{c-omd} cmk --debug -II --detect-plugins=foobar myhost123
Traceback (most recent call last):
  File "/omd/sites/myhost123/bin/cmk", line 82, in <module>
    exit_status = modes.call(mode_name, mode_args, opts, args)
  File "/omd/sites/myhost123/lib/python3/cmk/base/modes/__init__.py", line 68, in call
    return handler(*handler_args)
  File "/omd/sites/myhost123/lib/python3/cmk/base/modes/check_mk.py", line 1577, in mode_discover
    discovery.do_discovery(set(hostnames), options.get("checks"), options["discover"] == 1)
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 345, in do_discovery
    _do_discovery_for(
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 397, in _do_discovery_for
    discovered_services = _discover_services(
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 1265, in _discover_services
    service_table.update({
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 1265, in <dictcomp>
    service_table.update({
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 1337, in _execute_discovery
    yield from _enriched_discovered_services(hostname, check_plugin.name, plugins_services)
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 1351, in _enriched_discovered_services
    for service in plugins_services:
  File "/omd/sites/myhost123/lib/python3/cmk/base/api/agent_based/register/check_plugins.py", line 69, in filtered_generator
    for element in generator(*args, **kwargs):
  File "/omd/sites/myhost123/local/lib/python3/cmk/base/plugins/agent_based/foobar.py", line 5, in discover_foobar
    int("foo")
ValueError: invalid literal for int() with base 10: 'foo'
----


=== Ungültige Ausgaben vom Agenten

Die Frage ist, wie Sie reagieren sollen, wenn die Ausgaben vom Agenten
nicht die Form haben, die Sie eigentlich erwarten würden - egal ob es der
„echte“ Agent ist oder die Daten per link:snmp.html[SNMP] kommen. Nehmen wir an, dass Sie
pro Zeile immer drei Worte erwarten. Was sollen Sie tun, falls nur zwei kommen?

Nun -- wenn das ein _erlaubtes und bekanntes_ Verhalten des Agenten
ist, dann müssen das natürlich abfangen und mit einer Fallunterscheidung
arbeiten.

Falls das aber eigentlich nicht sein darf... dann tun Sie am besten so,
als ob die Zeile immer aus drei Worten besteht, also z.B. mit:

.
[{file}]
----
def check_foobar(section):
    for foo, bar, baz in section:
        # ...
----

Sollte jetzt mal eine Zeile dabei sein, die nicht aus genau drei Worten
besteht, wird eine hübsche Exception erzeugt und wir bekommen den gerade
erwähnten sehr hilfreichen Crashreport.


=== Fehlende Items

Was ist, wenn der Agent korrekte Daten ausgibt, aber das Item, das
überprüft werden soll, fehlt? Also z.B. auf diese Art:

.
[{file}]
----
def check_foobar(item, section):
    for sector, used, slots in section:
        if item == sector:
            # ... Check state ...
            yield Result(...)
            return
----

Ist das gesuchte Item nicht dabei, so wird die Schleife durchlaufen und
Python fällt am Ende der Funktion einfach hinten raus, ohne dass ein
Resultat „geyieldet“ wurde. Und das ist genau das Richtige! Denn daran
erkennt {CMK}, dass das zu überwachende Item fehlt und erzeugt mit {UNKNOWN}
den richtigen Status und einen passenden Standardtext dazu.


[#snmp]
== SNMP-basierte Checks

=== Grundsätzliches

Das Entwickeln von Checks, die mit SNMP arbeiten, läuft sehr ähnlich zu den
agentenbasierten, nur dass Sie hier noch angeben müssen, welche SNMP-Bereiche
(OIDs) der Check benötigt. Falls Sie noch keine Erfahrung mit SNMP haben,
so empfehlen wir Ihnen an dieser Stelle als Vorbereitung unbedingt den
Artikel über das link:snmp.html[Monitoren via SNMP].

Der Ablauf der Discovery und des Checkens via SNMP ist etwas anders als beim
normalen Agenten. Denn anders also dort -- wo der Agent von sich aus alle
interessanten Informationen senden -- müssen wir bei SNMP selbst genau
sagen, welche Datenbereiche wir benötigen. Ein Komplettabzug aller Daten
wäre zwar theoretisch möglich (via SNMP-Walk), dauert aber bei schnellen
Geräten eher im Bereich von Minuten und bei komplexen Switches gern auch
über eine Stunde. Daher scheidet das beim Checken und sogar auch bei der
Discovery aus. {CMK} geht deswegen etwas zielgerichteter vor.

==== SNMP-Detection

Die Serviceerkennung teilt sich in zwei Phasen auf. Zunächst geschieht die
_SNMP-Detection_. Diese ermittelt, welche Plugins
denn überhaupt auf dem jeweiligen Gerät interessant sind. Dazu werden einige
wenige SNMP-OIDs abgerufen -- und zwar einzelne, ohne Walk.  Die wichtigste
davon ist die `sysDescr` (OID: `1.3.6.1.2.1.1.1.0`). Unter dieser
OID hält jedes SNMP-Gerät eine Beschreibung von sich selbst bereit, z.B.
„`Cisco NX-OS(tm) n5000, Software (n5000-uk9),...`“.

Ausgehend von diesem Text kann man für sehr viele Plugins schon definitiv
entscheiden, ob diese hier Sinn ergeben. Wenn der Text noch nicht spezifisch
genug ist, werden weitere OIDs geholt und geprüft. Ergebnis der SNMP-Detection
ist dann eine Kandidaten-Liste von Checkplugins.

==== Discovery

Im zweiten Schritt werden für jeden dieser Kandidaten die jeweils nötigen
Monitoringdaten mit SNMP-Walks geholt. Diese werden dann zu einer Tabelle
zusammengefasst und der Discovery-Funktion des Checks in dem Argument
`section` bereitgestellt, welche dann daraus wie gewohnt die zu
überwachenden Items ermittelt.

==== Checken

Beim Checken ist ja schon bekannt, welche Plugins für das Gerät ausgeführt
werden sollen und die SNMP-Detection entfällt. Hier werden gleich per
SNMP-Walks die für die Plugins benötigten Monitoringdaten geholt und daraus
das Argument `section` für die Checkfunktion befüllt.

==== Zusammenfassung

Was müssen Sie also bei einem SNMP-Check anders machen als bei einem agentenbasierten?

. Sie benötigen kein Plugin für den Agenten.
. Sie müssen die für die SNMP-Detection nötigen Einzel-OIDs und Suchtexte festlegen.
. Sie müssen festlegen, welche SNMP-Bereiche für das Monitoring geholt werden müssen.

=== Ein Wort zu den MIBs

Bevor wir weitermachen will ich hier noch ein Wort zu den berüchtigten
SNMP-MIBs verlieren, denn über diese gibt es viele Vorurteile. Gleich zu
Beginn eine gute Nachricht: {CMK} benötigt sie nicht. Wirklich! Sie sind
aber eine wichtige Hilfe, um einen SNMP-Check _entwickleln_ zu können.

Was ist nun eine MIB? Wörtlich bedeutet die Abkürzung _Management
Information Base_ -- etwas nichtssagend. Konkret ist eine MIB eine
ganz gut lesbare Textdatei, welche einen bestimmten Teilbaum der SNMP-Welt
beschreibt. Und zwar steht hier, welcher Ast im Baum -- also welche _OID_ --
welche Bedeutung hat. Das umfasst einen Namen für die OID, einen Hinweis,
welche Werte diese annehmen kann (z.B. bei enumerierten Datentypen, wo
dann Dinge wie 1=up, 2=down, etc. festgelegt sind) und manchmal auch noch
einen nützlichen Kommentar.

{CMK} liefert eine Reihe von frei verfügbaren MIB-Dateien mit aus. Diese
beschreiben sehr allgemeine Bereiche im globalen OID-Baum, enthalten aber
keine herstellerspezifischen Bereiche. Daher helfen sie für selbstentwickelte
Checks nicht viel weiter.

Versuchen Sie also, die für Ihr spezielle Gerät relevaten MIB-Dateien irgendwo
auf den Webseiten vom Hersteller oder sogar auf dem Management-Interface
des Geräts zu finden und installieren Sie diese in der {CMK}-Instanz nach
`local/share/check_mk/mibs`. Dann können Sie in SNMP-Walks OID-Nummern
in Namen umrechnen lassen und so schneller finden, wo die für das Monitoring
interessanten Daten sind. Auch enthalten die MIBs, wenn sie sorgfältig
gemacht sind, wie gesagt interessante Information in den Kommentaren.
Sie können eine MIB-Datei einfach mit einem Texteditor oder mit `less` ansehen.

=== Die richtigen OIDs finden

Die entscheidende Voraussetzung, um ein Plugin zu entwickeln, ist natürlich,
dass Sie wissen, welche OIDs die notwendigen Informationen enthalten. Der
erste Schritt dabei ist (falls das Gerät das nicht verweigert), einen kompletten
SNMP-Walk zu ziehen. Dabei werden _alle_ per SNMP verfügbaren Daten
abgerufen.

{CMK} kann das sehr einfach für Sie erledigen. Nehmen Sie dazu zunächst
das Gerät (oder eines der Geräte), für das Sie ein Plugin entwickeln wollen,
ins Monitoring auf. Sagen wir es heißt `mydevice01`. Stellen Sie sicher,
dass dieses in den Grundfunktionen überwacht werden kann. Zumindest müssen
die Services [.guihint]#SNMP Info# und [.guihint]#Uptime# gefunden werden und wahrscheinlich
auch noch mindestens ein [.guihint]#Interface#. So stellen Sie sicher, dass der SNMP-Zugriff
sauber funktioniert.

Wechseln Sie dann auf die Kommandozeile der {CMK}-Instanz. Hier können
Sie mit folgendem Befehl einen kompletten Walk ziehen. Dabei empfehle ich,
gleich die Option `-v` (verbose) zu verwenden:

[{shell}]
----
{c-omd} cmk -v --snmpwalk mydevice01
mydevice01:
Walk on ".1.3.6.1.2.1"...3898 variables.
Walk on ".1.3.6.1.4.1"...6025 variables.
Wrote fetched data to /omd/sites/heute/var/check_mk/snmpwalks/mydevice01.
----

Wie bereits erwähnt, kann so ein Komplettwalk Minuten oder sogar
Stunden dauern (auch wenn letzteres eher selten ist). Werden Sie also
nicht nervös, wenn es hier etwas dauert. Der Walk wurde nun in der Datei
`var/check_mk/snmpwalks/mydevice01` gespeichert. Es handelt sich
dabei um eine gut lesbare Textdatei, die etwa so beginnt:

.var/check_mk/snmpwalks/mydevice01
[{file}]
----
.1.3.6.1.2.1.1.1.0 JetStream 24-Port Gigabit L2 Managed Switch with 4 Combo SFP Slots
.1.3.6.1.2.1.1.2.0 .1.3.6.1.4.1.11863.1.1.3
.1.3.6.1.2.1.1.3.0 546522419
.1.3.6.1.2.1.1.4.0 hh@example.com
.1.3.6.1.2.1.1.5.0 sw-ks-01
.1.3.6.1.2.1.1.6.0 Core Switch Serverraum klein
.1.3.6.1.2.1.1.7.0 3
.1.3.6.1.2.1.2.1.0 27
----

In jeder Zeile steht eine OID und danach deren Wert. Und gleich in der ersten Zeile finden Sie die
wichtigste, nämlich die `sysDescr`.

Nun sind die OIDs nicht sehr aussagekräftig. Wenn die richtigen MIBs installiert sind,
können Sie diese in einem zweiten Schritt mit dem Befehl `cmk --snmptranslate`
in Namen umrechnen lassen. Am besten leiten Sie das Ergebnis, was ansonsten im Terminal
käme, in eine Datei um:

[{shell}]
----
OMD[heute]:~$ cmk --snmptranslate mydevice01  > translated
Processing 9923 lines.
finished.
----

Die Datei `translated` liest sich wie der ursprüngliche Walk, hat aber in jeder
Zeile nach dem `--&gt;` einen übersetzten Wert für die OID:

.translated
[{file}]
----
.1.3.6.1.2.1.1.1.0 JetStream 24-Port Gigabit L2 Managed Switch with 4 Combo SFP Slots --> *SNMPv2-MIB::sysDescr.0*
.1.3.6.1.2.1.1.2.0 .1.3.6.1.4.1.11863.1.1.3 --> *SNMPv2-MIB::sysObjectID.0*
.1.3.6.1.2.1.1.3.0 546522419 --> *DISMAN-EVENT-MIB::sysUpTimeInstance*
.1.3.6.1.2.1.1.4.0 hh@example.com --> *SNMPv2-MIB::sysContact.0*
.1.3.6.1.2.1.1.5.0 sw-ks-01 --> *SNMPv2-MIB::sysName.0*
.1.3.6.1.2.1.1.6.0 Core Switch Serverraum klein --> *SNMPv2-MIB::sysLocation.0*
.1.3.6.1.2.1.1.7.0 3 --> *SNMPv2-MIB::sysServices.0*
.1.3.6.1.2.1.2.1.0 27 --> *IF-MIB::ifNumber.0*
.1.3.6.1.2.1.2.2.1.1.1 1 --> *IF-MIB::ifIndex.1*
.1.3.6.1.2.1.2.2.1.1.2 2 --> *IF-MIB::ifIndex.2*
----

Beispiel: die OID `.1.3.6.1.2.1.1.4.0` hat den übersetzten Namen
`SNMPv2-MIB::sysContact.0`. Dies ist ein wichtiger Hinweis, der Rest
ist dann Übung, Erfahrung und natürlich experimentieren.

=== Die Registrierung der SNMP-Sektion

Wenn Sie also die notwendigen OIDs festgestellt haben, geht es an die
eigentliche Entwicklung des Plugins. Das geschieht in drei Schritten:

* Legen Sie für die SNMP-Detection fest, welche OIDs welche Texte enthalten müssen, damit Ihr Plugin ausgeführt werden soll.
* Deklarieren Sie, welche OID-Zweige für das Monitoring geholt werden müssen.
* Schreiben Sie ein Checkplugin analog zu denjenigen für agentenbasierte Checks.

Die ersten beiden Schritte erfolgen durch die Registrierung einer SNMP-Sektion.
Dies erledigen Sie durch den Aufruf von `register.snmp_section()`. Hier
geben Sie mindestens drei Argumente an: den Namen der Sektion (`name`),
die Angaben für die SNMP-Detection `detect` und die benötigten
OID-Zweige für das eigentlich Monitoring (`fetch`). Hier ist ein Beispiel für ein
fiktives Checkplugin mit dem Namen `foo`:

.local/lib/check_mk/base/plugins/agent_based/foo.py
[{file}]
----
register.snmp_section(
    name = "foo",
    detect = startswith(".1.3.6.1.2.1.1.1.0", "foobar device"),
    fetch = SNMPTree(
        base = '.1.3.6.1.4.1.35424.1.2',
        oids = [
            '4.0',
            '5.0',
            '8.0',
        ],
    ),
)
----

==== Die SNMP-Dection

Mit dem Schlüsselwort `detect` geben Sie an, unter welchen Bedingungen
die Discoveryfunktion überhaupt ausgeführt werden soll. In unserem Beispiel
ist das der Fall, wenn der Wert der OID `.1.3.6.1.2.1.1.1.0` (also
die `sysDescr`) mit dem Text `foobar device` beginnt (wobei
Groß-/Kleinschreibung grundsätzlich nicht unterschieden wird). Neben
`startswith` gibt es noch eine ganze Reihe weiterer möglichen
Attribute. Dabei existiert von jedem auch eine negierte Form, welche mit
`not_` beginnt:

[cols="28,33,~"]
|===
|Attribut |Negation |Bedeutung 

|equals(oid, needle) |not_equals(oid, needle) |Der Wert der der OID ist gleich dem Text `needle`
|contains(oid, needle) |not_contains(oid, needle) |Der Wert der der OID enthält an irgendeiner Stelle den Text `needle`
|startswith(oid, needle) |not_startswith(oid, needle) |Der Wert der der OID beginnt mit dem Text `needle`
|endswith(oid, needle) |not_endswith(oid, needle) |Der Wert der der OID endet mit dem Text `needle`
|matches(oid, regex) |not_matches(oid, regex) |Wert der OID matcht auf den link:regexes.html[regulären Ausdruck] `regex`, und zwar hinten und vorne geankert, also mit einem exakten Match. Wenn Sie nur einen Teilstring benötigen, ergänzen Sie einfach vorne bzw. hinten noch ein `pass:[.*]`
|exists(oid) |not_exists(oid) |Erfüllt, wenn die OID auf dem Gerät verfügbar ist. Der Wert darf leer sein.
|===


Daneben gibt es noch die Möglichkeit, mehrere Tests mit `all_of`
oder `any_of` zu verknüpfen. `all_of` erfordert mehrere
erfolgreiche Attribute für eine positive Erkennung des Plugins. Folgendes
Beispiel findet auf einem Gerät das Plugin, wenn in der `sysDescr` mit
dem Text `foo` (oder `FOO` oder `Foo`) beginnt *und*
die OID `.1.3.6.1.2.1.1.2.0` den Text `.4.1.11863.` enthält:

.
[{file}]
----
detect = all_of(
    startswith(".1.3.6.1.2.1.1.1.0", "foo"),
    contains(".1.3.6.1.2.1.1.2.0", ".4.1.11863.")
)
----

`any_of` hingegen ist damit zufrieden, wenn auch nur eines der Kriterien
erfüllt ist. Hier ist ein Beispiel, wo verschiedene Werte für die `sysDescr`
erlaubt sind:

.
[{file}]
----
detect = any_of(
    startswith(".1.3.6.1.2.1.1.1.0", "foo version 3 system"),
    startswith(".1.3.6.1.2.1.1.1.0", "foo version 4 system"),
    startswith(".1.3.6.1.2.1.1.1.0", "foo version 4.1 system"),
)
----

Übrigens: Kennen Sie sich gut mit link:regexes.html[regulären Ausdrücken] aus? Dann würden Sie wahrscheinlich
das ganze vereinfachen und doch wieder mit einer Zeile auskommen:

.
[{file}]
----
detect = matches(".1.3.6.1.2.1.1.1.0", "FOO Version (3|4|4.1) .*"),
----

Und noch ein wichtiger Hinweis: Die OIDs, die Sie bei der `detect`-Deklaration
von einem Plugin angeben, werden im Zweifel von *jedem* Gerät geholt, welches
per SNMP überwacht wird. Sein Sie daher sehr sparsam bei der Verwendung von herstellerspezifischen
OIDs. Versuchen Sie, Ihre Erkennung unbedingt so zu machen, dass aussschließlich
die `sysDescr` (`.1.3.6.1.2.1.1.1.0`) und die `sysObjectID`
(`.1.3.6.1.2.1.1.2.0`) verwendet werden. Falls Sie dennoch eine weitere
andere OID benötgen, dann reduzieren Sie die Anzahl der Geräte, wo diese angefragt
wird auf ein Minimum, indem Sie zuvor mittels der `sysDescr` soviele Geräte
wie möglich bereits ausschließen, z.B. so:

.
[{file}]
----
detect = all_of(
    startswith(".1.3.6.1.2.1.1.1.0", "foo"),   # first check sysDescr
    contains(".1.3.6.1.4.1.4455.1.3", "bar"),  # fetch vendor specific OID
)
----

Das `all_of()` funktioniert so, dass bei einem Scheitern der ersten
Bedingung die zweite garnicht erst probiert wird (und somit die betreffende
OID auch nicht geholt). Hier im Beispiel wird die OID `.1.3.6.1.4.1.4455.1.3` nur
bei solchen Geräten geholt, die `foo` in ihrer `sysDescr` haben.

Was geschieht, wenn Sie die Deklaration falsch oder zumindest nicht ganz
zielsicher gemacht haben?

* Falls die Detection fälschlicherweise Geräte erkennt, auf denen die nötigen OIDs garnicht vorhanden sind, wird Ihre Discoveryfunktion dann auch keine Services erzeugen. Es passiert also nichts „Schlimmes“. Allerdings wird das die Discovery auf solchen Geräten verlangsamen, da jetzt jedesmal nutzlos versucht wird, die entsprechenden OIDs abzufragen.
* Falls die Detection eigentlich zulässige Geräte _nicht_ erkennt, werden dort im Monitoring bei der Discovery auch keine Services gefunden.

=== Die OID-Bereiche für das Monitoring

Die wichtigste Stelle der SNMP-Deklaration ist die Angabe, welche OIDs für
das Monitoring geholt werden sollen. In fast allen Fällen benötigt ein Plugin
dazu nur ausgewählte Äste aus einer einzigen Tabelle. Betrachten wir folgendes
Beispiel:

.
[{file}]
----
    fetch = SNMPTree(
        base = '.1.3.6.1.4.1.35424.1.2',
        oids = [
            '4.0',
            '5.0',
            '8.0',
        ],
    ),
----

Das Schlüsselwort `base` gibt hier einen OID-Präfix an. Alle
nötigen Daten liegen unterhalb. Bei `oids` geben Sie dann eine
Liste von Sub-OIDs an, die ab dort geholt werden sollen. In obigem
Beispiel werden dann insgesamt drei SNMP-Walks gemacht, nämlich auf
ausgehend von den OIDs `.1.3.6.1.4.1.35424.1.2.4.0`, `.1.3.6.1.4.1.35424.1.2.5.0`
und `.1.3.6.1.4.1.35424.1.2.8.0`. Dabei ist es wichtig, dass diese
Walks die gleiche Anzahl von Variablen holen und dass diese auch einander
entsprechen. Damit ist gemeint, dass z.B. das n-te Element aus jedem der
Walks dem selben überwachten Objekt entsprechen.

Hier ist ein Beispiel vom Checkplugin `snmp_quantum_storage_info`:

.
[{file}]
----
    tree = SNMPTree(
       base=".1.3.6.1.4.1.2036.2.1.1",  # qSystemInfo
       oids=[
           "4",   # qVendorID
           "5",   # qProdId
           "6",   # qProdRev
           "12",  # qSerialNumber
       ],
    ),
)
----

Hier wird pro Storagegerät jeweils die Vendor ID, die Product ID, die Product Revsion
und die Seriennummer geholt.

Der Discovery- und Checkfunktion werden diese Daten als Tabelle präsentiert, also
als Liste von Listen. Dabei wird die Tabelle so gespiegelt, dass Sie pro Eintrag
in der äußeren Liste alle Daten zu einem Item haben. Jeder Eintrag hat so viele
Elemente, wie Sie bei `oids` angegeben haben. So können Sie die Liste
sehr praktisch mit einer Schleife durchlaufen, z.B.

.
[{file}]
----
    for vendor_id, prod_id, prod_rev, serial_number in section:
        ...
----

Bitte beachten Sie
* Alle Einträge sind _strings_, selbst wenn die betreffenden OIDs eigentlich Zahlen sind.
* Fehlende OIDs werden als Leerstrings präsentiert
* Denken Sie an die Möglichkeit, während der Entwicklung mit `pprint` die Daten formatiert auszugeben.

=== Weitere SNMP-Sonderheiten


Hier beschreiben wir in Zukunft noch:
* Wie Sie mehrere unabhängige SNMP-Bereiche abrufen können
* Was es mit OIDEnd() auf sich hat.
* Weitere Sonderfälle beim Umgang mit SNMP

== Hinweise für Nutzer der alten API

Sind Sie bereits erfahren bei der Entwicklung von Checkplugins mit der bisherigen
API -- derjenigen bis Version VERSION[1.6.0] von {CMK}? Dann finden Sie hier einige
Hinweise über wichtige Änderungen zusammengefasst.

=== saveint() und savefloat()

Die beiden Funktionen `saveint()` und `savefloat()` sind weggefallen.
Zur Erinnerung: `saveint(x)` liefert `0` wenn sich `x` nicht
vernünftig in eine Zahl konvertieren lässt, z.B. weil es ein leerer String ist oder
nicht nur aus Ziffern besteht.

Auch wenn es dafür einige wenige gute Anwendungsfälle gab, wurde es doch in der
Mehrheit der Fälle falsch verwendet und hat dazu geführt, dass so viele
link:devel_check_plugins.html#errors[Fehler] verschleiert wurden.

Für den Fall, dass Sie bei einem Leerstring eine `0` bekommen möchten,
also den häufigsten „guten“ Anwendungsfall von `saveint(x)`, können
Sie einfach Folgendes schreiben:

.
[{file}]
----
foo = int(x) if x else 0
----

Für `savefloat()` gilt alles analog.


== Formatierung von Zahlen

=== Grundlegendes

In der Summary oder den Details eines Services werden oft Zahlen ausgegeben. Um Ihnen
eine schöne und korrekte Formatierung möglichst einfach zu machen und um
auch die Ausgaben von allen Checkplugins zu vereinheitlichen, gibt es Hilfsfunktionen
für die Darstellung von verschiedenen Arten von Größen.
Alle diese sind Unterfunktionen vom Modul `render` und werden folglich
mit `render.` aufgerufen. Z.B. ergibt `render.bytes(2000)` den Text
`1.95 KiB`.

Allen diesen Funktionen ist gemein, dass Sie ihren Wert in einer
sogenannten _kanonischen_ oder natürlichen Einheit bekommen. So muss
man nie nachdenken und es gibt keine Schwierigkeiten oder Fehler bei der
Umrechung. Z.B. werden Zeiten immer in Sekunden angegeben und Größen von
Festplatten, Dateien, etc. immer in Bytes und nicht in Kilobytes, Kibibytes,
Blöcken oder sonstigem Durcheinander.

Bitte verwenden Sie diese Funktionen auch dann, wenn Ihnen die Darstellung
nicht so gut gefällt. Immerhin ist diese dann für den Benutzer einheitlich.
Und zukünftige Versionen von {CMK} können die Darstellung möglicherweise
ändern oder sogar konfigurierbar für den Benutzer machen. Davon wird dann
Ihr Checkplugin auch profitieren.

Nach der ausführlichen Beschreibung aller Darstellungsfunktionen (Renderfunktionen) finden
Sie eine Zusammenfassung in Form einer übersichtlichen Tabelle.

=== Zeiten, Zeitspannen, Frequenzen

Absolute Zeitangaben (Zeitstempel) werden mit `render.date()` oder `render.datetime()`
formatiert. Die Angaben erfolgen immer in _Sekunden ab dem 1. Januar 1970, 00:00:00 UTC_ -- der
sogenannten Epochenzeit. Dies ist auch das Format, mit dem die Pythonfunktion `time.time()`
arbeitet. Vorteil an dieser Darstellung ist, dass sich damit sehr einfach rechnen lässt, also
z.B. die Dauer eines Vorgangs, wenn Start- und Endzeit bekannt sind. Die Formel ist dann
einfach `duration = end - start`. Und diese Berechnungen funktionieren unabhängig von
der Zeitzone, Sommerzeitumstellungen oder Schaltjahren.

`render.date()` gibt dabei nur das Datum aus, `render.datetime()` fügt noch die
Uhrzeit hinzu. Die Ausgabe erfolgt dabei gemäß der aktuellen Zeitzone desjenigen {CMK}-Servers,
welcher den Check ausführt! Beispiele:

[cols="50,~"]
|===
|Aufruf |Ausgabe 

|render.date(0) |Jan 01 1970
|render.datetime(0) |Jan 01 1970 01:00:00
|render.date(1600000000) |Sep 13 2020
|render.datetime(1600000000) |Sep 13 2020 14:26:40
|===


Bitte wundern Sie sich jetzt nicht, dass `render.date(0)` als Uhrzeit
nicht 00:00, sondern 01:00 ausgibt! Das liegt daran, dass ich dieses Handbuch
in der Zeitzone von Deutschland schreibe, und die ist der Standardzeit UTC
eine Stunde voraus (zumindest während der Normalzeit, denn der 1. Januar liegt
ja bekanntlich nicht in der Sommerzeit).

Für _Zeitspannen_ gibt es noch die Funktion `render.timespan()`.
Diese bekommt eine Dauer in Sekunden und gibt das menschenlesbar aus. Bei
größeren Zeitspannen werden Sekunden oder Minuten weggelassen.


[cols="50,~"]
|===
|Aufruf |Ausgabe 

|render.timespan(1) |1 second
|render.timespan(123) |2 minutes 3 seconds
|render.timespan(12345) |3 hours 25 minutes
|render.timespan(1234567) |14 days 6 hours
|===


Eine _Frequenz_ ist quasi der Kehrwert der Zeit. Die kanonische Einheit ist _Hz_, was
das gleiche bedeutet wie 1 / sec. Einsatzgebiet ist z.B. die Taktrate einer CPU:

[cols="50,~"]
|===
|Aufruf |Ausgabe 

|render.frequency(111222333444) |111 GHz
|===



=== Bytes

Überall wo es um Arbeitsspeicher, Dateien, Festplatten, Dateisystem und
dergleichen geht, ist die kanonische Einheit das _Byte_. Da Computer
sowas meist in Zweierpotenzen organisieren, also z.B. in Einheiten zu
512, 1024 oder 65536 Bytes, hatte sich dabei von Beginn an eingebürgert,
dass ein _Kilobyte_ nicht 1000, sondern 1024 Bytes sind. An sich
sehr praktisch, weil so meist runde Zahlen rauskamen. Der legendäre Commodore
C64 hatte eben 64 Kilobyte Speicher und nicht 65,536.

Leider kamen irgendwann Festplattenhersteller auf die Idee, die Größen
ihrer Platten in 1000'er-Einheiten anzugeben. Da bei jeder Größenordnung
der Unterschied zwischen 1000 und 1024 immerhin 2,4% ausmacht, und diese sich
aufmultiplizieren, wird so aus einer Platte der Größe 1 GB (1024 mal 1024 *
1024) auf einmal 1,07 GB. Das verkauft sich besser.

Diese lästige Verwirrung besteht bis heute und sorgt immer wieder für Fehler.
Als Linderung wurden von der internationalen elektrotechnischen Kommission
neue Präfixe auf Grundlage des Binärsystems festgelegt. Demnach ist heute
offiziell ein Kilobyte 1000 Byte und ein _Kibibyte_ 1024 Byte (2 hoch 10).
Außerdem soll man _Mebibyte_ und _Gibitbyte_ und _Tebibyte_
sagen (schon mal gehört?). Die Abkürzungen lauten (Achtung, hier auf
einmal immer i, statt e!) _KiB_, _MiB_, _GiB_ und _TiB_.

{CMK} passt sich an diesen Standard an und hilft Ihnen mit mehreren angepassten
Renderfunktionen dafür, dass Sie immer korrekte Ausgaben machen. So
gibt es speziell für Festplatten und Dateisysteme die Funktion
`render.disksize()`, welche die Ausgabe in 1000'er-Potenzen macht.

[cols="50,~"]
|===
|Aufruf |Ausgabe 

|render.disksize(1000) |1.00 kB
|render.disksize(1024) |1.02 kB
|render.disksize(2000000) |2.00 MB
|===


Bei der Größe von _Dateien_ ist es oft üblich, die genaue Größe in
Bytes _ohne Rundung_ anzugeben. Dies hat den Vorteil, dass man so
sehr schnell sehen kann, wenn sich eine Datei auch nur minimal geändert
hat oder dass zwei Dateien (wahrscheinlich) gleich sind. Hierfür ist
die Funktion `render.filesize()` verantwortlich:

[cols="50,~"]
|===
|Aufruf |Ausgabe 

|render.filesize(1000) |1,000 B
|render.filesize(1024) |1,024 B
|render.filesize(2000000) |2,000,000 B
|===


Wenn Sie eine Größe ausgeben möchte, die keine Platten- oder Dateigröße ist,
dann verwenden Sie einfach das generische `render.bytes()`. Hier bekommen
sie die Ausgabe in klassichen 1024'er-Potenzen in der neuen offiziellen Schreibweise:

[cols="50,~"]
|===
|Aufruf |Ausgabe 

|render.bytes(1000) |1000 B
|render.bytes(1024) |1.00 KiB
|render.bytes(2000000) |1.91 MiB
|===



=== Bandbreiten, Datenraten

Die Netzwerker haben ihre eigenen Begriffe und Arten, Dinge auszudrücken.
Und wie immer gibt sich {CMK}-Mühe, in jeder Domäne die dort übliche
Art zu kommunizieren zu übernehmen. Deswegen gibt es für Datenraten
und Geschwindigkeiten gleich drei verschiedene Renderfunktionen. Alle
haben gemeinsam, dass die Raten in _Bytes pro Sekunde_ übergeben
werden, selbst dann, wenn die Ausgabe in Bits erfolgt!

`render.nicspeed()` stellt die Maximalgeschwindigkeit einer
Netzwerkkarte oder eines Switchports dar. Da es keine Messwerte sind, muss
auch nicht gerundet werden. Obwohl kein Port einzelne Bits versenden
kann, sind die Angaben aus historischen Gründen in Bits. Achtung: trotzdem
müssen Sie auch hier Bytes pro Sekunde übergeben! Beispiele:

[cols="50,~"]
|===
|Aufruf |Ausgabe 

|render.nicspeed(12500000) |100 MBit/s
|render.nicspeed(100000000) |800 MBit/s
|===


`render.networkbandwidth()` ist für eine tatsächlich gemessene
Übertragungsgeschwindigkeit im Netzwerk. Eingabewert sind wieder Bytes pro
Sekunde (Oder „Oktette“, wie der Netzwerker sagen würde):

[cols="50,~"]
|===
|Aufruf |Ausgabe 

|render.networkbandwidth(123) |984 Bit/s
|render.networkbandwidth(123456) |988 kBit/s
|render.networkbandwidth(123456789) |988 MBit/s
|===


Wo es nicht ums Netzwerk geht und dennoch Datenraten ausgegeben werden,
sind wieder Bytes üblich. Prominentester Fall sind IO-Raten von Festplatten.
Dafür gibt es die Renderfunktion `render.iobandwidth()`, die in
{CMK} mit 1000'er-Potzenzen arbeitet:

[cols="50,~"]
|===
|Aufruf |Ausgabe 

|render.iobandwidth(123) |123 B/s
|render.iobandwidth(123456) |123 kB/s
|render.iobandwidth(123456789) |123 MB/s
|===


=== Prozentwerte

Die Funktion `render.percent()` stellt einen Prozentwert dar --
auf zwei Nachkommastellen gerundet. Es ist insofern eine Ausnahme zu
den anderen Funktionen, als hier nicht der eigentlich natürliche Wert
-- also das Verhältnis -- übergeben wird, sondern wirklich die Prozentzahl.
Wenn also etwas z.B. zur Hälfte voll ist, müssen Sie nicht 0.5 sondern 50 übergeben.

Weil es manchmal interessant sein kann zu wissen, ob ein Wert beinahe Null
oder exakt Null ist, werden Werte größer als Null, aber kleiner als 0.01
sind durch Anfügen eines „<“ Zeichens markiert.
[cols="50,~"]
|===
|Aufruf |Ausgabe 

|render.percent(0.004) |<0.01%
|render.percent(18.5) |18.50%
|render.percent(123) |123.00%
|===


=== Zusammenfassung

Hier ist nochmal eine Übersicht über alle Renderfunktionen:

[cols="10,10,40,~"]
|===
|Funktion |Eingabe |Beschreibung |Beispielausgabe 

|date |Epoche |Datum |Dec 18 1970
|datetime |Epoche |Datum und Uhrzeit |Dec 18 1970 10:40:00
|timespan |Sekunden |Dauer / Alter |3d 5m
|frequency |Hz |Frequenz (z.B. Taktrate) |110 MHz
|disksize |Bytes |Größe von Festplatte, Basis 1000 |1,234 GB
|filesize |Bytes |Größe von Dateien, volle Genauigkeit |1,334,560 B
|bytes |Bytes |Größe in Bytes, Basis 1024 |23,4 KiB
|nicspeed |Octets/sec |Geschwindigkeit von Netzwerkkarten |100 MBit/s
|networkbandwidth |Octets/sec |Übertragungsgeschwindigkeit |23.50 GBit/s
|iobandwidth |Bytes/sec |IO-Bandbreiten |124 MB/s
|percent |Prozent |Prozentwert, sinnvoll gerundet |99.997%
|===



== Weitere Aspekte

In diesem Artikel werden in Zukunft noch weitere Aspkete der Pluginentwicklung
besprochen werden. Die wichtigsten sind:


[#parameters]
=== Schwellwerte und andere Checkparameter
[#check_levels]
==== Die Hilfsfunktion `check_levels`
_... wird noch ergänzt ..._


=== Checks im Cluster
=== Checks mit einem Regelsatz, welche die Discovery steuert
=== Counter und andere persistierte Daten
=== Host- und Servicelabels erzeugen
=== Includefunktionen, geteilter Code
=== Definition von Perf-O-Metern, Graphtemplates, Metriken
=== Manpages schreiben
=== Checks, die mehr als eine Sektion verwenden
=== Deklaratoren in den Sektionen, z.B. `sep(...)`.
=== Mehrere Checks für die gleiche Sektion
=== Ein Check, der mehrere Sektionen auswertet

== Ausblick

Wenn das klappt, sind Sie eigentlich fertig. Sie können das Ganze aber noch
um etliche Zusatzfeatures erweitern, wie zum Beispiel:

* Definitionen für die von den Services gelieferten link:graphing.html[Messdaten], damit schöne und gut beschriftete Graphen und „Perf-O-Meter“ erzeugt werden.
* Ein Regelsatz, mit dem Sie die Parameter des Checkplugins konfigurieren können.
* Ein Regelsatz, welcher das Agentenplugin für die link:wato_monitoringagents.html#bakery[Agentenbäckerei] konfiguriert.
* Ein Regelsatz, mit der der Spezialagent konfiguriert werden kann.
* Eine Manualpage, welche das Checkplugin für den Anwender dokumentiert.
* Ein link:mkps.html[MKP-Paket], in welchem das Plugin paketiert und einfach installierbar ist.

Artikel dazu folgen hier in Kürze...

// H1:Komplexe Agentenausgaben mittels Parsefunktion bändigen#parsefunction
// Der nächste Schritt ist die sogenannten _Parse-Funktion_. Diese
// hat die Aufgabe, die „rohen“ Agentendaten zu parsen und in eine logisch
// aufgeräumte Form zu bringen, die für alle weiteren Schritte einfach
// zu verarbeiten ist. Konvention ist, dass diese nach der Agentensektion
// benannt wird und mit `parse_` beginnt. Sie bekommt als einziges
// Argument `string_table`. Bitte beachten Sie, dass Sie hier nicht
// frei in der Wahl des Arguments sind. Es muss wirklich so heißen.
//
// Wir schreiben unsere Parse-Funktion jetzt erstmal so, dass wir einfach
// nur die Daten, die sie bekommt, auf der Konsole ausgeben. Dazu nehmen
// wir einfach die `print`-Funktion (Achtung: seit Python 3 sind
// hier Klammern zwingend notwendig):
//
// F+:
// def parse_linux_usbstick(string_table):
//     print(string_table)
// F-:
//
// Damit das Ganze irgendetwas bewirken soll, müssen wir unsere Parse-Funktion
// und überhaupt die neue Agentensektion bei {CMK} bekannt machen. Dazu
// rufen wir eine Registrierfunktion auf:
//
// F+:
// register.agent_section(
//     name = "linux_usbstick",
//     parse_function = parse_linux_usbstick,
// )
// F-:
//
// Hier ist es wichtig, dass der Name der Sektion wirklich exakt mit dem
// Sektionsheader in der Agentenausgabe übereinstimmt. Insgesamt
// sieht das jetzt so aus:
//
// F+:local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
// from .agent_based_api.v1 import *
//
// def parse_linux_usbstick(string_table):
//     print(string_table)
//
// register.agent_section(
//     name = "linux_usbstick",
//     parse_function = parse_linux_usbstick,
// )
// F-:
//
// Wir haben jetzt gewissermaßen das einfachste mögliche Plugin gebaut, was noch
// keinen wirklich Nutzen hat, aber das wir immerhin schon testen können.  Dazu
// stoßen wir auf der Kommandozeile eine Serviceerkennung (Option `-I`)
// von dem Host an, dessen Agenten wir vorhin präpariert haben. _Wenn_
// dessen Ausgabe auch wirklich eine Sektion `linux_usbstick` enthält,
// dann müssten wir unsere Debugausgabe sehen:
//
// C+:
// OM:cmk -I myhost123
// [['ata-APPLE_SSD_SM0512F_S1K5NYBF810191'], ['wwn-0x5002538655584d30']]
// C-:
//
// Etwas übersichtlicher wird die Ausgabe, wenn wir das einfache `print`
// durch ein Pretty-print aus dem Modul `pprint` ersetzen. Das ist für
// alle weitere Debugausgaben sehr empfehlenswert:
//
// F+:local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
// from .agent_based_api.v1 import *
// *import pprint*
//
// def parse_linux_usbstick(string_table):
//     *pprint.pprint(string_table)*
//
// register.agent_section(
//     name = "linux_usbstick",
//     parse_function = parse_linux_usbstick,
// )
// F-:
//
// Das sieht dann so aus:
//
// C+:
// OM:cmk -I myhost123
// [['ata-APPLE_SSD_SM0512F_S1K5NYBF810191'],
//  ['wwn-0x5002538655584d30']]
// C-:
//
//
// H2:Die Parse-Funktion schreiben
//
// Wenn Sie genau hinsehen, dann erkennen Sie, dass es sich hier verschachtelte
// Listen handelt. Im Argument `string_table` bekommen Sie eine Liste,
// welche _pro Zeile_ der Agentenausgabe eine Liste von _Worten_
// beheinhaltet. Dabei werden die Zeilen an Folgen von Leerzeichen getrennt. Da
// unsere Sektion pro Zeile nur ein Wort enthält, bestehen ergo die inneren
// Listen aus nur jeweils einem Eintrag.
//
// Folgendes Beispiel macht die Struktur noch etwas klarer:
//
// F+:local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
// from .agent_based_api.v1 import *
// import pprint
//
// def parse_linux_usbstick(string_table):
//     print("Number of lines: %d" % len(string_table))
//     print("Number of words in first line: %d" % len(string_table[0]))
//     print("Length of first word: %d" % len(string_table[0][0]))
//
// register.agent_section(
//     name = "linux_usbstick",
//     parse_function = parse_linux_usbstick,
// )
// F-:
//
// Die Ausgabe sieht dann so aus:
//
// C+:
// OM:cmk -I myhost123
// Number of lines: 3
// Number of words in first line: 1
// Length of first word: 36
// C-:
//
// Für unser Beispiel benötigen wir einfach nur eine einfache Liste der Devicenamen.
// Also machen wir unsere Parse-Funktion so, dass sie aus jeder Zeile das eine Wort
// auspackt und in eine hübsche neue Liste verpackt:
//
// F+:
// def parse_linux_usbstick(string_table):
//     parsed = []
//     for line in string_table:
//         parsed.append(line[0])
//     pprint.pprint(parsed)
// F-:
//
// Die Debugausgabe sieht dann so aus (bitte schauen Sie genau hin, es
// gibt jetzt nur noch ein einziges paar eckiger Klammern):
//
// F+:
// ['ata-APPLE_SSD_SM0512F_S1K5NYBF810191',
//  'wwn-0x5002538655584d30']
// F-:
//
// Damit die Parse-Funktion vollständig ist, müssen wir jetzt noch die
// Debugmeldung entfernen und -- ganz wichtig -- das Ergebnis mit
// `return` zurückgeben:
//
// F+:
// def parse_linux_usbstick(string_table):
//     parsed = []
//     for line in string_table:
//         parsed.append(line[0])
//     *return parsed*
// F-:
== Dateien und Verzeichnisse

.
