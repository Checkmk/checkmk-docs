include::global_attr.adoc[]
= Benutzer, Zuständigkeiten, Berechtigungen
:revdate: 2021-09-22
:title: Benutzer, Zuständigkeiten, Berechtigungen - Autorisierungs- und Benutzerkonfiguration
:description: Jedes überwachte Objekt hat einen Zuständigen. Hier erfahren Sie, was Rollen und Kontaktgruppen sind, und alles andere, was für die Benutzerverwaltung wichtig ist.

{related-start}
xref:wato#[Die Konfiguration von {CMK}]
xref:wato_rules#[Host- und Serviceparameter]
xref:ldap#[Benutzerverwaltung mit LDAP/Active Directory]
{related-end}


== Einleitung

In diesem Artikel zeigen wir Ihnen alles rund um Benutzerverwaltung und Berechtigungen
in {CMK}. Doch bevor wir in die Details gehen können, müssen wir erst einige
Begriffe klären.

Ein *Benutzer* (_user_) ist in {CMK} jemand, der Zugang zur
xref:user_interface#[Benutzeroberfläche] hat. Er hat eine oder mehrere
*Rollen.* Aus den Rollen ergeben sich *Berechtigungen* (_permissions_).

Sobald ein Benutzer für bestimmte Hosts und Services zuständig ist, wird
er als *Kontakt* bezeichnet. Ein Kontakt sieht normalerweise nur
seine eigenen Hosts und Services in der xref:user_interface#[Monitoring-Umgebung] und wird eventuell
über Probleme benachrichtigt.

Es gibt auch Benutzer, die keine Kontakte sind. Ein Beispiel dafür ist
`cmkadmin`, der beim Erzeugen einer Instanz automatisch angelegt wird.
Dieser darf zwar alle Hosts und Services sehen, aber nur, weil in
seiner Rolle `admin` die Berechtigung [.guihint]#See all hosts and services#
enthalten ist und nicht, weil er für alles ein Kontakt wäre.

Wenn ein Kontakt nur zum Zwecke der xref:notifications#[Benachrichtigung] angelegt wurde
(z.B. zur Weiterleitung von Benachrichtigungen an ein Ticketsystem), dann kann es sinnvoll
sein, ihn so anzulegen, dass kein Login in die Oberfläche möglich ist.

Ein Kontakt ist immer Mitglied von einer oder mehreren
*Kontaktgruppen.* Der Zweck dieser Gruppen ist die Zuordnung von
Kontakten zu Hosts und Services. Zum Beispiel könnte der Kontakt
`hhirsch` in der Kontaktgruppe `linux` sein und diese wiederum
per xref:wato_rules#[Regel] allen Linux-Hosts zugeordnet. Eine direkte Zuordnung
von Kontakten zu Hosts oder Services ist nicht möglich und würde in der Praxis
auch Schwierigkeiten bereiten (z.B. beim Ausscheiden eines Benutzers).

Noch einmal zusammengefasst:

* *Benutzer* können die Benutzeroberfläche verwenden.
* *Kontakte* sind Benutzer, die für bestimmte Hosts und Services zuständig sind.
* *Kontaktgruppen* legen fest, für was jemand zuständig ist.
* *Rollen* legen fest, welche *Berechtigungen* jemand hat.


[#user_config]
== Benutzerverwaltung über die Konfigurationsumgebung


=== Übersicht

Die Benutzerverwaltung finden Sie unter [.guihint]#Setup > Users > Users#.
In einer frisch angelegten Instanz sieht diese Seite so aus (Auszug):

[{image-border}]
image::wato_user_users.png[alt="Liste der Benutzer mit Eigenschaften des Administrators."]

Sie sehen hier den einzigen Benutzer `cmkadmin`, welcher automatisch beim
Erzeugen der Instanz angelegt wurde. Bei der {CMK}-Appliance kann dieser Benutzer anders
heißen, da Sie dessen Namen und Passwort selbst festlegen. Dieser erste Benutzer hat folgende
Eigenschaften:

* Er hat die Rolle [.guihint]#Administrator# (`admin`) und damit alle Berechtigungen.
* Er ist für nichts Kontakt und bekommt keine Benachrichtigungen.
* Er darf trotzdem alles sehen (wegen seiner Rolle `admin`).
* Das Passwort, das beim Erstellen der Instanz vergeben wurde, sollten Sie auf jeden Fall ändern!

Das Formular zum Anlegen eines neuen Benutzers mit icon:button_new_user[] oder
zum Editieren eines bestehenden Benutzers mit icon:icon_edit[]
ist in fünf Abschnitte unterteilt. Im ersten geht es um die Identität:


=== Identität

image::wato_user_identity.png[alt="Dialog für die Identität eines Benutzers."]

Wie immer in {CMK} ist die ID eines Datensatzes (hier [.guihint]#Username#)
später nicht änderbar. Sie wird für die Anmeldung verwendet und auch
als interner Schlüssel in sämtlichen Dateien und Datenstrukturen.

Die E-Mail-Adresse ist optional und nur dann notwendig, wenn der Benutzer ein Kontakt
werden soll, der per E-Mail xref:notifications#[benachrichtigt] werden soll (xref:notifications#smtp[SMTP-Konfiguration] notwendig). Analog ist das Feld
[.guihint]#Pager address# für die Benachrichtigung per SMS oder ähnliche Systeme vorgesehen. Wenn Sie eigene Benachrichtigungsskripte
schreiben, können Sie auf die Werte in den Feldern zugreifen und sie für beliebige Zwecke
verwenden.

Über [.guihint]#Authorized sites# dürfen Sie optional beschränken, auf welche der vorhandenen Instanzen
zugegriffen werden darf. Praktisch ist das vor allem bei sehr großen Umgebungen, etwa einem
verteilten Monitoring mit Hunderten von Instanzen: Sofern ein Benutzer nur einen Teil dieser Instanzen für seine Hosts benötigt, wird die GUI auch nur die autorisierten Instanzen kontaktieren, um Ansichten aufzubauen -- was wiederum der Performanz enorm zugutekommt.


=== Sicherheit

image::wato_user_security.png[alt="Dialog für Sicherheitseinstellungen eines Benutzers."]

Der zweite Kasten dient der Anmeldung und Berechtigung. Die Option
[.guihint]#Automation secret for machine accounts# ist für Konten gedacht,
die skriptgesteuert per HTTP auf {CMK} zugreifen und sich über
die URL authentifizieren. Wie das geht, zeigen wir Ihnen xref:automation[weiter unten].

Bei den Rollen müssen Sie mindestens eine auswählen. Theoretisch können
Sie einem Benutzer auch mehrere Rollen geben. Er bekommt dann die Rechte
von allen diesen Rollen. Mit den drei vordefinierten Rollen (siehe
xref:roles[weiter unten]) macht dies jedoch wenig Sinn.

Wenn Sie einen Benutzer mit der Option [.guihint]#disable the login to this account#
*sperren,* wird er in der Tabelle mit dem Symbol
icon:icon_user_locked[] dargestellt. Er kann sich dann nicht mehr anmelden,
bleibt aber trotzdem im System erhalten. Falls er ein Kontakt ist, sind auch die Benachrichtigungen
von der Sperre nicht beeinflusst und er wird weiterhin E-Mails etc. erhalten.
War der Benutzer zum Zeitpunkt der Sperrung gerade angemeldet, so wird er
automatisch abgemeldet.


=== Kontaktgruppen

image::wato_user_contact_groups.png[alt="Dialog für Kontaktgruppen eines Benutzers."]

Sobald Sie einen Benutzer einer Kontaktgruppe oder mehreren zuordnen,
wird dieser Benutzer zum Kontakt. Bei einer neuen Instanz wird automatisch die
Kontaktgruppe [.guihint]#Everything# angelegt, die immer alle Hosts und alle
Services enthält. Ein Benutzer in
dieser Gruppe ist automatisch für _alle_ Hosts und Services zuständig.


[#user_config_notifications]
=== Benachrichtigungen

image::wato_user_notifications_fallback.png[alt="Dialog für Benachrichtigungseinstellungen eines Benutzers."]

Im Kasten [.guihint]#Notifications# können Sie über die Option [.guihint]#Receive fallback notifications#
festlegen, dass dieser Kontakt Benachrichtigungen bekommt, wenn
xref:notifications#fallback[keine Benachrichtigungsregel greift.]


[#user_config_personal]
=== Persönliche Einstellungen

image::wato_user_personal_settings.png[alt="Dialog für persönliche Einstellungen eines Benutzers."]

Alle Einstellungen in diesem Kasten kann der Benutzer über [.guihint]#User > Edit profile#
auch xref:personal_settings[selbst ändern]
(außer in der Rolle `guest`). Abgesehen von der Auswahl der Sprache der Oberfläche
handelt es sich um selten benötigte Einstellungen. Details dazu finden Sie wie
immer in der icon:icon_help[] Onlinehilfe.


[#user_config_interface]
=== Oberflächeneinstellungen

image::wato_user_interface_settings.png[alt="Dialog für Oberflächeneinstellungen eines Benutzers."]

Auch die Oberflächeneinstellungen können Benutzer selbst über [.guihint]#User > Edit profile# anpassen.
Besonders interessant ist die Option [.guihint]#Set custom show mode# zur Festlegung, ob {CMK} in der Oberfläche xref:intro_gui#show_less_more[mehr oder weniger anzeigen] soll. 
Wenn Sie immer alles sehen wollen, können Sie dies hier mit [.guihint]#Enforce show more# erzwingen.


[#contact_groups]
== Kontaktgruppen

=== Kontaktgruppen anlegen und editieren

Kontaktgruppen sind das Bindeglied zwischen Hosts und Services auf der einen und Kontakten
auf der anderen Seite. Jede Kontaktgruppe repräsentiert eine Zuständigkeit für einen bestimmten
Bereich in Ihrer IT-Landschaft. So könnte z.B. die Kontaktgruppe `SAP` alle Personen
umfassen, die SAP-Systeme betreuen, und allen Hosts und Services zugeordnet sein, die
Dienste in diesem Umfeld bereitstellen.

Die Kontaktgruppen verwalten Sie über [.guihint]#Setup > Users > Contact groups.# Folgende Abbildung zeigt
dieses Modul mit vier angelegten Kontaktgruppen:


image::wato_user_contact_groups_list.png[alt="Liste der Kontaktgruppen."]

Das Anlegen einer neuen Gruppe ist trivial. Wie immer ist die ID unveränderlich und der
Alias ein Anzeigename, den Sie später jederzeit anpassen können:

image::wato_user_contact_groups_new.png[alt="Dialog für Name und Alias von Kontaktgruppen."]

Die neue Kontaktgruppe ist erst einmal leer in doppelter Hinsicht: Sie enthält
weder Kontakte noch Hosts oder Services. Die Zuordnung von Kontaktgruppen
zu Kontakten geschieht über die Benutzerprofile, wie Sie schon beim Editieren
des Benutzers gesehen haben.


[#visibility]
==== Inventar-Sichtbarkeit festlegen

Zusätzlich können Sie die Sichtbarkeit des mit der xref:inventory#[Hardware-/Software-Inventur] gefundenen Inventars festlegen.
Standardmäßig ist das komplette Inventar sichtbar, es lässt sich aber auch komplett unterdrücken oder gezielt freischalten mit der Option [.guihint]#Allowed to see the following entries# und den *internen Inventur-Pfaden*:

image::wato_user_contact_groups_inventory_00.png[alt="Dialog für die Sichtbarkeit von Inventurdaten."]

Um die geforderten Pfadinformationen eingeben zu können, müssen Sie diese zuerst aus den xref:inventory#internal_paths[Inventurdaten auslesen.]
Mit diesen Informationen können Sie dann die Pfade und Attribute befüllen und so beispielsweise ausschließlich einige ausgewählte Inventurdaten zum Prozessor sichtbar machen (Modell und Architektur):

image::wato_user_contact_groups_inventory_03.png[alt="Dialog für die Sichtbarkeit von Inventurdaten mit CPU-Filter."]


[#add_host_to_contact_group]
=== Hosts in eine Kontaktgruppe aufnehmen

Zum Aufnehmen von Hosts in Kontaktgruppen gibt es zwei Methoden: über xref:wato_hosts#folder[Ordner] und
über xref:wato_rules#[Regeln]. Sie können auch beide Methoden kombinieren. In diesem
Fall bekommt der Host dann die Summe der jeweiligen Kontaktgruppen zugeordnet.

==== Zuweisung über Ordner

Zu den Eigenschaften eines Ordners gelangen Sie über [.guihint]#Folder > Properties#
während Sie im Ordner sind. Dort finden Sie die Option [.guihint]#Permissions#. Aktivieren Sie diese
Checkbox, um zur Auswahl der Kontaktgruppen zu kommen:

image::wato_user_contact_groups_folder.png[alt="Dialog zum Zuordnen von Kontaktgruppen zu Ordnern."]

Der eigentliche Sinn dieser Option ist das Setzen von Berechtigungen für das Pflegen von
Hosts, was wir xref:folder_permissions[weiter unten] im Detail zeigen.

Sobald Sie Berechtigungen für bestimmte Kontaktgruppen vergeben, können Sie diese Gruppen im gleichen
Zug wiederum als Kontaktgruppen für die Hosts im Monitoring eintragen lassen. Dabei können Sie
entscheiden, ob die Zuordnungen auch für Hosts in Unterordnern gelten sollen und, ob die Services
der Hosts ebenfalls _explizit_ diese Gruppen bekommen sollen. Services ohne
explizite Zuweisung erben nämlich *alle* Kontaktgruppen eines Hosts, auch solche, die durch
Regeln zugewiesen wurden.

*Achtung:* Die xref:wato_hosts#inheritance[Vererbung] des [.guihint]#Permissions#-Attributs über die Ordner ist an
dieser Stelle außer Kraft gesetzt. Dies erlaubt Ihnen, in Unterordnern weitere Kontaktgruppen
hinzuzufügen. Die Zuordnung geschieht also kumulativ auch über alle Elternordner, falls in
diesen die Option [.guihint]#Add these groups as contacts in all subfolders# aktiviert ist.

Übrigens finden Sie die Kontaktgruppenoptionen in vereinfachter Form auch direkt in den
Details eines Hosts. Somit können Sie einzelnen Hosts auch hierüber Kontaktgruppen
zuordnen. Da das aber schnell recht unübersichtlich werden kann, sollten Sie das nur in
Ausnahmefällen tun und bei Bedarf eventuell lieber mit Regeln arbeiten.


==== Zuweisung über Regeln

Die zweite Methode -- das Zuweisen von Kontaktgruppen über xref:wato_rules#[Regeln] --
ist etwas umständlicher, aber dafür deutlich flexibler. Und es ist
sehr nützlich, wenn Sie Ihre Ordnerstruktur nicht nach organisatorischen
Prinzipien aufgebaut haben und daher die Ordner nicht eindeutig Kontaktgruppen
zuordnen können.

Den dafür nötigen Regelsatz
[.guihint]#Assignment of hosts to contact groups# erreichen Sie über
[.guihint]#SSetup > Hosts > Host monitoring rules.# In diesem Regelsatz finden
Sie eine vordefinierte Regel, die beim Erzeugen der Instanz angelegt wurde
und welche alle Hosts der Kontaktgruppe [.guihint]#Everything# zuweist.

image::wato_user_contact_groups_rules_list.png[alt="Regelsatz für die Zuordnung von Hosts zu Kontaktgruppen."]

Beachten Sie, dass dieser Regelsatz so definiert ist, dass *alle*
zutreffenden Regeln ausgewertet werden und nicht nur die erste! Es kann
nämlich durchaus nützlich sein, dass ein Host zu mehreren Kontaktgruppen
gehört. In diesem Fall benötigen Sie für jede Zuweisung eine eigene Regel.

image::wato_user_contact_groups_rules_new.png[alt="Dialog für die Zuordnung von Hosts zur Kontaktgruppe Windows-Servers."]

[#add_service_to_contact_group]
=== Services in Kontaktgruppen aufnehmen

Es ist nicht immer sinnvoll, dass ein Service in den gleichen Kontaktgruppen
ist wie sein Host. Daher können Sie über den Regelsatz
[.guihint]#Assignment of services to contact groups# Services zu Kontaktgruppen zuordnen --
unabhängig von den Kontaktgruppen des Hosts. Dabei gelten folgende Regeln:

* Wenn einem Service *keine* Kontaktgruppe zugeordnet ist, erhält er automatisch die *gleichen Kontaktgruppen wie sein Host*.
* Sobald einem Service *mindestens eine* Kontaktgruppe explizit zugeordnet ist, erbt er die Kontaktgruppen vom Host *nicht* mehr.

In einer einfachen Umgebung genügt es also, wenn Sie nur den Hosts
Kontaktgruppen zuordnen. Sobald Sie mehr Differenzierung brauchen, können
Sie auch Regeln für die Services anlegen.


=== Kontrolle der Zuordnung

Ob Sie alle Regeln und Ordner richtig konfiguriert haben, können Sie in den Details
eines Hosts oder Services in der Monitoring-Umgebung überprüfen. 
Dort finden Sie die Einträge [.guihint]#Host contact groups# und [.guihint]#Host contacts# (bzw. [.guihint]#Service contact groups# und [.guihint]#Service contacts#), welche die letztendliche Zuordnung für dieses Objekt auflisten:

image::wato_user_contact_groups_host_details.png[alt="Liste mit Host-Details."]

[#visibility]
== Sichtbarkeit von Hosts und Services

=== Übersicht

Die Tatsache, dass ein normaler Benutzer (Rolle `user`) nur solche
Objekte sieht, für die er ein Kontakt ist, ist umso wichtiger, je größer
Ihre Monitoring-Umgebung ist. Das sorgt nicht nur für Übersicht, sondern
verhindert auch, dass Benutzer dort eingreifen, wo sie nichts zu suchen
haben.

Als Administrator (Rolle `admin`) dürfen Sie natürlich immer
alles sehen. Gesteuert wird das über die Berechtigung [.guihint]#See all host and services#.
In Ihren xref:personal_settings[persönlichen Einstellungen]
finden Sie die Checkbox
[.guihint]#Only show hosts and services the user is a contact for#. Mit dieser können
Sie das „Alles Sehen“ freiwillig aufgeben und sich nur noch die Hosts und Services
anzeigen lassen, für die Sie ein Kontakt sind. Diese Option ist für Doppelrollen gedacht --
also für jemanden, der gleichzeitig Administrator und auch normaler Benutzer ist.

Die Rolle `guest` ist so voreingestellt, dass auch ihre Benutzer alles
sehen können. Ein Eingreifen oder persönliche Einstellungen sind hier deaktiviert.

Für normale Benutzer ist die Sichtbarkeit in der xref:user_interface#[Monitoring-Umgebung]
so umgesetzt, dass sich das System so anfühlt, als wären
die Hosts und Services, für die man nicht Kontakt ist, überhaupt nicht
vorhanden. Unter anderem berücksichtigen folgende Elemente die Sichtbarkeit:

* xref:views#[Tabellenansichten] von Hosts und Services
* xref:dashboards#[Dashboards]
* Das Snapin xref:user_interface#overview[Overview] der Seitenleiste
* xref:reporting#[Berichte], die von dem Benutzer erstellt werden


=== Sichtbarkeit von Services

Wie wir oben gezeigt haben, ist es möglich, dass Sie für einen Host
Kontakt sind, aber nicht für alle seine Services. Trotzdem werden Sie
in so einem Fall alle Services des Hosts in der GUI sehen können.

Diese Ausnahme ist so voreingestellt, weil das meistens nützlich ist.
Das bedeutet in der Praxis z.B., dass die Kollegin, die für den Host an sich
verantwortlich ist, auch solche Services sehen kann, die mit dem eigentlichen
Host (Hardware, Betriebssystem etc.) nichts zu tun haben. Trotzdem erhält
sie für diese keine Benachrichtigungen!

Wenn Ihnen das nicht gefällt, können Sie das umstellen über icon:icon_configuration[] [.guihint]#Global settings > Monitoring Core > Authorization settings#. Wenn Sie
dort [.guihint]#Hosts# auf [.guihint]#Strict - Visible if user is contact for the service#
umstellen, können Benutzer Services nur noch dann sehen, wenn sie direkt
als Kontakt dem Service zugeordnet sind.

image::wato_user_authorization_settings.png[alt="Dialog mit Autorisierungseinstellungen."]

Das Ganze hat übrigens *nichts* damit zu tun, dass ein Service die
Kontaktgruppen seines Hosts erbt, falls für ihn keine eigenen definiert
sind. Denn dann _wären_ Sie ja Kontakt für den Service (und würden
auch deren Benachrichtigungen bekommen).


=== Host- und Service-Gruppen

Die zweite Option in der globalen Einstellung [.guihint]#Authorization settings# betrifft Host- und Service-Gruppen.
Normalerweise können Sie eine Gruppe immer dann sehen, wenn Sie mindestens
ein Element der Gruppe sehen können. Allerdings sieht die Gruppe dann für Sie
aus, als würde sie auch nur die für Sie sichtbaren Element enthalten.

Ein Umschalten auf [.guihint]#Strict - Visible if all members are visible# macht alle
Gruppen unsichtbar, in denen Sie für mindestens einen Host bzw. Service
*kein* Kontakt sind.

Beachten Sie, dass diese beiden Einstellungen zur Sichtbarkeit
_keinen Einfluss_ auf die Benachrichtigungen haben.


== Benachrichtigungen

Kontaktzuordnungen haben auch einen Einfluss auf die
Benachrichtigungen. {CMK} ist so voreingestellt, dass im Falle
eines Problems alle Kontakte des betroffenen Hosts oder Services benachrichtigt
werden. Das geschieht durch eine Benachrichtigungsregel, die bei neuen Instanzen
automatisch angelegt wird. Dies ist ein sehr sinnvolles Verhalten.

Trotzdem können Sie bei Bedarf die Regel anpassen oder durch weitere Regeln
ergänzen, so dass Benachrichtigungen im Extremfall sogar ganz unabhängig von
den Kontaktgruppen geschehen. Häufiger Grund dafür ist, dass ein Benutzer
sich wünscht, bestimmte Benachrichtigungen _nicht_ zu bekommen oder umgekehrt
über Probleme bei einzelnen Hosts oder Services informiert zu werden,
auch wenn er für diese nicht zuständig (und folglich kein Kontakt) ist.

Details erfahren Sie im xref:notifications#[Artikel über die Benachrichtigungen.]


[#roles]
== Rollen und Berechtigungen

=== Vordefinierte Rollen

{CMK} vergibt Berechtigungen an Benutzer immer über Rollen -- niemals
direkt. Eine Rolle ist nichts anderes als eine Liste von Berechtigungen.
Wichtig ist, dass Sie verstehen, dass Rollen das _Niveau_ von
Berechtigungen definieren und nicht den Bezug zu irgendwelchen Hosts
oder Services. Dafür sind die Kontaktgruppen da.

{CMK} wird mit folgenden drei vordefinierten Rollen ausgeliefert, welche
niemals gelöscht, aber beliebig angepasst werden können:

[cols="10,~,~"]
|===
|Rolle |Berechtigungen |Einsatzzweck 

|admin |Alle Berechtigungen -- insbesondere das Recht, Berechtigungen zu ändern. |Der {CMK}-Administrator, der das Monitoring-System an sich betreut.
|user |Darf nur seine Hosts und Services sehen, in der Weboberfläche nur in für ihn xref:folder_permissions[freigegebenen Ordnern] Änderungen machen und darf generell nichts machen, was andere Benutzer beeinflusst. |Der normale {CMK}-Benutzer, der das Monitoring nutzt und auf Benachrichtigungen reagiert.
|guest |Darf alles sehen aber nichts ändern. |Gedacht zum einfachen „Gucken“, wobei sich alle Gäste ein gemeinsames Konto teilen. Auch nützlich für öffentliche Statusmonitore, die an der Wand hängen.
|===

Die Rollen werden über [.guihint]#Setup > Users > Roles & permissions# verwaltet:

image::wato_user_roles_list.png[alt="Liste mit Benutzerrollen."]

Übrigens: Beim Erzeugen einer neuen {CMK}-Instanz wird nur ein Benutzer
der Rolle `admin` angelegt (`cmkadmin`). Die beiden anderen
Rollen werden erst mal nicht verwendet. Wenn Sie einen Gastbenutzer wünschen,
müssen Sie diesen selbst anlegen.


=== Bestehende Rollen anpassen

Wie üblich gelangen Sie über das Symbol icon:icon_edit[] in den Editiermodus für eine Rolle:

image::wato_user_roles_permissions.png[alt="Liste mit Berechtigungen für eine Benutzerrolle."]

Welche Bedeutung die zahlreichen Berechtigungen haben (hier in Auszügen dargestellt), erfahren Sie aus der icon:icon_help[] Onlinehilfe.

Das Besondere hier: Für jede Berechtigung gibt es drei Auswahlmöglichkeiten:
_yes_, _no_ und _default (yes)_ bzw. _default(no)_. Am
Anfang stehen alle Werte auf _default_. Für die Berechtigung selbst
macht es erst mal keinen Unterschied, ob Sie _yes_ oder _default
(yes)_ eingestellt haben. Allerdings kann eine neue Version von {CMK}
den Defaultwert ändern (auch wenn das sehr selten vorkommt). Eine von
Ihnen explizite gemachte Einstellung wäre dann von der Änderung nicht betroffen.

Außerdem können Sie durch dieses Prinzip sehr schnell erkennen, wo Ihre
{CMK}-Installation vom Standard abweicht.


=== Eigene Rollen definieren

Vielleicht sind Sie überrascht, dass es keinen Knopf gibt, um eine neue
Rolle anzulegen. Dahinter steckt Absicht! Neue Rollen erschaffen Sie
durch ein Ableiten von bestehenden Rollen mittels icon:icon_clone[]
[.guihint]#Clone#. Die neue Rolle wird nicht einfach als Kopie erzeugt, sondern
behält den Bezug zur Ausgangsrolle ([.guihint]#Based on role#):

image::wato_user_roles_new_role.png[alt="Basiseigenschaften einer erstellten Benutzerrolle."]

Diese Verbindung hat eine wichtige Funktion. Denn alle Berechtigungen der
geklonten Rolle, die nicht explizit gesetzt sind (also noch auf [.guihint]#default#
stehen), werden von der Ausgangsrolle geerbt. Änderungen in der Ausgangsrolle
schlagen also durch. Das ist sehr praktisch, wenn man bedenkt, wie viele
Berechtigungen es gibt. Bei einer simplen Kopie könnten Sie sonst leicht
den Überblick verlieren, was eigentlich das Besondere an Ihrer selbst
definierten Rolle ausmacht.

Das Ableiten löst noch ein weiteres Problem: Da wir {CMK} rege
weiterentwickeln, kommen immer wieder neue Berechtigungen hinzu.
Jedes mal entscheiden wir dann, in welcher der drei Rollen
`admin`, `user` und `guest` die neue Berechtigung
enthalten sein soll. Da jede Ihrer eigenen Rollen von genau einer der drei vordefinierten Rollen
abgeleitet ist, wird dann die neue Berechtigung automatisch auf einen sinnvollen
Wert voreingestellt. Es wäre doch sehr unpraktisch, wenn Sie z.B. eine eigene
`user`-Rolle definieren und dort neue Berechtigungen immer fehlen
würden. Dann müssten Sie bei jedem neuen Feature Ihre Rolle anpassen,
damit Ihre Benutzer diese nutzen könnten.

=== Rollen vergleichen mit der Matrixansicht

Wenn Sie die Berechtigungen in den einzelnen Rollen vergleichen möchten, hilft
die Matrixansicht, zu erreichen über [.guihint]#Setup > Users > Roles & permissions > Permission matrix.#
Der Menüeintrag erzeugt folgende Darstellung,
in der Sie nicht nur die Berechtigungen der einzelnen Rollen vergleichen können,
sondern auch die Stellen sehen, an denen explizit Berechtigungen gesetzt
(Symbol icon:icon_perm_yes[]) bzw. entfernt (Symbol icon:icon_perm_no[]) wurden.

image::wato_user_roles_matrix.png[alt="Matrix mit Benutzerrollen im Vergleich."]

[#personal_settings]
== Persönliche Einstellungen

Einen kleinen Teil der Benutzereinstellungen kann jeder Benutzer für sein Profil
selbst verwalten. Eine genaue Beschreibung aller Optionen finden Sie im Artikel zur
xref:user_interface#user_menu[Benutzeroberfläche.]

Dazu ein Hinweis für *verteiltes Monitoring:*
In einer xref:distributed_monitoring#[verteilten Umgebung] werden nach jeder
Änderung die neuen Einstellungen sofort auf alle Monitoring-Instanzen
übertragen. Nur so ist sichergestellt, dass insbesondere ein neu vergebenes Passwort auch
sofort überall funktioniert -- und nicht erst beim nächsten Aktivieren der
Änderungen. Das klappt allerdings nur für Instanzen, die zu diesem Zeitpunkt
auch über das Netzwerk erreichbar sind. Alle andere Instanzen bekommen die
Aktualisierungen beim nächsten erfolgreichen xref:wato#activate_changes[Aktivieren der Änderungen.]

[#automation]
== Automationsbenutzer (für Webdienste)

Bei der Anbindung von {CMK} an andere Systeme kommt oft der Wunsch auf, bestimmte
Tätigkeiten, die normalerweise über die GUI stattfinden, zu automatisieren. Einige
Beispiele dafür sind:

* Setzen und Entfernen von xref:monitoring_basics#downtimes[Wartungszeiten] per Skript
* Verwalten von Hosts per xref:rest_api#[REST-API]
* Abrufen von Daten aus xref:views#[Ansichten] als CSV oder JSON zum Zwecke der Weiterverarbeitung
* Abrufen des aktuellen Status von xref:bi#[BI-Aggregaten], um diese als Service anzulegen

In diesen Situationen muss eine externe Software bestimmte URLs der
{CMK}-Oberfläche automatisiert abrufen können. Und da stellt sich
natürlich die Frage, wie hier die Benutzeranmeldung geschieht. Der normale
Weg über den xref:checkmk_getting_started#login[Anmeldedialog] ist umständlich und erfordert den Abruf von mehreren
URLs hintereinander und das Speichern eines Cookies.

Um dies zu vereinfachen, bietet {CMK} das Konzept der
_Automationsbenutzer_. Diese Benutzer sind ausschließlich für eine
Fernsteuerung vorgesehen und erlauben keine normale Anmeldung über die GUI.
Die Authentifizierung geschieht hier über bestimmte Variablen in der URL.

Sie legen einen Automationsbenutzer wie einen normalen Benutzer an, vergeben
aber kein normales Passwort, sondern ein Automationspasswort ([.guihint]#Automation secret#). Dieses
können Sie mit dem icon:icon_random[] Würfel automatisch erstellen lassen:

image::wato_user_automation_user.png[alt="Sicherheitseinstellungen des Automationsbenutzers."]

Ein Automationsbenutzer hat genauso wie ein normaler Benutzer eine Rolle und kann
auch Kontakt sein. Damit können Sie also die Berechtigungen und die Sichtbarkeit
von Hosts und Services nach Bedarf einschränken.

Beim automatischen Abruf von Webseiten geben Sie dann in der URL
folgende Variablen zusätzlich an:

[cols="25,~"]
|===

|`_username` |die ID des Automationsbenutzer
|`_secret` |dessen Automationspasswort ([.guihint]#Automation secret#)
|===

Hier ist ein Beispiel für den Abruf einer Ansicht im JSON-Format mit dem
Automationsbenutzer `automation` und dem Automationspasswort aus der obigen Abbildung:

[{shell}]
----
{c-root} curl 'http://moni01.mycompany.net/mysite/check_mk/view.py?_username=automation&_secret=a8075a39-e7fe-4b5c-9daa-02635&view_name=svcproblems&output_format=json'
 [
  "service_state",
  "host",
  "service_description",
  "service_icons",
  "svc_plugin_output",
  "svc_state_age",
  "svc_check_age",
  "perfometer"
 ],
 [
  "CRIT",
  "stable",
  "Filesystem /",
  "menu pnp",
  "CRIT - 96.0% used (207.27 of 215.81 GB), (warn/crit at 80.00/90.00%), trend: +217.07 MB / 24 hours",
  "119 min",
  "30 sec",
  "96%"
 ],
 ...
----

Wenn das Skript, das die URL abruft, direkt in der Monitoring-Instanz läuft,
können Sie das Automationspasswort für den Benutzer direkt aus dem Dateisystem auslesen.
Das ist keine Sicherheitslücke, sondern so vorgesehen: Sie können
Automatisierungsskripte schreiben, die das Automationspasswort nicht enthalten müssen und
keine Konfigurationsdatei benötigen. Lesen Sie dazu die Datei
`~/var/check_mk/web/myuser/automation.secret` aus:

[{shell}]
----
{c-omd} cat var/check_mk/web/automation/automation.secret
a8075a39-e7fe-4b5c-9daa-02635
----

In der Shell können Sie den Inhalt dieser Datei leicht in einer Variable speichern:

[{shell}]
----
{c-omd} SECRET=$(cat var/check_mk/web/automation/automation.secret)
{c-omd} echo "$SECRET"
a8075a39-e7fe-4b5c-9daa-02635
----

Dies macht sich z.B. auch das Skript `downtime` zunutze, welches Sie
im `treasures`-Verzeichnis von {CMK} finden und mit dem Sie skriptgesteuert
Wartungszeiten für Hosts und Services setzen und entfernen können. Wenn
der Automationsbenutzer wie bei uns im Beispiel `automation` heißt,
brauchen Sie als einziges Argument den Host-Namen, für den eine Wartung
eingetragen werden soll:

[{shell}]
----
{c-omd} ~/share/doc/check_mk/treasures/downtime.py myhost123
----

Weitere Optionen des Skripts erfahren Sie in dessen Onlinehilfe:

[{shell}]
----
{c-omd} ~/share/doc/check_mk/treasures/downtime.py --help
----


== Automatische Anmeldung über die URL

Wie Sie gesehen haben, können Sie mit Automationsbenutzern beliebige URLs
ohne Anmeldung skriptgesteuert abrufen. In Situationen, die ein echtes
Login im Browser benötigen, funktioniert dies jedoch nicht, da die Logindaten
bei enthaltenen Links (z.B. zu Bildern und iFrames) nicht weitergereicht werden.

Das beste Beispiel dafür ist der Wunsch, einen Monitor an die Wand zu hängen,
der ständig ein bestimmtes Dashboard von {CMK} zeigt. Der Monitor soll von
einem Rechner angesteuert werden, der beim Starten automatisch den Browser öffnet,
sich an {CMK} anmeldet und das Dashboard aufruft.

Um so etwas zu realisieren, legen Sie sich am besten zunächst dafür einen
speziellen Benutzer an. Die Rolle `guest` ist dafür gut geeignet, weil
diese alle Leserechte einräumt, aber keine Veränderungen oder Eingriffe zulässt.

Die URL für eine automatische Anmeldung konstruieren Sie wie folgt:

. Beginnen Sie mit: `\http://mycmkserver/mysite/login.py?_origtarget=`
. Ermitteln Sie die eigentlich anzuzeigende URL (z.B. die des Dashboards) mit Ihrem Browser -- am besten ohne Navigation, was über [.guihint]#Display > This page without navigation# geht.
. Hängen Sie diese URL an, wobei Sie alles vor dem Teil `/mysite/...` weglassen.
. Fügen Sie an die URL die beiden Variablen `_username` und `_password` an und zwar in folgender Form: `&_username=myuser&_password=mysecret`.
. Fügen Sie noch ein `&_login=1` an.

Hier ist ein Beispiel für so eine URL:

[{shell-raw}]
----
http://mycmkserver/mysite/check_mk/login.py?_origtarget=/mysite/check_mk/dashboard.py?name=mydashboard&_username=myuser&_password=mypassword&_login=1
----

Beachten Sie:

* Ersetzen Sie im Beispiel die Werte `mycmkserver`, `mysite`, `myuser` und `mypassword` durch die bei Ihnen gültigen Werte. Als `myuser` können Sie nicht den Automationsbenutzer verwenden, da für ihn eine Anmeldung über die GUI nicht erlaubt ist.
* Kommen die Sonderzeichen `&` oder `%` in einem dieser Werte oder in dem Wert von `_origtarget` vor, müssen Sie diese wie folgt ersetzen: `&` durch `%26` und `%` durch `%25`.

Testen Sie das Ganze, indem Sie sich in Ihrem Browser von {CMK}
abmelden und dann die konstruierte URL in Ihre Adresszeile vom Browser
kopieren. Sie müssen dann direkt auf die Zielseite gelangen -- ohne
Anmeldedialog. Gleichzeitig werden Sie dabei angemeldet und können in der
Seite enthaltene Links direkt aufrufen.

Sie können die fertige URL auch mit `curl` auf der Kommandozeile
ausprobieren. Wenn Sie alles richtig gemacht haben, bekommen Sie als
Ergebnis den HTTP-Status-Code `302 FOUND` und eine Weiterleitung auf die angegebene `Location`, wie in der folgenden gekürzten Ausgabe:

[{shell-raw}]
----
{c-omd}  curl -v 'http://mycmkserver/mysite/check_mk/login.py?_origtarget=/mysite/check_mk/dashboard.py?name=mydashboard&_username=myuser&_password=mypassword&_login=1'
...
< HTTP/1.1 302 FOUND
...
< Location: /mysite/check_mk/dashboard.py?name=mydashboard
...
----

Sollten Sie im Browser trotz dieser Erfolgsmeldung nicht die gewünschte Ansicht bekommen,
prüfen Sie die unter `Location` angegebene URL - auch wenn diese falsch ist, liefert `curl`
den HTTP-Status-Code `302 FOUND`.

Bei falschen Login-Daten bekommen Sie die HTTP-Status-Code `200 OK`,
sehen aber lediglich den HTML-Code der Anmeldeseite, wie in der folgenden erneut gekürzten Ausgabe:

[{shell-raw}]
----
{c-omd} curl -v 'http://mycmkserver/mysite/check_mk/login.py?_origtarget=/mysite/check_mk/dashboard.py?name=mydashboard&_username=myuser&_password=NOT&_login=1'
...
< HTTP/1.1 200 OK
...
<!DOCTYPE HTML>
<html><head><meta content="text/html; ...
...
</script>
<script type="text/javascript">
cmk.visibility_detection.initialize();
</script>
</body></html>
----


[#wato_permissions]
== Berechtigungen in {CMK}

=== Bedeutung der Rolle user für {CMK}

Wenn Sie eine etwas größere Monitoring-Umgebung zu verwalten haben, dann
möchten Sie sicher auch Mit-Administratoren in die Konfiguration und insbesondere in
das Verwalten von Hosts und Services mit einbeziehen. Damit Sie die Kontrolle
darüber behalten, wer was ändern darf und damit sich die Leute nicht in
die Quere kommen, können Sie Berechtigungen für das {CMK} xref:wato#[Setup] auf der Basis von Ordnern vergeben.

Der erste Schritt dazu ist, dass Ihre Administrator-Kollegen mit eigenen Benutzern arbeiten, die auf der Rolle `user` basieren. 

Diese Rolle hat grundsätzlich eine Berechtigung für die Konfigurationsumgebung, allerdings mit einigen wichtigen Einschränkungen:

* Es sind lediglich Änderungen an Hosts, Services, xref:wato_rules#[Regeln] und xref:bi#[BI-Aggregaten] erlaubt.
* Hosts, Services und Regeln können nur in xref:folder_permissions[freigegebenen Ordnern] verwaltet werden.
* BI-Aggregate können nur in freigegebenen BI-Paketen verwaltet werden.
* Alles, was globale Auswirkungen hat, ist nicht erlaubt.

Solange Sie noch keine Ordner oder BI-Pakete freigegeben haben bedeutet das,
dass die Benutzer der Rolle `user` zunächst keinerlei Änderungen
machen können! Das *abgespeckte* [.guihint]#Setup#-Menü der Navigationsleiste sieht für normale Benutzer so aus:

image::wato_user_setupmenu.png[width=65%, align=center, alt="Setup-Menü aus Benutzersicht."]


[#folder_permissions]
=== Benutzern das Verwalten von Hosts ermöglichen

Die Berechtigung für das Anlegen, Editieren und Entfernen von Hosts
erhält ein Benutzer über xref:contact_groups[Kontaktgruppen.] Der Ablauf ist wie folgt:

. Nehmen Sie den Benutzer in eine Kontaktgruppe auf.
. Bestimmen Sie einen oder mehrere xref:wato_hosts#folder[Ordner], für die der Benutzer berechtigt sein soll.
. Aktivieren Sie die Eigenschaft [.guihint]#Permissions# dieser Ordner und wählen Sie die Kontaktgruppe hier aus.

Das folgende Beispiel zeigt die Eigenschaften eines Ordners, in dem alle
Benutzer der Kontaktgruppe [.guihint]#Linux# Hosts verwalten dürfen. Dabei ist die
Option aktiviert, dass dies auch in Unterordnern erlaubt sein soll.

image::wato_user_user_folder.png[alt="Ordnereigenschaften mit freigegebener Kontaktgruppe Linux."]

Ob Sie die Hosts automatisch in die Kontaktgruppe aufnehmen möchten, bleibt Ihnen
überlassen. In diesem Beispiel ist die Option
[.guihint]#Add these groups as contacts to all hosts in this folder#
nicht gesetzt und die Hosts werden somit auch nicht
in die Kontaktgruppe [.guihint]#Linux# aufgenommen. Damit sind sie in
der Monitoring-Umgebung dann für die Kontaktgruppe [.guihint]#Linux# nicht sichtbar
(solange dies nicht eine Regel erledigt).
Wie Sie sehen, sind also die Sichtbarkeit (und Zuständigkeit im Monitoring)
und die Berechtigung für die Konfigurationsumgebung getrennt regelbar.


== Passwörter

=== Sicherheit von Passwörtern

Sicherheit wird heutzutage hoch aufgehängt. Daher gibt es in manchen Unternehmen
generelle Vorgaben, wie mit Passwörtern umgegangen werden soll. {CMK} bietet
etliche Einstellungen, um solche Vorgaben zu erzwingen.
Einen Teil davon finden Sie unter
[.guihint]#Global settings > User management > Password policy for local accounts#:

image::wato_user_password_policy.png[alt="Dialog für Passwort-Regeln."]

Die erste Option [.guihint]#Minimum password length# soll die Qualität des Passworts sicherstellen.

Für die zweite Option [.guihint]#Number of character groups to use# gibt es insgesamt vier Zeichengruppen:

* Kleinbuchstaben
* Großbuchstaben
* Ziffern
* Sonderzeichen

Tragen Sie hier eine `4` ein, so muss ein Passwort aus jeder der genannten
Gruppen mindestens ein Zeichen enthalten. Bei einer `2` ist zumindest
sichergestellt, dass das Passwort nicht z.B. nur aus Kleinbuchstaben besteht.
Diese Einstellungen werden bei jeder Änderung des Passworts überprüft.

Die dritte Option [.guihint]#Maximum age of passwords# zwingt den Benutzer, in regelmäßigen Abständen sein
Passwort zu ändern. Sobald es soweit ist, führt der nächste Seitenzugriff
den Benutzer zu folgender Eingabeaufforderung:

image::wato_user_forced_password_change.png[alt="Dialog für erzwungene Passwort-Neuvergabe."]

Erst nach einer Änderung seines Passworts darf der Benutzer weitermachen.

Sie können eine Änderung des initialen Passworts gleich beim ersten
Login vorschreiben. Dazu dient die Option [.guihint]#Enforce change: Change password at next login or access#
im Abschnitt [.guihint]#Security# in den Eigenschaften des jeweiligen Benutzers.


=== Richtlinien für die Anmeldung

Unter [.guihint]#Global settings > User management# finden Sie noch weitere globale
Einstellungen, welche die Anmeldung von Benutzern betreffen.


[#suspension]
==== Sperrung nach fehlerhaften Anmeldungen

Mit der Einstellung [.guihint]#Lock user accounts after N logon failures# können Sie
ein Konto nach einer Reihe von fehlerhaften Anmeldeversuchen sperren:

image::wato_user_login_failures.png[alt="Dialog für automatische Login-Deaktivierung."]

Ein Entsperren ist dann nur noch durch einen Benutzer mit der Rolle `admin`
möglich. Beachten Sie dabei, dass auch die Administratorkonten gesperrt werden können!
Sollten Sie endgültig ausgesperrt sein, so können Sie Ihr Konto nur noch auf der Kommandozeile
entsperren. Editieren Sie dazu als Instanzbenutzer die Datei `etc/htpasswd` und
entfernen Sie in der Zeile des betroffenen Benutzers, hier [.guihint]#myuser#, das Ausrufezeichen:

[{shell}]
----
{c-omd} cat etc/htpasswd
myuser:!$5$rounds=535000$PbQjbXyK...
automation:$5$rounds=535000$ygVkI2Ac...
cmkadmin:$apr1$bhGavmqd...
{c-omd} vim etc/htpasswd
...
{c-omd} cat etc/htpasswd
myuser:$5$rounds=535000$PbQjbXyK...
automation:$5$rounds=535000$ygVkI2Ac...
cmkadmin:$apr1$bhGavmqd...
----

Dann können Sie sich wieder anmelden.


==== Automatisches Abmelden

Die Einstellung [.guihint]#Login session idle timeout# sorgt für ein automatisches Abmelden für den Fall, dass
ein Benutzer längere Zeit die GUI nicht verwendet:

image::wato_user_login_idle_timeout.png[alt="Dialog für Login-Timeouts."]

Der Timeout wird hierbei nur durch aktives Verwenden der GUI aufgehalten.
Es reicht z.B. nicht, nur eine Ansicht geöffnet zu haben, die sich selbst regelmäßig neu lädt.


==== Verhinderung von Mehrfachanmeldungen

Die Einstellung [.guihint]#Limit login to single session at a time# verhindert,
dass ein Benutzer sich mit zwei Browsern parallel an {CMK} anmeldet:

image::wato_user_limit_login.png[alt="Dialog zur Begrenzung der Anzahl von Sitzungen."]

Diese Option ist gleichzeitig mit einem Timeout für einen automatischen
Logout bei Untätigkeit verknüpft. Dies ist auch sinnvoll. Nehmen wir an,
Sie haben an Ihrem Arbeitsplatz vergessen, sich abzumelden, bevor Sie den
Browser schließen. Ohne einen Timeout wäre es Ihnen in diesem Fall nicht möglich, sich
während der Bereitschaft von zu Hause aus anzumelden. Denn das Schließen
des Browsers oder das Herunterfahren des Rechners löst keine Abmeldung
aus!

Bei dem Versuch einer parallelen zweiten Anmeldung sehen Sie dann
folgenden Fehler:

image::wato_user_another_session_is_active.png[width=60%, align=center, alt="Gesperrter Anmeldedialog mit Hinweis auf laufende Sitzung."]

Die Anmeldung kann in diesem Fall nur durchgeführt werden, wenn Sie die
bestehende Sitzung aktiv beenden oder
den eingestellten Timeout abwarten.

////
ML: Hinweis, für intern oder später, als Entwurf:
Nach dem Aktivieren dieser globalen Einstellung *kann* es Ihnen passieren, dass sie vom System
abgemeldet werden und sich nicht mehr einloggen können - wenn noch eine alte Sitzung auf
einem anderen System als aktiv gilt. Sollten Sie kein weiteres Administratorkonto für die
Korrektur haben, können Sie die Einstellung händisch aus der zugehörigen Konfigurationsdatei entfernen.
Anschließend können Sie sich wieder normal in der Weboberfläche einloggen. Die globalen
Einstellungen finden Sie als Instanzbenutzer in der Datei `etc/check_mk/multisite.d/wato/global.mk`.
Löschen Sie dort einfach die folgende Zeile (hier mit einem Timeout von 300 Sekunden):

.etc/check_mk/multisite.d/wato/global.mk
[{file}]
----
single_user_session = 300
----
////


[#change_passwd]
=== Passwort auf der Kommandozeile ändern

Sie können im Notfall ein Passwort auch per Kommandozeile ändern. Das rettet Sie
in dem Fall, in dem Sie das Passwort von `cmkadmin` verloren haben. Voraussetzung
ist natürlich, dass noch eine Anmeldung als Linux-Benutzer auf dem {CMK}-Server möglich ist
und Sie mit `omd su mysite` Instanzbenutzer werden können.

Die Passwörter sind in der Datei `~/etc/htpasswd` gespeichert, wie bereits xref:suspension[weiter oben] beschrieben.

Das Ändern geschieht mit dem Befehl `htpasswd`, der aus der Apache-Installation
kommt. Dieser fragt Sie *nicht* nach dem bestehenden Passwort. Wir empfehlen,
dass Sie ihr Passwort durch Verwendung der Option `-m` mithilfe von MD5
verschlüsseln. Unverschlüsselte oder mit bcrypt verschlüsselte Passwörter
erlauben derzeit keinen Login in die GUI.

[{shell}]
----
{c-omd} htpasswd -m etc/htpasswd cmkadmin
New password: *geheim*
Re-type new password: *geheim*
Updating password for user cmkadmin
----


== Benutzerdefinierte Attribute

Für die Benachrichtigung von Benutzern steht Ihnen neben dem Feld für die
E-Mail-Adresse noch das Feld [.guihint]#Pager address# zur Verfügung. Wenn Ihnen das nicht
ausreicht und Sie noch mehr Informationen zu einem Benutzer speichern möchten,
können Sie über [.guihint]#Setup > Users > Custom user attributes > Add attribute#
eigene Felder erzeugen, die dann pro Benutzer individuell mit Werten gefüllt
werden können.

Das Anlegen eines neuen solchen Attributs bringt Sie zu folgendem Dialog:

image::wato_user_custom_macro.png[alt="Dialog für benutzerdefinierte Attribute."]

Wie immer ist die ID ([.guihint]#Name#) später nicht änderbar, der Titel ([.guihint]#Title#) aber schon. Das
[.guihint]#Topic# legt fest, in welchen Abschnitt der Benutzereinstellungen das neue Feld einsortiert
wird. Ferner können Sie entscheiden, ob Benutzer das Feld selbst editieren
können (es wird dann in ihren persönlichen Einstellungen auftauchen)
und ob der Wert direkt in der Benutzertabelle angezeigt werden soll.

*Wichtig:* Nur wenn Sie die Checkbox bei [.guihint]#Make this variable available in notifications#
aktivieren, können Sie diesen Wert auch bei Benachrichtigungen verwenden.
Denn dazu muss der Wert dem Monitoring-Kern (z.B. xref:cmc#[CMC]) in einer Variablen
(ein sogenanntes „Custom macro“) bekannt gemacht werden.

Der Name der Custom-Variable wird aus der von Ihnen gewählten ID abgeleitet.
Diese wird in Großbuchstaben umgewandelt und es wird ein `CONTACT_`
vorangestellt. Aus einem `phone` wird dann also `CONTACT_PHONE`.
Beachten Sie, dass beim Übergeben der Variable über Umgebungsvariablen
dann nochmal ein `NOTIFY_` vorangestellt wird. Bei Ihrem eigenen
xref:notifications#scripts[Benachrichtigungsskript] kommt die Variable dann also als `NOTIFY_CONTACT_PHONE`
an.


== Meldungen an Benutzer schreiben

Im Artikel über xref:notifications#[Benachrichtigungen] gehen wir sehr ausführlich
darauf ein, wie {CMK} die Kontakte über Probleme bei Hosts oder Service
informieren kann. Manchmal möchten Sie aber vielleicht alle Benutzer (auch
solche, die keine Kontakte sind) über Organisatorisches in eigener Sache
informieren -- z.B. über eine Wartung des {CMK}-Systems selbst.

Für solche Zwecke bietet {CMK} ein kleines eingebautes Meldungstool,
das völlig getrennt von den Benachrichtigungen funktioniert. Das Tool finden Sie
über [.guihint]#Setup > Users# und dort in [.guihint]#Users > Notify users#.
Hier haben Sie die Möglichkeit, eine Meldung an alle (oder manche)
Ihrer Benutzer zu schreiben.

image::wato_user_notify_users.png[alt="Dialog für Benutzermeldungen."]

Dabei haben Sie die Wahl zwischen vier Meldungsarten:

[cols=2]
|===

|[.guihint]#Open window in the user interface# |Beim nächsten Seitenaufruf des Benutzers wird ein Popup-Fenster mit der Nachricht geöffnet.
|[.guihint]#Show hint in the 'User' menu# |Der Benutzer wird durch ein Zahlensymbol im xref:user_interface#user_menu[User-Menü] der Navigationsleiste auf die Nachricht hingewiesen.
|[.guihint]#Send an E-Mail# |Versendet eine E-Mail. Damit erreichen Sie aber nur Benutzer, bei denen auch eine E-Mail-Adresse konfiguriert ist.
|[.guihint]#Show notification in dashboard element 'User notifications'# |Die Nachricht wird in einem xref:dashboards#builtin_dashlets[Dashlet] des Typs [.guihint]#User notifications# angezeigt.
|===


Mit [.guihint]#Enable automatic invalidation at# können Sie noch nicht abgerufene Meldungen einfach
löschen, sobald diese nicht mehr relevant sind.


== Weiterführende Themen

{CMK} beherrscht noch weitere Spielarten der Anmeldung:

* Anbindung von xref:ldap#[LDAP/Active Directory]
* Authentifizierung mit xref:kerberos#[Kerberos]
* Authentifizierung in einem Aufbau mit Reverse-Proxy
* Authentifizierung mit HTTP Basic Authentication


[#files]
== Dateien und Verzeichnisse
Folgende Aufstellung zeigt Ihnen, welche Dateien und Verzeichnisse auf dem
{CMK}-Server mit der Benutzerverwaltung zu tun haben. Wie immer sind
alle Angaben hier relativ zum Instanzverzeichnis (z.B. `/omd/sites/mysite`).

[cols="45,~"]
|===
|Pfad |Bedeutung 

|`etc/htpasswd` |Passwörter der Benutzer im Apache-`htpasswd`-Format.
|`etc/auth.secret` |Diese Datei enthält ein zufälliges Geheimnis, mit dem Anmelde-Cookies signiert werden. In verteilten Umgebungen soll diese Datei in allen Instanzen gleich sein -- und ist dies auch, wenn Sie alles mit der Weboberfläche einrichten. Wird diese Datei geändert, so werden alle Anmeldungen sofort ungültig und Benutzer müssen sich neu anmelden. Diese Datei ist mit den Rechten `660` versehen, da ein Lesezugriff von Dritten das Fälschen einer Anmeldung ermöglichen würde.
|`etc/auth.serials` |Seriennummern der Passwörter pro Benutzer. Jede Änderung des Passworts erhöht die Seriennummer und macht damit alle aktuellen Sitzungen ungültig. Damit ist sichergestellt, dass eine Passwortänderung einen Benutzer zuverlässig abmeldet.
|`etc/check_mk/multisite.d/wato/users.mk` |Enthält die mit der Konfigurationsumgebung eingerichteten Benutzer. Hier sind nur diejenigen Daten über die Benutzer gespeichert, die sich rein mit der GUI befassen. Manuelle Änderungen in dieser Datei werden sofort wirksam.
|`etc/check_mk/conf.d/wato/contacts.mk` |Kontaktinformationen der mit der Konfigurationsumgebung eingerichteten Benutzer. Hier sind alle Daten abgelegt, die für die Konfiguration des Monitoring-Kerns relevant sind. Nur Benutzer, die auch Kontakte sind, sind hier aufgeführt. Damit manuelle Änderungen hier wirksam werden, muss die neue Konfiguration in den Kern geladen werden -- z.B. mit `cmk -O`.
|`var/check_mk/web` |Jeder Benutzer, der sich mindestens einmal an der GUI angemeldet hat, hat hier ein Unterverzeichnis, in dem Dinge wie selbst erstellte Ansichten und Berichte, die aktuelle Konfiguration der Seitenleiste und vieles anderes in einzelnen kleinen Dateien mit der Endung `.mk` gespeichert sind. Diese Dateien haben Pythonformat.
|`var/log/web.log` |Logdatei der Benutzeroberfläche. Hier finden Sie Fehlermeldungen bezüglich Authentifizierung und LDAP-Anbindung.
|===
