// -*- coding: utf-8 -*-
include::global_attr.adoc[]
= Grundlagen des Monitorings mit {CMK}
:revdate: draft
:title: Grundlagen des Monitorings mit {CMK} - Begriffe in {CMK} verstehen
:description: In diesem Artikel werden grundlegende Begriffe und Konzepte in {CMK} erläutert, wie z.B. Host, Service, Benutzer, Kontaktgruppe, Benachrichtigung, Zeitraum, Wartungszeit.

{related-start}
xref:hosts_setup#[Verwaltung der Hosts]
xref:checkmk_getting_started#[Schnelleinstieg ins Monitoring]
xref:wato_monitoringagents#[Monitoring-Agenten]
{related-end}


== Zustände und Ereignisse

Bisher haben wir uns damit befasst, wie man {CMK} installiert und in Betrieb
nimmt. Nun ist es an der Zeit, die grundlegenden Konzepte und Begriffe des
Monitorings (mit {CMK}) zu erläutern.

Zunächst ist es wichtig, die grundlegenden Unterschiede zwischen _Zuständen_
und _Ereignissen_ zu verstehen -- und zwar aus ganz praktischem Nutzen.
Die meisten klassischen IT-Monitoring-Systeme drehen sich um
Ereignisse (Events). Ein Ereignis ist etwas zu einem ganz bestimmten Zeitpunkt
einmalig Geschehenes. Ein gutes Beispiel wäre _Fehler beim Zugriff
auf Platte X_. Übliche Quellen von Ereignissen sind Syslog-Meldungen,
SNMP-Traps, das Windows-Event-Log und Einträge in Logdateien. Ereignisse
passieren quasi spontan (von selbst, asynchron).

Dagegen beschreibt ein _Zustand_ eine anhaltende Situation, z.B.
_Platte X ist online_. Um den aktuellen Zustand von etwas zu überwachen,
muss das Monitoring-System diesen regelmäßig abfragen. Wie das Beispiel
zeigt, gibt es beim Monitoring oft die Wahl, ob man mit Ereignissen oder
mit Zuständen arbeitet.

{CMK} beherrscht beide Disziplinen, gibt jedoch
immer dort, wo die Wahl besteht, dem zustandsbasierten Monitoring den Vorzug.
Der Grund liegt in den zahlreichen Vorteilen dieser Methode. Einige davon
sind:

* Ein Fehler in der Überwachung selbst wird sofort erkannt, weil es natürlich auffällt, wenn das Abfragen des Zustands nicht mehr funktioniert.
Das Nichtauftreten einer _Meldung_ dagegen gibt keine Sicherheit, ob das Monitoring noch funktioniert.
* Das Monitoring kann selbst steuern, mit welcher Rate Zustände abgerufen werden.
Es gibt keine Gefahr eines Sturms an Event-Meldungen in systemweiten Problemsituationen.
* Das regelmäßige Abfragen in einem festen Zeitraster ermöglicht das Erfassen von xref:graphing#[Metriken], um deren Zeitverlauf aufzuzeichnen.

* Auch nach chaotischen Situationen  --  z.B. Stromausfall im RZ  --  hat man immer einen zuverlässigen Gesamtzustand.

Man kann also sagen, dass das zustandsbasierte Monitoring bei {CMK} das
_normale_ ist. Für das Verarbeiten von Ereignissen gibt es daneben
die xref:ec#[{CMK} Event Console]. Diese ist auf das Korrelieren und Bewerten
von großen Mengen an Events spezialisiert und nahtlos in das Monitoring
integriert.


[#hosts_services]
== Hosts und Services

[#hosts]
=== Hosts
Alles in der Überwachung dreht sich um _Hosts_ und _Services_. Wir haben
uns lange Gedanken gemacht, wie man Host ins Deutsche übersetzen könnte und am Ende
entschieden, dass wir den Begriff so belassen, um keine unnötige Verwirrung zu stiften.
Denn ein Host kann vieles sein, z.B.:

* Ein Server
* Ein Netzwerkgerät (Switch, Router, Loadbalancer)
* Ein Messgerät mit IP-Anschluss (Thermometer, Luftfeuchtesensor)
* Irgendetwas anderes mit einer IP-Adresse
* Ein Cluster aus mehreren Hosts
* Eine virtuelle Maschine
* Ein Docker-Container

Im Monitoring hat ein Host immer einen der folgenden Zustände:

[cols="11,6,~"]
|===
|Zustand |Farbe |Bedeutung 

|{UP} |grün |Der Host ist über das Netzwerk erreichbar (in der Regel heißt das, dass er auf PING antwortet).
|{DOWN} |rot |Der Host antwortet nicht auf Anfragen aus dem Netzwerk, ist nicht erreichbar.
|{UNREACH} |orange |Der _Weg_ zu dem Host ist aktuell für das Monitoring versperrt, weil ein Router oder Switch auf dem Weg dorthin ausgefallen ist.
|{PEND} |grau |Der Host wurde frisch in die Überwachung aufgenommen und noch nie abgefragt. Genau genommen ist das aber kein Zustand.
|===


Neben dem Zustand hat ein Host noch einige Attribute, die vom Anwender
konfiguriert werden, z.B.:

* Einen eindeutigen Namen
* Eine IP-Adresse
* Optional einen Alias-Namen, welcher nicht eindeutig sein muss
* Optional einen oder mehrere _Parents_


[#parents]
=== Parents

Damit das Monitoring den Zustand {UNREACH} berechnen kann, muss es wissen, über welchen Weg es jeden einzelnen Host erreichen kann.
Dazu kann man bei jedem Host einen oder mehrere sogenannte _Parent-Hosts_ angeben.
Wenn z.B. ein Server A _vom Monitoring aus gesehen_ nur über einen Router B erreichbar ist, dann ist B ein Parent-Host von A.
In xref:hosts_structure#parents[{CMK} konfiguriert] werden dabei nur _direkte_ Parents.
Daraus ergibt sich dann eine baumartige Struktur mit der {CMK}-Instanz in der Mitte (hier dargestellt als icon:parent_map_root[alt="Symbol für die {CMK}-Instanz."]):

image::monitoring_basics_parents.png[alt="Netzwerktopologie mit einem konfigurierten Parent.",width=43%,align=center]

Nehmen wir an, dass in der oben gezeigten beispielhaften Netzwerktopologie die Hosts _myhost_ und _myhost4_ nicht mehr erreichbar sind.
Der Ausfall von _myhost4_ ist dadurch erklärbar, dass _myhost_ ausgefallen ist.
Daher wird _myhost4_ im Monitoring als {UNREACH} klassifiziert.
Es ist schlicht nicht eindeutig feststellbar, weswegen {CMK} _myhost4_ nicht mehr erreichen kann und der Status {DOWN} wäre daher unter Umständen irreführend.
Stattdessen bewirkt das {UNREACH} standardmäßig die Unterdrückung einer xref:notifications#[Benachrichtigung].
Denn das ist die wichtigste Aufgabe des Konzepts der Parents:
Die Vermeidung massenhafter Benachrichtigungen, falls ein ganzes Netzwerksegment aufgrund einer Unterbrechung für das Monitoring nicht mehr erreichbar ist.

Der Vermeidung von Fehlalarmen dient auch ein xref:cmc_differences#no_on-demand_host_checks[Feature] des in den {CEE} verwendeten {CMK} Micro Core (CMC).
Hier wird der Statuswechsel über einen ausgefallenen Host wenige Augenblicke zurückgehalten und findet erst dann statt, wenn _gesichert_ ist, dass der Parent noch erreichbar ist.
Falls der Parent dagegen sicher {DOWN} ist, wechselt der Host nach {UNREACH} -- ohne dass benachrichtigt wird.

In manchen Fällen hat ein Host mehrere Parents, zum Beispiel, wenn ein Router hochverfügbar in einem Cluster betrieben wird.
Für {CMK} reicht es, wenn einer dieser Parents erreichbar ist, um den Status des Hosts eindeutig zu bestimmen.
Falls ein Host also _mehrere_ Parents hat und zumindest einer dieser Parents {UP} ist, wird der Host im Monitoring als erreichbar betrachtet.
Mit anderen Worten: In diesem Fall wird der Host nicht automatisch in den Zustand {UNREACH} wechseln.


[#services]
=== Services

Ein Host hat eine Menge von _Services_. Ein Service kann alles Mögliche
sein, bitte verwechseln Sie das nicht mit den Services von Windows. Ein Service
ist irgendein Teil oder Aspekt des Hosts, der {OK} sein kann oder eben nicht.
Der Zustand von Services kann natürlich immer nur dann abgefragt werden, wenn
der Host im Zustand {UP} ist.

Folgende Zustände kann ein Service im Monitoring haben:

[cols="11,6,~"]
|===
|Zustand |Farbe |Bedeutung 

|{OK} |grün |Der Service ist vollständig in Ordnung. Alle Messwerte liegen im erlaubten Bereich.
|{WARN} |gelb |Der Service funktioniert normal, aber seine Parameter liegen außerhalb des optimalen Bereichs.
|{CRIT} |rot |Der Service ist ausgefallen, defekt.
|{UNKNOWN} |orange |Der Zustand des Services konnte nicht korrekt ermittelt werden. Der Monitoring-Agent hat fehlerhafte Daten geliefert oder die zu überwachende Sache ist ganz verschwunden.
|{PEND} |grau |Der Service ist gerade in die Überwachung aufgenommen worden und es gibt noch keine Monitoring-Daten.
|===


Wenn es darum geht, welcher Zustand „schlimmer“ ist, verwendet {CMK} folgende Reihenfolge:

{OK} → {WARN} → {UNKNOWN} → {CRIT}

[#checks]
=== Checks
In {CMK} wird jede Prüfung eines Hosts oder Services gemäß der erstellten Regeln und eines Check-Plugins als xref:glossar#check[Check] bezeichnet. Ein Check ist also der Vorgang, der den Status von Hosts und Services bestimmt. Dabei kann ein Check verschiedene Services abdecken.


== Host- und Servicegruppen

Hosts und Services können zur Übersicht gruppiert werden. Dabei kann ein Host/Service
auch in mehreren Gruppen sein. Diese Gruppen sind rein optional und für die Konfiguration
nicht notwendig. Hostgruppen können nützlich sein, wenn Sie eine zusätzliche Gruppierung
quer zu der Ordnerstruktur wünschen, in der Sie die Hosts verwalten. Haben Sie
die Ordnerstruktur z.B. nach geographischen Gesichtspunkten aufgebaut, dann kann
eine Hostgruppe _Linux-Server_ sinnvoll sein, die alle Linux-Server zusammenfasst,
egal an welchen Standorten diese stehen.



== Kontakte und Kontaktgruppen

Kontakte und xref:wato_user#contact_groups[Kontaktgruppen] bieten die Möglichkeit, Hosts und Services
Personen zuzuordnen. Ein Kontakt entspricht einer Benutzerkennung der
Weboberfläche. Die Zuordnung zu Hosts und Services geschieht jedoch
nicht direkt, sondern über Kontaktgruppen. Zunächst wird ein Kontakt
(z.B. `harri`) einer Kontaktgruppe (z.B. `linux-admins`) zugeordnet.
Der Kontaktgruppe werden dann wieder Hosts oder nach Bedarf auch einzelne
Services zugeordnet. Dabei können sowohl Benutzer als auch Hosts und Services
jeweils mehreren Kontaktgruppen zugeordnet sein.

Diese Zuordnung ist für mehrere Aspekte nützlich:

. Wer darf was _sehen?_
. Wer darf welche Hosts und Services _konfigurieren und steuern?_
. Wer wird bei welchen Problemen _benachrichtigt?_

Der Benutzer `cmkadmin`, der beim Erzeugen einer Instanz automatisch
angelegt wird, darf übrigens immer alle Hosts und Services sehen, auch wenn
er kein Kontakt ist. Dies ist durch seine Rolle als Administrator bedingt.


== Benutzer und Rollen

Während über Kontakte und Kontaktgruppen gesteuert wird, welche Personen
für einen bestimmten Host oder Service zuständig oder berechtigt sind,
werden die Privilegien über _Rollen_ gesteuert. {CMK} wird dabei
mit drei Rollen ausgeliefert, von denen Sie später weitere Rollen ableiten
können. Jede Rolle definiert eine Reihe von Rechten, welche Sie anpassen
können. Die Bedeutung der Standardrollen sind:

[cols="5,10,~"]
|===
| |Rolle |Bedeutung 

|icon:icon_roles[] |`admin` |Darf alles sehen, hat alle Privilegien.
|icon:icon_roles[] |`user` |Darf nur sehen, wofür er Kontakt ist. Darf Hosts verwalten in Ordnern, die ihm zugewiesen sind. Darf keine globalen Einstellungen machen.
|icon:icon_roles[] |`guest` |Darf alles sehen, aber nichts konfigurieren und auch nicht in das Monitoring eingreifen.
|===



== Probleme, Ereignisse und Benachrichtigungen

[#problems]
=== Bearbeitete und unbehandelte Probleme

{CMK} bezeichnet jeden Host der nicht {UP} und jeden
Service, der nicht {OK} ist, als ein _Problem_.
Dabei kann ein Problem zwei Zustände haben: _unbehandelt_ (unhandled)
und _bearbeitet_ (handled). Der Ablauf ist so, dass ein neues Problem
zunächst als unbehandelt gilt. Sobald jemand das Problem im Monitoring
_bestätigt_ (quittiert, acknowledged), gilt es als bearbeitet.
Man könnte auch sagen, dass die unbehandelten Probleme solche sind, um
die sich noch niemand gekümmert hat. Der xref:user_interface#overview[Overview] in der
Seitenleiste unterscheidet deswegen diese beiden Arten von Problemen:

image::overview_more.png[alt="Snapin Overview im Show-more-Modus.",width=50%]

Übrigens: Service-Probleme von Hosts, die gerade nicht {UP} sind, werden
hier nicht als Problem angezeigt.

Weitere Details zu den Quittierungen finden Sie in einem xref:basics_ackn#[eigenen Artikel.]


[#notifications]
=== Benachrichtigungen

Wann immer sich der Zustand eines Hosts oder Services ändert (z.B. von
{OK} auf {CRIT}), spricht {CMK} von
einem _Monitoring-Ereignis._ So ein Ereignis kann -- muss aber nicht -- zu einer
xref:glossar#notification[Benachrichtigung] führen. {CMK} ist so voreingestellt, dass im Falle eines
Problems von einem Host oder Service jeder Kontakt dieses Objekts per E-Mail
benachrichtigt wird (bitte beachten Sie hierbei, dass `cmkadmin`
erst mal _kein_ Kontakt von irgendeinem Objekt ist). Dies kann aber
sehr flexibel angepasst werden. Auch hängen die Benachrichtigungen von einigen
Rahmenbedingungen ab. Am einfachsten ist es, wenn wir uns ansehen, in
welchen Fällen _nicht_ benachrichtigt wird. Benachrichtigungen werden
unterdrückt, wenn:

* Benachrichtigungen global in der _Master control_ ausgeschaltet wurden,
* Benachrichtigungen bei dem Host/Service ausgeschaltet wurden,
* der jeweilige Zustand bei dem Host/Service für Benachrichtigungen abgeschaltet ist (z.B. keine Benachrichtigung bei {WARN}),
* das Problem einen Service betrifft, dessen Host {DOWN} oder {UNREACH} ist,
* das Problem einen Host betrifft, dessen Parents alle {DOWN} oder {UNREACH} sind,
* für den Host/Service ein Benachrichtigungszeitraum (_notification period_) definiert wurde, der gerade nicht aktiv ist (siehe unten),
* der Host/Service gerade _unstetig_ icon:icon_flapping[] (flapping) ist (siehe unten),
* sich der Host/Service gerade in einer Wartungszeit (_scheduled downtime_) befindet (siehe unten).

Wenn keine dieser Bedingungen für eine Unterdrückung erfüllt ist, erzeugt der Monitoring-Kern
eine Benachrichtigung, welche dann im zweiten Schritt eine Kette von benutzerdefinierbaren
Regeln durchläuft. Dort können Sie dann noch weitere Ausschlusskriterien
festlegen und entscheiden, wer auf welchem Wege benachrichtigt werden soll (E-Mail,
SMS etc.).

Alle Einzelheiten rund um die Benachrichtigungen finden Sie in einem xref:notifications#[eigenen Artikel].

[#flapping]
=== Unstetige Hosts und Services (Flapping)

Manchmal kommt es vor, dass sich der Zustand von einem Service in kurzen
Abständen immer wieder ändert. Um ständige Benachrichtigungen zu
vermeiden, schaltet {CMK} so einen Service in den Zustand „unstetig“
(_flapping_). Dies wird durch das Symbol icon:icon_flapping[] illustriert. Jetzt wird ein
letztes Mal eine Benachrichtigung erzeugt. Diese informiert, dass eben dieser
Zustand eingetreten ist, und danach ist Ruhe. Wenn für eine angemessene
Zeit kein weiterer Zustandswechsel geschieht  --  sich also alles beruhigt und
endgültig zum Guten oder zum Schlechten gewendet hat  --  verschwindet dieser
Zustand wieder und die normalen Benachrichtigungen setzen wieder ein.


[#downtimes]
=== Wartungszeiten (Scheduled downtimes)

Wenn Sie an einem Server, Gerät oder an einer Software Wartungsarbeiten vornehmen möchten,
möchten Sie in der Regel Benachrichtigungen über eventuelle Probleme in dieser Zeit
vermeiden. Außerdem möchten Sie Ihren Kollegen evtl. signalisieren, dass Probleme, die
das Monitoring anzeigt, vorübergehend ignoriert werden sollen.

Zu diesem Zweck können Sie zu einem Host oder Service Wartungszeiten (_scheduled
downtimes_) eintragen. Diese können Sie entweder direkt beim Beginn der Arbeiten oder
auch schon im Vorfeld eintragen. Wartungszeiten werden durch Symbole illustriert:

[cols="5,~"]
|===
|icon:icon_downtime[alt="Symbol zur Anzeige der Wartungszeit bei Services."] |Der Service befindet sich in einer Wartungszeit.
|icon:icon_derived_downtime[alt="Symbol zur Anzeige der Wartungszeit bei Hosts."] |Der Host befindet sich in einer Wartungszeit. Auch Services, deren Host sich in einer Wartung befindet, werden mit diesem Symbol gekennzeichnet.
|===

Während ein Host oder Service in Wartungszeit ist,

* werden keine Benachrichtigungen versendet,
* werden Probleme nicht im [.guihint]#Overview# angezeigt.

Auch wenn Sie später Auswertungen über die Verfügbarkeit von Hosts
oder Services machen möchten, ist es eine gute Idee Wartungszeiten
einzutragen. Diese können dann später bei der Berechnung berücksichtigt
werden.


[#stale]
=== Veraltete Hosts und Services (Stale)

Wenn Sie eine Weile mit {CMK} gearbeitet haben, kann es passieren, dass in Ihren Service- oder Hostansichten Spinnennetze angezeigt werden. Für die Services sieht das dann zum Beispiel so aus:

image::monitoring_basics_stale.png[alt="Ansicht zweier Services im Zustand stale."]

Diese Spinnennetze symbolisieren den Zustand veraltet (_stale_).

Auch das Snapin [.guihint]#Overview#, das im Abschnitt xref:intro_tools#overview[Die Monitoring-Werkzeuge] erklärt wurde, wird dann um die Spalte [.guihint]#Stale# erweitert.

Doch was bedeutet der Zustand _stale_? Generell wird ein Host oder Service als _stale_ gekennzeichnet, wenn {CMK} über eine längere Zeitdauer keine aktuellen Informationen über dessen Zustand mehr bekommt:

* Ein Service wird _stale_:
Fällt ein Agent - aus welchen Gründen auch immer - über längere Zeit aus, so liefert er an ein oder mehrere Checks keine aktuellen Daten für die Auswertung. Folglich können auch die abhängigen Services nicht mit aktuellen Daten versorgt werden. Die Services verbleiben im jeweils letzten Status, werden aber nach Ablauf einer bestimmten Zeit als _stale_ markiert.

* Ein Host wird _stale_:
Schlägt für einen Host der Ping bzw. xref:cmc_differences#smart_ping[Smart Ping] mehrfach fehl, behält der Host den letzten ermittelten Zustand bei. Er wird dann aber als _stale_ gekennzeichnet.

Sie können die Auslöser, die für den Zustand _stale_ verantwortlich sind, anpassen. Lesen Sie hierzu den Abschnitt xref:checkinterval[Check-Intervall und Check-Versuche.]


[#time_periods]
== Zeiträume (Time periods)

[{image-left}]
image::timeperiods.png[width=8%]

Zeiträume definieren regelmäßig wöchentlich wiederkehrende Zeitbereiche, die
an verschiedenen Stellen in der Konfiguration des Monitorings zum Einsatz kommen.
Ein typischer Zeitraum könnte `workhours` heißen und die Zeiten von
jeweils 8:00 bis 17:00 Uhr beinhalten, an allen Wochentagen außer Samstag und Sonntag.
Vordefiniert ist der Zeitraum `24X7`, welcher einfach alle Zeiten einschließt.
Zeiträume können auch Ausnahmen für bestimmte Kalendertage enthalten -- z.B.
für die bayerischen Feiertage.

Einige wichtige Stellen, an denen Zeiträume zum Einsatz kommen, sind:

* Begrenzung der Zeiten, innerhalb derer benachrichtigt wird (Benachrichtigungszeitraum, _notification period_).
* Begrenzung der Zeiten, innerhalb derer Checks ausgeführt werden (xref:checkinterval[Check-Zeitraum, check period]).
* Servicezeiten für die Berechnung von Verfügbarkeiten (Service-Zeitraum, service period).
* Zeiten, innerhalb derer bestimmte Regeln in der [.guihint]#Event Console# greifen.

Wie Sie Zeiträume einstellen können, lesen Sie im Kapitel xref:timeperiods#[Zeitperioden (Time Periods).]


[#checkinterval]
== Check-Intervall und Check-Versuche

{CMK} führt innerhalb des xref:time_periods[Check-Zeitraums] in regelmässigen Abständen, also mit dem definierten xref:check_interval[Check-Intervall], Checks durch. Schlägt die vorgegebene Zahl an Check-Versuchen fehl, so geht der zugehörige Service auf _stale_.

[#check_interval]
=== Check-Intervalle einstellen
Damit das Zielsystem (Server, Netzwerkgerät, etc.) nicht für jeden einzelnen Service aufs Neue kontaktiert werden muss, holt {CMK} einmal pro Intervall alle wichtigen Daten in einem Rutsch und berechnet daraus die neuen Resultate für alle zugehörigen Checks auf einmal.
Das schont CPU-Ressourcen auf beiden Systemen und ist ein wichtiger Grund für die hohe Performance und gute Skalierbarkeit von {CMK}.

{CMK} verwendet als Standard für Service-Checks eine Minute, für Host-Checks mit Smart Ping 6 Sekunden.
Mit Hilfe der Regeln [.guihint]#Normal check interval for service checks# bzw. [.guihint]#Normal check interval for host checks# kann dies geändert werden:

* Auf einen längeren Wert, um CPU-Ressourcen auf Server und Zielsystem zu sparen
* Auf einen kürzeren Wert, um schneller Benachrichtigungen zu bekommen und Messdaten in einer höheren Auflösung einzusammeln

Kombinieren Sie nun einen Check-Zeitraum mit einem Check-Intervall, so können Sie dafür sorgen, dass ein aktiver Check genau einmal am Tag zu einer ganz bestimmten Zeit ausgeführt
wird. Setzen Sie z.B. das Check-Intervall auf 24 Stunden und den Check-Zeitraum auf 2:00 bis 2:01 Uhr an jedem Tag (also nur eine Minute pro Tag),
dann wird {CMK} dafür sorgen, dass der Check auch wirklich in dieses kurze
Zeitfenster verschoben wird.

Schlägt die Ausführung eines Check mehrfach fehl, so wird der zugehörige Service/Host _stale_, wie im Abschnitt xref:stale[Veraltete Hosts und Services (Stale)] beschrieben. In den [.guihint]#Global settings# > [.guihint]#User interface#  können Sie definieren, wieviel Zeit vergehen soll, bis ein Service/Host auf _stale_ geht:

image::monitoring_basics_staleness.png[alt="Einstellungen der Staleness."]

Dieser Faktor stellt das n-fache des Check-Intervalls dar.
Ist also Ihr Check-Intervall beispielsweise auf eine Minute (60 Sekunden) eingestellt, so geht ein Service, der keine Daten von den Checks erhält, nach der 1,5-fachen Zeit, somit nach 90 Sekunden, auf _stale_.


[#max_check_attempts]
=== Check-Versuche anpassen
Mit Hilfe der _Check-Versuche_ (max check attempts) können Sie Benachrichtigungen
bei sporadischen Fehlern vermeiden. Sie machen einen Check damit quasi weniger
sensibel. Sind die Check-Versuche z.B. auf 3 eingestellt, und der entsprechende
Service wird {CRIT}, dann wird zunächst noch keine Benachrichtigung
ausgelöst. Erst wenn auch die nächsten beiden Checks ein Resultat liefern, das
nicht {OK} ist, steigt die Nummer des aktuellen Versuchs
auf 3 und die Benachrichtigung wird versendet.

Ein Service, der sich in diesem Zwischenzustand befindet -- also nicht {OK} ist,
aber die maximalen Versuche noch nicht erreicht hat -- hat einen _weichen
Zustand_ (soft state).


== Übersicht über die wichtigsten Host- und Service-Icons

Folgende Tabelle gibt eine kurze Übersicht der wichtigsten Icons, die
Sie als Status neben Hosts und Services finden:

[cols="5,~"]
|===

|icon:icon_downtime[alt="Symbol zur Anzeige der Wartungszeit bei Services."] |Dieser Service ist in einer Wartungszeit.
|icon:icon_derived_downtime[alt="Symbol zur Anzeige der Wartungszeit bei Hosts."] |Dieser Host ist in einer Wartungszeit. Auch Services, deren Host sich in einer Wartung befindet, werden mit diesem Symbol gekennzeichnet.
|icon:icon_outofnot[] |Dieser Host/Service ist gerade außerhalb seiner Benachrichtigungsperiode.
|icon:icon_notif_man_disabled[] |Benachrichtigungen für diesen Host/Service sind gerade abgeschaltet.
|icon:icon_disabled[] |Checks dieses Services sind gerade abgeschaltet.
|icon:icon_stale[] |Der Zustand dieses Hosts/Services ist veraltet (stale).
|icon:icon_flapping[] |Der Zustand dieses Hosts/Services ist unstetig (flapping).
|icon:icon_ack[] |Dieser Host/Service hat ein Problem, das bestätigt wurde.
|icon:icon_comment[] |Zu diesem Host/Service gibt es einen Kommentar.
|icon:icon_aggr[] |Dieser Host/Service ist Teil einer BI-Aggregation.
|icon:icon_check_parameters[] |Hier gelangen Sie direkt zur Einstellung der Checkparameter.
|icon:icon_logwatch[] |Nur bei Logwatch-Services: Hier gelangen Sie zu den gespeicherten Logfiles.
|icon:icon_pnp[] |Hier gelangen Sie zum Zeitverlauf der aufgezeichneten Messwerte.
|icon:icon_inventory[] |Dieser Host besitzt HW/SW-Inventurdaten. Ein Klickt bringt Sie zu deren Ansicht.
|icon:icon_crash[] |Bei diesem Check ist ein Fehler aufgetreten. Über einen Klick können Sie einen Fehlerreport einsehen und absenden.
|===
