// -*- coding: utf-8 -*-
// IGNORE 
// NOLUNR
include::global_attr.adoc[]
= Benachrichtigungen per ilert
:revdate: draft
:title: Benachrichtigungen per ilert (notifications)
:description: Sie können Benachrichtigungen von {CMK} an die Plattform ilert senden lassen. Wie Sie die Anbindung durchführen, erfahren Sie hier.

{related-start}
xref:notifications#[Benachrichtigungen]
{related-end}


[#function]
== Funktion

link:https://www.ilert.com/[ilert^] ist eine Plattform für Alarmierung, Rufbereitschaften und Statusseiten, die Alarme aus verschiedenen Quellen sammelt und weiterverarbeiten kann.
{CMK} kann als eine dieser Alarmquellen genutzt werden.
Die Benachrichtigungen von {CMK} werden in ilert als Alarme (_alerts_) angezeigt, für die wiederum Aktionen festgelegt werden können,
wie die die Einrichtung von Arbeitsabläufen (_workflows_) oder die Weiterleitung per E-Mail und an andere Incident-Management-Systeme wie z.B. Jira oder TOPdesk.
//SK: Wichtiger im Kotext dieses Tickets ist allerdings dieses winzige " (z.B. ServiceNow)". Das irritiert innerhalb eines Artikels über ein anderes Plugin nur und könnte auch die Leute von ilert ein wenig nerven.
// TK: Hm, die ilerts scheinen da doch ganz entspannt zu sein und schreiben im Blog https://checkmk.com/blog/improve-your-uptime-with-checkmk-and-ilert:
// TK: Just like Checkmk, iLert has integrations with outbound tools such as Slack, ServiceNow or Jira
// TK: Ich hab ServiceNow trotzdem ersetzt durch TOPdesk - ist ja eigentlich auch egal. GitHub wäre u.a. auch noch im Angebot.

Die Anbindung erfolgt über einen API-Schlüssel, den Sie in ilert für eine Alarmquelle der Integration {CMK} erstellen.

*Hinweis:* Wie Sie nach erfolgter Anbindung die Alarme in ilert weiterverarbeiten können, erfahren Sie in unserem link:https://checkmk.com/blog/setting-up-checkmk-in-ilert[Blog-Artikel.^]


[#config_ilert]
== Konfiguration ilert

In ilert erstellen Sie für {CMK} eine neue Alarmquelle (_alert source_) und erhalten zum Abschluss der Einrichtung den zugehörigen API-Schlüssel:

. Öffnen Sie die Seite [.guihint]#Alert sources# und starten Sie die Erstellung einer neue Alarmquelle mit [.guihint]#Create a new alert source.#
Ein Wizard führt Sie durch die nächsten Schritte.
Im folgenden werden die Einträge vorgeschlagen, mit denen Sie am schnellsten ans Ziel kommen.
Die im Wizard getroffenen Entscheidungen können Sie später durch das Editieren der Alarmquelle ändern.

. Wählen Sie auf der ersten Wizard-Seite {CMK} als Integration für die Alarmquelle aus und bestätigen Sie mit [.guihint]#Next.#
Geben Sie anschließend Ihrer Alarmquelle einen Namen.
Wählen Sie dann eine Eskalationskette (_escalation policy_) aus, z. B. [.guihint]#Default.#
Als Letztes wählen Sie die Alarm-Gruppierung oder lassen es (erstmal) bleiben mit [.guihint]#Do not group alerts.#

. Beenden Sie den Wizard mit [.guihint]#Continue setup#.
Sie erhalten eine Zusammenfassung der bisher gemachten Einstellungen und weitere Auswahlmöglichkeiten für Alarmvorlage (_alert template_) und Benachrichtigungspriorität (_notification priority_).
+
Die Benachrichtigungspriorität können Sie sowohl in ilert als auch xref:config_checkmk[später in {CMK}] festlegen.
Wenn Sie möchten, dass die Priorität von {CMK} gesteuert wird, dann wählen Sie hier [.guihint]#High (with escalation)# oder [.guihint]#Low (no escalation),# das heißt einen Wert, der in beiden Systemen verfügbar ist. Lassen Sie außerdem die Prioritätsbindung (_priority mapping_) deaktiviert.
//SK: Das hat mich beim ersten Lesen sehr verwirrt. Ich kann also die "Benachrichtigungspriorität" festlegen. Aha. Das mache ich aber in Checkmk. Was? Aber ich bin doch gerade in ilert. Ich würde hier beschreiben, dass die "Standard-Priorität" durch die von Checkmk übermittelte überschrieben wird. Es sei denn...
//SK: Das Checkmk alleine die Prorität festlegt stimmt nicht (mehr). Die "Dynamische Prioritäts-Bindung" von ilert scheint später zu greifen und überschreibt dann wiederum die Prio, die aus Checkmk kommt. Das ist zwar nicht so richtig unser Problem, aber das die "Auswahl unter [.guihint]#Notification priority# [...] die Benachrichtigungspriorität" überschreibt, stimmt nicht immer.
//TK: Geändert wie besprochen

. Bestätigen Sie mit [.guihint]#Finish setup.#
Auf der folgenden Seite wird der API-Schlüssel (_API key_) angezeigt, den Sie für die Konfiguration in {CMK} benötigen.
Vor dem Schlüssel finden Sie einen Knopf zum Kopieren in die Zwischenablage.

//SK: Diese vier Schritte wirken etwas fahrig. Das Ende von Schritt 1 enthält eine allgemeine Erklärung und Dinge die erst nach Abschluss des Wizards relevant werden. Im zweiten Schritt mache ich dann etwas "zuerst". Im dritten Schritt wird erstmalig einer der blauen Knöpfe erwähnt, die ich vorher auch schon zwei Mal betätigen musste.
//TK: 1. Satz des 2. Listeneintrags geändert


[#config_checkmk]
== Konfiguration {CMK}

Wie Sie Benachrichtigungen im Allgemeinen in {CMK} einrichten, haben Sie bereits im Artikel über xref:notifications#[Benachrichtigungen] erfahren.

//SK: Generell sollten wir uns auch noch mal das include anschauen. Das ist mir nach n Wochen Abstinenz nicht mehr ganz klar.

////
Zur Erinnerung:
include::include_ticketsystem.asciidoc[]
////
// TK: Ich hab das include mal auskommentiert und die enthaltene Info zur Kontaktauswahl ans Ende (ohne include) geschoben. Bitte schauen, ob nun besser. (Ticket für die Änderung war KNW-904.)

In {CMK} genügt nun die Angabe des API-Schlüssels:
// TK: Gibt es eigentlich 1 (guten) Grund, warum die folgende Liste mittendrin und nicht zumindest mit dem Erstellen einer Benachrichtigungsregel startet: Setup > Events > Notifications > Add rule?
// TK: plus Verweis nach notifications#rules? Gilt für alle Benachrichtigungsartikel.

. Wählen Sie als [.guihint]#Notification Method# den Eintrag [.guihint]#iLert.#
. Fügen Sie als [.guihint]#API Key# den kopierten API-Schlüssel ein.

image::notifications_ilert.png[alt="Die Einstellungen zur Benachrichtigungsmethode für ilert."]

Statt den API-Schlüssel hier direkt anzugeben, können Sie ebenso den {CMK}-xref:password_store#[Passwortspeicher] heranziehen und den Schlüssel aus einem der Einträge auslesen.

Die Auswahl unter [.guihint]#Notification priority# überschreibt die Benachrichtigungspriorität in bestimmten Fällen, wie bei der xref:config_ilert[Konfiguration von ilert] beschrieben.
//SK: Siehe oben. Die Auswahl in ilert wird nur überschrieben, wenn in ilert
// a) High (with escalation) oder Low (no escalation) ausgewählt ist und
// b) kein Priority mapping greift.
// Die beiden Default priorities "High during support hours, low priority otherwise" und "Low during support hours, high priority otherwise" überschreiben die von Checkmk kommende Prio ebenfalls.
// TK: Weichmacher hinzugefügt
Mit den beiden Eingabefeldern zu [.guihint]#Custom incident summary# legen Sie fest, wie eine {CMK}-Benachrichtigung in ilert in der Liste der Alerts als [.guihint]#Summary# angezeigt wird.

Optional dürfen Sie URL-Präfixe angeben, um Links auf Ihre Checkmk-GUI innerhalb der Benachrichtigung zu steuern.

// TK: Jetzt folgt die Info zur Kontaktauswahl
Bei der anschließenden Kontaktauswahl im Kasten [.guihint]#Contact selection# beachten Sie die folgenden beiden Punkte:

. Als Kontakt darf nur ein einzelner Benutzer eingetragen werden, d.h. weder eine Kontaktgruppe noch ein Objektkontakt, ansonsten werden pro Ereignis mehrere Benachrichtigungen an das Zielsystem geschickt.

. Wenn der erste Punkt erfüllt ist, dieser Benutzer aber in mehreren Benachrichtigungsregeln für die gleiche Benachrichtigungsmethode verwendet wird, dann greift jeweils nur die letzte Regel.
Es empfiehlt sich daher, für jede dieser Benachrichtigungsregeln einen eigenen funktionalen Benutzer anzulegen.

*Hinweis:* In ilert werden nur die xref:notifications#environment_variables[{CMK}-Benachrichtigungstypen] `PROBLEM`, `ACKNOWLEDGEMENT` und `RECOVERY` verarbeitet - alle anderen werden ignoriert.

Zum Testen können Sie die xref:commands#[Kommandos] [.guihint]#Fake check results# und [.guihint]#Custom notification# verwenden.
