// -*- coding: utf-8 -*-
// IGNORE 
// NOLUNR
include::global_attr.adoc[]
= Benachrichtigungen per iLert
:revdate: draft
:title: Benachrichtigungen per iLert (notifications)
:description: Sie können Benachrichtigungen von {CMK} an die Plattform iLert senden lassen. Wie Sie die Anbindung durchführen, erfahren Sie hier.

{related-start}
xref:notifications#[Benachrichtigungen]
{related-end}


[#function]
== Funktion

link:https://www.ilert.com/[iLert^] ist eine Plattform für Alarmierung, Rufbereitschaften und Statusseiten, die Alarme aus verschiedenen Quellen sammelt und weiterverarbeiten kann.
{CMK} kann als eine dieser Alarmquellen genutzt werden.
Die Benachrichtigungen von {CMK} werden in iLert als Alarme (_alerts_) angezeigt, für die wiederum Aktionen festgelegt werden können,
wie die die Einrichtung von Arbeitsabläufen (_workflows_) oder die Weiterleitung per E-Mail und an andere Incident-Management-Systeme wie Jira oder ServiceNow.

Die Anbindung erfolgt über einen API-Schlüssel, den Sie in iLert für eine Alarmquelle der Integration {CMK} erstellen.

*Hinweis:* Wie Sie nach erfolgter Anbindung die Alarme in iLert weiterverarbeiten können, erfahren Sie in unserem link:https://checkmk.com/blog/setting-up-checkmk-in-ilert[Blog-Artikel.^]


[#config_ilert]
== Konfiguration iLert

In iLert erstellen Sie für {CMK} eine neue Alarmquelle (_alert source_) und erhalten zum Abschluss der Einrichtung den zugehörigen API-Schlüssel:

. Öffnen Sie die Seite [.guihint]#Alert sources# und starten Sie die Erstellung einer neue Alarmquelle mit [.guihint]#Create a new alert source.#
Ein Wizard führt Sie durch die nächsten Schritte.
Im folgenden werden die Einträge vorgeschlagen, mit denen Sie am schnellsten ans Ziel kommen.
Die im Wizard getroffenen Entscheidungen können Sie später durch das Editieren der Alarmquelle ändern.

. Wählen Sie zuerst {CMK} als Integration für die Alarmquelle aus.
Geben Sie anschließend Ihrer Alarmquelle einen Namen.
Wählen Sie dann eine Eskalationskette (_escalation policy_) aus, z. B. [.guihint]#Default.#
Als Letztes wählen Sie die Alarm-Gruppierung oder lassen es (erstmal) bleiben mit [.guihint]#Do not group alerts.#

. Beenden Sie den Wizard mit [.guihint]#Continue setup#.
Sie erhalten eine Zusammenfassung der bisher gemachten Einstellungen und weitere Auswahlmöglichkeiten für Alarmvorlage (_alert template_) und Benachrichtigungspriorität (_notification priority_).
Die Priorität legen Sie übrigens bei der Konfiguration in {CMK} fest.

//SK: Das hat mich beim ersten Lesen sehr verwirrt. Ich kann also die "Benachrichtigungspriorität" festlegen. Aha. Das mache ich aber in Checkmk. Was? Aber ich bin doch gerade in ilert. Ich würde hier beschreiben, dass die "Standard-Priorität" durch die von Checkmk übermittelte überschrieben wird. Es sei denn...

//SK: Das Checkmk alleine die Prorität festlegt stimmt nicht (mehr). Die "Dynamische Prioritäts-Bindung" von ilert scheint später zu greifen und überschreibt dann wiederum die Prio, die aus Checkmk kommt. Das ist zwar nicht so richtig unser Problem, aber das die "Auswahl unter [.guihint]#Notification priority# [...] die Benachrichtigungspriorität" überschreibt, stimmt nicht immer.

. Bestätigen Sie mit [.guihint]#Finish setup.#
Auf der folgenden Seite wird der API-Schlüssel (_API key_) angezeigt, den Sie für die Konfiguration in {CMK} benötigen.
Vor dem Schlüssel finden Sie einen Knopf zum Kopieren in die Zwischenablage.

//SK: Diese vier Schritte wirken etwas fahrig. Das Ende von Schritt 1 enthält eine allgemeine Erklärung und Dinge die erst nach Abschluss des Wizards relevant werden. Im zweiten Schritt mache ich dann etwas "zuerst". Im dritten Schritt wird erstmalig einer der blauen Knöpfe erwähnt, die ich vorher auch schon zwei Mal betätigen musste.


[#config_checkmk]
== Konfiguration {CMK}

Wie Sie Benachrichtigungen im Allgemeinen in {CMK} einrichten, haben Sie bereits im Artikel über xref:notifications#[Benachrichtigungen] erfahren.

Zur Erinnerung:

include::include_ticketsystem.asciidoc[]
5t
In {CMK} genügt nun die Angabe des API-Schlüssels:

. Wählen Sie als [.guihint]#Notification Method# den Eintrag [.guihint]#iLert.#
. Fügen Sie als [.guihint]#API Key# den kopierten API-Schlüssel ein.

image::notifications_ilert.png[alt="Die Einstellungen zur Benachrichtigungsmethode für iLert."]

Statt den API-Schlüssel hier direkt anzugeben, können Sie ebenso den {CMK}-xref:password_store#[Passwortspeicher] heranziehen und den Schlüssel aus einem der Einträge auslesen.

Die Auswahl unter [.guihint]#Notification priority# überschreibt die Benachrichtigungspriorität, die in iLert festgelegt ist.
Mit den beiden Eingabefeldern zu [.guihint]#Custom incident summary# legen Sie fest, wie eine {CMK}-Benachrichtigung in iLert in der Liste der Alerts als [.guihint]#Summary# angezeigt wird.

//SK: Siehe oben. Die Auswahl in ilert wird nur überschrieben, wenn in ilert
// a) High (with escalation) oder Low (no escalation) ausgewählt ist und
// b) kein Priority mapping greift.
// Die beiden Default priorities "High during support hours, low priority otherwise" und "Low during support hours, high priority otherwise" überschreiben die von Checkmk kommende Prio ebenfalls.

Optional dürfen Sie URL-Präfixe angeben, um Links auf Ihre Checkmk-GUI innerhalb der Benachrichtigung zu steuern.

Beachten Sie, dass in iLert nur die xref:notifications#environment_variables[{CMK}-Benachrichtigungstypen] `PROBLEM`, `ACKNOWLEDGEMENT` und `RECOVERY` verarbeitet werden - alle anderen werden ignoriert.

Zum Testen können Sie die xref:commands#[Kommandos] [.guihint]#Fake check results# und [.guihint]#Custom notification# verwenden.
