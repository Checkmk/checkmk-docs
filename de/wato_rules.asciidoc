// -*- coding: utf-8 -*-
include::global_attr.adoc[]
= Host- und Serviceparameter
:revdate: draft
:title: Host- und Serviceparameter - Regeln in {CMK} verstehen und nutzen
:description: Regeln in {CMK} können den Standard oder die Ausnahme definieren. Dieser Artikel beschreibt detailliert die Nutzung von Regeln und wie sie ausgewertet werden.

{related-start}
xref:wato#[Die Konfiguration von {CMK}]
xref:hosts_setup#[Verwaltung der Hosts]
xref:wato_services#[Services verstehen und konfigurieren]
{related-end}


== Einleitung

In {CMK} konfigurieren Sie Parameter für Hosts und Services über
_Regeln_. Diese Besonderheit macht {CMK} in komplexen Umgebungen
sehr leistungsfähig und bringt auch in kleineren Installationen etliche
Vorteile. Um das Prinzip der regelbasierten Konfiguration anschaulich zu
machen, machen wir einen Vergleich mit der klassischen Methode:

=== Der klassische Ansatz

Nehmen wir als Beispiel die Konfiguration von Schwellwerten für {WARN} und
{CRIT} bei der Überwachung von Dateisystemen. Bei einer an Datenbanken
orientierten Konfiguration würde man in einer Tabelle für jedes Dateisystem
eine Zeile anlegen:

[cols=4]
|===
|Host |Filesystem |Warnung |Kritisch

|myserver001 |/var |{nbsp}90% |{nbsp}95%
|myserver001 |/sapdata |{nbsp}90% |{nbsp}95%
|myserver001 |/var/log |{nbsp}90% |{nbsp}95%
|myserver002 |/var |{nbsp}85% |{nbsp}90%
|myserver002 |/opt |{nbsp}85% |{nbsp}90%
|myserver002 |/sapdata |{nbsp}85% |{nbsp}95%
|myserver002 |/var/trans |100% |100%
|===


Das ist einigermaßen übersichtlich -- aber nur weil die Tabelle hier kurz ist. In der
Praxis haben Sie eher Hunderte oder Tausende von Dateisystemen. Werkzeuge
wie Copy & Paste und Bulk-Operationen können die Arbeit erleichtern, aber
es bleibt ein Grundproblem: Wie können Sie hier eine _Policy_ erkennen
und durchsetzen? Wie ist die generelle Regel? Wie sollen Schwellwerte für
zukünftige Hosts eingestellt werden?

[#rule_based]
=== Regelbasiert ist besser!

Eine regelbasierte Konfiguration hingegen *besteht* aus der Policy!
Die Logik der obigen Tabelle ersetzen wir durch einen Satz aus vier Regeln.
Wenn wir davon ausgehen, dass `myserver001` ein Testsystem ist und dass
für jedes Dateisystem die jeweils _erste zutreffende Regel_ gilt, ergeben
sich die gleichen Schwellwerte wie in der Tabelle von oben:

. Dateisysteme mit dem Mountpunkt `/var/trans` haben die Schwellwerte 100/100%.
. Das Dateisystem `/sapdata` auf `myserver002` hat die Schwellwerte 85/95%.
. Dateisysteme auf Testsystemen haben die Schwellwerte 90/95%.
. Alle (übrigen) Dateisysteme haben die Schwellwerte 85/90%.

Zugegeben -- bei nur zwei Hosts bringt das nicht viel. Aber wenn es nur ein
paar mehr sind, wird der Mehraufwand schnell sehr groß. Die Vorteile der
regelbasierten Konfiguration liegen auf der Hand:

* Die Policy ist klar erkennbar und wird zuverlässig durchgesetzt.
* Sie können die Policy jederzeit ändern, ohne dass Sie Tausende Datensätze anfassen müssen.
* _Ausnahmen_ sind immer noch möglich, aber in Form von Regeln dokumentiert.
* Das Aufnehmen von neuen Hosts ist einfach und wenig fehleranfällig.

Zusammengefasst also: weniger Arbeit -- mehr Qualität! Und deswegen finden Sie Regeln bei {CMK}
an allen Stellen, wo es irgendwie um Hosts oder Services geht: bei Schwellwerten, Monitoring-Einstellungen,
Zuständigkeiten, Benachrichtigungen, Agentenkonfiguration und vielem mehr.


[#rule_set_types]
=== Arten von Regelsätzen

Im Setup von {CMK} werden Regeln in _Regelsätzen_ organisiert. Jeder Regelsatz
hat die Aufgabe, einen ganz bestimmten Parameter für Hosts oder Services
festzulegen. In {CMK} gibt es über 700 Regelsätze! Hier einige Beispiele:

* [.guihint]#Host check command# -- legt fest, wie geprüft werden soll, ob Hosts {UP} sind.
* [.guihint]#Alternative display name for services# -- definiert für Services alternative Anzeigenamen.
* [.guihint]#JVM memory levels# -- legt Schwellwerte und andere Parameter für die Überwachung des Speicherbedarfs von Java-VMs fest.

Jeder Regelsatz ist entweder für Hosts oder für Services zuständig
 -- nie für beides. Wenn Parameter sowohl für Hosts als auch für
Services einstellbar sind, gibt es jeweils ein Pärchen von Regelsätzen --
z.B. [.guihint]#Normal check interval for host checks# und
[.guihint]#Normal check interval for services checks#.

Einige Regelsätze legen genau genommen nicht Parameter fest, sondern erzeugen
Services. Ein Beispiel sind die Regeln in der Rubrik _Active checks_.
Damit können Sie z.B. einen HTTP-Check für bestimmte Hosts einrichten. Diese
Regeln gelten als Host-Regeln. Denn die Tatsache, dass so ein Check auf einem
Host existiert, gilt als eine Host-Eigenschaft des Hosts.

Ferner gibt es Regelsätze, welche die xref:wato_services#[Serviceerkennung]
steuern. So können Sie z.B. über [.guihint]#Windows service discovery# festlegen, für welche
Windows-Dienste automatisch Checks eingerichtet werden sollen, falls diese auf einem
System gefunden werden. Auch dies sind Host-Regeln.

//SP: Hier wechselt der Text meiner Meinung nach sehr plötzlich und erst auf den zweiten Blick erkennbar von Host- zu Serviceregeln.
Der Großteil der Regelsätze legt Parameter für bestimmte
Check-Plugins fest. Ein Beispiel ist [.guihint]#Network interfaces and switch ports#.
Die Einstellungen in diesen Regeln sind sehr individuell auf das
jeweilige Plugin zugeschnitten. Solche Regelsätze finden grundsätzlich nur
bei denjenigen Services Anwendung, die auf diesem Check-Plugin basieren. Falls
Sie unsicher sind, welcher Regelsatz für welche Services zuständig ist,
navigieren Sie am besten direkt über den Service zur passenden Regel.
Wie das geht, erfahren Sie später.


=== Host-Merkmale

Eines haben wir bisher noch unterschlagen:
In obigem Beispiel gibt es eine Regel für alle Testsysteme.
Wo ist eigentlich festgelegt, welcher Host ein Testsystem ist?

So etwas wie _Testsystem_ heißt bei {CMK} _Host-Merkmal_ (englisch: _host tag_).
Welche Merkmale es gibt, können Sie sich über [.guihint]#Setup > Hosts > Tags# anzeigen lassen.
Einige Merkmale sind bereits vordefiniert -- zum Beispiel für ein [.guihint]#Test system#, das in der Gruppe [.guihint]#Criticality# definiert ist.

Die Zuordnung zu den Hosts geschieht entweder explizit in den Eigenschaften des Hosts oder per
Vererbung über die Ordnerhierarchie.
Wie das geht, erfahren Sie im xref:hosts_setup#folder[Artikel über die Hosts.]
Wie Sie eigene Merkmale anlegen können und was es mit den bereits vordefinierten Merkmalen auf sich hat, lesen Sie im Artikel über die xref:host_tags#[Host-Merkmale.]


== Auffinden der richtigen Regelsätze

=== Host-Regelsätze

Wenn Sie eine neue Regel anlegen möchten, die für einen oder mehrere Hosts einen
Parameter definiert, dann gibt es mehrere Wege zum Ziel. Der direkte Weg geht
über die entsprechende Gruppe im [.guihint]#Setup#-Menü, in diesem Fall also
[.guihint]#Setup > Hosts > Host monitoring rules#:

image::wato_rules_host_monitoring_rules.png[alt="Setup-Menü mit Fokus auf die Host monitoring rules."]

In der folgenden Ansicht werden nun alle für das Host-Monitoring relevanten
Regelsätze angezeigt. Die Zahlen hinter den Namen dieser Regelsätze zeigen die Anzahl der bereits definierten Regeln:

image::wato_rules_host_monitoring_rules_2.png[alt="Ansicht der Host monitoring rules im Setup-Menü."]

Etwas schneller können Sie allerdings über das _Suchfeld_ an Ihr Ziel gelangen.
Dazu müssen Sie natürlich ungefähr wissen, wie der Regelsatz heißt.
Hier ist als Beispiel das Ergebnis einer Suche nach _host checks_.

image::wato_rules_search_host_checks.png[width=50%, alt="Auszug des Ergebnisses einer Suche nach host checks."]

Ein anderer Weg geht über den Menüpunkt [.guihint]#Hosts > Effective parameters#
in den Eigenschaften eines vorhandenen Hosts im Setup oder über das Symbol
icon:icon_rulesets[] in der Liste der Hosts eines Ordners.

image::wato_rules_setup_object_parameters.png[alt="Liste einiger Hosts im Setup-Menü mit Hervorhebung des Knopfes für Host Parameter."]

Dort finden Sie nicht nur alle Regelsätze, die den Host betreffen, sondern auch
den jeweils für diesen Host aktuell wirksamen Parameter. Im Beispiel von
[.guihint]#Host check command# greift für den gezeigten Host keine Regel und er
steht deswegen auf der Defaulteinstellung [.guihint]#Smart PING (only with Checkmk Micro Core)#. Oder entsprechend in der {RE} auf der Defaulteinstellung [.guihint]#PING (active check with ICMP echo request).#

image::wato_rules_host_rule_sets.png[alt="Anzeige des Defaultparameters für die Hostprüfregel."]

Klicken Sie auf _Host Check Command_, um den ganzen Regelsatz zu sehen.

Falls bereits eine Regel existiert, erscheint anstelle von _Default Value_
die Nummer der Regel, welche diesen Parameter festlegt. Ein Klick darauf bringt
Sie direkt zu dieser Regel.

image::wato_rules_host_rule_sets2.png[alt="Anzeige des eingestellten Parameters für die Hostprüfregel."]

[#checkparameters]
=== Service-Regelsätze

Der Weg zu den Regelsätzen für Services ist ähnlich. Der allgemeine Zugang geht
auch hier über das [.guihint]#Setup#-Menü, in diesem Fall also
[.guihint]#Setup > Services > Service monitoring rules# oder zweckmäßigerweise
über das Suchfeld.

image::wato_rules_service_monitoring_rules.png[alt="Ansicht der Regelsätze für die Überwachung der Services im Setup-Menü."]

Wenn Sie nicht schon sehr geübt mit den Namen der Regelsätze sind, dann ist der
Weg über den Service allerdings einfacher. Analog zu den Hosts gibt es auch hier
eine Seite, auf der alle Parameter des Services dargestellt werden und Sie die
Möglichkeit haben, die passenden Regelsätze direkt anzusteuern. Sie erreichen
diese Parameterseite mit dem Symbol icon:icon_services[] in der Liste der
Services eines Hosts im Setup. Das Symbol icon:icon_check_parameters[] bringt Sie
direkt zu demjenigen Regelsatz, der die
xref:wato_services#parameters[Parameter für das Check-Plugin] des Services
festlegt.

image::wato_rules_setup_service_list.png[alt="Ansicht der überwachten Services zu einem Host mit Markierung der Symbole zum Aufruf der Parameter."]

Das Symbol icon:icon_rulesets[] für die Parameterseite gibt es übrigens
auch in der Statusoberfläche im Kontextmenü jedes Services:

image::wato_rules_service_context_menu.png[alt="Ansicht der Statusoberfläche der Services mit Marikerung der Option Parameterservices."]

[#enforced_services]
[#manual_checks]
=== Erzwungene Services

Im [.guihint]#Setup#-Menü finden Sie desweiteren einen Eintrag für
[.guihint]#erzwungene Services# ([.guihint]#Enforced Services#). Wie der Name
schon sagt, können Sie über diese Regelsätze erzwingen, dass Services bei Ihren
Hosts angelegt werden. Einzelheiten dazu finden Sie im
xref:wato_services#enforced_services[Artikel über die Services]. Eine
kleine Zahl von Regelsätzen - wie bspw. [.guihint]#Simple checks for
BIOS/Hardware errors# - finden Sie ausschließlich unter den erzwungenen
Services. Hierbei handelt es sich um Services, welche nicht durch die
Serviceerkennung entstehen, sondern von Ihnen manuell angelegt werden.


=== Benutzte Regelsätze

In jeder der vorgenannten Auflistungen von Regelsätzen - sei es in den
[.guihint]#Host monitoring rules# oder den [.guihint]#Service monitoring rules#
- können Sie über [.guihint]#Related > Used rulesets# in der Menüleiste, nur
genau die Regelsätze anzeigen lassen, in denen Sie mindestens eine Regel
definiert haben. Dies ist oft ein bequemer Einstieg, wenn Sie Anpassungen an
Ihren bestehenden Regeln vornehmen möchten. Einige der Regeln entstehen übrigens
schon beim Anlegen der {CMK}-Instanz und sind Teil der Beispielkonfiguration.
Auch diese werden hier angezeigt.


=== Wirkungslose Regeln

Monitoring ist eine komplexe Sache.
Da kann es schon mal vorkommen, dass es Regeln gibt, welche auf keinen einzigen
Host oder Service matchen -- entweder, weil Sie einen Fehler gemacht haben oder
weil die passenden Hosts und Services verschwunden sind. Solche wirkungslosen
Regeln können Sie, in den vorgenannten Auflistungen von Regelsätzen, über
[.guihint]#Related > Ineffective rulesets# in der Menüleiste anzeigen lassen.


=== Veraltete Regelsätze

{CMK} wird ständig weiterentwickelt. Gelegentlich werden dabei Dinge
vereinheitlicht und es kommt dazu, dass manche Regelsätze durch andere
ersetzt werden. Wenn Sie solche Regelsätze im Einsatz haben, finden Sie diese am
einfachsten durch eine Regelsuche. Öffnen Sie diese über [.guihint]#Setup > General > Rule search# in der Navigationsleiste. Klicken Sie anschließend in der
Menüleiste auf [.guihint]#Rules > Refine search#, wählen Sie hinter [.guihint]#Deprecated#
die Option [.guihint]#Search for deprecated rulesets# und hinter [.guihint]#Used# die Option [.guihint]#Search for rulesets that have rules configured#. Nach einem
weiteren Klick auf [.guihint]#Search# bekommen Sie die gewünschte Übersicht.

image::wato_rules_search_deprecated_rules.png[alt="Eingabemaske für die Suche nach veralteten Regelsätzen."]

[#create_rules]
== Regeln erstellen und editieren

Die folgende Abbildung zeigt den Regelsatz [.guihint]#Filesystems (used space and growth)#
mit vier konfigurierten Regeln:

image::rules_filesystem.png[]

*Neue Regeln* erzeugen Sie entweder über den Knopf [.guihint]#Create rule in folder#
oder über das icon:icon_clone[] Klonen einer bestehenden
Regel. Das Klonen erzeugt eine identische Kopie einer Regel, die Sie anschließend
mit icon:icon_edit[] bearbeiten können. Eine über den Knopf [.guihint]#Create rule in folder#
erzeugte neue Regel wird immer am Ende der Liste der Regeln erzeugt, während eine
geklonte Regel als Kopie unterhalb des Originals erzeugt wird.

Die *Reihenfolge* von Regeln können Sie mit dem Knopf
icon:icon_drag[] ändern. Die Reihenfolge ist wichtig, weil weiter oben stehende Regeln immer *Vorrang* vor späteren haben.

Die Regeln sind dabei in den *xref:hosts_setup#folder[Ordnern]* abgelegt,
in denen Sie auch die Hosts verwalten. Der Wirkungsbereich von Regeln ist
auf die Hosts eingeschränkt, die in diesem Ordner oder in seinen Unterordnern
liegen. Falls sich Regeln widersprechen, so hat immer die Regel in einem
Unterordner Vorrang. So können z.B. Benutzer, die nur für manche Ordner
xref:wato_user#wato_permissions[berechtigt] sind, für ihre Hosts Regeln anlegen, ohne
dass diese Einfluss auf den Rest des Systems haben. In den Eigenschaften
einer Regel können Sie deren Ordner ändern und sie somit „umziehen“.

=== Analyse mit der Ampel

//ML:  Hier braucht es mehr Details. Die Icons kommen gerne mehrfach vor oder bewirken auf unterschiedlichen Seiten unterschiedliche Dinge. Hier wird nicht ganz klar, dass das nur aus der Service-Konfiguration aus geht und nur mit manuell angelegten/Host-spezifischen (??) Regeln. Ansonsten sieht man zwar die Icons zum Draufklicken, kommt aber auf alles Mögliche, nur nicht auf die Ampel aus dem Screenshot. Bei einer Site, die in Betrieb ist stößt man sicherlich drauf - bei einer frisch aufgesetzten Site artet das schnell aus.

Wenn Sie einen Regelsatz über einen Host oder Service ansteuern -- also
z.B. über die Symbole icon:icon_rulesets[] oder icon:button_check_parameters[]
bei einem Host oder Service -- zeigt {CMK} Ihnen den Regelsatz im *Analysemodus:*

image::rules_filesystem_analyze.png[alt="Ansicht der Ampelfunktion für die bestehenden Regeln."]

Dies bewirkt zwei Dinge: Zum einen taucht ein zweiter Knopf zum Anlegen von
Regeln auf -- hier im Beispiel [.guihint]#Create mount point specific rule for#.
Damit können Sie eine neue Regel erzeugen, welche als Bedingung direkt den
aktuellen Host bzw. Service voreingetragen hat. So können Sie sehr einfach
direkt eine Ausnahmeregel erzeugen. Zum anderen taucht in jeder Zeile ein
Kugelsymbol auf, welches Ihnen anzeigt, ob diese Regel für den aktuellen
Host bzw. Service greift. Dabei gibt es folgende mögliche Fälle:

[cols="5,~"]
|===

|icon:icon_rulenmatch[] |Diese Regel greift nicht für den aktuellen Host oder Service.
|icon:icon_rulematch[] |Diese Regel greift und definiert Parameter.
|icon:icon_ruleimatch[] |Diese Regel greift zwar. Aber da eine Regel weiter oben auch greift und Vorrang hat, ist die  Regel wirkungslos.
|icon:icon_rulepmatch[] |Diese Regel greift. Eine Regel weiter oben hat zwar Vorrang und greift auch,  definiert aber nicht alle Parameter,  so dass mindestens ein Parameter von dieser Regel definiert wird.
|===


Der letzte Fall -- das icon:icon_rulepmatch[] partielle Matchen einer
Regel -- kann nur bei solchen Regelsätzen auftreten, in denen eine Regel
*mehrere Parameter* festlegt, welche durch Checkboxen einzeln angewählt
werden können. Hier kann theoretisch jeder einzelne der Parameter von einer
anderen Regel festgelegt werden. Dazu später mehr.


== Eigenschaften einer Regel

=== Allgemeine Optionen

Jede Regel ist in drei Blöcken aufgebaut. Alles im ersten Block [.guihint]#Rule Properties# ist optional und dient
vor allem der Dokumentation:

image::rules_props_properties.png[alt="Ansicht der Regeloptionen."]

* Die [.guihint]#Description# wird in der Tabelle aller Regeln eines Regelsatzes angezeigt.
* Das Feld [.guihint]#Comment# können Sie für eine längere Beschreibung verwenden. Es erscheint nur im Editiermodus einer Regel. Über das Symbol icon:icon_insertdate[] können Sie einen Zeitstempel und Ihren Loginnamen in den Text einfügen lassen.
* Die [.guihint]#Documentation-URL# ist für einen Link auf interne Dokumentation gedacht, die Sie in einem anderen System (z.B. einer CMDB) pflegen.  Sie wird in der Regeltabelle über das Symbol icon:icon_url[] anklickbar dargestellt.
* Mit der Checkbox [.guihint]#do not apply this rule# können Sie die Regel vorübergehend abschalten. Sie wird dann in der Tabelle mit icon:icon_disabled[] dargestellt und hat keine Wirkung.

=== Die festgelegten Parameter

Der zweite Abschnitt ist bei jeder Regel anders. Folgende Abbildung zeigt einen weit verbreiteten
Typ von Regel ([.guihint]#DB2 Tablespaces#). Über Checkboxen können Sie bestimmen, welche Einzelparameter die Regel definieren
soll. Wie weiter oben beschrieben, wird von {CMK} für jeden einzelnen Parameter getrennt ermittelt,
welche Regel diesen setzt. Die Regel aus der Abbildung setzt also nur den einen Wert
und lässt alle anderen Einstellungen unbeeinflusst.

image::rules_props_value_1.png[alt="Exemplarische Ansicht der Regelwerte mit Festlegung eines Wertes."]

Manche Regelsätze legen keinen Parameter fest, sondern entscheiden
nur, welche Hosts _drin_ sind und welche nicht. Ein Beispiel ist der
Regelsatz [.guihint]#Hosts to be monitored#, mit welchem Sie manche Hosts ganz
aus dem Monitoring entfernen können. Der Parameterbereich sieht dann so
aus:

image::rules_props_value_2.png[alt="Exemplarische Ansicht der Regelwerte mit Auswahl einer Option."]

Wählen Sie hier [.guihint]#Positive match (Add matching hosts to the set)#, so heißt das,
dass die betroffenen Hosts in die Menge aufgenommen -- in unserem
Beispiel also gemonitort werden sollen. Die _betroffenen Hosts_ definieren Sie in den nachfolgenden Bedingungen ([.guihint]#Conditions#).

[#conditions]
=== Bedingungen (Conditions)

Im vorigen Abschnitt haben Sie festgelegt, wie all jene Hosts bzw. Services bearbeitet werden sollen, die von Ihrer Regel betroffen sind. 
Im dritten Abschnitt [.guihint]#Conditions# definieren Sie nun, welche Hosts bzw. Services für die Regel -- und damit deren Auswirkungen -- herangezogen werden sollen. Dabei gibt es verschiedene Arten von Bedingungen, die alle erfüllt sein
müssen, damit die Regel greift. Die Bedingungen werden also logisch UND-verknüpft:

image::rules_props_conditions_1.png[alt="Ansicht möglicher Bedingungen für eine Regel."]

*Hinweis:* Haben Sie keine Bedingungen definiert, wird die Regel immer auf alle Hosts bzw. Services angewendet. Nachfolgende Regeln werden dadurch unter Umständen nicht mehr ausgewertet, siehe xref:matching[Arten der Regelauswertung].

==== Condition type

Hier haben Sie die Möglichkeit, neben einer normalen Bedingung auch auf
_vordefinierte Bedingungen_ ([.guihint]#Predefined Conditions#) zurückzugreifen.
Diese werden über [.guihint]#Setup > General > Predefined conditions#
verwaltet. Geben Sie hier Regelbedingungen, die Sie immer wieder
brauchen, einen festen Namen und verweisen in den Regeln einfach darauf. Sie
können sogar später den Inhalt dieser Bedingungen zentral ändern und alle Regeln
werden automatisch angepasst. In folgendem Beispiel wird die vordefinierte
Bedingung [.guihint]#No VM# ausgewählt:

image::rules_props_conditions_2.png[alt="Auswahl vordefinierter Bedingungen für eine Regel."]

==== Folder

Mit der Bedingung [.guihint]#Folder# legen Sie fest, dass die Regel nur für Hosts gelten soll,
die in diesem Ordner (oder einem Unterordner) enthalten sind. Ist die Einstellung auf
[.guihint]#Main Directory#, so gilt diese Bedingung also für alle Hosts. Wie weiter oben beschrieben, haben
die Ordner auch einen Einfluss auf die Reihenfolge der Regeln. Regeln in tieferen Ordnern
haben immer Vorrang vor Regeln in höher liegenden.

==== Host tags

Die [.guihint]#Host tags# schränken die Regel auf solche Hosts ein, die bestimmte Host-Merkmale
haben oder nicht haben. Auch hier wird immer mit UND verknüpft. Jede weitere Bedingung für Host-Merkmale
in einer Regel verringert also die Menge der Hosts, auf die diese wirkt.

Wenn Sie eine Regel für zwei mögliche Ausprägungen eines Merkmals gelten
lassen möchten (z.B. bei [.guihint]#Criticality# sowohl [.guihint]#Productive system# als
auch [.guihint]#Business critical#), so geht das nicht mit einer
einzelnen Regel. Sie benötigen dann eine Kopie der Regel für jede Variante.
Manchmal hilft hier aber auch die Negation. Sie können als Bedingung auch
festlegen, dass ein Merkmal *nicht* vorhanden ist (z.B. nicht [.guihint]#Test system#).
Eine andere Möglichkeit sind sogenannte xref:host_tags#aux_tag[Hilfsmerkmale.]

Weil einige Anwender wirklich sehr viele Host-Merkmale verwenden, haben wir den
Dialog so gestaltet, dass nicht sofort alle Host-Merkmalsgruppen angezeigt werden.
Sie müssen diese zunächst für die Regel aktivieren. Das geht so:

. Wählen Sie in der Auswahlbox eine Host-Merkmalsgruppe.
. Klicken Sie [.guihint]#Add tag condition#. Dadurch wird darüber ein Eintrag für diese Gruppe hinzugefügt.
. Wählen Sie [.guihint]#is# oder [.guihint]#is not#.
. Wählen Sie das gewünschte Merkmal als Vergleichswert.

image::rules_props_hosttags.png[alt="Festlegung eines Host tags mit Merkmalen."]

==== Host labels

Auch xref:labels#[Host labels] können Sie für Bedingungen in Regeln verwenden. Fügen Sie
Bedingungen mit [.guihint]#Add label condition# hinzu. Wählen Sie nun entweder [.guihint]#has#
oder [.guihint]#has not# um eine positive oder negative Bedingung zu formulieren und
geben Sie dann das Label in der gewohnten Form
_Schlüssel_`:`_Wert_ ein. Achten Sie hier bitte auf ganz exakte
Schreibung, auch was Groß-/Kleinschreibung betrifft. Sonst wird die Bedingung
nicht korrekt funktionieren.

image::rules_props_labels.png[alt="Ansicht der Einstellungen für Service labels."]


==== Explicit hosts

Diese Art von Bedingung ist für Ausnahmeregeln vorgesehen. Hier können Sie einen
oder mehrere Hostnamen auflisten. Die Regel gilt dann nur für diese Hosts.
Bitte beachten Sie, dass wenn Sie [.guihint]#Explicit hosts# angekreuzt haben
und *keinen* Host eintragen, die Regel überhaupt nicht greifen wird.

Über die Option [.guihint]#Negate# können Sie eine umgekehrte Ausnahme definieren. Damit
schließen Sie bestimmte explizit genannte Hosts von der Regel aus. Die Regel greift dann für alle Hosts *außer* den hier genannten.

image::rules_props_explicithosts_1.png[alt="Ansicht der Einstellungen für Explicit hosts."]

Wichtig: Alle hier eingetippten Hostnamen werden auf *genaue Übereinstimmung*
geprüft. Groß-/Kleinschreibung wird von {CMK} in Hostnamen grundsätzlich unterschieden!

Sie können dieses Verhalten auf xref:regexes#[reguläre Ausdrücke] umstellen,
indem Sie dem Hostnamen eine Tilde (`~`) voranstellen. In diesem Fall gilt wie
immer im [.guihint]#Setup#:

* Der Match geht auf den *Anfang* des Hostnamens.
* Der Match ignoriert Groß-/Kleinschreibung.

Punkt-Stern (`pass:[.*]`) bedeutet bei xref:regexes#[regulären Ausdrücken] eine beliebige Folge von Zeichen.
Folgendes Beispiel zeigt eine Bedingung, die auf alle Hosts matcht, deren Namen die
Zeichenfolge `my` (oder `My`, `MY`, `mY` usw.) *enthält*:

image::rules_props_explicithosts_2.png[alt="Anzeige einer Bedingung zur Host-Auswahl mit Platzhaltern."]


==== Explicit services

Bei Regeln, die sich auf Services beziehen, gibt es als letzte
Bedingungsart noch einen Match auf den Namen des Services, bzw. bei Regeln,
die Checkparameter festlegen, auf den Namen des *Check items*. Auf was
genau gematcht wird, sehen Sie in der Beschriftung. In unserem Beispiel ist
das der Name ([.guihint]#Instance#) eines [.guihint]#Tablespaces#:

image::rules_props_explicitservices.png[alt="Anzeige einer Bedingung zur Serviceauswahl mit Platzhaltern."]

Hier gilt grundsätzlich ein Match mit xref:regexes#[regulären Ausdrücken].
Die Folge `pass:[.*]temp` matcht alle Tablespaces, die `temp` *enthalten,* denn der Match geht immer auf den Anfang des Namens.
Das Dollarzeichen am Ende von `transfer$` steht für das Ende und erzwingt somit einen exakten Match.
Ein Tablespace mit dem Namen `transfer2` würde daher *nicht* matchen.

Bitte vergessen Sie nicht: Bei Regeln, in denen es um [.guihint]#Explicit services#
geht, benötigen Sie einen Match auf den Servicenamen (z.B. `Tablespace
transfer`). Bei Checkparameter-Regeln geht es um einen Match auf das
Item (z.B. `transfer`). Das Item ist quasi der variable Teil des
Servicenamens und legt fest, um _welchen_ Tablespace es
sich handelt.

Es gibt übrigens auch Services ohne Item. Ein Beispiel ist die
_CPU load_. Diese gibt es pro Host nur einmal, also ist kein Item
notwendig. Regeln für solche Checktypen haben folglich auch keine Bedingung
dafür.


[#matching]
== Regelauswertungen

Nun haben wir beschrieben, wie Regeln erstellt werden. Mit der Erstellung von Regeln ist es jedoch nicht getan. Im Beispiel des Abschnitts xref:rule_based[Regelbasiert ist besser] reicht eine einzelne Regel nicht, um das gewünschte Ergebnis zu erreichen. Ein komplexeres System aus logisch aufeinanderfolgenden Regeln wird hierfür benötigt. Damit wird auch das Verständnis für das Zusammenspiel verschiedener Regeln bedeutsam.

=== Arten der Regelauswertung

In der Einleitung in das Prinzip der Regeln haben Sie gesehen, dass immer die erste zutreffende Regel den Ergebniswert festlegt.
Das ist nicht die ganze Wahrheit.
Es gibt insgesamt drei verschiedene Arten der Auswertung:

[cols=2]
|===
|Auswertung |Verhalten

|Erste Regel |Die erste Regel, die zutrifft, legt den Wert fest. Weitere Regeln werden nicht mehr ausgewertet. Dies ist der Normalfall für Regeln, die einfache Parameter festlegen.
|Erste Regel pro Parameter |Jeder Einzelparameter wird von der ersten Regel festgelegt, bei der dieser Parameter definiert ist (Checkbox angekreuzt). Dies ist der Normalfall für alle Regeln mit Unterparametern, die mit Checkboxen aktiviert werden.
|Alle Regeln |Alle zutreffenden Regeln fügen Elemente zum Ergebnis hinzu. Dieser Typ kommt z.B. bei der Zuordnung von Hosts und Services zu Host-, Service- und Kontaktgruppen zum Einsatz.
|===

Diese Information wird bei jedem Regelsatz oben angezeigt.

image::rules_matching_strategy.png[alt="Anzeige der geltenden Regelauswertung oberhalb der Regel."]

[#match_example]
=== Regelauswertung praktisch erklärt

Wie wird nun konkret ausgewertet, wenn man mehrere Regeln erstellt hat? Um dies zu veranschaulichen, nutzen wir noch einmal das Beispiel aus xref:rule_based[Abschnitt 1.2 Regelbasiert ist besser!]

Es gibt also vier Regeln:

* Regel A: Dateisysteme mit dem Mountpunkt `/var/trans` haben die Schwellwerte 100/100%.
* Regel B: Das Dateisystem `/sapdata` auf `myserver002` hat die Schwellwerte 85/95%.
* Regel C: Dateisysteme auf Testsystemen haben die Schwellwerte 90/95%.
* Regel D: Alle (übrigen) Dateisysteme haben die Schwellwerte 85/90%.

Viele der {CMK} Regelauswertungen suchen die erste gematchte Regel und melden dann deren Ergebnis (The first matching rule defines the parameter.).
Bei dem klassischen Positivmatch (Regel trifft zu) wird für jeden Host also eine Regel nach der anderen durchlaufen und der erste Treffer (falls vorhanden) zurückgeliefert.

Damit werden die Schwellwerte für die Beispielserver gesetzt:

[cols=5]
|===
|Regel |Host |Filesystem |Warnung |Kritisch

|A |myserver002 |/var/trans |100% |100%
|B |myserver002 |/sapdata |{nbsp}85% |{nbsp}95%
|C |myserver001 |/var |{nbsp}90% |{nbsp}95%
|C |myserver001 |/sapdata |{nbsp}90% |{nbsp}95%
|C |myserver001 |/var/log |{nbsp}90% |{nbsp}95%
|D |myserver002 |/var |{nbsp}85% |{nbsp}90%
|D |myserver002 |/opt |{nbsp}85% |{nbsp}90%
|===

Angenommen, Regel B steht jetzt stattdessen auf Negativmatch (Regel trifft nicht zu). Beim Durchlaufen der Regeln wird also Regel B auf alle Hosts angewendet, die nicht Dateisystem `/sapdata` auf `myserver002` sind. Selbst wenn es für einen dieser Hosts also in Regel C oder Regel D ein weiteres Positivmatch geben würde, die Regelkette würde nichts liefern. 

Damit werden die Schwellwerte für die Beispielserver diesmal so gesetzt:

[cols=5]
|===
|Regel |Host |Filesystem |Warnung |Kritisch

|A |myserver002 |/var/trans |100% |100%
|B |myserver001 |/var |{nbsp}85% |{nbsp}95%
|B |myserver001 |/sapdata |{nbsp}85% |{nbsp}95%
|B |myserver001 |/var/log |{nbsp}85% |{nbsp}95%
|B |myserver002 |/var |{nbsp}85% |{nbsp}95%
|B |myserver002 |/opt |{nbsp}85% |{nbsp}95%
|D |myserver002 |/sapdata |{nbsp}85% |{nbsp}90%
|===


Ein Negativmatch ist also nicht nur dafür da, Hosts auszuschließen. Im Umkehrschluss werden alle nicht genannten eingeschlossen.

Durch die richtige Kombination aus Positiv- und Negativmatches können damit komplexe Regelketten für ganze Hostkomplexe aufgebaut werden.

