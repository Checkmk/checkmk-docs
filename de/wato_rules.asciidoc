// -*- coding: utf-8 -*-
include::global_attr.adoc[]
= Host- und Serviceparameter
:revdate: 2021-08-13
:title: Host- und Serviceparameter - Regeln in {CMK} verstehen und nutzen
:description: Regeln in {CMK} können den Standard oder die Ausnahme definieren. Dieser Artikel beschreibt detailliert die Nutzung von Regeln und wie sie ausgewertet werden.

{related-start}
xref:wato#[Die Konfiguration von {CMK}]
xref:wato_hosts#[Verwaltung der Hosts]
xref:wato_services#[Services verstehen und konfigurieren]
{related-end}


== Einleitung

In {CMK} konfigurieren Sie Parameter für Hosts und Services über
_Regeln_. Diese Besonderheit macht {CMK} in komplexen Umgebungen
sehr leistungsfähig und bringt auch in kleineren Installationen etliche
Vorteile. Um das Prinzip der regelbasierten Konfiguration anschaulich zu
machen, machen wir einen Vergleich mit der klassischen Methode:

=== Der klassische Ansatz

Nehmen wir als Beispiel die Konfiguration von Schwellwerten für {WARN} und
{CRIT} bei der Überwachung von Dateisystemen. Bei einer an Datenbanken
orientierten Konfiguration würde man in einer Tabelle für jedes Dateisystem
eine Zeile anlegen:

[cols=4]
|===
|Host |Filesystem |Warnung |Kritisch

|myserver001 |/var |{nbsp}90% |{nbsp}95%
|myserver001 |/sapdata |{nbsp}90% |{nbsp}95%
|myserver001 |/var/log |{nbsp}90% |{nbsp}95%
|myserver002 |/var |{nbsp}85% |{nbsp}90%
|myserver002 |/opt |{nbsp}85% |{nbsp}90%
|myserver002 |/sapdata |{nbsp}85% |{nbsp}95%
|myserver002 |/var/trans |100% |100%
|===


Das ist einigermaßen übersichtlich -- aber nur weil die Tabelle hier kurz ist. In der
Praxis haben Sie eher Hunderte oder Tausende von Dateisystemen. Werkzeuge
wie Copy & Paste und Bulk-Operationen können die Arbeit erleichtern, aber
es bleibt ein Grundproblem: Wie können Sie hier eine _Policy_ erkennen
und durchsetzen? Wie ist die generelle Regel? Wie sollen Schwellwerte für
zukünftige Hosts eingestellt werden?

=== Regelbasiert ist besser!

Eine regelbasierte Konfiguration hingegen *besteht* aus der Policy!
Die Logik der obigen Tabelle ersetzen wir durch einen Satz aus vier Regeln.
Wenn wir davon ausgehen, dass `myserver001` ein Testsystem ist und dass
für jedes Dateisystem die jeweils _erste zutreffende Regel_ gilt, ergeben
sich die gleichen Schwellwerte wie in der Tabelle von oben:

. Dateisysteme mit dem Mountpunkt `/var/trans` haben die Schwellwerte 100/100%.
. Das Dateisystem `/sapdata` auf `myserver002` hat die Schwellwerte 85/95%.
. Dateisysteme auf Testsystemen haben die Schwellwerte 90/95%.
. Alle (übrigen) Dateisysteme haben die Schwellwerte 85/90%.

Zugegeben -- bei nur zwei Hosts bringt das nicht viel. Aber wenn es nur ein
paar mehr sind, wird der Mehraufwand schnell sehr groß. Die Vorteile der
regelbasierten Konfiguration liegen auf der Hand:

* Die Policy ist klar erkennbar und wird zuverlässig durchgesetzt.
* Sie können die Policy jederzeit ändern, ohne dass Sie Tausende Datensätze anfassen müssen.
* _Ausnahmen_ sind immer noch möglich, aber in Form von Regeln dokumentiert.
* Das Aufnehmen von neuen Hosts ist einfach und wenig fehleranfällig.

Zusammengefasst also: weniger Arbeit -- mehr Qualität! Und deswegen finden Sie Regeln bei {CMK}
an allen Stellen, wo es irgendwie um Hosts oder Services geht: bei Schwellwerten, Monitoring-Einstellungen,
Zuständigkeiten, Benachrichtigungen, Agentenkonfiguration und vielem mehr.


[#rule_set_types]
=== Arten von Regelsätzen

Im Setup von {CMK} werden Regeln in _Regelsätzen_ organisiert. Jeder Regelsatz
hat die Aufgabe, einen ganz bestimmten Parameter für Hosts oder Services
festzulegen. In {CMK} gibt es über 700 Regelsätze! Hier einige Beispiele:

* [.guihint]#Host check command# -- legt fest, wie geprüft werden soll, ob Hosts {UP} sind.
* [.guihint]#Alternative display name for services# -- definiert für Services alternative Anzeigenamen.
* [.guihint]#JVM memory levels# -- legt Schwellwerte und andere Parameter für die Überwachung des Speicherbedarfs von Java-VMs fest.

Jeder Regelsatz ist entweder für Hosts oder für Services zuständig
 -- nie für beides. Wenn Parameter sowohl für Hosts als auch für
Services einstellbar sind, gibt es jeweils ein Pärchen von Regelsätzen --
z.B. [.guihint]#Normal check interval for host checks# und
[.guihint]#Normal check interval for services checks#.

Einige Regelsätze legen genau genommen nicht Parameter fest, sondern erzeugen
Services. Ein Beispiel sind die Regeln in der Rubrik _Active checks_.
Damit können Sie z.B. einen HTTP-Check für bestimmte Hosts einrichten. Diese
Regeln gelten als Host-Regeln. Denn die Tatsache, dass so ein Check auf einem
Host existiert, gilt als eine Host-Eigenschaft des Hosts.

Ferner gibt es Regelsätze, welche die xref:wato_services#[Serviceerkennung]
steuern. So können Sie z.B. über [.guihint]#Windows service discovery# festlegen, für welche
Windows-Dienste automatisch Checks eingerichtet werden sollen, falls diese auf einem
System gefunden werden. Auch dies sind Host-Regeln.

//SP: Hier wechselt der Text meiner Meinung nach sehr plötzlich und erst auf den zweiten Blick erkennbar von Host- zu Serviceregeln.
Der Großteil der Regelsätze legt Parameter für bestimmte
Check-Plugins fest. Ein Beispiel ist [.guihint]#Network interfaces and switch ports#.
Die Einstellungen in diesen Regeln sind sehr individuell auf das
jeweilige Plugin zugeschnitten. Solche Regelsätze finden grundsätzlich nur
bei denjenigen Services Anwendung, die auf diesem Check-Plugin basieren. Falls
Sie unsicher sind, welcher Regelsatz für welche Services zuständig ist,
navigieren Sie am besten direkt über den Service zur passenden Regel.
Wie das geht, erfahren Sie später.


=== Hostmerkmale

//SP: Wenn wir an die Überschrift "(Tags)" oder "(Host tags)" anfügen, wird das Thema möglicherweise sichtbarer.
Eines haben wir bisher noch unterschlagen: In obigem Beispiel gibt es eine
Regel für alle _Testsysteme_. Wo ist eigentlich festgelegt, welcher
Host ein Testsystem ist?

So etwas wie _Testsystem_ heißt bei {CMK} _Hostmerkmal_ (englisch: _Host tag_).
Welche Merkmale es gibt, können Sie über [.guihint]#Setup > Tags# frei
definieren, und einige Merkmale sind bereits vordefiniert. Die Zuordnung zu den
Hosts geschieht entweder explizit in den Eigenschaften des Hosts oder per
Vererbung über die Ordnerhierarchie. Wie das geht, erfahren Sie im
xref:wato_hosts#[Artikel über die Hosts]. Wie Sie eigene Merkmale anlegen
können und was es mit den bereits vordefinierten Merkmalen auf sich hat, lesen
Sie xref:wato_rules#hosttags[weiter unten] in diesem Artikel.


== Auffinden der richtigen Regelsätze

=== Host-Regelsätze

Wenn Sie eine neue Regel anlegen möchten, die für einen oder mehrere Hosts einen
Parameter definiert, dann gibt es mehrere Wege zum Ziel. Der direkte Weg geht
über die entsprechende Gruppe im [.guihint]#Setup#-Menü, in diesem Fall also
[.guihint]#Setup > Hosts > Host monitoring rules#:

image::wato_rules_host_monitoring_rules.png[alt="Setup-Menü mit Fokus auf die Host monitoring rules"]

In der folgenden Ansicht werden nun alle für das Host-Monitoring relevanten
Regelsätze angezeigt. Die Zahlen hinter den Namen dieser Regelsätze zeigen die Anzahl der bereits definierten Regeln:

image::wato_rules_host_monitoring_rules_2.png[alt="Ansicht der Host monitoring rules im Setup-Menü"]

Etwas schneller können Sie allerdings über das _Suchfeld_ an Ihr Ziel gelangen.
Dazu müssen Sie natürlich ungefähr wissen, wie der Regelsatz heißt.
Hier ist als Beispiel das Ergebnis einer Suche nach _host checks_.

image::wato_rules_search_host_checks.png[width=50%, alt="Auszug des Ergebnisses einer Suche nach host checks"]

Ein anderer Weg geht über den Menüpunkt [.guihint]#Hosts > Effective parameters#
in den Eigenschaften eines vorhandenen Hosts im Setup oder über das Symbol
icon:icon_rulesets[] in der Liste der Hosts eines Ordners.

image::wato_rules_setup_object_parameters.png[alt="Liste einiger Hosts im Setup-Menü mit Hervorhebung des Knopfes für Host Parameter"]

Dort finden Sie nicht nur alle Regelsätze, die den Host betreffen, sondern auch
den jeweils für diesen Host aktuell wirksamen Parameter. Im Beispiel von
[.guihint]#Host check command# greift für den gezeigten Host keine Regel und er
steht deswegen auf der Defaulteinstellung [.guihint]#PING (active check with
ICMP echo request)#:
//SP: Erweiterung des Texts? In den CEE heißt der Ping anders (siehe Screenshot!)

image::wato_rules_host_rule_sets.png[]

Klicken Sie auf _Host Check Command_, um den ganzen Regelsatz zu sehen.

Falls bereits eine Regel existiert, erscheint anstelle von _Default Value_
die Nummer der Regel, welche diesen Parameter festlegt. Ein Klick darauf bringt
Sie direkt zu dieser Regel.

image::wato_rules_host_rule_sets2.png[]

[#checkparameters]
=== Service-Regelsätze

Der Weg zu den Regelsätzen für Services ist ähnlich. Der allgemeine Zugang geht
auch hier über das [.guihint]#Setup#-Menü, in diesem Fall also
[.guihint]#Setup > Services > Service monitoring rules# oder zweckmäßigerweise
über das Suchfeld.

image::wato_rules_service_monitoring_rules.png[]

Wenn Sie nicht schon sehr geübt mit den Namen der Regelsätze sind, dann ist der
Weg über den Service allerdings einfacher. Analog zu den Hosts gibt es auch hier
eine Seite, auf der alle Parameter des Services dargestellt werden und Sie die
Möglichkeit haben, die passenden Regelsätze direkt anzusteuern. Sie erreichen
diese Parameterseite mit dem Symbol icon:icon_services[] in der Liste der
Services eines Hosts im Setup. Das Symbol icon:icon_check_parameters[] bringt Sie
direkt zu demjenigen Regelsatz, der die
xref:wato_services#parameters[Parameter für das Check-Plugin] des Services
festlegt.

image::wato_rules_setup_service_list.png[]

Das Symbol icon:icon_rulesets[] für die Parameterseite gibt es übrigens
auch in der Statusoberfläche im Kontextmenü jedes Services:

image::wato_rules_service_context_menu.png[]

[#enforced_services]
[#manual_checks]
=== Erzwungene Services

Im [.guihint]#Setup#-Menü finden Sie desweiteren einen Eintrag für
[.guihint]#erzwungene Services# ([.guihint]#Enforced Services#). Wie der Name
schon sagt, können Sie über diese Regelsätze erzwingen, dass Services bei Ihren
Hosts angelegt werden. Einzelheiten dazu finden Sie im
xref:wato_services#enforced_services[Artikel über die Services]. Eine
kleine Zahl von Regelsätzen - wie bspw. [.guihint]#Simple checks for
BIOS/Hardware errors# - finden Sie ausschließlich unter den erzwungenen
Services. Hierbei handelt es sich um Services, welche nicht durch die
Serviceerkennung entstehen, sondern von Ihnen manuell angelegt werden.


=== Benutzte Regelsätze

In jeder der vorgenannten Auflistungen von Regelsätzen - sei es in den
[.guihint]#Host monitoring rules# oder den [.guihint]#Service monitoring rules#
- können Sie über [.guihint]#Related > Used rulesets# in der Menüleiste, nur
genau die Regelsätze anzeigen lassen, in denen Sie mindestens eine Regel
definiert haben. Dies ist oft ein bequemer Einstieg, wenn Sie Anpassungen an
Ihren bestehenden Regeln vornehmen möchten. Einige der Regeln entstehen übrigens
schon beim Anlegen der {CMK}-Instanz und sind Teil der Beispielkonfiguration.
Auch diese werden hier angezeigt.


=== Wirkungslose Regeln

Monitoring ist eine komplexe Sache.
Da kann es schon mal vorkommen, dass es Regeln gibt, welche auf keinen einzigen
Host oder Service matchen -- entweder, weil Sie einen Fehler gemacht haben oder
weil die passenden Hosts und Services verschwunden sind. Solche wirkungslosen
Regeln können Sie, in den vorgenannten Auflistungen von Regelsätzen, über
[.guihint]#Related > Ineffective rulesets# in der Menüleiste anzeigen lassen.


=== Veraltete Regelsätze

{CMK} wird ständig weiterentwickelt. Gelegentlich werden dabei Dinge
vereinheitlicht und es kommt dazu, dass manche Regelsätze durch andere
ersetzt werden. Wenn Sie solche Regelsätze im Einsatz haben, finden Sie diese am
einfachsten durch eine Regelsuche. Öffnen Sie diese über [.guihint]#Setup > General > Rule search# in der Navigationsleiste. Klicken Sie anschließend in der
Menüleiste auf [.guihint]#Rules > Refine search#, wählen Sie hinter [.guihint]#Deprecated#
die Option [.guihint]#Search for deprecated rulesets# und hinter [.guihint]#Used# die Option [.guihint]#Search for rulesets that have rules configured#. Nach einem
weiteren Klick auf [.guihint]#Search# bekommen Sie die gewünschte Übersicht.

image::wato_rules_search_deprecated_rules.png[alt="Eingabemaske für die Suche nach veraltetem Regelsätzen"]

[#create_rules]
== Regeln erstellen und editieren

Die folgende Abbildung zeigt den Regelsatz [.guihint]#Filesystems (used space and growth)#
mit vier konfigurierten Regeln:

image::rules_filesystem.png[]

*Neue Regeln* erzeugen Sie entweder über den Knopf [.guihint]#Create rule in folder#
oder über das icon:icon_clone[] Klonen einer bestehenden
Regel. Das Klonen erzeugt eine identische Kopie einer Regel, die Sie anschließend
mit icon:icon_edit[] bearbeiten können. Eine über den Knopf [.guihint]#Create rule in folder#
erzeugte neue Regel wird immer am Ende der Liste der Regeln erzeugt, während eine
geklonte Regel als Kopie unterhalb des Originals erzeugt wird.

Die *Reihenfolge* von Regeln können Sie mit dem Knopf
icon:icon_drag[] ändern. Die Reihenfolge ist wichtig, weil weiter oben stehende Regeln immer *Vorrang* vor späteren haben.

Die Regeln sind dabei in den *xref:wato_hosts#folder[Ordnern]* abgelegt,
in denen Sie auch die Hosts verwalten. Der Wirkungsbereich von Regeln ist
auf die Hosts eingeschränkt, die in diesem Ordner oder in seinen Unterordnern
liegen. Falls sich Regeln widersprechen, so hat immer die Regel in einem
Unterordner Vorrang. So können z.B. Benutzer, die nur für manche Ordner
xref:wato_user#wato_permissions[berechtigt] sind, für ihre Hosts Regeln anlegen, ohne
dass diese Einfluss auf den Rest des Systems haben. In den Eigenschaften
einer Regel können Sie deren Ordner ändern und sie somit „umziehen“.

=== Analyse mit der Ampel

//ML:  Hier braucht es mehr Details. Die Icons kommen gerne mehrfach vor oder bewirken auf unterschiedlichen Seiten unterschiedliche Dinge. Hier wird nicht ganz klar, dass das nur aus der Service-Konfiguration aus geht und nur mit manuell angelegten/Host-spezifischen (??) Regeln. Ansonsten sieht man zwar die Icons zum Draufklicken, kommt aber auf alles Mögliche, nur nicht auf die Ampel aus dem Screenshot. Bei einer Site, die in Betrieb ist stößt man sicherlich drauf - bei einer frisch aufgesetzten Site artet das schnell aus.

Wenn Sie einen Regelsatz über einen Host oder Service ansteuern -- also
z.B. über die Symbole icon:icon_rulesets[] oder icon:button_check_parameters[]
bei einem Host oder Service -- zeigt {CMK} Ihnen den Regelsatz im *Analysemodus:*

image::rules_filesystem_analyze.png[]

Dies bewirkt zwei Dinge: Zum einen taucht ein zweiter Knopf zum Anlegen von
Regeln auf -- hier im Beispiel [.guihint]#Create mount point specific rule for#.
Damit können Sie eine neue Regel erzeugen, welche als Bedingung direkt den
aktuellen Host bzw. Service voreingetragen hat. So können Sie sehr einfach
direkt eine Ausnahmeregel erzeugen. Zum anderen taucht in jeder Zeile ein
Kugelsymbol auf, welches Ihnen anzeigt, ob diese Regel für den aktuellen
Host bzw. Service greift. Dabei gibt es folgende mögliche Fälle:

[cols="5,~"]
|===

|icon:icon_rulenmatch[] |Diese Regel greift nicht für den aktuellen Host oder Service.
|icon:icon_rulematch[] |Diese Regel greift und definiert Parameter.
|icon:icon_ruleimatch[] |Diese Regel greift zwar. Aber da eine Regel weiter oben auch greift und Vorrang hat, ist die  Regel wirkungslos.
|icon:icon_rulepmatch[] |Diese Regel greift. Eine Regel weiter oben hat zwar Vorrang und greift auch,  definiert aber nicht alle Parameter,  so dass mindestens ein Parameter von dieser Regel definiert wird.
|===


Der letzte Fall -- das icon:icon_rulepmatch[] partielle Matchen einer
Regel -- kann nur bei solchen Regelsätzen auftreten, in denen eine Regel
*mehrere Parameter* festlegt, welche durch Checkboxen einzeln angewählt
werden können. Hier kann theoretisch jeder einzelne der Parameter von einer
anderen Regel festgelegt werden. Dazu später mehr.


== Eigenschaften einer Regel

=== Allgemeine Optionen

Jede Regel ist in drei Blöcken aufgebaut. Alles im ersten Block [.guihint]#Rule Properties# ist optional und dient
vor allem der Dokumentation:

image::rules_props_properties.png[]

* Die [.guihint]#Description# wird in der Tabelle aller Regeln eines Regelsatzes angezeigt.
* Das Feld [.guihint]#Comment# können Sie für eine längere Beschreibung verwenden. Es erscheint nur im Editiermodus einer Regel. Über das Symbol icon:icon_insertdate[] können Sie einen Zeitstempel und Ihren Loginnamen in den Text einfügen lassen.
* Die [.guihint]#Documentation-URL# ist für einen Link auf interne Dokumentation gedacht, die Sie in einem anderen System (z.B. einer CMDB) pflegen.  Sie wird in der Regeltabelle über das Symbol icon:icon_url[] anklickbar dargestellt.
* Mit der Checkbox [.guihint]#do not apply this rule# können Sie die Regel vorübergehend abschalten. Sie wird dann in der Tabelle mit icon:icon_disabled[] dargestellt und hat keine Wirkung.

=== Die festgelegten Parameter

Der zweite Abschnitt ist bei jeder Regel anders. Folgende Abbildung zeigt einen weit verbreiteten
Typ von Regel ([.guihint]#DB2 Tablespaces#). Über Checkboxen können Sie bestimmen, welche Einzelparameter die Regel definieren
soll. Wie weiter oben beschrieben, wird von {CMK} für jeden einzelnen Parameter getrennt ermittelt,
welche Regel diesen setzt. Die Regel aus der Abbildung setzt also nur den einen Wert
und lässt alle anderen Einstellungen unbeeinflusst.

image::rules_props_value_1.png[]

Manche Regelsätze legen keinen Parameter fest, sondern entscheiden
nur, welche Hosts _drin_ sind und welche nicht. Ein Beispiel ist der
Regelsatz [.guihint]#Hosts to be monitored#, mit welchem Sie manche Hosts ganz
aus dem Monitoring entfernen können. Der Parameterbereich sieht dann so
aus:

image::rules_props_value_2.png[]

Wählen Sie hier [.guihint]#Make the outcome of the rule *positive*#, so heißt das,
dass die betroffenen Hosts in die Menge aufgenommen -- in unserem
Beispiel also gemonitort werden sollen.

[#conditions]
=== Bedingungen

Im dritten Abschnitt [.guihint]#Conditions# legen Sie fest, für welche Hosts bzw. Services die Regel
greifen soll. Dabei gibt es verschiedene Arten von Bedingungen, die alle erfüllt sein
müssen, damit die Regel greift. Die Bedingungen werden also logisch UND-verknüpft:

image::rules_props_conditions_1.png[]

==== Condition type

Hier haben Sie die Möglichkeit, neben einer normalen Bedingung auch auf
_vordefinierte Bedingungen_ ([.guihint]#Predefined Conditions#) zurückzugreifen.
Diese werden über [.guihint]#Setup > General > Predefined conditions#
verwaltet. Geben Sie hier Regelbedingungen, die Sie immer wieder
brauchen, einen festen Namen und verweisen in den Regeln einfach darauf. Sie
können sogar später den Inhalt dieser Bedingungen zentral ändern und alle Regeln
werden automatisch angepasst. In folgendem Beispiel wird die vordefinierte
Bedingung [.guihint]#No VM# ausgewählt:

image::rules_props_conditions_2.png[]

==== Folder

Mit der Bedingung [.guihint]#Folder# legen Sie fest, dass die Regel nur für Hosts gelten soll,
die in diesem Ordner (oder einem Unterordner) enthalten sind. Ist die Einstellung auf
[.guihint]#Main Directory#, so gilt diese Bedingung also für alle Hosts. Wie weiter oben beschrieben, haben
die Ordner auch einen Einfluss auf die Reihenfolge der Regeln. Regeln in tieferen Ordnern
haben immer Vorrang vor Regeln in höher liegenden.

==== Host tags

Die [.guihint]#Host tags# schränken die Regel auf solche Hosts ein, die bestimmte Hostmerkmale
haben oder nicht haben. Auch hier wird immer mit UND verknüpft. Jede weitere Host-tag-Bedingung
in einer Regel verringert also die Menge der Hosts, auf die diese wirkt.

Wenn Sie eine Regel für zwei mögliche Ausprägungen eines Merkmals gelten
lassen möchten (z.B. bei [.guihint]#Criticality# sowohl [.guihint]#Productive system# als
auch [.guihint]#Business critical#), so geht das nicht mit einer
einzelnen Regel. Sie benötigen dann eine Kopie der Regel für jede Variante.
Manchmal hilft hier aber auch die Negation. Sie können als Bedingung auch
festlegen, dass ein Merkmal *nicht* vorhanden ist (z.B. nicht [.guihint]#Testsystem#).
Eine andere Möglichkeit sind sogenannte xref:wato_rules#auxtags[Hilfsmerkmale].

Weil einige Anwender wirklich sehr viele Hostmerkmale verwenden, haben wir den
Dialog so gestaltet, dass nicht sofort alle Merkmalsgruppen angezeigt werden.
Sie müssen diese zunächst für die Regel aktivieren. Das geht so:

. Wählen Sie in der Auswahlbox eine Merkmalsgruppe.
. Klicken Sie [.guihint]#Add tag condition#. Dadurch wird darüber ein Eintrag für diese Gruppe hinzugefügt.
. Wählen Sie [.guihint]#is# oder [.guihint]#is not#.
. Wählen Sie den gewünschten Vergleichswert.

image::rules_props_hosttags.png[]

==== Labels

Auch xref:labels#[Labels] können Sie für Bedingungen in Regeln verwenden. Fügen Sie
Bedingungen mit [.guihint]#Add label condition# hinzu. Wählen Sie nun entweder [.guihint]#has#
oder [.guihint]#has not# um eine positive oder negative Bedingung zu formulieren und
geben Sie dann das Label in der gewohnten Form
_Schlüssel_`:`_Wert_ ein. Achten Sie hier bitte auf ganz exakte
Schreibung, auch was Groß-/Kleinschreibung betrifft. Sonst wird die Bedingung
nicht korrekt funktionieren.

image::rules_props_labels.png[]


==== Explicit hosts

Diese Art von Bedingung ist für Ausnahmeregeln vorgesehen. Hier können Sie einen
oder mehrere Hostnamen auflisten. Die Regel gilt dann nur für diese Hosts.
Bitte beachten Sie, dass wenn Sie [.guihint]#Explicit hosts# angekreuzt haben
und *keinen* Host eintragen, die Regel überhaupt nicht greifen wird.

Über die Option [.guihint]#Negate# können Sie eine umgekehrte Ausnahme definieren. Damit
schließen Sie bestimmte explizit genannte Hosts von der Regel aus.

image::rules_props_explicithosts_1.png[]

Wichtig: Alle hier eingetippten Hostnamen werden auf *genaue Übereinstimmung*
geprüft. Groß-/Kleinschreibung wird von {CMK} in Hostnamen grundsätzlich unterschieden!

Sie können dieses Verhalten auf xref:regexes#[reguläre Ausdrücke] umstellen,
indem Sie dem Hostnamen eine Tilde (`~`) voranstellen. In diesem Fall gilt wie
immer im [.guihint]#Setup#:

* Der Match geht auf den *Anfang* des Hostnamens.
* Der Match ignoriert Groß-/Kleinschreibung.

Punkt-Stern (`pass:[.*]`) bedeutet bei xref:regexes#[regulären Ausdrücken] eine beliebige Folge von Zeichen.
Folgendes Beispiel zeigt eine Bedingung, die auf alle Hosts matcht, deren Namen die
Zeichenfolge `my` (oder `My`, `MY`, `mY` usw.) *enthält*:

image::rules_props_explicithosts_2.png[]


==== Explicit services

Bei Regeln, die sich auf Services beziehen, gibt es als letzte
Bedingungsart noch einen Match auf den Namen des Services, bzw. bei Regeln,
die Checkparameter festlegen, auf den Namen des *Check items*. Auf was
genau gematcht wird, sehen Sie in der Beschriftung. In unserem Beispiel ist
das der Name ([.guihint]#Instance#) eines [.guihint]#Tablespaces#:

image::rules_props_explicitservices.png[]

Hier gilt grundsätzlich ein Match mit xref:regexes#[regulären Ausdrücken].
Die Folge `pass:[.*]temp` matcht alle Tablespaces, die `temp` *enthalten,* denn der Match geht immer auf den Anfang des Namens.
Das Dollarzeichen am Ende von `transfer$` steht für das Ende und erzwingt somit einen exakten Match.
Ein Tablespace mit dem Namen `transfer2` würde daher *nicht* matchen.

Bitte vergessen Sie nicht: Bei Regeln, in denen es um [.guihint]#Explicit services#
geht, benötigen Sie einen Match auf den Servicenamen (z.B. `Tablespace
transfer`). Bei Checkparameter-Regeln geht es um einen Match auf das
Item (z.B. `transfer`). Das Item ist quasi der variable Teil des
Servicenamens und legt fest, um _welchen_ Tablespace es
sich handelt.

Es gibt übrigens auch Services ohne Item. Ein Beispiel ist die
_CPU load_. Diese gibt es pro Host nur einmal, also ist kein Item
notwendig. Regeln für solche Checktypen haben folglich auch keine Bedingung
dafür.


[#matching]
== Arten der Regelauswertung

In der Einleitung in das Prinzip der Regeln haben Sie gesehen, dass immer die erste zutreffende Regel den Ergebniswert festlegt.
Das ist nicht die ganze Wahrheit.
Es gibt insgesamt drei verschiedene Arten der Auswertung:

[cols=2]
|===
|Auswertung |Verhalten

|Erste Regel |Die erste Regel, die zutrifft, legt den Wert fest. Weitere Regeln werden nicht mehr ausgewertet. Dies ist der Normalfall für Regeln, die einfache Parameter festlegen.
|Erste Regel pro Parameter |Jeder Einzelparameter wird von der ersten Regel festgelegt, bei der dieser Parameter definiert ist (Checkbox angekreuzt). Dies ist der Normalfall für alle Regeln mit Unterparametern, die mit Checkboxen aktiviert werden.
|Alle Regeln |Alle zutreffenden Regeln fügen Elemente zum Ergebnis hinzu. Dieser Typ kommt z.B. bei der Zuordnung von Hosts und Services zu Host-, Service- und Kontaktgruppen zum Einsatz.
|===

Diese Information wird bei jedem Regelsatz oben angezeigt.

image::rules_matching_strategy.png[]


[#hosttags]
== Host-Merkmale im Detail

Wie Sie gesehen haben, sind die Host-Merkmale eine wichtige Grundlage für die Definition von Regeln.
Sie sind aber auch an anderen Stellen nützlich.
Zum Beispiel gibt es in xref:views#[Views] einen Filter für Host-Merkmale.
Das Seitenleistenelement [.guihint]#Virtual host tree# kann Ihre Ordner anhand von Hostmerkmalen in einem Baum anordnen.
Und auf der Kommandozeile können Sie bei vielen Befehlen mit der Syntax `@foo` alle Hosts mit dem Tag `foo` auswählen.

Damit alles richtig Sinn ergibt, sollten Sie Ihr eigenes Schema für Host-Merkmale einrichten, welches für Ihre Umgebung optimal passt.
Aber bevor wir Ihnen zeigen, wie Sie im [.guihint]#Setup# eigene Host-Merkmale definieren können, sollten wir zunächst einige Begriffe klären.

[#auxtags]
=== Merkmalsgruppen, Checkboxtags, Themen und Hilfsmerkmale

Host-Merkmale (Englisch: _Host tags_) sind in *Gruppen* organisiert.
Dabei kann ein Host aus jeder Gruppe maximal ein Merkmal haben!
Ein gutes Beispiel für eine eigene Gruppe wäre z.B. _Datacenter_ mit den möglichen Merkmalen _DC 1_ und _DC 2_.
Damit wäre dann jeder Host genau einem der beiden Rechenzentren zugeordnet.
Möchten Sie Hosts anlegen, die in keinem der beiden Rechenzentren
stehen, so brauchen Sie eine dritte Auswahlmöglichkeit -- z.B. _Not in a datacenter_.

Manche Anwender haben versucht, die _Anwendung_, die auf einem Host läuft, in einer Merkmalsgruppe abzubilden.
Die Gruppe hieß z.B. _Anwendung_ und hatte die Ausprägungen _ORACLE_, _SAP_, _MS Exchange_, usw.
Das geht solange gut, bis der Tag kommt, an dem ein Host _zwei_ Anwendungen hat -- und der kommt gewiss!

Die richtige Lösung ist hier daher eine andere: Erzeugen Sie pro Anwendung eine eigene Merkmalsgruppe, welche nur zwei Möglichkeiten hat:
_ja_ oder _nein_. {CMK} vereinfacht dies, indem es Ihnen erlaubt,
Merkmalsgruppen mit nur einem _einzigen_ Merkmal anzulegen. Diese werden dann in der Hostmaske nicht als Auswahlfeld, sondern als Checkbox dargestellt.
Ein Ankreuzen der Checkbox setzt das Merkmal, andernfalls entfällt das Tag.
Solche Merkmalsgruppen heißen auch *Checkboxtags.*

Damit das Ganze nicht unübersichtlich wird, wenn Sie sehr viele Merkmalsgruppen haben
(z.B. weil Sie viele verschiedene Anwendungen abbilden), können Sie die Merkmalsgruppen
zu *Themen* (Englisch: _Topics_) zusammenfassen.
Alle Merkmalsgruppen des gleichen Themas sind dann

* in den Hostdetails in einem eigenen Kasten zusammengefasst und
* bei den Bedingungen der Regel über ein kleines Dreieck auf- und zuklappbar dargestellt.

Die Themen haben also „nur“ eine optische Funktion und keine Auswirkung auf die eigentliche Konfiguration.

*Hilfsmerkmale* (_Englisch: Auxiliary tags_) lösen folgendes Problem:
Stellen Sie sich vor, dass Sie eine Merkmalsgruppe _Betriebssystem_ definieren, mit
den Ausprägungen _Linux_, _AIX_, _Windows 2008_ und _Windows 2012_.
Nun möchten Sie eine Regel definieren, welche für alle Windows-Hosts gelten soll.
Das geht so überhaupt nicht, da Sie in einer Bedingung wie oben gezeigt pro Gruppe immer nur ein Tag auswählen können.

Um das Problem zu lösen, können Sie das Hilfsmerkmal _Windows_ definieren.
Dann ordnen Sie den beiden Merkmalen _Windows 2008_ und _Windows 2012_ dieses Hilfsmerkmal zu.
Ein Host, der eines der beiden Merkmale hat, erhält dann von
{CMK} _automatisch_ immer auch das Hilftstag _Windows_.
In den Regeln erscheint _Windows_ als eigenes Merkmal für die Formulierung von Bedingungen.

[#predefined_tags]
=== Vordefinierte Merkmale

//SK: Ich habe 06.12.2021 ein paar Änderungen der Übersetzung des Begriffs "Tag group" über Weblate eingekippt. Sobald die Änderung in der deutschsprachigen GUI sichtbar sind, kann dann hier auch der Verweis auf die "Tag-Gruppen" entfernt werden.

{CMK} richtet bei der Installation mehrere Merkmalsgruppen bzw. Tag-Gruppen für Sie ein:

[cols="^,^,^,m", options="header"]

|===

| Tag-Gruppe
| id
| Zweck
| Wahlmöglichkeiten

| [.guihint]#Checkmk Agent / API integrations#
| agent
| Legt fest, auf welche Art der Host Daten von seinem xref:wato_monitoringagents#[Agenten] bekommt.| cmk-agent, all-agents, special-agents, no-agent
|[.guihint]#Criticality# |criticality|Wichtigkeit (Servicelevel) des Systems. Für das Merkmal _Do not monitor this host_ wird eine  Regel mit ausgeliefert, welche die Überwachung des Hosts abschaltet. Die anderen Merkmale sind nur  Beispiele und ohne Funktion. Sie können diese aber Hosts zuweisen und dann in Regeln verwenden.|prod, critical, test, offline
|[.guihint]#Networking Segment# |networking|Verstehen Sie diese Merkmalsgruppe nur als Beispiel. Für das Merkmal _WAN (high latency)_ ist eine  Beispielregel hinterlegt, welche die Schwellwerte für PING-Antwortzeiten an die längeren Laufzeiten im  WAN anpasst.|lan, wan , dmz
|[.guihint]#IP address family# |address_family|Legt fest, ob der Host per IPv4 oder IPv6 oder beidem überwacht werden soll. Diese Gruppe hat den  Status _builtin_ und kann nicht modifiziert werden. Das ist notwendig, da die Tags intern von  {CMK} bei der Konfigurationserzeugung benötigt werden.|"ip-v4-only" "ip-v6-only" "ip-v4v6" "no-ip"
|[.guihint]#SNMP# |snmp_ds |Hier wird bestimmt, ob SNMP-Daten ausgewertet werden.|"no-snmp" "snmp-v2" "snmp-v1"
|[.guihint]#Piggyback# |piggyback |Dieses Merkmal legt fest, ob und wie Huckepackdaten für entsprechende Hosts erwartet/verarbeitet werden.| "auto-piggyback" "piggyback" "no-piggyback"
|===


==== Ändern von vordefinierten Merkmalsgruppen

Theoretisch können Sie die vordefinierten Merkmalsgruppen (_predefined tag groups_) anpassen, solange diese nicht als [.guihint]#builtin# markiert sind.
Änderungen in [.guihint]#Criticality# oder [.guihint]#Network Segment# sind unkritisch.
Diese sind nur als Beispiel vorgesehen.
Die Gruppe [.guihint]#Agent Type# jedoch sollten Sie auf keinen Fall ändern oder
erweitern -- auch wenn diese nicht als [.guihint]#builtin# gekennzeichnet ist!
Die Merkmale dieser Gruppe werden intern von {CMK} referenziert.

=== Merkmalsgruppen erstellen

Das Erzeugen von eigenen Merkmalen geschieht über [.guihint]#Setup > Hosts >
Tags#. Dieses sieht bei einem frisch aufgesetzten System je nach {CMK}-Version
etwa so aus:

image::rules_hosttags_main.png[alt="Eine Liste aller eingebauten Host-Merkmalsgruppen."]

Das Anlegen einer neuen Merkmalsgruppe geschieht mit dem Knopf
icon:icon_new[alt="Symbol zum Anlegen einer neuen Merkmalsgruppe."]
[.guihint]#Add tag group# und bringt Sie zu folgenden Eingabemasken:

image::rules_hosttags_config_properties.png[]

Die *[.guihint]#Tag group ID#* wird intern als ID für die Merkmalsgruppe verwendet. Diese
muss eindeutig sein und kann später nicht geändert werden. Es gelten die üblichen
Regeln für erlaubte Zeichen (nur Buchstaben, Ziffern, Unterstrich).

Der *[.guihint]#Title#* wird überall in der GUI verwendet, wo es um die Merkmalsgruppe
geht. Da dies ein reiner Anzeigetext ist, kann er jederzeit geändert werden, ohne
dass das einen Einfluss auf die bestehende Konfiguration hat.

Das *[.guihint]#Topic#* können Sie leer lassen. Dann wird Ihre Merkmalsgruppe zusammen mit
den mitgelieferten Gruppen angezeigt. Sie können aber auch eigene Themen anlegen und damit
Ihre Merkmale übersichtlich zusammenfassen.

Am wichtigsten sind natürlich die *[.guihint]#Choices#* im nächsten Kasten.

image::rules_hosttags_config_choices.png[]

Wichtig ist, dass
auch hier die *[.guihint]#Tag ID#* jeweils eindeutig sein muss -- und zwar nicht nur
innerhalb der Gruppe, sondern über alle Gruppen hinweg!  Im Zweifelsfall
können Sie einfach mit Präfixen arbeiten, z.B. `loc_dc01` anstelle
von nur `dc01`.

Die Reihenfolge, welche Sie wie gewohnt mit dem Knopf
icon:icon_drag[] ändern können, hat nicht nur eine optische Funktion:
*Das erste Merkmal in der Liste gilt als Defaultwert*! Das bedeutet, dass
alle Hosts, die keine explizite Einstellung für diese Merkmalsgruppe haben, automatisch
auf diesen Wert gesetzt werden.

Unter *[.guihint]#Auxiliary tags#* können Sie dem Merkmal Hilfsmerkmale
zuordnen, die automatisch dem Host hinzugefügt werden sollen, wenn dieses Merkmal
gewählt ist.


=== Hilfsmerkmale erstellen

Neue Hilfsmerkmale (Auxiliary Tags) können Sie über icon:icon_aux_tag[alt="Symbol zum Anlegen von Hilfsmerkmalen."] [.guihint]#Add aux tag# erstellen. Im folgenden
Dialog vergeben Sie wieder eine unveränderliche ID und einen aussagekräftigen Titel. Wie schon
bei den Merkmalsgruppen lässt sich hier zudem ein [.guihint]#Topic# angeben.

image::rules_hosttags_auxtag_basic.png[]

Die Zuordnung/Nutzung dieser Hilfsmerkmale erfolgt dann direkt in den
Merkmalsgruppen bei den einzelnen Auswahlmöglichkeiten.


=== Löschen und Ändern von bestehenden Merkmalen und Merkmalsgruppen

Das Ändern der bestehenden Merkmalsgruppenkonfiguration mag auf den ersten Blick
wie eine einfache Operation aussehen. Das ist aber leider nicht immer so, da es
größere Auswirkungen auf Ihre bestehende Konfiguration haben kann.
Änderungen, die lediglich die Anzeige betreffen oder nur neue Auswahlen
hinzufügen, sind unproblematisch und haben keine Auswirkung auf die
bestehenden Hosts und Regeln:

* Änderung im Titel oder Thema von Merkmalen und Merkmalsgruppen
* Hinzufügen eines weiteren Merkmals zu einer Merkmalsgruppe

Alle anderen Änderungen können Auswirkungen auf bestehende Hosts oder Regeln
haben, die die betroffenen Merkmale verwenden. {CMK} verbietet dabei nicht einfach
solche Änderungen, sondern versucht für Sie, Ihre bestehende Konfiguration so
anzupassen, dass alles wieder Sinn ergibt. Was das genau bedeutet, hängt von der
Art der Operation ab.

==== Löschen von Merkmalsgruppen

Von allen Hosts wird die Information über die betroffenen Merkmale entfernt.
Falls die Merkmalsgruppe in vorhandenen Regeln als Bedingung verwendet wird,
bekommen Sie folgende Warnung:

image::rules_hosttags_delete.png[]

Sie müssen sich hier entscheiden, ob Sie aus den bestehenden Regeln die
Bedingungen entfernen möchten oder ob Sie die ganzen Regeln löschen möchten.
Beides kann sinnvoll sein und {CMK} kann nicht für Sie entscheiden, was hier
besser ist. Wenn Sie sich nicht sicher sind, sollten Sie die Regelsätze (hier in
der Warnung verlinkt) von Hand durchgehen und alle Bedingungen der betroffenen
Gruppe von Hand entfernen oder abändern.


==== Löschen von einzelnen Merkmalen

Das Löschen von Merkmalen erreichen Sie durch Editieren der Gruppe, Entfernen
des Merkmals und anschließendes Speichern. Dabei kann es zu einer ähnlichen
Warnung wie beim Entfernen einer Merkmalsgruppe kommen.

Hosts, die das betroffene Merkmal gesetzt hatten, werden automatisch auf den Defaultwert gesetzt.
Dies ist (wie oben beschrieben) stets das oberste Merkmal in der Liste.

Regeln, die eine _negative_ Bedingung auf das Merkmal haben, verlieren
einfach diese Bedingung -- ohne Rückfrage. Wenn Sie z.B. eine Regel haben
für alle Hosts, die *nicht* das Merkmal `loc_dc2` haben und Sie entfernen
das Merkmal `loc_dc2` komplett aus der Konfiguration, dann ist augenscheinlich
auch diese Bedingung überflüssig.

Falls jedoch eine _positive_ Bedingung mit dem Merkmal existiert, kommt es
wieder zu obiger Warnung und Sie müssen entscheiden, wie die Konfiguration
angepasst werden soll.


==== Umbenennen von Merkmal-IDs

Anders als bei den Merkmalsgruppen können Sie die IDs von Merkmalen tatsächlich nachträglich
ändern. Dies ist sozusagen eine Ausnahme vom {CMK}-Prinzip, nach dem IDs, wenn
einmal vergeben, unveränderlich sind. Es kann aber nützlich sein, wenn Sie z.B. einen
Datenimport von einem bestehenden System vorbereiten wollen, und sich dafür an ein
vorhandenes, unterschiedliches Tagschema anpassen müssen.

Um Merkmal-IDs umzubenennen, gehen Sie in den Editiermodus der Merkmalsgruppe und ändern Sie
dort einfach die IDs, wobei Sie *die Titel unverändert lassen.* Letzteres
ist wichtig, damit {CMK} überhaupt erkennt, dass es sich um eine Umbenennung
handelt und nicht einfach eine Merkmal-ID entfernt und eine neue hinzugefügt
wurde.

Bevor {CMK} mit der Anpassung der Konfiguration zu Werke geht, werden Sie
nochmal über die Konsequenzen aufgeklärt:

image::rules_hosttags_rename.png[]

{CMK} wird nun alle betroffenen Hosts, Folder und Regeln entsprechend anpassen.

Bitte beachten Sie, dass es trotzdem noch Situationen geben kann, in denen
Sie an anderen Stellen manuell nacharbeiten müssen. So sind z.B. Merkmal-IDs
Bestandteile von URLs, welche Views aufrufen, die nach Merkmalen filtern. {CMK} kann
diese URLs nicht für Sie anpassen. Auch Filter-Konfigurationen in Reports
und Dashboards können nicht automatisch angepasst werden. Es ist also sicher
eine gute Idee, sich über das Merkmalschema am Anfang genügend Gedanken zu
machen, so dass Sie Umbenennungen später nach Möglichkeit vermeiden können.


=== Baumansicht aus Host-Merkmalen erstellen

Hosts werden in {CMK} in der Regel in Ordnern organisiert, woraus sich eine natürliche Hierarchie ergibt.
Diese können Sie als Baumansicht am unteren Ende des Seitenleisten-Snapins [.guihint]#Tree of Folders# darstellen und von dort die Standardansicht für die pro Verzweigung gefilterten Hosts aufrufen.
Das Snapin ergänzt diesen Baum noch um Filtermöglichkeiten für Themen und Optionen für unterschiedliche Ansichten.

Eine solche Baumansicht können Sie aber auch aus xref:wato_rules#hosttags[Host-Merkmalen] erstellen und so eine „virtuelle“ Hierarchie abbilden -- und zwar über das Snapin [.guihint]#Virtual Host Tree#.
Neben den Host-Merkmalen dürfen Sie auch die Ordnerstruktur in derlei Bäume einbauen, wobei sowohl die Anzahl der virtuellen Bäume als auch der jeweiligen Verzweigungen unbeschränkt ist.

Angenommen, Sie haben für Ihre Hosts die drei Merkmalsgruppen _Ort_,
_Geräteklasse_ und _Betriebssystem_ angelegt. Dann bekommen Sie auf
der obersten Baumebene eine Auswahl der Orte zu sehen, darunter der Geräteklassen
und letztlich der Betriebssysteme. Jede Hierarchieebene bringt Sie direkt zur
Ansicht aller Hosts mit eben diesen Merkmalen.

Zum Anlegen eines Virtual Host Tree fügen Sie zunächst das Snapin über
icon:button_sidebar_add_snapin[] unten links in der Seitenleiste zu dieser hinzu.

image::rules_virtual_host_tree_snapin.png[width=42%]

Rufen Sie dann die Einstellungen über [.guihint]#Setup > General > Global
Settings > User Interface > Virtual Host Trees# auf und erstellen Sie einen
neuen Baum über [.guihint]#Create new virtual host tree configuration#.

image::rules_virtual_host_tree_new.png[]

Vergeben Sie anschließend ID und
Titel des Baums und schließen Sie optional leere Baumzweige über ein Häkchen bei
[.guihint]#Exclude empty tag choices# aus. Anschließend fügen Sie über [.guihint]#Add new element#
die gewünschten Merkmalsgruppen in der gewünschten Reihenfolge hinzu. Wenn Sie die
Ordnerhierarchie als oberste Ordnung übernehmen wollen, beginnen Sie einfach
mit [.guihint]#WATO folder tree#. Die Reihenfolge/Hierarchie können Sie freilich wie
üblich über die Anfasser nachträglich ändern.

image::rules_virtual_host_tree_settings.png[]

Speichern Sie noch und übernehmen Sie die Änderungen -- und schon liefert die
Baumstruktur etliche neue Ansichten.

image::rules_virtual_host_tree_views.png[width=42%]

//ML: Ich würde noch irgendwas hier drunter pinnen - Hinweis auf anderes Thema, Warnung, was zu Fehler oder sonstwas. Ein Bild als Abschluss sieht einfach nicht gut aus.
