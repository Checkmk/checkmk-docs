// -*- coding: utf-8 -*-
// IGNORE versionieren vollumfängliche
// TK: Die beiden gehören ins Hunspell-Wörterbuch (ich kümmer mich bei Gelegenheit drum)
include::global_attr.adoc[]
= Erweiterungen für {CMK} entwickeln
:revdate: draft
:title: Erweiterungen für {CMK} entwickeln
:description: Hier erfahren Sie, mit welchen Methoden und Programmiersprachen Sie Erweiterungen für {CMK}-Plugins entwickeln können - mit allem was dazugehört, insbesondere mit der in der Version 2.0.0 neu entwickelten Check-API.
// TK: description ist zu lang: ab „, insbesondere" abschneiden: Stimmt eh nicht mehr für diesen Artikel.

{related-start}
xref:localchecks#[Lokale Checks]
xref:wato_monitoringagents#[Monitoring-Agenten]
xref:agent_linux#[Linux überwachen]
xref:agent_windows#[Windows überwachen]
xref:snmp#[Überwachen via SNMP]
xref:wato_services#[Services verstehen und konfigurieren]
xref:cmk_commandline#[{CMK} auf der Kommandozeile]
xref:mkps#[{CMK}-Erweiterungspakete (MKPs)]
xref:simulation_mode#[Der Simulationsmodus]
{related-end}
// TK: In die Liste müssen noch die beiden neuen devels rein. Kann man dafür ein paar rausschmeissen? agent_linux, agent_windows, snmp, simulation_mode?

// TK: Allgemein: Dateiname: draft_devel_intro statt draft_intro_devel


[#intro]
== Einleitung

Irgendwann kommt jeder Anwender von {CMK} an den Punkt, an dem die link:https://checkmk.com/de/integrations[mitgelieferten Check-Plugins^] nichts passendes bereit halten, link:https://exchange.checkmk.com/[die Exchange^] nichts anbietet und andere Methoden wie die xref:mk_filestats#[Überwachung von Dateien und Ordnerinhalten], die xref:ec#[Auswertung von Log-Meldungen] oder der Aufruf lokaler Skripte mit Werkzeugen wie xref:monitoring_jobs#[`mk-job`] aus verschiedensten Gründen nicht anwendbar sind.
// TK: Der Satz ist zu lang - insbesondere als Einstieg in den Artikel.
// TK: Du erklärst gar nicht, was nichts bzw. nichts passendes ist - und warum jeder (wirklich?) Anwender an den Punkt kommt: Was sucht er denn?

Dann ist der Zeitpunkt gekommen, sich Gedanken um die Entwicklung eigener Checks und Plugins zu machen.
// TK: Bittschön mir (aber nicht nur) zuliebe: Check und Check-Plugin im ganzen Artikel begrifflich voneinander trennen - und nicht noch mit {CMK}-Plugin einen neuen Begriff einführen.
// TK: Hier gute Stelle, um die beiden einzuführen: Check zum Überprüfen von irgendwas und Zustand setzen abhängig vom Ergebnis. Check-Plugin als eine Möglichkeit der Umsetzung mit festgelegter Programmiersprache Python, Check-API, ...
Dieser Artikel soll Ihnen einen Überblick verschaffen, welche Arten von Checks wann genutzt werden können, welche Programmiersprachen zur Verfügung stehen und mit welchem Aufwand zu rechnen ist.

In manchen Fällen genügt es beispielsweise, ein Backup-Skript um wenige Zeilen zu erweitern, um Erfolg oder Misserfolg in einer gut in {CMK} darstellbaren Form auszugeben.
Da einfachere Checks in vielen Fällen mit wenig Aufwand in komplexere umgewandelt werden können, raten wir dazu, mit der einfacheren Variante zu beginnen, wenn nicht bereits zu Beginn der Entwicklung abzusehen ist, dass die Grenzen bald erreicht sind.
// TK: Hm, was willst Du mir mit dem Satz sagen? Insbesondere mit dem Nebensatz am Ende.


== Erweiterungsmöglichkeiten mit eigenen Programmen

Die folgenden Abschnitte zeigen, welche Verfahren in {CMK} möglich sind, eigene Erweiterungen zu integrieren, und wo dabei jeweils die Datenerhebung und die Auswertung erfolgt.

[#local_checks]
=== Lokale Checks

Die wahrscheinlich einfachste Art und Weise, {CMK} zu erweitern, sind xref:localchecks#[lokale Checks.]
Ein Plugin, welches vom Agentenskript des überwachten Hosts ausgeführt wird, gibt in einer Zeile Namen, Zustand und weitere Informationen aus.
// TK: Muss das Ding jetzt auch noch Plugin heissen? Hilft das beim Verständnis? Warum nicht: Ein Skript, welches vom Agenten des überwachten Hosts ...
Für lokale Checks unterstützt {CMK} die automatische xref:glossar#service_discovery[Service-Erkennung.]
Die Programmierung ist in beliebigen Sprachen möglich, ohne ein API erlernen zu müssen.

* *Ausführung:* Vollständig auf dem überwachten Host. Sie müssen selbst sicherstellen, dass gegebenenfalls auf allen Hosts, die einen lokalen Check erhalten, der passende Interpreter verfügbar ist.
* *Schwellwerte:* Ein Paar von Schwellwerten (für die Übergänge nach {WARN} respektive {CRIT}) kann von der {CMK}-Instanz verwaltet werden.
* *Metriken:* Eine Metrik pro Service ist möglich. Einheiten können nicht explizit verwaltet werden, diese werden automatisch zugewiesen oder weggelassen.

[#check_plugins_agent]
=== Native {CMK}-Plugins
// TK: Bitte nicht noch einen Plugin-Begriff. Stattdessen meinetwegen: Native Check-Plugins für {CMK}-Agenten oder Native agentenbasierte Check-Plugins
// TK: Wenn nativ der Gegenbegriff zu Nagios ist, braucht man nicht zusätzlich noch {CMK}.

xref:draft_devel_check_plugins#[Native {CMK}-Plugins] bestehen immer aus zwei Komponenten:
// TK: Hier eher: Die xref:draft_devel_check_plugins#[agentenbasierten Check-Plugins] werten vom {CMK}-Agenten gelieferte Daten aus.
Ein xref:glossar#agent_plugin[Agentenplugin] sammelt Rohdaten und filtert diese vor, wertet sie aber nicht aus.
Diese Datensammlung kann in beliebigen Programmiersprachen erfolgen.
Sehr verbreitet ist die Ausgabe als JSON-Datei oder im CSV-Format.
Sie werden aber auch viele Agentenplugins sehen, die nur rohe Linux-Systembefehle aufrufen.

Auf dem {CMK}-Server findet dann die Auswertung in einem in Python geschriebenen Plugin, welches APIs von {CMK} nutzt, statt.
// TK: Hier: Plugin > Check-Plugin
// TK: Bei Dir ist API sächlich, bei mir (im REST-API Artikel) weiblich. Aber da hast Du wohl recht: das Interface vs. die Schnittstelle
Die Ermittlung des Zustands kann dabei sehr flexibel erfolgen, so ist die Verwendung unterer und oberer Schwellwerte möglich.
Zudem können mehrere Parameter zusammen einen Status bestimmen.
// TK: Zudem können mehrere Services erzeugt werden und der Status eines Services durch mehrere Überprüfungen (hier würde dann sogar Checks passen ;-) bestimmt werden.
Des weiteren ist die Ermittlung von Trends und Einbeziehung älterer Werte möglich.
// TK: Echt? Was meinst Du?
Native {CMK}-Plugins unterstützen die automatische Erstellung von xref:glossar#label[Labels] und die xref:inventory#[HW/SW-Inventur].
// TK: {CMK}-Plugins > Check-Plugins

* *Ausführung:* Plugin zur Datensammlung in beliebiger Programmiersprache auf dem überwachten Host, weitere Auswertung durch Plugin auf dem {CMK}-Server unter Verwendung der Check-API.
* *Schwellwerte:* Beliebige Kombination von Schwellwerten für jeden Service.
* *Metriken:* Beliebig viele Metriken pro Service mit Einheiten.

[#special_agent]
=== Spezialagenten

Eine Sonderform der "echten" {CMK}-Plugins sind xref:datasource_programs#[Spezialagenten]:
// TK: Den Spezialagenten würde ich nicht als Check-Plugin Variante einführen: Da läuft doch quasi alles anders.
// TK: Linkziel heisst nicht Spezialagent: Entweder tiefer linken (datasource_programs#specialagents) oder ins Glossar.
Hier sammelt kein Agentenplugin die Rohdaten ein, sondern ein Programm, das auf dem {CMK}-Server läuft und Daten aus einer anderen Quelle abfragt und in das Agentenformat von {CMK} umwandelt.
Spezialagenten kommen beispielsweise zum Einsatz, wenn ein zu überwachendes Gerät fürs Monitoring relevante Daten als JSON oder XML über eine REST-API-Schnittstelle bereitstellt.
Beispiele von bei {CMK} mitgelieferten Spezialagenten sind die Überwachung von xref:monitoring_aws#[AWS], xref:monitoring_azure#[Azure] oder xref:monitoring_vmware#[VMware.]
// TK: Beispiele von Spezialagenten = Überwachung ist sprachlich nicht ganz sauber. Vielleicht so: ... Spezialagenten sind die Programme (oder Skripte?) zur Überwachung ...

Die Programmierung erfolgt in Python unter Nutzung eines API oder in der Variante Datenquellenprogramm in einer beliebigen Programmiersprache.
// TK: eines API > eines vom überwachten System zur Verfügung gestellten REST-API
// TK: Datenquellenprogramm fällt hier vom Himmel. Hier kannst du zumindest auf datasource_programs verlinken.
Für die auswertende Komponente gilt das für native Plugins gesagte.
// TK: Die Auswertung auf dem {CMK}-Server erfolgt so, wie im vorherigen Abschnitt zu nativen Check-Plugins beschrieben. 

* *Ausführung:* Plugin zur Datensammlung und weitere Auswertung auf dem {CMK}-Server.
// TK: Plugin > Programm/Skript
* *Schwellwerte:* Beliebige Kombination von Schwellwerten für jeden Service.
* *Metriken:* Beliebig viele Metriken pro Service mit Einheiten.

[#check_plugins_snmp]
=== SNMP-Plugins
// TK: Native Check-Plugins für SNMP oder Native SNMP-basierte Check-Plugins
// TK: Der Abschnitt sollte vor den Spezialagenten kommen.

Eine weitere Variante der nativen {CMK}-Plugins sind xref:snmp#[SNMP]-Plugins.
// TK: Eine Variante der agentenbasierten sind die xref:draft_devel_check_plugins_snmp[Check-Plugins für SNMP.]
Der Unterschied besteht hier darin, dass keine Agentensektion angefordert und ausgewertet wird, sondern bestimmte SNMP-OIDs, deren Werte dann wie oben beschrieben – auch kombiniert – weiterverarbeitet werden.
// TK: ... dass keine Agentensektion ausgewertet wird, sondern bestimmte SNMP-OIDs, die explizit vom SNMP-Agenten angefordert werden.
// TK: die kombierte Weiterverarbeitung würde ich hier weglassen, zumal nicht klar ist, was "wie oben" gemeint ist.

* *Ausführung:* Datensammlung und weitere Auswertung auf dem {CMK}-Server.
// TK: Hier durch die Formulierung die Ähnlichkeit zum anderen nativen CPI klarmachen.
* *Schwellwerte:* Beliebige Kombination von Schwellwerten für jeden Service.
* *Metriken:* Beliebig viele Metriken pro Service mit Einheiten.

Da das SNMP-Protokoll inhärent sehr ineffizient ist, raten wir, SNMP nur dann zu verwenden, wenn kein anderer Zugriff auf die Monitoring-Daten möglich ist.
Stellt ein Gerät beispielsweise dieselben Daten auch über ein REST-API zur Verfügung, sollten Sie dafür einen Spezialagenten bauen.

[#check_plugins_nagios]
=== Legacy Nagios Check-Plugins

An zwei Stellen in {CMK} finden Sie Nagios Check-Plugins:
Als xref:active_checks#[aktive Checks], um vom {CMK}-Server aus die Erreichbarkeit bestimmter Dienste zu prüfen und als MRPE-Erweiterung der xref:agent_windows#mrpe[Windows-] oder xref:agent_linux#mrpe[Linux-]Agenten, um lokal Dienste zu prüfen, die von außen nicht erreichbar sind – und für die kein lokaler Check oder ein vollwertiges {CMK}-Plugin verfügbar sind.
// TK: Der Satz ist wieder ganz schön lang: aktive Checks und MRPEs in je 1 Satz.
// TK: vollwertiges {CMK}-Plugin > natives Check-Plugin

Die Programmierung ist in beliebigen Sprachen möglich.

* *Ausführung:* Vollständig auf dem überwachten Host (via MRPE) oder vollständig auf dem {CMK}-Server (aktiver Check).
* *Schwellwerte:* Schwellwerte nur bei Verwendung als aktive Checks.
* *Metriken:* Metriken nur bei Verwendung als aktive Checks.

Wegen diverser Nachteile wie umständlicher Fehlersuche empfehlen wir die Neuimplementierung nur, wenn vollumfängliche Kompatibilität zu Nagios erforderlich ist.
Verwenden Sie in allen anderen Fällen {CMK} native Plugins oder – bei einfachen Überprüfungen – lokale Checks.
// TK: {CMK} native Plugins > native Check-Plugins
Eine ausführliche Dokumentation der Ausgabeformate finden Sie auf link:https://www.monitoring-plugins.org/[Monitoring-Plugins.org^].


== Ergänzende Artikel

=== Das Spool-Verzeichnis

{CMK} stellt noch einen weiteren Mechanismus bereit, wie Agentendaten erzeugt werden können:
Lassen Sie ein Programm direkt eine Textdatei schreiben, welche das Format der Agentenausgabe enthält.
// TK: ... direkt eine Textdatei im {CMK}-Agentenformat schreiben.
Im xref:spool_directory#[Spool-Verzeichnis] abgelegt überträgt der {CMK}-Agent den Inhalt dieser Datei mit der restlichen Agentenausgabe.

Mit dem Spool-Verzeichnis können Sie beispielsweise Backup-Skripte direkt bei Beendigung Status und Statistik für einen lokalen Check oder ein Check-Plugin schreiben lassen.
Dies erspart Umwege über die Auswertung von Log-Dateien.

Bei der Entwicklung eigener Plugins helfen Spool-Dateien, bestimmte Ausgaben Ihres Agentenplugins zu simulieren.
// TK: Plugins > Check-Plugins?

=== Der Piggyback-Mechanismus

Der xref:piggyback#[Piggyback-Mechanismus] (_piggyback_, englisch für _huckepack_) kommt dann zum Einsatz, wenn ein Host etwas über einen anderen weiß.
// TK: Wenn Du hier ins Glossar linkst, kannst Du Dir huckepack sparen.
Eine speziell formatierte Agentensektion wird dann beim Auswerten der Agentenausgabe dem betreffenden Host zugeordnet.

Bei virtuellen Maschinen wird der Piggyback-Mechanismus genutzt, um von der Virtualisierungssoftware erhobene Daten mit den Daten aus dem Monitoring von innerhalb der virtuellen Maschine zusammenzuführen.
// TK: Nebensatz ist schwer zu lesen. So? ... um die von der Virtualisierungssoftware erhobenen Daten mit den Monitoring-Daten aus der virtuellen Maschine zusammenzuführen.

=== {CMK}-Erweiterungspakete (MKPs)

Wenn Sie eigene Erweiterungen programmiert haben und diese versionieren und schließlich weitergeben wollen, haben Sie die Möglichkeit, zusammengehörige Dateien in xref:mkps#[{CMK}-Erweiterungspaketen (MKPs)] zu bündeln.
Dieses Paketformat müssen Sie auch nutzen, wenn Sie planen, Erweiterungen über link:https://exchange.checkmk.com/[die Exchange^] anzubieten.
// TK: ... wenn Sie diese Erweiterungen in der link:https://exchange.checkmk.com/[{CMK} Exchange^] anbieten wollen/hochladen wollen.


[#contribute]
== Zu {CMK} beitragen

Wenn Sie selbst Erweiterungen programmieren, raten wir zunächst dazu, diese in link:https://exchange.checkmk.com/[die Exchange^] einzureichen.
Hier bleiben Sie Maintainer und Sie können unkompliziert neue Versionen bereitstellen.
// TK: Maintainer > Eigentümer?
Da die Anforderungen an die Code-Qualität für die Exchange nicht so hoch sind wie für mit {CMK} ausgelieferte Plugins, können Sie via Exchange neue Ideen unkompliziert mit einem breiten Publikum ausprobieren.
// TK: Plugins > Check-Plugins

Sollten Sie irgendwann zum Entschluss kommen, dass Ihr Plugin fester Bestandteil von {CMK} werden soll, lesen Sie zunächst link:https://github.com/Checkmk/checkmk/blob/master/CONTRIBUTING.md[Contributing to {CMK}^].
// TK: Plugin > Check-Plugin
