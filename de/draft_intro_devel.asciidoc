// -*- coding: utf-8 -*-
// IGNORE versionieren vollumfängliche Scriptlets
// TK: Die beiden gehören ins Hunspell-Wörterbuch (ich kümmer mich bei Gelegenheit drum)
include::global_attr.adoc[]
= Erweiterungen für {CMK} entwickeln
:revdate: draft
:title: Erweiterungen für {CMK} entwickeln
:description: Hier erfahren Sie, mit welchen Methoden und Programmiersprachen Sie Erweiterungen für {CMK}-Plugins entwickeln können - mit allem was dazugehört.

{related-start}
xref:localchecks#[Lokale Checks]
xref:devel_check_plugins#[Agenten basierte Check-Plugins entwickeln]
xref:draft_devel_check_plugins_snmp#[SNMP basierte Check-Plugins entwickeln]
xref:wato_monitoringagents#[Monitoring-Agenten]
xref:snmp#[Überwachen via SNMP]
xref:wato_services#[Services verstehen und konfigurieren]
xref:cmk_commandline#[{CMK} auf der Kommandozeile]
xref:mkps#[{CMK}-Erweiterungspakete (MKPs)]
{related-end}

// TK: Allgemein: Dateiname: draft_devel_intro statt draft_intro_devel


[#intro]
== Einleitung

Mit über 2000 link:https://checkmk.com/de/integrations[mitgelieferten Check-Plugins^] und vielfältigen Methoden für die xref:mk_filestats#[Überwachung von Dateien und Ordnerinhalten], die xref:ec#[Auswertung von Log-Meldungen], sowie xref:monitoring_jobs#[Überwachung wieder kehrender Aufgaben] hat {CMK} für eine Fülle von Monitoring-Aufgaben die passende Out-of-the-Box-Lösung. Und wo es die nicht gibt, hilft die Community gerne mit in der link:https://exchange.checkmk.com/[Exchange^] bereitgestellten Eigenentwicklungen.

Dennoch kommt es immer wieder vor, dass eine Hardware zu neu ist, eine Software zu exotisch, oder eine Firmen interne Eigenentwicklung zu individuell, als dass schon jemand Bedarf für die Integration in {CMK} gesehen hätte.
Sind Sie an diesem Punkt angelangt, ist es an der Zeit, sich mit der Programmierung eigener Erweiterungen zu befassen.

Dieser Artikel zeigt eine Übersicht der zur Verfügung stehenden Möglichkeiten.

////
Irgendwann kommt jeder Anwender von {CMK} an den Punkt, an dem die link:https://checkmk.com/de/integrations[mitgelieferten Check-Plugins^] nichts passendes bereit halten, link:https://exchange.checkmk.com/[die Exchange^] nichts anbietet und andere Methoden wie die xref:mk_filestats#[Überwachung von Dateien und Ordnerinhalten], die xref:ec#[Auswertung von Log-Meldungen] oder der Aufruf lokaler Skripte mit Werkzeugen wie xref:monitoring_jobs#[`mk-job`] aus verschiedensten Gründen nicht anwendbar sind.
// TK: Der Satz ist zu lang - insbesondere als Einstieg in den Artikel.
// TK: Du erklärst gar nicht, was nichts bzw. nichts passendes ist - und warum jeder (wirklich?) Anwender an den Punkt kommt: Was sucht er denn?

Dann ist der Zeitpunkt gekommen, sich Gedanken um die Entwicklung eigener Checks und Plugins zu machen.
// TK: Bittschön mir (aber nicht nur) zuliebe: Check und Check-Plugin im ganzen Artikel begrifflich voneinander trennen - und nicht noch mit {CMK}-Plugin einen neuen Begriff einführen.
// TK: Hier gute Stelle, um die beiden einzuführen: Check zum Überprüfen von irgendwas und Zustand setzen abhängig vom Ergebnis. Check-Plugin als eine Möglichkeit der Umsetzung mit festgelegter Programmiersprache Python, Check-API, ...
Dieser Artikel soll Ihnen einen Überblick verschaffen, welche Arten von Checks wann genutzt werden können, welche Programmiersprachen zur Verfügung stehen und mit welchem Aufwand zu rechnen ist.
////

Die sind vielfältig: 
In manchen Fällen genügt es beispielsweise, ein Backup-Skript um wenige Zeilen zu erweitern, um Erfolg oder Misserfolg in einer gut in {CMK} darstellbaren Form auszugeben – damit ist die "Eigenentwicklung" mitunter in wenigen Minuten abgeschlossen.
In anderen Fällen werden Sie darauf angewiesen sein, mit umfangreichen Graphen Lastsituationen zu visualisieren – dann lohnt es sich auch, einige Stunden mehr zu investieren.

// Da einfachere Checks in vielen Fällen mit wenig Aufwand in komplexere umgewandelt werden können, raten wir dazu, mit der einfacheren Variante zu beginnen, wenn nicht bereits zu Beginn der Entwicklung abzusehen ist, dass die Grenzen bald erreicht sind.
// TK: Hm, was willst Du mir mit dem Satz sagen? Insbesondere mit dem Nebensatz am Ende.

[#definitions]
=== Begriffe

Wir verwenden in diesem und den hier verlinkten Artikeln die Begriffe _Check_ und _Check-Plugin_, dabei gilt folgende Unterscheidung:

 * Ein _Check_ ist ein in einer beliebigen Programmiersprache geschriebenes Programm, das alleine ausgeführt werden kann.
Von {CMK} aufgerufen, bestimmen Ausgaben und Rückgabewerte den Status eines Dienstes.
 * Ein _Check-Plugin_ ist in einer festgelegten Programmiersprache – bei {CMK} ist das Python – geschrieben und kann auf Grund der Verwendung von APIs nur im Kontext einer laufenden {CMK}-Instanz ausgeführt werden.

== Erweiterungsmöglichkeiten mit eigenen Programmen

Die folgenden Abschnitte zeigen, welche Verfahren in {CMK} möglich sind, eigene Erweiterungen zu integrieren, und wo dabei jeweils die Datenerhebung und die Auswertung erfolgt.

[#local_checks]
=== Lokale Checks

Die wahrscheinlich einfachste Art und Weise, {CMK} zu erweitern, sind xref:localchecks#[lokale Checks.]
Ein Programm, welches vom Agentenskript des überwachten Hosts ausgeführt wird, gibt in einer Zeile Namen, Zustand und weitere Informationen aus.
Für lokale Checks unterstützt {CMK} die automatische xref:glossar#service_discovery[Service-Erkennung.]
Die Programmierung ist in beliebigen Sprachen möglich, ohne eine API erlernen zu müssen.

* *Ausführung:* Vollständig auf dem überwachten Host. Sie müssen selbst sicherstellen, dass gegebenenfalls auf allen Hosts, die einen lokalen Check erhalten, der passende Interpreter verfügbar ist.
* *Schwellwerte:* Ein Paar von Schwellwerten (für die Übergänge nach {WARN} respektive {CRIT}) kann von der {CMK}-Instanz verwaltet werden.
* *Metriken:* Eine Metrik pro Service ist möglich. Einheiten können nicht explizit verwaltet werden, diese werden automatisch zugewiesen oder weggelassen.

[#check_plugins_agent]
=== Native agentenbasierte Check-Plugins
// TK: Bitte nicht noch einen Plugin-Begriff. Stattdessen meinetwegen: Native Check-Plugins für {CMK}-Agenten oder Native agentenbasierte Check-Plugins
// TK: Wenn nativ der Gegenbegriff zu Nagios ist, braucht man nicht zusätzlich noch {CMK}.

Die xref:draft_devel_check_plugins#[agentenbasierten Check-Plugins] werten vom {CMK}-Agenten gelieferte Daten aus.
Ein xref:glossar#agent_plugin[Agentenplugin] sammelt Rohdaten und filtert diese vor, führt aber keine Bewertung der erhobenen Daten durch.
Diese Datensammlung kann in beliebigen Programmiersprachen erfolgen.
Sehr verbreitet ist die Ausgabe als JSON-Datei oder im CSV-Format.
Sie werden aber auch viele Agentenplugins sehen, die nur rohe Linux-Systembefehle aufrufen.

Auf dem {CMK}-Server findet dann die Auswertung in einem in Python geschriebenen Check-Plugin, welches APIs von {CMK} nutzt, statt.
// TK: Bei Dir ist API sächlich, bei mir (im REST-API Artikel) weiblich. Aber da hast Du wohl recht: das Interface vs. die Schnittstelle
// MFS: Bei "Die Bakery-API" auch feminin, daher alles nachgezogen
Die Ermittlung des Zustands kann dabei sehr flexibel erfolgen, so ist die Verwendung unterer und oberer Schwellwerte möglich.
// Zudem können mehrere Parameter zusammen einen Status bestimmen.
// TK:
Zudem können mehrere Services erzeugt werden und der Status eines Services durch mehrere Überprüfungen bestimmt werden.
Des weiteren ist die Ermittlung von Trends und Einbeziehung älterer Werte möglich.
// TK: Echt? Was meinst Du?
// MFS: Es gibt einen Keystore, mit dem Du Werte speichern und später drauf zugreifen kannst, daraus kann man Trends errechnen oder bspw. einen Zustandswechsel von der Richtung eines Übergangs abhängig machen.
Native {CMK}-Plugins unterstützen die automatische Erstellung von xref:glossar#label[Labels] und die xref:inventory#[HW/SW-Inventur].
// TK: {CMK}-Plugins > Check-Plugins

* *Ausführung:* Agentenplugin zur Datensammlung in beliebiger Programmiersprache auf dem überwachten Host, weitere Auswertung durch Check-Plugin auf dem {CMK}-Server unter Verwendung der Check-API.
* *Schwellwerte:* Beliebige Kombination von Schwellwerten für jeden Service.
* *Metriken:* Beliebig viele Metriken pro Service mit Einheiten.

[#special_agent]
=== Spezialagenten

Eine Erweiterung der agentenbasierten Check-Plugins sind xref:datasource_programs#specialagents[Spezialagenten]:
// TK: Den Spezialagenten würde ich nicht als Check-Plugin Variante einführen: Da läuft doch quasi alles anders.
// MFS: Doch, ab dem Zeitpunkt, an dem die Agentensektion bereitsteht, ist die weitere Verarbeitung identisch.
Hier sammelt kein Agentenplugin die Rohdaten ein, sondern ein Programm, das auf dem {CMK}-Server läuft und Daten aus einer anderen Quelle abfragt und in das Agentenformat von {CMK} umwandelt.
Spezialagenten kommen beispielsweise zum Einsatz, wenn ein zu überwachendes Gerät fürs Monitoring relevante Daten als JSON oder XML über eine REST-API bereitstellt.
Beispiele für den Einsatz von bei {CMK} mitgelieferten Spezialagenten finden Sie in der Überwachung von xref:monitoring_aws#[AWS], xref:monitoring_azure#[Azure] oder xref:monitoring_vmware#[VMware.]
// TK: Beispiele von Spezialagenten = Überwachung ist sprachlich nicht ganz sauber. Vielleicht so: ... Spezialagenten sind die Programme (oder Skripte?) zur Überwachung ...

// Die Programmierung erfolgt in Python unter Nutzung eines API oder in der Variante xref:datasource_programs#[Datenquellenprogramm] in einer beliebigen Programmiersprache.
// TK: eines API > eines vom überwachten System zur Verfügung gestellten REST-API
// MFS: Ne, eigentlich zwei APIs, ein recht schlankes von Checkmk für Parameterübergabe und das des überwachten Gerätes:
Bei der Programmierung greifen Sie auf zwei APIs zu: Für die Konfiguration von Ports oder ähnlichem stellt {CMK} eine API bereit, das erlaubt, solche Einstellungen im Setup zu bestimmen
Für die Datenabfrage selbst verwenden Sie die REST-API der externen Quelle. 
Die Auswertung auf dem {CMK}-Server erfolgt so, wie im vorherigen Abschnitt zu nativen Check-Plugins beschrieben. 

* *Ausführung:* Programm/Skript zur Datensammlung und weitere Auswertung auf dem {CMK}-Server.
* *Schwellwerte:* Beliebige Kombination von Schwellwerten für jeden Service.
* *Metriken:* Beliebig viele Metriken pro Service mit Einheiten.

[#check_plugins_snmp]
=== Native SNMP-basierte Check-Plugins
// TK: Native Check-Plugins für SNMP oder Native SNMP-basierte Check-Plugins
// TK: Der Abschnitt sollte vor den Spezialagenten kommen.
// MFS: Sollten wir später festlegen, wenn umgehängt wird. Ich bin mir nicht sicher, welche der beiden Varianten ich bevorzuge.
// MFS: Da SNMP ineffizient ist und die Programmierung der Spezialagenten näher an den agentenbasierten Check-Plugins, tendiere ich, es so zu lassen.

// Eine Variante der nativen {CMK}-Plugins sind xref:snmp#[SNMP]-Plugins.
// TK:
Eine Variante der agentenbasierten Check-Plugins sind die xref:draft_devel_check_plugins_snmp#[Check-Plugins für SNMP.]
Der Unterschied besteht hier darin, dass keine Agentensektion angefordert und ausgewertet wird, sondern bestimmte SNMP-OIDs, 
// deren Werte dann wie oben beschrieben – auch kombiniert – weiterverarbeitet werden.
// TK: ... dass keine Agentensektion ausgewertet wird, sondern bestimmte SNMP-OIDs,
die explizit vom SNMP-Agenten angefordert werden.
// TK: die kombierte Weiterverarbeitung würde ich hier weglassen, zumal nicht klar ist, was "wie oben" gemeint ist.

* *Ausführung:* Datensammlung und weitere Auswertung auf dem {CMK}-Server.
// TK: Hier durch die Formulierung die Ähnlichkeit zum anderen nativen CPI klarmachen.
* *Schwellwerte:* Beliebige Kombination von Schwellwerten für jeden Service.
* *Metriken:* Beliebig viele Metriken pro Service mit Einheiten.

Da das SNMP-Protokoll inhärent sehr ineffizient ist, raten wir, SNMP nur dann zu verwenden, wenn kein anderer Zugriff auf die Monitoring-Daten möglich ist.
Stellt ein Gerät beispielsweise dieselben Daten auch über eine REST-API zur Verfügung, sollten Sie dafür einen Spezialagenten bauen.

[#check_plugins_nagios]
=== Legacy Nagios Check-Plugins

An zwei Stellen in {CMK} finden Sie Nagios Check-Plugins:
Als xref:active_checks#[aktive Checks], um vom {CMK}-Server aus die Erreichbarkeit bestimmter Dienste zu prüfen.
Und als MRPE-Erweiterung der xref:agent_windows#mrpe[Windows-] oder xref:agent_linux#mrpe[Linux-]Agenten, um lokal Dienste zu prüfen, die von außen nicht erreichbar sind – und für die kein lokaler Check oder ein natives Check-Plugin verfügbar sind.

Die Programmierung ist in beliebigen Sprachen möglich.

* *Ausführung:* Vollständig auf dem überwachten Host (via MRPE) oder vollständig auf dem {CMK}-Server (aktiver Check).
* *Schwellwerte:* Schwellwerte nur bei Verwendung als aktive Checks.
* *Metriken:* Metriken nur bei Verwendung als aktive Checks.

Wegen diverser Nachteile wie umständlicher Fehlersuche empfehlen wir die Neuimplementierung nur, wenn vollumfängliche Kompatibilität zu Nagios erforderlich ist.
Verwenden Sie in allen anderen Fällen native Check-Plugins oder – bei einfachen Überprüfungen – lokale Checks.
Eine ausführliche Dokumentation der Ausgabeformate finden Sie auf link:https://www.monitoring-plugins.org/[Monitoring-Plugins.org^].

[#further_readings]
== Ergänzende Artikel

[#spool_directory]
=== Das Spool-Verzeichnis

{CMK} stellt noch einen weiteren Mechanismus bereit, wie Agentendaten erzeugt werden können:
Lassen Sie ein Programm direkt eine Textdatei im {CMK}-Agentenformat schreiben.
Im xref:spool_directory#[Spool-Verzeichnis] abgelegt überträgt der {CMK}-Agent den Inhalt dieser Datei mit der restlichen Agentenausgabe.

Mit dem Spool-Verzeichnis können Sie beispielsweise Backup-Skripte direkt bei Beendigung Status und Statistik für einen lokalen Check oder ein Check-Plugin schreiben lassen.
Dies erspart Umwege über die Auswertung von Log-Dateien.

Bei der Entwicklung eigener Check-Plugins helfen Spool-Dateien, bestimmte Ausgaben Ihres Agentenplugins zu simulieren.

[#piggyback]
=== Der Piggyback-Mechanismus

Der xref:glossar#piggyback[Piggyback-Mechanismus] kommt dann zum Einsatz, wenn ein Host etwas über einen anderen weiß.
Eine speziell formatierte Agentensektion wird dann beim Auswerten der Agentenausgabe dem betreffenden Host zugeordnet.

Bei virtuellen Maschinen wird der Piggyback-Mechanismus genutzt, um von der Virtualisierungssoftware erhobene Daten mit den Daten aus dem Monitoring von innerhalb der virtuellen Maschine zusammenzuführen.
// TK: Nebensatz ist schwer zu lesen. So? ... um die von der Virtualisierungssoftware erhobenen Daten mit den Monitoring-Daten aus der virtuellen Maschine zusammenzuführen.

[#mkps]
=== {CMK}-Erweiterungspakete (MKPs)

Wenn Sie eigene Erweiterungen programmiert haben und diese versionieren und schließlich weitergeben wollen, haben Sie die Möglichkeit, zusammengehörige Dateien in xref:mkps#[{CMK}-Erweiterungspaketen (MKPs)] zu bündeln.
Dieses Paketformat müssen Sie auch nutzen,
// wenn Sie planen, Erweiterungen über link:https://exchange.checkmk.com/[die Exchange^] anzubieten.
// TK: ... 
wenn Sie diese Erweiterungen in der link:https://exchange.checkmk.com/[{CMK} Exchange^] anbieten wollen.

[#bakery_api]
=== Die Bakery-API

In vielen Fällen werden Sie Agentenplugins mit zusätzlicher Konfiguration versehen wollen oder Sie möchten in Abhängigkeit von im Setup von {CMK} vorgenommenen Einstellungen bestimmte _Installations-Scriptlets_ ausführen lassen.

Wenn Sie für die Verteilung von Agentenpaketen die xref:glossar#agent_bakery[Agentenbäckerei] verwenden, steht Ihnen mit der xref:bakery_api#[Bakery-API] eine Programmierschnittstelle zur Verfügung, mit der in {CMK} vorgenommene Einstellungen einfach den Weg auf überwachte Hosts finden.  

[#contribute]
== Zu {CMK} beitragen

Wenn Sie selbst Erweiterungen programmieren, raten wir zunächst dazu, diese in link:https://exchange.checkmk.com/[die Exchange^] einzureichen.
Hier bleiben Sie Eigentümer und Ansprechpartner und Sie können unkompliziert neue Versionen bereitstellen.
// TK: Maintainer > Eigentümer? Eigentümer und Ansprechpartner
Da die Anforderungen an die Code-Qualität für die Exchange nicht so hoch sind wie für mit {CMK} ausgelieferte Check-Plugins, können Sie via Exchange neue Ideen unkompliziert mit einem breiten Publikum ausprobieren.
// TK: Plugins > Check-Plugins

Sollten Sie irgendwann zum Entschluss kommen, dass Ihr Check-Plugin fester Bestandteil von {CMK} werden soll, lesen Sie zunächst link:https://github.com/Checkmk/checkmk/blob/master/CONTRIBUTING.md[Contributing to {CMK}^].
