// -*- coding: utf-8 -*-
include::global_attr.adoc[]
= Das Spool-Verzeichnis
:revdate: draft
:title: Das Spool-Verzeichnis - Dateiinhalte der Agentenausgabe hinzuf√ºgen
// TK: Warum hier nur Cronjobs? Besser: Das Spool-Verzeichnis - Dateiinhalte der Agentenausgabe hinzuf√ºgen
// MFS: üëç
:description: Im Spool-Verzeichnis k√∂nnen regelm√§√üig laufende Programme Informationen zu ihrem Zustand ablegen, die dann in die Agentenausgabe √ºbernommen werden.

// IGNORE OpenWRT Programmes Softlinks inhalt unpriviligierten

{related-start}
xref:wato_monitoringagents#[Monitoring-Agenten]
xref:agent_linux#[Linux √ºberwachen]
xref:agent_windows#[Windows √ºberwachen]
{related-end}

////
TK: Grunds√§tzliches:
- Wie hilft mir denn das Spool-Verzeichnis beim Problem "gro√üe Datenmengen zu lesen, um wenig Information herauszuziehen"? 
Das Herausziehen gelingt doch nur, wenn ich auf CMK-Seite auch ein Check-Plugin habe, dass diesen Job erledigt.
- M.E. sollte es deutlicher werden, dass es nicht reicht, nur neue Daten in den Agenten zu schieben, sondern dass ich mich zus√§tzlich auch um die Auswertung (=Check-Plugin) k√ºmmern muss.
- Vielleicht w√§re es zur Einordnung hilfreich, im Intro die √§hnliche Erweiterung der Agentenausgabe mittels Agentenplugin zu erw√§hnen.

MFS: Das Spool-Directory kann helfen, dass man sich das Lesen gro√üer Datenmengen erspart.
Beispielsweise indem ein Programm selbst seinen Zustand in eine Spool-Datei schreibt.
Das Beispiel mit dem Check-Plugin ist eigentlich ein sehr sch√∂nes:
Ich kann bspw. ein Script schreiben, das als asynchrones Check-Plugin durch Logdateien durchgeht und dann die Agentenausgabe liefert.
Oder ich kann mit praktisch dem gleichen Code ein Programm bauen, dass jede neu hinzugekommene Zeile einer Logdatei analysiert und dann sofort eine Spool-Datei schreibt, wenn was faul ist.
Das zweite ist viel effizienter und sogar aktueller.
////


== Einleitung

Die √úberwachung regelm√§√üig oder bei Bedarf abgearbeiteter Aufgaben, sowie dauerhaft laufender Prozesse kann beispielsweise durch die Analyse von Log- oder Statusdateien erfolgen.
Dies ist jedoch h√§ufig mit Aufwand verbunden:
Oft ist es erforderlich, gro√üe Datenmengen zu lesen, um wenig Information herauszuziehen.

Um diesen Aufwand zu reduzieren, bietet {CMK} die M√∂glichkeit, dass ein Programm Ausgaben direkt im {CMK}-Agentenformat in eine Datei schreibt.
Im sogenannten Spool-Verzeichnis (_spool directory_) abgelegt, sammelt der Agent diese Dateien und integriert ihren Inhalt in die Agentenausgabe.
Der Weg √ºber das Spool-Verzeichnis bietet sich beispielsweise an bei

- der regelm√§√üigen Analyse von Log-Dateien,
- der √úberwachung automatischer Backups,
- der Erstellung und Pr√ºfung von Nutzungsstatistiken aus einer Datenbank,
// - ‚Ä¶ Checks, deren Laufzeit extrem variiert
- der Kontrolle von Cronjobs allgemein,
- der Entwicklung eigener Checks zum Test von Beispielausgaben.

// TK: Ich hab das nach vorne gezogen, weil ich das wichtig finde. {v21} hab ich gel√∂scht  
In {CMK} wird das Spool-Verzeichnis von den Agenten der folgenden Betriebssysteme unterst√ºtzt: Windows, Linux, AIX, FreeBSD, OpenWRT und Solaris.

Damit Sie dieses Feature reibungslos nutzen k√∂nnen, sind einige Dinge zu beachten.

[#paths]
== Verzeichnispfade

Der Standardpfad des Spool-Verzeichnisses ist unter Linux und anderen Unix-Systemen `/var/lib/check_mk_agent/spool/` und unter Windows `C:\ProgramData\checkmk\agent\spool\`.
F√ºr Linux und Unix k√∂nnen Sie den Pfad des √ºbergeordneten Verzeichnisses mit der Regel [.guihint]#Agent rules > Installation paths for agent files (Linux, UNIX)# und der dort vorhandenen Option [.guihint]#Base directory for variable data (caches, state files)# anpassen.

Wenn Sie auf einem Host im Monitoring arbeiten, k√∂nnen Sie das dort konfigurierte Spool-Verzeichnis aus der Agentenausgabe herausfiltern:

[{shell}]
----
{c-user} check_mk_agent | grep SpoolDirectory
SpoolDirectory: /var/lib/check_mk_agent/spool
----

{CMK} nutzt ein einziges Spool-Verzeichnis, welches in den Standardeinstellungen `root` geh√∂rt.
Mehrere Verzeichnisse mit unterschiedlichen Eigent√ºmern sind nicht vorgesehen.
Selbstverst√§ndlich k√∂nnen Sie aber im Spool-Verzeichnis (zun√§chst leere) Dateien anlegen und einen anderen Benutzer zum Eigent√ºmer machen, der den Inhalt seiner Datei dann √ºberschreiben kann.

[#content]
== Dateinamen und -inhalt
// TK Ich hab den Inhalt umgestellt, damit erst alles zu Dateinamen kommt und zum Schluss zum Dateiinhalt.

Spool-Dateien k√∂nnen beliebige Textausgaben in den von {CMK} verarbeiteten Formaten beinhalten.
Sie werden in der im Spool-Verzeichnis vorhandenen Reihenfolge aneinander geh√§ngt.
// TK: Besser?: Sie werden in alphabetischer Reihenfolge der Dateinamen im Spool-Verzeichnis aneinander geh√§ngt.
// MFS: Alphanumerisch sollte es je nach Shell treffen‚Ä¶ Ich kann allerdings nicht ausschlie√üen, dass manche Implementierungen (jetzt oder k√ºnftig) die Inode-Reihenfolge verwenden.
// MFS: Aus diesem Grund w√ºrde ich die schwammigere Formulierung beibehalten wollen.
Die verwendete Dateiendung ist dabei egal.

Wenn Sie ein numerisches Schema zur Sortierung verwenden wollen, stellen Sie dem Dateinamen einen Unterstrich (`_`) voran, da mit Zahlen beginnende Dateinamen einer xref:agecheck[Alterspr√ºfung] dienen.
Dateien, die mit einem Punkt beginnen, werden ignoriert.

// MFS: Sollte, oder besser muss?
// TK: Da hab ich keine Antwort drauf ;-)
Um Durcheinander bei den aneinander geh√§ngten Dateiinhalten zu vermeiden, sollte

- jede Spool-Datei mit einem Sektions-Header beginnen, d.h. einer Zeile, die in `<<<` und `>>>` eingeschlossen ist -- auch wenn in der Datei nur das Format xref:glossar#local_check[lokaler Checks] verwendet wird,
- mit einem Zeilenumbruch beendet werden.

Ein lokaler Check, der sofort einen Service bereitstellt, kann demnach so aussehen:

./var/lib/check_mk_agent/spool/spooldummy.txt
[{file}]
----
<<<local>>>
0 "Spool Test Dummy" - This static service is always OK
----

Analog k√∂nnen Sie Ausgaben ablegen, die auf {CMK}-Seite ein xref:glossar.html#check_plugin[Check-Plugin] erfordern:

./var/lib/check_mk_agent/spool/poolplugin.txt
[{file}]
----
<<<waterlevels>>>
rainbarrel 376
pond 15212
pool 123732
----

[#piggyback]
=== Terminierung von Piggyback-Sektionen

Wenn Sie in einer Datei xref:glossar#piggyback[Piggyback]-Sektionen verwenden, schlie√üen Sie diese Datei mit der Zeile `<<<<>>>>` ab.
Nur so ist sichergestellt, dass bei einer m√∂glichen √Ñnderung der Auslesereihenfolge die der Piggyback-Ausgabe folgenden Ausgaben wieder dem Host selbst zugeordnet werden.

[#agecheck]
== Alterspr√ºfung vorgefundener Dateien
// Age check of files

Wenn ein Programm korrekt in seine Ausgabedatei schreiben kann, ob es erfolgreich durchgelaufen ist, oder nicht, ist alles prima.
Doch was, wenn ein Programm vor dem Schreiben auf Festplatte abbricht oder ein Fehler am Dateisystem verhindert, dass neue Dateien geschrieben werden?

F√ºr diesen Fall haben Sie die M√∂glichkeit, dem Dateinamen eine Ganzzahl vorne anzustellen, beispielsweise `600MyCronjob`.
Die Zahl wird in diesem Fall als Maximalalter der Datei in Sekunden interpretiert.
Ist die Datei √§lter, wird sie vom Agenten ignoriert und der zugeh√∂rige Service in {CMK} wechselt wegen der fehlenden Ausgabe in den Zustand {UNKNOWN}.
// TK: Hier ist nicht klar, wer ignoriert. Der Agent beim Aufsammeln? Der Zustand wechselt doch dann nur, wenn die Datei vorher schonmal √ºbertragen wurde, oder?
// MFS: Zusammenspiel besser erl√§utert.
Im Falle einer Datei `3900_hourly_cleaner.txt` ist die Zahl demnach passend gew√§hlt f√ºr einen st√ºndlich laufenden Cronjob, bei dem eine Ausf√ºhrungszeit von unter f√ºnf Minuten erwartet wird. 

[#example]
== Ein Praxisbeispiel

Nehmen wir an, Sie betreiben einen Dienst, an dem sich Nutzer an- und abmelden.
In den Logdateien des Dienstes finden Sie Zeilen der folgenden drei Arten vor:

./var/log/dummyapp.log
[{file}]
----
21/Oct/2022:12:42:09 User harrihirsch logged in from 12.34.56.78
21/Oct/2022:12:42:23 User zoezhang logged out after 10 min idle
21/Oct/2022:13:00:00 Current user count: 739
----

Die Zeile _Current user count: ‚Ä¶_ schreibt der Prozess dabei nicht nach jedem Login/Logout, sondern in festen Zeitabst√§nden.
Ist die Zahl der Zeilen in der Logdatei klein genug, um sie schnell einzulesen, k√∂nnen Sie einen xref:localchecks#[lokalen Check] programmieren.
Dieser liest jedes Mal die ganze Logdatei Zeile f√ºr Zeile und setzt immer beim Vorkommen der Zeile _Current user count: ‚Ä¶_ die Nutzerzahl auf den angezeigten Wert. 
Bei Vorkommen der Zeilen _logged in_ und _logged out_ inkrementiert oder dekrementiert er die Nutzerzahl.
Am Ende gibt Ihr Check eine Zeile √§hnlich der folgenden aus:

.Beispiel-Output
[{file}]
----
1 "Frobolator User Count" count=1023 Watch out! Limit nearly used up.
----

Mit steigender Beliebtheit Ihres Dienstes l√§uft der lokale Check immer l√§nger, so dass irgendwann auch die Ausf√ºhrung als asynchrones Agenten-Plugin nicht mehr praktikabel ist.

An dieser Stelle kommt das Spool-Verzeichnis ins Spiel.
√Ñndern Sie Ihr Programm so ab, dass es am Ende der Datei angekommen, sich nicht mit einer Ausgabe beendet, sondern zun√§chst eine Spool-Datei schreibt:

./var/lib/check_mk_agent/spool/1800_frobolator.txt
[{file}]
----
<<<local>>>
2 "Frobolator User Count" count=1200 Maximum number of users reached!
----

Ihr Programm wartet dann eine gewisse Zeitspanne ‚Äì ob wenige Sekunden oder mehrere Minuten, sollten Sie von der Frequenz neu hinzukommender Log-Eintr√§ge abh√§ngig machen.
Es wertet dann nur die neu hinzugekommenen Zeilen aus, berechnet den Zustand neu und schreibt die Spool-Datei frisch, wenn ge√§nderte Zahlen vorliegen.
Um abzufangen, dass dieses Programm auch abst√ºrzen kann, sollten Sie die Logdatei entsprechend benennen, beispielsweise `1800_frobolator.txt`, wenn 30 Minuten ohne Login/Logout auf Probleme des Dienstes oder des auswertenden Programmes hindeuten.

Anstatt √ºber das Plugin-Verzeichnis des Agenten starten Sie das Programm jetzt als _Daemon_ oder _Hintergrundprogramm_ mit den Mitteln Ihres Betriebssystems.
Achten Sie hierbei auf automatischen Neustart, wenn das Programm abst√ºrzt oder terminiert wird.
Viele Serverapplikationen bieten zudem die M√∂glichkeit, statt oder zus√§tzlich zum Schreiben normaler Logdateien, einem anderen Programm Log-Ausgaben per Pipe zu √ºbergeben.
Diesen Mechanismus f√ºr ein Auswertungsskript zu nutzen, das Spool-Dateien schreibt, bietet sich ebenfalls an.

[#pitfalls]
== Zu beachtende Feinheiten

Das Lesen von Dateien h√§lt andere Fallstricke bereit als das regelm√§√üige Starten von Prozessen durch den Agenten.
// TK: Der Vergleich zum Starten der Prozesse kommt hier ziemlich unmotiviert.
// MFS: Wer startet und wie wird gestartet, damit die Intention deutlicher wird.
Beachten Sie die folgenden Punkte f√ºr einen reibungslosen Betrieb.

[#softlinks]
=== Softlinks und benannte Pipes

// MFS: Named Pipes, denen man nur sehr langsam Daten liefert, sind ein zuverl√§ssiger Weg, den Agenten zu DoSen.
// MFS: Named Pipes, die man richtig f√ºttert, ein richtig smarter Weg, Daten nach Checkmk zu bringen. 
Im Prinzip k√∂nnen Dateien im Spool-Verzeichnis auch Softlinks oder benannte Pipes (_named pipes_) sein.
Zu beachten ist, dass hier die Alterspr√ºfung √ºber Dateinamen nicht funktioniert, weil das Alter des Softlinks oder der benannten Pipes selbst ausgewertet wird und nicht das Alter der geschriebenen Daten.
// TK: vielleicht so komplettieren?: ... und nicht das Alter der geschriebenen Daten.
// MFS: √ºbernommen
Bei benannten Pipes m√ºssen Sie zudem sicherstellen, dass der in die Pipe schreibende Prozess immer Daten nachliefert.
Werden keine Daten geliefert, wartet der {CMK}-Agent ewig und wird schlie√ülich mit Timeout abgebrochen.

Falls Sie unpriviligierten Benutzern die M√∂glichkeit geben m√ºssen, in Spool-Dateien zu schreiben, legen Sie leere Dateien f√ºr diese Benutzer an, deren Eigent√ºmerschaft Sie entsprechend setzen.
Diese Benutzer k√∂nnen dann von sich aus einen Softlink setzen oder direkt in die Spool-Datei schreiben.
// TK: Das steht schon oben im Kap. 2. Verzeichnispfade
// MFS: Lass uns das mal drin lassen, das ist ein Fallstrick, bei dem Redundanz gegen √ºberlesen hilft

[#locking]
=== Sperren und Puffern
// Locking and Buffering

Beim Schreiben l√§ngerer Programme, die mehrere Statuszeilen in eine Spool-Datei schreiben, ist die Versuchung gro√ü, die Ausgabedatei beim Start des Programms schreibend zu √∂ffnen.
Die Datei bleibt in diesem Fall aber komplett leer, bis der Schreibpuffer das erste Mal geleert und ins Ziel geschrieben wird, und sie wird unvollst√§ndig sein, bis das schreibende Programm die Datei geschlossen hat.
// MFS: Kennt wer ein sch√∂neres Wort f√ºr "geflusht"?
// TK: Vielleicht so: "bis der Schreibpuffer das erste Mal geleert wird" bzw. "bis der Puffer das erste Mal geleert und ins Ziel geschrieben wird"
// MFS: üëç
√Ñhnlich sieht es aus, wenn eine Datei f√ºr die Dauer eines l√§ngeren Schreibvorgangs exklusiv gesperrt ist.

Aus diesem Grund sollten Sie entweder die Ausgabedatei erst schreibend √∂ffnen, wenn der gesamte zu schreibende Inhalt vorliegt, oder in eine tempor√§re Datei schreiben, die Sie dann ins Spool-Verzeichnis kopieren ‚Äì respektive den Inhalt einer tempor√§ren Datei mit `cat` in eine vorhandene im Spool-Verzeichnis √ºbertragen.

[#losingcontrol]
=== Den √úberblick behalten
// MFS: Brauchen wir das? Ich finde es hilfreich, bin dr√ºber gestolpert.
// TK: Ist f√ºr mich nachvollziehbar > Ok

Ein weiteres Problem kann auftreten, wenn verschiedene Programme versuchen, in gleichnamige Dateien zu schreiben.
Bei vielen Spool-Dateien kann leicht der √úberblick verloren gehen, welches Programm eigentlich in welche Spool-Datei schreibt.
Insbesondere, wenn eine falsch formatierte Spool-Datei zur Folge hat, dass ein Teil der Agentenausgabe unbrauchbar wird, ist dies sehr √§rgerlich und kann eine Zeit raubende Suche verursachen.

Sie k√∂nnen hier Ordnung schaffen, indem Sie zu jeder Spool-Datei eine gleichnamige Datei mit vorangestelltem Punkt anlegen, die Informationen zum Job und gegebenenfalls einem Ansprechpartner enth√§lt.
Der Inhalt dieser versteckten Datei wird nicht mit √ºbertragen.
// TK: Der Inhalt dieser versteckten Datei wird nicht mit √ºbertragen.
// MFS: üëç
