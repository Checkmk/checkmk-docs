include::global_attr.adoc[]
= Services verstehen und konfigurieren
:revdate: 2021-09-22
:title: Services verstehen und konfigurieren - Elemente eines Hosts erkennen und überwachen
:description: Services bilden den Kern eines jeden überwachten Hosts. Sie werden automatisch erfasst und können umfangreich konfiguriert und strukturiert werden.

{related-start}
xref:monitoring_basics#[Grundlagen des Monitorings mit {CMK}]
xref:wato_hosts#[Verwaltung der Hosts]
xref:wato_rules#[Host- und Serviceparameter]
{related-end}

////
ML: Ein paar Bilder sind nicht getrimmt plus, dazu zwei Anmerkungen, ansonsten passt das. Bilder in en-Version nicht nochmal kommentiert.
Bilder: Viele haben abgerundete Ecken auf Weiß - hast Du Dir den seeligen Screenshot-Modus nachgebaut? Ehrenwert, aber den Aufwand kannst Du Dir sparen, die sind gestorben ;)
////

== Einleitung

Die Services sind das eigentliche Fleisch im Monitoringsystem. Jeder Einzelne
von ihnen repräsentiert ein wichtiges Rädchen in Ihrer komplexen IT-Landschaft.
Der Nutzen des ganzen Monitorings steht und fällt damit, wie treffsicher und
sinnvoll die Services konfiguriert sind. Schließlich soll das Monitoring
zuverlässig melden, wenn sich irgendwo ein Problem abzeichnet, aber auf der
anderen Seite falsche und nutzlose Benachrichtigungen unbedingt vermeiden.

[{image-left}]
image::wato_services_services_illu.png[width=300]

Bei der Konfiguration der Services zeigt {CMK} seine vielleicht größte Stärke:
Es verfügt über ein einzigartiges und sehr mächtiges System für eine
_automatische Erkennung und Konfiguration von Services._ Sie müssen mit {CMK}
nicht jeden einzelnen Service über Schablonen und Einzelzuweisungen definieren.
Denn {CMK} kann die Liste der zu überwachenden Services sehr zuverlässig
automatisch ermitteln und vor allem auch _aktuell halten._  Das spart nicht nur
sehr viel Zeit -- es macht das Monitoring auch _genauer._ Denn es stellt sicher,
dass die täglichen Änderungen im Rechenzentrum auch immer zeitnah im Monitoring
abgedeckt werden und kein wichtiger Dienst ohne Monitoring bleibt.

Die Serviceerkennung in {CMK} basiert auf einem wichtigen Grundprinzip:
der Trennung des _Was_ vom _Wie_:

* *Was* soll überwacht werden? → _Das Dateisystem `/var` auf dem Host `myserver01`_
* *Wie* soll es überwacht werden? → _Bei 90% belegtem Platz {WARN}, bei 95% {CRIT}_

Das _Was_ wird bei der Serviceerkennung automatisch ermittelt. Es
setzt sich aus dem *Hostnamen* (`myserver01`), dem
xref:wato_services#checkplugins[*Check-Plugin*] (`df:` Dateisystemcheck
unter Linux) und dem *Item* (`/var`) zusammen.  Check-Plugins, die auf
einem Host maximal einen Service erzeugen können, benötigen kein Item
(z.B. das Check-Plugin für die CPU-Ausnutzung). Das Ergebnis der Erkennung
ist eine Tabelle, die Sie sich so vorstellen können:

[cols=3]
|===
|Host |Check-Plugin |Item

|myserver01 |df |/
|myserver01 |df |/var
|myserver01 |cpu.util |
|... |... |...
|app01cz2 |hr_fs |/
|... |... |...
|===

Das _Wie_ -- also die Schwellwerte/Checkparameter für die
einzelnen Services -- wird unabhängig davon über xref:wato_rules#[Regeln]
konfiguriert. Sie können z.B. eine Regel aufstellen, dass alle Dateisysteme mit
dem Mountpunkt `/var` mit den Schwellwerten 90%/95% überwacht werden,
ohne sich dabei Gedanken machen zu müssen, auf welchen Hosts denn nun
überhaupt so ein Dateisystem existiert. Das ist es, was die Konfiguration mit
{CMK} so einfach und übersichtlich macht!

Einige wenige Services können nicht über eine automatische Erkennung eingerichtet werden.
Dazu gehören z.B. Checks, die per HTTP bestimmte Webseiten abrufen sollen.
Diese werden per Regeln angelegt; wie, erfahren Sie im Artikel über die xref:active_checks#[aktiven Checks.]


[#discovery]
== Services eines Hosts im Setup

=== Host neu aufnehmen

Nachdem Sie einen neuen Host im Setup aufgenommen haben, ist der nächste
Schritt, die Liste der Services aufzurufen. Hierbei läuft bereits das erste Mal
die Serviceerkennung für den Host. Sie können diese Liste auch jederzeit später
wieder aufrufen, um die Erkennung neu zu starten oder Anpassungen an der
Konfiguration vorzunehmen. Sie erreichen die Serviceliste auf verschiedene
Arten:

* über den Knopf icon:icon_save_to_services[] [.guihint]#Save & go to service
configuration#  in den [.guihint]#Properties of host# im Setup
* in der der Menüleiste der [.guihint]#Properties of host# über [.guihint]#Hosts
> Service configuration#
* über das Symbol icon:icon_services[] in der Liste der Hosts in einem Ordner im
Setup
* über den Eintrag icon:icon_services[] [.guihint]#Edit services# im Kontextmenü
des Services xref:wato_services#discovery_check[[.guihint]#Check_MK Discovery#] eines Hosts

Wenn der Host gerade neu aufgenommen wurde, ist noch kein Service konfiguriert
und daher erscheinen alle gefundenen Services in der Rubrik
[.guihint]#Undecided services (currently not monitored)#:

// ML: Bild zu breit, Higlight-Text 2x17 und 1x21, sollte also auf 17 und entsprechend 1275 Pixel Breite skaliert werden.

image::wato_services_first_service_discovery.png[alt="Ansicht der Services of host nach der ersten Serviceerkennung"]

Der übliche Weg ist nun einfach das Hinzufügen der Services über den Knopf
[.guihint]#Fix all#. Auf diese Weise werden zeitgleich auch alle neuen
Host-Labels mit aufgenommen. Danach ein [.guihint]#Activate changes# und schon ist
der Host samt Services im Monitoring.


[#available]
=== Fehlende Services hinzufügen

Bei einem Host, der bereits überwacht wird, sieht diese Liste anders aus.
Anstelle von [.guihint]#Undecided services (currently not monitored)# sehen Sie
[.guihint]#Monitored services#. Sollte {CMK} allerdings feststellen, dass es auf
dem Host etwas gibt, das aktuell nicht überwacht wird, aber überwacht werden
_sollte,_ dann sieht das etwa so aus:


// ML: Bild zu breit, 18 Pixel -> 1350; unten fehlt Rand in 1-facher Zeichenhöhe.

image::wato_services_adding_newly_discovered_services.png[alt="Liste von erkannten, nicht aufgenommen Services."]

Ein Klick auf icon:icon_service_to_old[] [.guihint]#Monitor undecided services#
oder auf [.guihint]#Fix all# fügt abermals alle fehlenden Services hinzu, so
dass die Überwachung wieder vollständig ist. Wenn Sie nur manche der fehlenden
Services aufnehmen möchten, können Sie in den jeweiligen Zeilen auf den Knopf
icon:icon_service_to_old[] für [.guihint]#Move to monitored services# klicken.


=== Verschwundene Services

Im Rechenzentrum können Dinge nicht nur neu auftauchen, sondern auch verschwinden.
Eine Datenbankinstanz wird abgeschafft, eine LUN ausgehängt, ein Dateisystem entfernt
u.s.w. {CMK} erkennt solche Services dann automatisch als verschwunden _(vanished)._
In der Serviceliste sieht das z.B. so aus:

// ML: Bild zu schmal: Laut Text gehts um "vanished" -> 31px -> 2325px (Oder vanished aus dem Fließtext - für den Servicenamen "Interface" passt die Breite)

image::wato_services_vanished_services.png[alt="Listeneintrag eines verschwundenen Services."]

Der einfachste Weg um diese Services loszuwerden ist erneut ein Klick auf
[.guihint]#Fix all#. Alternativ können Sie die verschwundenen Services auch über den
Knopf icon:icon_service_to_removed[] [.guihint]#Remove vanished services#
entfernen. *Achtung:* Der Grund für das Verschwinden kann durchaus auch ein
Problem sein! Das Verschwinden eines Dateisystems kann ja auch bedeuten, dass
dieses aufgrund eines Fehlers nicht gemounted werden konnte. Und für solche
Fälle ist das Monitoring schließlich da! Sie sollten den Service also nur dann
entfernen, wenn Sie wissen, dass hier eine Überwachung auch wirklich keinen Sinn
mehr macht.


=== Ungewünschte Services loswerden

Nicht alles, was {CMK} findet, möchten Sie auch unbedingt überwachen. Zwar arbeitet
die Erkennung durchaus zielgerichtet und kann schon viel Unnützes im Vorfeld ausschließen.
Doch woher soll {CMK} z.B. wissen, dass eine bestimmte Datenbankinstanz nur
zum „Herumspielen“ eingerichtet wurde und nicht produktiv ist?
Sie können solche Services auf zwei Arten loswerden:

==== Vorübergehendes Abschalten von Services

Um bestimmte Services vorübergehendes aus der Überwachung zu entfernen, klicken
Sie entweder auf das Symbol icon:icon_service_to_undecided[]. Hiermit wird der
Service wieder in die Liste der [.guihint]#Undecided services# verschoben. Oder
Sie deaktivieren den Service gänzlich, indem Sie am Anfang der Zeile auf
icon:icon_move_to_disabled[] klicken. Und natürlich, wie immer
[.guihint]#Activate changes# nicht vergessen{nbsp}...

//SK: Argh... unter Show more gibt es natürlich auch wieder alle anderen Möglichkeiten.

Das Ganze ist allerdings nur für vorübergehende und kleinere Maßnahmen gedacht. Denn
die so abgewählten Services werden von {CMK} dann wieder als [.guihint]#missing# angemahnt.
Und der xref:wato_services#discovery_check[Discovery Check] (den wir Ihnen weiter unten zeigen)
wird ebenfalls nicht glücklich damit sein.
Außerdem ist das in einer Umgebung mit ein paar zigtausend Services einfach zu viel
Arbeit und nicht wirklich praktikabel{nbsp}...


[#disabled_services]
==== Permanentes Abschalten von Services

Viel eleganter und dauerhafter ist das permanente Ignorieren von Services mit
Hilfe des xref:wato_rules#[Regelsatzes] [.guihint]#Disabled services#. Hier
können Sie nicht nur einzelne Services vom Monitoring ausschließen, sondern
Regeln wie „Auf dem Host [.guihint]#myserver01# sollen keine Services überwacht
werden, die mit _myservice_ beginnen.“ formulieren.

Sie erreichen die Regel über [.guihint]#Setup > Services > Discovery rules >
Discovery and Checkmk settings > Disabled Services#.

// ML: Bild zu schmal (31px -> 2325px) und unten fehlt Rand

image::wato_services_disabled_services_conditions.png[alt="Eingabemaske für Discovery-Bedinungen."]

Wenn Sie die Regel speichern und erneut auf die Serviceliste des Hosts gehen,
finden Sie die stillgelegten Services gemeinsam mit manuell deaktivierten
Services unter [.guihint]#Disabled Services.#

image::wato_services_disabled_services.png[alt="Liste mit Services mit unterschiedlichen Status."]


[#refresh]
=== Services auffrischen

Es gibt einige Check-Plugins, die sich während der Erkennung Dinge
_merken._  So merkt sich z.B. das Plugin für Netzwerkinterfaces die
Geschwindigkeit, auf die das Interface während der Erkennung eingestellt
war. Warum? Um Sie zu warnen, falls sich diese ändert! Es ist selten ein
gutes Zeichen, wenn ein Interface mal auf 10MBit, mal auf 1GBit eingestellt
ist -- eher ein Hinweis auf eine fehlerhafte Autonegotiation.

Was aber, wenn diese Änderung gewollt ist und von nun an als OK gelten soll?
Entfernen Sie entweder den Service über das Symbol
icon:icon_service_to_undecided[] für [.guihint]#Move to undecided services# und
fügen Sie Ihn anschließend wieder hinzu. Dazu müssen Sie nach dem Entfernen
einmal speichern. Oder Sie frischen _alle_ Services des Host auf, indem Sie in
der Menüleiste auf [.guihint]#Actions > Remove all and find new# klicken. Das
ist natürlich viel bequemer -- geht aber nur, wenn Sie nicht einzelne Services
im Fehlerzustand behalten wollen.

[#update_labels]
=== Host-Labels aktualisieren

Über die Menüleiste haben Sie über [.guihint]#Actions > Host labels > Update
host labels# auch die Möglichkeit nur die Liste der zugehörigen Host-Labels zu
aktualisieren.

[#snmp]
=== Besonderheiten bei SNMP

Bei Geräten, die per SNMP überwacht werden, gibt es ein paar Sonderheiten.
Diese erfahren Sie im xref:snmp#services[Artikel über SNMP.]


[#bulk_discovery]
== Serviceerkennung für viele Hosts gleichzeitig

Wenn Sie die Erkennung für mehrere Hosts auf einmal machen wollen, können Sie
sich die Arbeit mit xref:wato_hosts#bulk_operations[Bulkoperationen] von
{CMK} erleichtern. Wählen Sie zunächst aus, auf welchen Hosts die Erkennung
durchgeführt werden soll. Dazu haben Sie mehrere Möglichkeiten:

. In einem Ordner die Checkboxen bei einzelnen Hosts ankreuzen und dann in der
Menüleiste auf [.guihint]#Hosts > On selected hosts > Discover services#
drücken.
. Mit der xref:wato_hosts#search[Hostsuche] Hosts suchen, alle gefunden mit
einem Klick auf das Kreuz icon:button_select_all[] auswählen und wieder in der
Menüleiste über [.guihint]#Hosts > On selected hosts > Discover services# gehen.
. In einem Ordner in der Menüleiste auf [.guihint]#Hosts > *In this folder* >
Discover services# klicken.

Bei der dritten Variante können Sie die Serviceerkennung auch rekursiv in allen
Unterordnern ausführen lassen. In allen drei Fällen gelangen Sie im nächsten
Schritt zu folgendem Dialog:

image::wato_services_bulk_discovery.png[alt="Eingabemaske für Optionen der Serviceerkennung."]

Im [.guihint]#Mode# finden Sie genau die verschiedenen Möglichkeiten, die Sie
auch in der Serviceliste im Setup haben und die wir schon weiter oben erläutert
haben.

image::wato_rules_bulk_discovery_modes.png[width=73%, alt="Liste mit Optionen für die Servicerkennung."]

Unter [.guihint]#Selection# können Sie die Auswahl der Hosts noch mal steuern. Das ist vor
allem dann sinnvoll, wenn Sie diese nicht per Checkboxen, sondern über den Ordner
ausgewählt haben. Die meisten Optionen zielen auf eine Beschleunigung der Discovery
hin:

// ML: icon_inventory_failed-Icon: Konnte das nicht nachstellen, weiß nicht, ob das richtig ist (rein namentlich passt es nicht ...).

[cols=2]
|===
|[.guihint]#Include all subfolders#|Wenn Sie die Serviceerkennung für einen
Order gestartet haben, dann ist diese Option überhaupt nur verfügbar und
standardmäßig aktiv. Die Serviceerkennung wird dann auch bei allen Hosts in den
Unterordnern des aktuell geöffneten Ordners durchgeführt.
|[.guihint]#Only include hosts that failed on previous discovery# |Hosts, bei denen eine frühere Serviceerkennung per Bulkoperation fehlgeschlagen ist (z.B. weil der Host zu dem Zeitpunkt nicht erreichbar war), werden von {CMK} mit dem Symbol icon:icon_inventory_failed[] markiert. Diese Option erlaubt, die Erkennung nur genau für diese Hosts zu wiederholen.
|[.guihint]#Only include hosts with a failed discovery check# |Dies schränkt die Erkennung auf solche Hosts ein, bei denen der xref:wato_services#discovery_check[Discovery Check] angeschlagen hat. Wenn Sie mit dem Discovery Check arbeiten, ist das eine gute Methode, um das Discovery von vielen Hosts massiv zu beschleunigen. Die Kombination mit der Option [.guihint]#Refresh all services (tabula rasa)# macht hier allerdings weniger Sinn, da dies den Status von bestehenden Services verfälschen kann.
|[.guihint]#Exclude hosts where the agent is unreachable# |Hosts, die nicht erreichbar sind, verursachen beim Discovery Wartezeiten durch Verbindungstimeouts. Dies kann das Discovery einer größeren Zahl von Hosts stark verlangsamen. Wenn die Hosts aber schon im Monitoring sind und dieses weiß, dass die Hosts {DOWN} sind, können Sie diese hiermit überspringen und die Timeouts somit vermeiden.
|===

Die [.guihint]#Performance options# sind so voreingestellt, dass immer ein
vollständiger Service-Scan durchgeführt wird. Wenn Sie nicht auf neue Plugins
aus sind, können Sie die Erkennung durch Wegnahme der Option beschleunigen.
////
Das Arbeiten ohne Cachedateien ist nur in Ausnahmefällen ratsam. Insbesondere bei
Hosts, die per {CMK}-Agent überwacht werden, kann es dann sogar dazu kommen,
dass, wenn es der Zufall will, neue Logmeldungen quasi von der Discovery
„verbraucht“ werden und nicht mehr beim eigentlichen Check ankommen.
////
Die eingestellte `10` unter [.guihint]#Number of hosts to handle at once#
bedeutet, dass immer zehn Hosts auf ein mal bearbeitet werden. Intern geschieht
das mit einem HTTP-Request. Sollten Sie Probleme mit Timeouts haben, weil
einzelne Hosts sehr lange zum Discovern brauchen, können Sie versuchen,
diese Zahl kleiner einzustellen (zulasten der Gesamtdauer).

Sobald Sie den Dialog bestätigen, geht es los und Sie können den Fortschritt
beobachten:

image::wato_services_bulk_discovery_progress.png[alt="Status der laufenden Serviceerkennung."]


[#parameters]
== Checkparameter von Services

Viele der Check-Plugins können über Parameter konfiguriert werden.
Die häufigste Anwendung ist das Setzen von Schwellwerten für
{WARN} und {CRIT}. Parameter können aber auch deutlich komplexer aufgebaut sein,
wie das Beispiel der Temperaturüberwachung mit {CMK} zeigt:

image::wato_services_example_check_parameters_temperature_levels.png[]

Die Checkparameter für einen Service werden in drei Schritten
gebildet:

. Jedes Plugin hat Standardwerte für die Parameter.
. Manche Plugins setzen Werte während der Erkennung (siehe xref:wato_services#refresh[oben]).
. Parameter können über Regeln gesetzt werden.

Dabei haben Parameter aus Regeln Vorrang vor den bei der Erkennung gesetzten
und diese wiederum Vorrang für den Defaultwerten. Bei komplexen Parametern,
bei denen per Checkbox einzelne Unterparameter festgelegt werden (wie im
Beispiel mit der Temperatur), gilt diese Vorrangregel für jeden einzelnen
Unterparameter separat. Wenn Sie also per Regel nur einen der Unterparameter
anpassen, bleiben die anderen auf ihren jeweiligen Defaultwerten.
So können Sie z.B mit einer Regel die Trendberechnung der Temperatur aktivieren
und mit einer anderen die Temperaturschwellwerte für einen konkreten Sensor einstellen.
Der komplette Parametersatz wird dann aus beiden Regeln zusammengesetzt.

Welche Parameter ein Service am Ende genau hat, erfahren Sie in der
Parameterseite des Services. Diese erreichen Sie in der Serviceliste eines Hosts
über das Symbol für die Check-Parameter icon:icon_check_parameters[]. Wenn Sie
die Parameter von allen Services direkt in der Servicetabelle sehen möchten,
können Sie diese mit über die Menüleiste [.guihint]#Display > Details > Show
check parameters# einblenden. Das sieht dann etwa so aus:

image::wato_services_check_parameters.png[]


== Anpassen der Serviceerkennung

Wie Sie die Serviceerkennung konfigurieren, um nicht erwünschte Services auszublenden,
haben wir bereits xref:wato_services#disabled_services[weiter oben] gezeigt. Es gibt aber
für etliche Check-Plugins noch weitere Regelsätze, die das Verhalten der Discovery bei diesen
Plugins beeinflussen. Dabei gibt es nicht nur Einstellungen zum _Weglassen_ von
Items, sondern auch solche, die positiv Items finden oder zu Gruppen zusammenfassen.
Auch die Benennung von Items ist manchmal ein Thema -- z.B. bei den Switchports, wo
Sie sich entscheiden können, anstelle der Interface-ID dessen Description oder Alias
als Item (und damit im Servicenamen) zu verwenden.

Alle Regelsätze, die mit der Serviceerkennung zu tun haben, finden Sie unter
[.guihint]#icon:icon_main_setup_dark[] Setup > Services > Discovery rules#.
Bitte verwechseln Sie diese Regelsätze nicht mit denen, die zum Parametrieren
der eigentlichen Services gedacht sind. Etliche Plugins haben in der Tat zwei
Regelsätze -- einen für die Erkennung und einen für die Parameter. Dazu gleich
ein paar Beispiele.


[#processes]
=== Überwachung von Prozessen

Es wäre wenig sinnvoll, wenn {CMK} einfach für jeden Prozess,
den es auf einem Host findet, einen Service für die Überwachung einrichten
würde. Die meisten Prozesse sind entweder nicht interessant oder sogar
nur vorübergehend vorhanden. Und auf einem normalen Linux-Server laufen
mindestens hunderte von Prozessen.

Zum Überwachen von Prozessen müssen Sie daher mit
xref:wato_services#enforced_services[erzwungenen Services] arbeiten oder -- und
das ist viel eleganter -- der Serviceerkennung mit dem Regelsatz
[.guihint]#Process discovery# sagen, nach welchen Prozessen sie Ausschau halten
soll. So können Sie immer dann, wenn auf einem Host _bestimmte interessante_
Prozesse gefunden werden, dafür automatisch eine Überwachung einrichten lassen.

Folgende Abbildung zeigt eine Regel im Regelsatz [.guihint]#Process discovery#,
welche nach Prozessen sucht, die das Programm `/usr/sbin/apache2`
ausführen.  In diesem Beispiel wird für jeden unterschiedlichen
Betriebssystembenutzer, für den ein solcher Prozess gefunden wird,
ein Service erzeugt ([.guihint]#Grab user from found processes#). Der Name des Services
wird `Apache %u`, wobei das `%u` durch den Benutzernamen ersetzt
wird. Als Schwellwerte für die Anzahl der Prozessinstanzen werden 1/1 (untere)
bzw. 30/60 (obere) verwendet:

image::wato_services_process_discovery.png[]

Bitte beachten Sie, dass die festgelegten Schwellwerte [.guihint]#Default
parameters for detected services# heißen. Denn Sie können diese -- wie bei allen
anderen Services auch -- per Regel überdefinieren. Zur Erinnerung: Obige Regel
konfiguriert die _Erkennung_ der Services -- also das _Was._ Sind die Services
erst mal vorhanden, so ist eigentlich die Regelkette [.guihint]#State and count
of processes# für die Schwellwerte zuständig.

Die Tatsache, dass Sie schon bei der Erkennung Schwellwerte festlegen können,
ist nur der Bequemlichkeit geschuldet. Und es gibt auch einen Haken: Änderung in
der Erkennungsregel haben erst bei der _nächsten Erkennung_ Einfluss. Wenn Sie
also Schwellwerte ändern, müssen Sie die Erkennung nochmal ausführen. Wenn Sie
aber die Regel nur zum eigentlichen Finden verwenden (also das _Was_), und den
Regelsatz [.guihint]#State and count of processes# für das _Wie_ verwenden,
haben Sie dieses Problem nicht.

Um bestimmte oder einzelne Prozesse auf einem Windows-Host zu überwachen, muss
im Feld [.guihint]#Executable# tatsächlich nur der Dateiname ohne Pfad angegeben
werden. In Windows finden Sie diese Namen im Reiter Details des Windows Task
Managers. In der Regel [.guihint]#Process discovery# könnte das für den Prozess
svchost dann wie folgt aussehen:

image::wato_services_process_discovery_windows.png[]

Weitere Details zur Prozesserkennung finden Sie über in der Inline-Hilfe dieses
Regelsatzes. Diese aktivieren Sie wie immer über [.guihint]#Help > Show inline
help# in der Menüleiste.


=== Überwachung von Windows-Diensten

Das Erkennen und Parametrieren der Überwachung von Windows-Services geht analog
zu den Prozessen und wird über die Regelsätze [.guihint]#Windows service discovery# _(Was)_
bzw. [.guihint]#Windows services# _(Wie)_ gesteuert. Hier ist ein Beispiel für eine
Regel, die nach zwei Diensten Ausschau hält:

image::wato_services_windows_service_discovery.png[]

Genau wie bei den Prozessen ist auch hier die Serviceerkennung nur eine Option.
Wenn Sie anhand von Hostmerkmalen und Ordnern präzise Regeln formulieren
können, auf welchen Hosts bestimmte Dienste erwartet werden, können Sie
auch mit xref:wato_services#enforced_services[erzwungenen Services]
arbeiten. Das ist dann unabhängig von der tatsächlich vorgefundenen Situation --
allerdings kann das deutlich mehr Aufwand sein, da Sie unter Umständen viele
Regeln brauchen, um genau abzubilden, auf welchem Host welche Dienste erwartet
werden.


[#switches]
=== Überwachung von Switchports

{CMK} verwendet für die Überwachung von Netzwerkschnittstellen von Servern und
für die Ports von Ethernetswitchen die gleiche Logik. Vor allem bei den
Switchports sind die vorhandenen Optionen für die Steuerung der Serviceerkennung
interessant, auch wenn (im Gegensatz zu den Prozessen und Windows-Diensten) die
Erkennung auch erst mal ohne Regel funktioniert. Per Default überwacht {CMK}
nämlich automatisch alle physikalischen Ports, die gerade den Zustand {UP} haben.
Der Regelsatz dazu heißt [.guihint]#Network interface and switch port discovery#
und bietet zahlreiche Einstellmöglichkeiten, die hier nur gekürzt dargestellt
sind:

image::wato_services_network_interface_switch_port_discovery.png[]

Am wichtigsten sind folgende Möglichkeiten:

* Im Abschnitt [.guihint]#Appearance of network interface# können Sie bestimmen, wie das Interface im Servicenamen erscheinen soll. Sie haben hier die Wahl zwischen [.guihint]#Use description#, [.guihint]#Use alias# und [.guihint]#Use index#.
* [.guihint]#Match port types# ermöglicht das Einschränken oder _Ausweiten_ der überwachten Interfacetypen oder -namen.

[#manual_checks]
[#enforced_services]
== Einrichtung von Services erzwingen

Es gibt einige Situationen, in denen eine automatische Serviceerkennung
nicht sinnvoll ist. Das ist immer dann der Fall, wenn Sie das Einhalten
einer bestimmte _Richtlinie_ erzwingen möchten. Wie Sie im vorherigen
Kapitel gesehen haben, können Sie Überwachung von Windows-Diensten automatisch
einrichten lassen, wenn diese gefunden werden. Was ist aber, wenn schon das
Fehlen eines solchen Diensts ein Problem darstellt? Beispiele:

* Auf jedem Windows-Host soll ein bestimmter Virenscanner installiert sein.
* Auf jedem Linux-Host soll NTP konfiguriert sein.

In solchen Fällen können Sie das Anlegen von Services erzwingen. Den
Einstiegspunkt dafür finden Sie unter sind die [.guihint]#Setup > Services >
Enforced services#. Dahinter verbirgt sich eine Sammlung von
xref:wato_rules#[Regelsätzen], welche exakt die gleichen Namen haben, wie
diejenigen Regelsätze, mit denen auch Parameter für diese Checks konfiguriert
werden.

Die Regeln unterscheiden sich jedoch in zwei Punkten:

* Es sind Regeln für _Hosts,_ nicht für Services. Die Services werden ja erst durch die Regeln erzeugt.
* Da keine Erkennung stattfindet, müssen Sie selbst das Check-Plugin auswählen, das für den Check verwendet werden soll.

Folgendes Beispiel zeigt den Rumpf der Regel [.guihint]#State of NTP time synchronisation# unter
[.guihint]#Enforced services#:

image::wato_services_example_enforced_services_ntp.png[]

Neben den Schwellwerten legen Sie hier auch das Check-Plugin fest
(z.B. `chrony` oder `ntp_time`).  Bei Check-Plugins, die ein
Item benötigen, müssen Sie auch dieses angeben. Dies ist z.B. beim Plugin
[.guihint]#oracle_processes# notwendig, welches die Angabe der zu überwachenden
Datenbank-SID benötigt:

image::wato_services_example_enforced_services_oracle_processes.png[]

Der so definierte manuelle Service wird auf allen Hosts angelegt, auf die
diese Regel greift. Für die eigentliche Überwachung gibt es jetzt drei Fälle:

. Der Host ist korrekt aufgesetzt und der Service geht auf {OK}.
. Der Agent liefert die Information, dass der gefragte Dienst nicht läuft oder ein Problem hat. Dann geht der Service auf {CRIT} oder auf {UNKNOWN}.
. Der Agent stellt überhaupt keine Informationen bereit, z.B. weil NTP überhaupt nicht installiert ist. Dann bleibt der Service auf {PEND} und der {CMK}-Service geht auf {WARN}, mit dem Hinweis, dass die entsprechende Sektion in den Agentendaten fehlt.

//SK: Benutzen wir das Wort "Modul" noch auf diese Weise in der 2.0.0?
// ML: Ist an einigen Stellen auch neueren Datums noch so zu lesen, insofern würde ich ja tippen.

Die meisten Regelsätze im Modul [.guihint]#Enforced services# werden Sie nie
benötigen und sind nur der Vollständigkeit halber vorhanden. Die häufigsten
Fälle für erzwungene Services sind:

* Überwachung von Windows-Diensten (Regelsatz: [.guihint]#Windows Services#)
* Überwachung von Prozessen (Regelsatz: [.guihint]#State and count of processes#)



[#discovery_check]
== Der Discovery Check

In der Einleitung haben wir versprochen, dass {CMK} die Liste der
Services nicht nur automatisch ermitteln, sondern auch _aktuell halten_
kann. Natürlich wäre dafür eine Möglichkeit, dass Sie ab und zu von Hand
eine Bulk-Erkennung über alle Hosts durchführen.

[#discovery_auto]
=== Automatisches Prüfen auf nicht überwachte Services

Viel besser ist dafür aber ein regelmäßiger [.guihint]#Discovery Check,# welcher
von {CMK} bei neuen Instanzen automatisch
eingerichtet wird. Dieser Service existiert für jeden Host und meldet
sich mit einer Warnung, wenn er nicht überwachte Dinge findet:

image::wato_services_discovery_check_warn.png[]

Die Einzelheiten zu den nicht überwachten oder verschwundenen Services
finden Sie im [.guihint]#Long output of check plugin# in den Details des Services:

// ML: Padding in einfacher Fonthöhe fehlt.
image::wato_services_discovery_check_details.png[]

Zu der Serviceliste der Hosts im Setup gelangen Sie bequem über das
icon:icon_menu[] Kontextmenü des Discovery Checks über den Eintrag
icon:icon_services[] [.guihint]#Edit services#.

Das Parametrieren des Discovery Checks geht sehr einfach über den
xref:wato_rules#[Regelsatz] [.guihint]#Periodic service discovery#. In einer
frischen Site werden Sie hier bereits eine global wirksame Regel mit den
folgenden Einstellungen vorfinden:

image::wato_services_periodic_service_discovery.png[]

Neben dem Intervall, in dem der Check laufen soll, können Sie auch noch den
Monitoringstatus, für die Fälle von nicht überwachten bzw. verschwundenen
Services und Host-Labels, auswählen.

=== Services automatisch hinzufügen

Sie können den Discovery Check fehlende Services automatisch hinzufügen lassen.
Dazu aktivieren Sie die Option [.guihint]#Automatically update service
configuration#. Nun werden weitere Optionen sichtbar.

image::wato_services_periodic_service_discovery_update_configuration.png[]

Neben dem Hinzufügen können Sie bei [.guihint]#Mode# auch auswählen,
überflüssige Services zu entfernen oder sogar alle bestehenden Services zu
entfernen und komplett neu zu erkennen ([.guihint]#Refresh#). Beide Optionen
sind mit Vorsicht zu genießen! Ein verschwundener Service kann auf ein Problem
hindeuten! Der Discovery Check wird so einen Service dann einfach entfernen und
Sie im Glauben wiegen, dass alles in Ordnung ist. Der Refresh ist besonders
gefährlich. So übernimmt z.B. der Check für Switchports nur solche Ports in das
Monitoring, die up sind. Ports mit Status down gelten dann als verschwunden und
würden vom Discovery Check ohne Rückfrage weggeräumt!

Ein weiteres Problem gilt es noch zu bedenken: Das Hinzufügen von Services oder
gar das automatische [.guihint]#Activate Changes# kann Sie als Admin bei Ihrer
Arbeit am System stören, wenn Sie gerade beim Konfigurieren sind. Es kann
theoretisch passieren, dass Sie gerade dabei sind, an Regeln und Einstellungen
zu arbeiten und just in dem Augenblick ein Discovery Check Ihre Änderungen
aktiviert. Denn in {CMK} können immer nur alle Änderungen auf einmal aktiviert
werden! Um dies zu verhindern, können Sie die Uhrzeiten, in denen so etwas
geschieht, z.B. in die Nacht legen. Die obige Abbildung zeigt dafür ein
Beispiel.

Die Einstellung [.guihint]#Group discovery and activation for up to# sorgt
dafür, dass nicht jeder einzelne Service, der neu gefunden wird, sofort ein
[.guihint]#Activate Changes# auslöst, sondern eine bestimmte Zeit gewartet wird,
um gleich mehrere Änderungen in einem Rutsch zu aktivieren. Denn selbst wenn der
Discovery Check auf ein Intervall von zwei Stunden oder mehr eingestellt ist,
gilt das nur für jeden Host separat. Die Checks laufen nicht für alle Hosts
gleichzeitig -- und das ist auch gut so, denn der Discovery Check braucht
erheblich mehr Ressourcen als ein normaler Check.


[#passive_checks]
== Passive Services

//Integrate Nagios plugins

Passive Services sind solche, die nicht von {CMK} aktiv angestoßen werden, sondern bei
denen regelmäßig von außen neue Checkergebnisse eingeschleust werden. Dies geschieht
in der Regel über die Kommandopipe des Cores. Hier ist ein Schritt-für-Schritt-Vorgehen
für das Einrichten eines passiven Services:

Zunächst müssen Sie den Service dem Kern bekannt machen.
Dies geschieht mit dem gleichen Regelsatz wie bei den xref:active_checks#nagios_plugins[eigenen aktiven Checks], nur dass Sie die [.guihint]#Command line# weglassen:

image::wato_services_passive_checks_integrate_nagios_plugins.png[]

Die Abbildung zeigt auch, wie Sie prüfen lassen können, ob regelmäßig
Checkergebnisse eingehen. Wenn dies für länger als 10 Minuten ausbleibt,
so wird der Service hier automatisch auf {UNKNOWN} gesetzt.

Nach einem [.guihint]#Activate Changes# beginnt der neue Service sein Leben im Zustand {PEND}:

image::wato_services_passive_checks_pending.png[]

////
ML: Das Senden von Befehlen per echo in eine "Kommandopipe" ist imho dermaßen unüblich, dass man da vielleicht nen Link setzen sollte, oder?
https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/3/en/extcommands.html
Zudem: Wieso taucht hier überhaupt plötzlich Nagios auf, ohne jede Erklärung? Man könnte ja meinen, CMC oder Nagios ... ist jetzt aber auch nicht wirklich ein 2.0-Problem, sofern e der tote Link von oben nicht erklärt hätte.
////

Das Senden der Checkergebnisse geschieht nun auf der Kommandozeile durch
ein `echo` des Befehls `PROCESS_SERVICE_CHECK_RESULT` in die
Kommandopipe `~/tmp/run/nagios.cmd`.

Die Syntax entspricht den bei Nagios üblichen Konventionen -- inklusive eines
aktuellen Zeitstempels in eckigen Klammern. Als Argumente nach dem Befehl
brauchen Sie den Hostnamen (z.B. `myhost`) und den gewählten
Servicenamen (im Beispiel `BAR`). Die beiden weiteren Argumente sind
wieder der Status (`0` ... `3`) und die Pluginausgabe. Den
Zeitstempel erzeugen Sie mit `$(date +%s)`:

[{shell}]
----
{c-omd} echo "[$(date +%s)] PROCESS_SERVICE_CHECK_RESULT;myhost;BAR;2;Something bad happened" > ~/tmp/run/nagios.cmd
----

Nun zeigt der Service ohne Verzögerung den neuen Status:

image::wato_services_passive_checks_crit.png[]

Wenn Sie von Nagios noch das Werkzeug _NSCA_ kennen, können Sie das auch
mit {CMK} weiterverwenden. Dazu müssen Sie zuerst eine Abhängigkeit
auflösen und das Paket libmcrypt installieren:

*Debian/Ubuntu*

[{shell}]
----
{c-root} apt-get install libmcrypt4
----

*Red Hat/CentOS*

[{shell}]
----
{c-root} yum install libmcrypt
----


*SLES*

[{shell}]
----
{c-root} zypper install libmcrypt
----

Schalten Sie anschließend den NSCA-Empfänger mittels `omd config` ein und
bearbeiten Sie nach Bedarf die Konfiguration für NSCA, welche unter
`etc/nsca/nsca.cfg` liegt:

[{shell}]
----
{c-omd} omd stop
{c-omd} omd config set NSCA on
{c-omd} omd config set NSCA_TCP_PORT 5667
{c-omd} vim etc/nsca/nsca.cfg
{c-omd} omd start
----

Das System ist dann zum Empfang von passiven Checkergebnissen via NSCA bereit.


[#commandline]
== Serviceerkennung auf der Kommandozeile

So schön eine GUI ist, so praktisch ist doch manchmal noch die gute alte Kommandozeile --
sei es zum Automatisieren oder einfach zum schnellen Arbeiten für den geübten Benutzer.
Die Serviceerkennung können Sie auf der Kommandozeile mit dem Befehl `cmk -I` auslösen.
Dabei gibt es ein paar verschiedene Spielarten. Bei allen empfehlen wir die Option `-v`,
damit Sie sehen, was genau passiert. Ohne `-v` verhält sich {CMK} nach guter alter
Unix-Tradition: Solange alles gut geht, schweigt es.

Mit einem einfachen `-I` suchen Sie auf *allen* Hosts nach neuen Services:

[{shell}]
----
{c-omd} cmk -vI
Discovering services and host labels on all hosts
myserver01:
+ FETCHING DATA
Using data from cache file /omd/sites/mysite/tmp/check_mk/cache/myserver01
[TCPFetcher] Use cached data
No piggyback files for 'myserver01'. Skip processing.
[PiggybackFetcher] Execute data source
+ PARSE FETCHER RESULTS
Received no piggyback data
+ EXECUTING HOST LABEL DISCOVERY
+ PERFORM HOST LABEL DISCOVERY
+ EXECUTING DISCOVERY PLUGINS (42)
SUCCESS - Found no new services, 2 host labels
myserver02:
+ FETCHING DATA
Using data from cache file /omd/sites/mysite/tmp/check_mk/cache/myserver02
[TCPFetcher] Use cached data
No piggyback files for 'myserver02'. Skip processing.
[PiggybackFetcher] Execute data source
+ PARSE FETCHER RESULTS
Received no piggyback data
+ EXECUTING HOST LABEL DISCOVERY
+ PERFORM HOST LABEL DISCOVERY
+ EXECUTING DISCOVERY PLUGINS (1900)
SUCCESS - Found no new services, 2 host labels
----

Sie können nach dem `-I` auch einen oder mehrere Hostnamen angeben, um nur diese zu untersuchen.
Das hat gleich noch einen zweiten Effekt. Während ein `-I` auf allen Hosts
grundsätzlich nur mit *gecachten* Daten arbeitet, holt {CMK} bei der
expliziten Angabe von einem Host immer *frische* Daten!

[{shell}]
----
{c-omd} cmk -vI myserver01
----

Alternativ können Sie über Tags filtern:

[{shell}]
----
{c-omd} cmk -vI @mytag
----

Damit würde das Discovery für alle Hosts mit dem Hostmerkmal `mytag` durchgeführt.
Filtern mit Tags steht für alle cmk-Optionen zur Verfügung, die mehrere Hosts akzeptieren.

Mit den Optionen `--cache` bzw. `--no-cache` können Sie die Verwendung
von Cache auch explizit bestimmen.

Zusätzliche Ausgaben bekommen Sie mit einem zweiten `-v`. Bei SNMP-basierten Geräten
können Sie dann sogar jede einzelne OID sehen, die vom Gerät geholt wird:

[{shell}]
----
{c-omd} cmk -vvI myswitch01
Discovering services on myswitch01:
myswitch01:
  SNMP scan:
       Getting OID .1.3.6.1.2.1.1.1.0: Executing SNMP GET of .1.3.6.1.2.1.1.1.0 on switch
=> ['24G Managed Switch'] OCTETSTR
24G Managed Switch
       Getting OID .1.3.6.1.2.1.1.2.0: Executing SNMP GET of .1.3.6.1.2.1.1.2.0 on switch
=> ['.1.3.6.1.4.1.11863.1.1.3'] OBJECTID
.1.3.6.1.4.1.11863.1.1.3
       Getting OID .1.3.6.1.4.1.231.2.10.2.1.1.0: Executing SNMP GET of .1.3.6.1.4.1.231.2.10.2.1.1.0 on switch
=> [None] NOSUCHOBJECT
failed.
       Getting OID .1.3.6.1.4.1.232.2.2.4.2.0: Executing SNMP GET of .1.3.6.1.4.1.232.2.2.4.2.0 on switch
=> [None] NOSUCHOBJECT
failed.
----

Ein komplettes Erneuern der Services (Tabula Rasa) machen Sie mit einem Doppel- `-II`:

[{shell}]
----
{c-omd} cmk -vII myserver01
Discovering services and host labels on: myserver01
myserver01:
+ FETCHING DATA
Using data from cache file /omd/sites/mysite/tmp/check_mk/cache/myserver01
[TCPFetcher] Use cached data
No piggyback files for 'myserver01'. Skip processing.
No piggyback files for '127.0.0.1'. Skip processing.
[PiggybackFetcher] Execute data source
+ PARSE FETCHER RESULTS
Received no piggyback data
+ EXECUTING HOST LABEL DISCOVERY
+ PERFORM HOST LABEL DISCOVERY
+ EXECUTING DISCOVERY PLUGINS (10)
    [green]#1# cpu.loads
    [green]#1# cpu.threads
    [green]#6# cups_queues
    [green]#3# df
    [green]#1# diskstat
    [green]#3# kernel
    [green]#1# kernel.util
    [green]#3# livestatus_status
    [green]#1# lnx_if
    [green]#1# lnx_thermal
[green]#SUCCESS# - Found 21 services, 2 host labels
----

Sie können das Ganze auch auf ein einzelnes Check-Plugin einschränken. Die Option dazu
lautet `--detect-plugins=` und muss vor dem Hostnamen stehen:

[{shell}]
----
cmk -vII --detect-plugins=df myserver01
Discovering services and host labels on: myserver01
myserver01:
+ FETCHING DATA
[TCPFetcher] Execute data source
No piggyback files for 'myserver01'. Skip processing.
No piggyback files for '127.0.0.1'. Skip processing.
[PiggybackFetcher] Execute data source
+ PARSE FETCHER RESULTS
Received no piggyback data
+ EXECUTING HOST LABEL DISCOVERY
+ PERFORM HOST LABEL DISCOVERY
+ EXECUTING DISCOVERY PLUGINS (1)
  [green]#3# df
[green]#SUCCESS# - Found 3 services, no host labels
----

Wenn Sie fertig sind, können Sie mit `cmk -O` (bei Nagios als Kern `cmk -R`)
die Änderungen aktivieren:

[{shell}]
----
{c-omd} cmk -O
Generating configuration for core (type cmc)...[green]#OK#
Creating helper config...[green]#OK#
Reloading monitoring core...[green]#OK#
----

Und wenn Sie mal bei einer Discovery auf einen Fehler stoßen{nbsp}...

[{shell}]
----
{c-omd} cmk -vII --detect-plugins=df myserver01
  [yellow]#WARNING:# Exception in discovery function of check type 'df': global name 'bar' is not defined
  nothing
----

{nbsp}&#8230; dann können Sie mit einem zusätzlichen `--debug` einen genauen Python-Stacktrace der
Fehlerstelle bekommen:

[{shell}]
----
{c-omd} cmk --debug -vII --detect-plugins=df myserver01
Discovering services and host labels on myserver01:
myserver01:
Traceback (most recent call last):
  File "/omd/sites/heute/share/check_mk/modules/check_mk.py", line 5252, in <module>
    do_discovery(hostnames, check_types, seen_I == 1)
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 76, in do_discovery
    do_discovery_for(hostname, check_types, only_new, use_caches, on_error)
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 96, in do_discovery_for
    new_items = discover_services(hostname, check_types, use_caches, do_snmp_scan, on_error)
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 677, in discover_services
    for item, paramstring in discover_check_type(hostname, ipaddress, check_type, use_caches, on_error):
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 833, in discover_check_type
    discovered_items = discovery_function(info)
  File "/omd/sites/heute/share/check_mk/checks/df", line 91, in inventory_df
    foo = bar
NameError: global name 'bar' is not defined
----


=== Optionen im Überblick

Hier noch mal alle Optionen auf einen Blick:

[cols=2]
|===

|cmk -I |Neue Services erkennen.
|cmk -II |Alle Services verwerfen und neu erkennen (Tabula Rasa).
|-v |Verbose: Hosts und gefundene Services anzeigen.
|-vv |Very verbose: genaues Protokoll von allen Operationen anzeigen.
|--detect-plugins=foo |Erkennung (und auch Tabula Rasa) nur für das gewählte Check-Plugin durchführen.
|@foo |Erkennung (und auch Tabula Rasa) nur für Hosts mit dem gewählten Hostmerkmal durchführen.
|--cache |Verwendung von Cachedateien erzwingen (sonst nur bei fehlender Hostangabe).
|--no-cache |Frische Daten holen (sonst nur bei Angabe von Hostname).
|--debug |Im Fehlerfall abbrechen und den kompletten Aufrufstapel von Python anzeigen.
|cmk -O |Änderungen aktivieren ({EE} mit CMC als Kern.)
|cmk -R |Änderungen aktivieren ({RE} bzw. Nagios als Kern).
|===



=== Speicherung in Dateien

Das _Ergebnis_ der Serviceerkennung -- also die eingangs genannte Tabelle
von Hostname, Check-Plugin, Item und erkannten Parametern -- finden Sie im
Verzeichnis `var/check_mk/autochecks`. Dort existiert für jeden Host
eine Datei, welche die automatisch erkannten Services speichert. Solange
Sie die Python-Syntax der Datei nicht verletzen, können Sie einzelne Zeilen
auch von Hand löschen oder ändern. Ein Löschen der Datei entfernt
alle Services und setzt diese quasi wieder auf „unmonitored“.

.var/check_mk/autochecks/myserver01.mk
[{file}]
----
[
  {'check_plugin_name': 'cpu_loads', 'item': None, 'parameters': (5.0, 10.0), 'service_labels': {}},
  {'check_plugin_name': 'cpu_threads', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'diskstat', 'item': 'SUMMARY', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'kernel_performance', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'kernel_util', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'livestatus_status', 'item': 'myremotesite', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'lnx_thermal', 'item': 'Zone 0', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'mem_linux', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'mknotifyd', 'item': 'mysite', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'mknotifyd', 'item': 'myremotesite', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'mounts', 'item': '/', 'parameters': ['errors=remount-ro', 'relatime', 'rw'], 'service_labels': {}},
  {'check_plugin_name': 'omd_apache', 'item': 'mysite', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'omd_apache', 'item': 'myremotesite', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'tcp_conn_stats', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'timesyncd', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'uptime', 'item': None, 'parameters': {}, 'service_labels': {}},
]
----


[#service_groups]
== Servicegruppen

=== Wofür Servicegruppen?

Bis hierher haben Sie erfahren, wie Sie Services ins Monitoring aufnehmen. Nun
macht es wenig Sinn, sich Listen mit Tausenden Services anzuschauen oder
immer über Hostansichten zu gehen. Wenn Sie beispielsweise alle Dateisystem-
oder Update-Services gemeinsam beobachten wollen, können Sie in ähnlicher
Weise Gruppen bilden, wie das mit link:wato_hosts.html#hostgroups[Hostgruppen]
möglich ist.

Servicegruppen ermöglichen Ihnen auf einfach Art, über xref:views#[Ansichten]
und NagVis-Karten deutlich mehr Ordnung ins Monitoring zu bringen und gezielte
xref:notifications#[Benachrichtigungen] und xref:alert_handlers#[Alert Handler] zu schalten.
Übrigens: Sie könnten entsprechende Ansichten fast immer auch rein über
die Ansichten-Filter konstruieren -- Servicegruppen sind aber einfacher und
übersichtlicher zu handeln.


=== Servicegruppen anlegen

Sie finden Servicegruppen unter [.guihint]#Setup > Services > Service groups#.

image::wato_services_service_groups_add_group.png[]

Das Anlegen einer Servicegruppe ist simpel: Legen Sie über icon:icon_new[]
[.guihint]#Add group# eine neue Gruppe an und vergeben Sie einen später nicht
mehr veränderbaren Namen sowie einen aussagekräftigen Alias.

image::wato_services_add_service_group.png[]


=== Services in Servicegruppe aufnehmen

Für die Zuordnung von Services in Servicegruppen benötigen Sie den
xref:wato_rules#conditions[Regelsatz] [.guihint]#Assignment of services to
service groups#. In der Übersicht Ihrer Servicegruppen ([.guihint]#Setup >
Services > Service Groups#), finden Sie diese Regel am schnellsten und zwar über
die Menüleiste und dort die Punkte [.guihint]#Service Groups > Assign to group > Rules#.
Alternativ können Sie die Regel natürlich auch über die Regelsuche im [.guihint]#Setup#-Menü finden,
oder sich über [.guihint]#Setup > Services > Service monitoring rules > Various > Assignment of services to service groups# durchklicken.
Erstellen Sie nun über [.guihint]#Create rule in folder# eine neue Regel im
gewünschten Ordner. Zunächst legen Sie fest, welcher Servicegruppe Services
zugeordnet werden sollen, hier beispielsweise _myservicegroup_ beziehungsweise
dessen Alias _My service group 1._

image::wato_services_servicegroups_rule_assignment.png[]

Der spannende Teil folgt nun im Bereich [.guihint]#Conditions#. Zum einen dürfen
Sie hier über Ordner, Hostmerkmale und explizite Hostnamen Einschränkungen
abseits der Services vornehmen. Zum anderen nennen Sie eben die Services, die
Sie gerne gruppiert hätten, beispielsweise [.guihint]#Filesystem# und
[.guihint]#myservice#, um eine Gruppe mit Dateisystemen zu erstellen. Die Angabe
der Services erfolgt hier in Form xref:regexes#[Regulärer Ausdrücke]. So
können Sie Gruppen ganz exakt definieren.

image::wato_services_servicegroups_rule_conditions.png[]


===  Servicegruppen eines Services prüfen

Die Zuordnungen von Services können Sie auf der Detailseite eines jeweiligen
Service prüfen. Hier finden Sie, standardmäßig weit unten, die Zeile
[.guihint]#Service groups the service is member of#.

image::wato_services_servicegroups_service_detail.png[]


=== Servicegruppen einsetzen

Zum Einsatz kommen die Servicegruppen wie bereits erwähnt an mehreren Stellen:
xref:views#[Ansichten], NagVis-Karten,
xref:notifications#[Benachrichtigungen] und xref:alert_handlers#[Alert
Handler]. Bei neuen Ansichten ist hier wichtig, dass Sie als Datenquelle die
[.guihint]#Servicegroups# setzen. Im [.guihint]#Views#-Widget finden Sie
natürlich auch vordefinierte Ansichten für Servicegruppen, zum Beispiel eine
übersichtliche Zusammenfassung:

image::wato_services_servicegroups_view_summary.png[]

Mit einem Klick auf die Servicegruppennamen gelangen Sie zur vollständigen
Ansicht aller Services der jeweiligen Gruppe.

Wenn Sie Servicegruppen in NagVis-Karten einsetzen, bekommen Sie als Ergebnis
beispielsweise Zusammenfassungen von Servicegruppen per Hover-Menü über
ein einzelnes Icon:

image::wato_services_servicegroups_nagvis_example.png[]

Wenn Sie Servicegruppen in xref:notifications#[Benachrichtigungen]
und xref:alert_handlers#[Alert Handlern] nutzen, stehen sie als
xref:wato_rules#conditions[Bedingungen/Filter] zur Verfügung, von denen Sie
einen oder mehrere nutzen können:

image::wato_services_servicegroups_notification_rule.png[]


[#checkplugins]
== Mehr über Check-Plugins

=== Kurze Beschreibung der Funktionsweise

Check-Plugins werden benötigt, um die Services in {CMK} zu erstellen. Jeder
Service greift auf ein Check-Plugin zurück, um seinen Status zu ermitteln,
Metriken zu erstellen/pflegen usw. Dabei kann ein solches Plugin einen oder
mehrere Services pro Host erstellen. Damit mehrere Services vom gleichen
Plugin unterschieden werden können, wird ein *Item* benötigt. So ist
z.B. beim Service `Filesystem /var` das Item der Text `/var`. Bei
Plugins, die pro Host maximal einen Service anlegen können (z.B. `CPU
utilization`), ist das Item leer und nicht sichtbar.


=== Verfügbare Check-Plugins

Eine Liste aller verfügbaren Check-Plugins finden Sie unter [.guihint]#Setup >
Services > Catalog of check plugins#. Hier können Sie nach verschiedenen
Kategorien gefiltert die einzelnen Plugins durchsuchen:

image::wato_services_catalog_of_check_plugins.png[]

Zu jedem Plugin werden drei Spalten ausgegeben, die die Servicebeschreibung
(Type of Check), den Namen des Check-Plugins (Plugin Name) und die kompatiblen
Datenquellen (Agents) enthalten:

image::wato_services_catalog_of_check_plugins_telephony.png[]
