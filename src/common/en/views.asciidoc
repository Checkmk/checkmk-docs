// -*- coding: utf-8 -*-
// IGNORE % Logfile ➤
include::global_attr.adoc[]
= Host and service views
:revdate: 2025-02-17
:title: Host and service views
:description: Views are very powerful in {CMK} and can be individually created or customized. How to effectively use views is explained here.

{related-start}
xref:user_interface#[The user interface]
xref:dashboards#[Dashboards]
xref:graphing#[Measured values and graphing]
{related-end}


== Introduction

The most important task performed by {CMK}’s xref:user_interface#[user interface] is displaying the current state of hosts and services.
This is achieved largely with _views_ in a table format.
In order for the daily operations to run as efficiently as possible, these tabular views provide numerous functions, and they can be customized to meet your requirements.

We distinguish between *global* views and those that require a *context*.
Global views can always be called-up directly.
An example of a global view is the list of all current service problems.
A context view -- the [.guihint]#Status of Host ...# view for example -- namely needs to specify by name the host whose state is to be displayed.
Such views can only be called-up in situations relevant to a particular host.


=== Global views

The global view is most easily accessed via the [.guihint]#Monitor# menu.

ifdef::onprem[]
.The [.guihint]#Monitor# menu of {RE} in Show less mode
image::monitor_menu_less.png[alt="Monitor menu of {RE} in Show less mode."]
endif::[]
ifdef::saas[]
.The [.guihint]#Monitor# menu in Show less mode
image::monitor_menu_less_saas.png[alt="Monitor menu in Show less mode."]
endif::[]

Alternatively, you can use the [.guihint]#Overview# and [.guihint]#Views# xref:glossar#snapin[snap-ins].
In the [.guihint]#Overview# each number is clickable and takes you to a global view that individually lists the hosts or services counted in each case.

image::views_snapin_overview.png[alt="'Overview' snap-in of the sidebar.",width=50%]

All global views are accessible in the [.guihint]#Views# snap-in -- grouped according to topics.
In addition you will find a few entries that are not actually [.guihint]#Views# -- such as for example, the xref:glossar#dashboard#[dashboards], which are sorted under the [.guihint]#Overview# topic.
Dashboards can however _contain_ views.

image::views_snapin_views.png[alt="'Views' snap-in of the sidebar.",width=50%]

From a global view, with a further step you can access the details for a particular host or service.
The names of hosts and services and the individual cells in other columns are clickable &hellip;

image::views_all_hosts.png[alt="'All hosts' view."]

&hellip; and bring you to a more detailed (context-dependent) view.


=== Context-dependent views

In views that relate to _a specific_ host or service, you will find all sorts of entries in the menu [.guihint]#Host# or respectively [.guihint]#Service#,
which will then take you to other views with the same context -- i.e. for the same host or service.

image::views_context_buttons.png[alt="View with the 'Service' menu open."]

You can also access host- and service-specific views by xref:intro_gui#search_monitor[searching within the Monitor menu]:

image::views_monitor_search.png[alt="The search in the Monitor menu.",width=60%,align=center]

Another way to the detailed view is via the [.guihint]#Quicksearch# snap-in in the sidebar:

image::views_snapin_quicksearch.png[alt="'Quicksearch' snap-in of the sidebar.",width=50%]

Which view you receive will depend on the result of the search.
If the search identifies a host explicitly, you will reach this host's [.guihint]#Services of Host ...# page directly.

image::views_services_of_host.png[alt="The view of a host's services."]

There you will again find the menu items for the other views of this same host.
A click on the host's name takes you to the [.guihint]#Status of Host# view.


=== Effect in the menu bar

[#menucontext]
The distinction between global, host-specific and service-specific views is also noticeable in the menu bar.
Always present are the menus [.guihint]#Commands, Add to, Export, Display# and [.guihint]#Help#.

In global host views there is also the menu [.guihint]#Hosts# as well as in global service views [.guihint]#Services# -- note the plural here!
You can use this, for example, to call up the xref:availability#[availability] of all hosts or services of the current view.

image::views_menu_global.png[alt="Menu bar of the 'All hosts' view."]

Views of a single host, on the other hand, contain the menus [.guihint]#Host# and [.guihint]#Services# with all actions for the current host and all services for the current view.

image::views_menu_context_host.png[alt="Menu bar of the 'Services of Host' view."]

Views of a single service likewise contain the [.guihint]#Host# menu, but additionally, now in the singular, the [.guihint]#Service# menu, with actions for this one service.

image::views_menu_context_service.png[alt="Menu bar of the view of a service."]


[#using_views]
== Using views

=== Options, filters and commands

At the top left of every view there are six symbols with which you can influence the display, and trigger actions:

[#filter]

[cols="30,~",options="header"]
|===
|Menu |Function

|[.guihint]#Commands# |Here you can execute commands to the object shown (e.g., entering scheduled downtimes).
 The commands are described in detail in their xref:commands#[own article].

|[.guihint]#Display > Filter# |Opens the filter bar on the right side of the main page.
With this you can further restrict the displayed data.
As soon as you set a filter the symbol on icon:icon_filters_set[alt="Icon for a set filter."] changes so that it is clear that under certain circumstances not all data will be displayed.
Conversely, some views already have predefined filters, (e.g. the list of all problems).
Here, by removing the filters you can also have more data displayed.
Changes to filters are not saved, rather they are reset when you quit the view.

|[.guihint]#Display > Show checkboxes# |With this you switch checkboxes on or off.
Using the checkboxes you can restrict the commands to selected data sets.

|[.guihint]#Display > Modify display options > Entries per row# |Defines the number of columns for the view.
Views with multiple columns allow the space available on wider monitors to be fully-utilized.
For views that only display a single data set this setting has no effect.

|[.guihint]#Display > Modify display options > Refresh interval# |Defines the view’s refresh interval.
You can also disable the automatic refreshing.
Be aware that in this case it is possible that you will not be informed of problems that occur in the meantime!

|[.guihint]#Display > Modify display options > Date format# |Change the format for the date display.

|[.guihint]#Display > Modify display options > Time stamp format# |Timestamps can be displayed as absolute, relative, mixed, in combination or as ‘Unix Timestamp’.
|===


=== Time and date

{CMK} shows time stamps as relative values in all of the views of states if these are less than 24 hours in the past or future -- e.g., [.guihint]#16 hours#.
You can switch this in the menu via [.guihint]#Display > Modify display options# and choose between displaying only absolute, only relative or both values, or also the ‘Unix timestamp’.
You can also specify the date format in this dialog.

image::views_time_date.png[alt="Changing the display options."]


=== Sorting

The views can be sorted by clicking on a column's heading.
A column has three states that can be selected through a loop of multiple clicks:

* sorted in ascending order
* sorted in descending order
* column unsorted

Views are initially sorted ‘naturally’ according to how the view is defined.
In service views the sorting is alphabetic by service name -- with the exception of [.guihint]#Check_MK# services which are always at the top.
The [.guihint]#Check_MK# service is responsible for managing the monitoring agent.
There are also the [.guihint]#Check_MK Discovery# and [.guihint]#Check_MK HW/SW Inventory# services.
In order to sort such a list by the current state of the services a click on [.guihint]#State# will suffice.

image::views_sort_by_state.png[alt="Sorting a list by column headers."]

Sorting by the [.guihint]#Perf-O-Meter# column sometimes produces surprising results.
This is due to the graphic display of the xref:graphing#[measured values] being partly a percentage summary of the actual values.
The sorting is however performed according to absolute values, and is always based on the _first metric_ produced by a service.


[#export]
=== Exporting

Data displayed in a view can be exported in various formats using the [.guihint]#Export# menu:

[cols="30,~",options="header"]
|===
|Menu item |Function

|[.guihint]#Data > Export CSV# |A semicolon is used as a separator.
The individual cells are enclosed in quotes.
The first line contains the internal abbreviations for each column.

|[.guihint]#Data > Export JSON# |For an export in JSON-format, the cells also end up in quotes, separated by breaks and commas, enclosed by square brackets.

|[.guihint]#Reports > This view as PDF# |
ifdef::onprem[]
Only in the commercial editions:
endif::[]
This creates a so-called _instant report_, which converts the current view into a PDF document, minus icons, navigation and so on.
Its layout can be customized with special templates in the xref:reporting#[reports].

|[.guihint]#Reports# |Depending on the current view, further PDF exports are offered, e.g. for availability, as well as individually-created report templates, if available.

|[.guihint]#REST API > Query hosts/services resource# |Output of the xref:rest_api#[REST API] for host/service selection of the current (filtered) view.
|===


[#limit]
=== The display limit

In a larger monitoring environment displaying all views is no longer practical.
When you are monitoring 50,000 services and select the [.guihint]#All Services# view, not only will the display require a very long time -- it will also not be very useful.

In such situations, in order to protect the user from long waiting times and to avoid crippling the system with absurd quantities of data,
views are limited to 1000 entries in their display.
Exceeding this limit produces the following warning:

image::views_limit1.png[alt="Hint before displaying a view with more than 1000 entries.",width=80%]

As you can see, the records being displayed are not necessarily the first 1000 corresponding to the selected sorting method!
There is a technical reason for this:
namely that the limit is applied to the data source
ifdef::onprem[]
in the connected site’s monitoring cores.
endif::[]
ifdef::saas[]
in the site’s monitoring core.
endif::[]
This is very important, because if we accumulate one million data records 
ifdef::onprem[]
from your environment spread around the world, then 99.9{nbsp}% of the data
endif::[]
ifdef::saas[]
from your environment, then 99.9{nbsp}% of the data
endif::[]
will be deleted immediately.
The sorting takes place over the interface only at the end, thus it happens _after_ the limit.
The data from all sites must, after all, be sorted together.

If you really want to see more than one thousand records, then you can reach the
next level by clicking on [.guihint]#Repeat query and allow more results#. Here the
limit is 5,000 records. If this limit has again been exceeded, with
_unlimited_ you can continue. Insofar this is a potentially risky action,
you will require _Administrator rights_. You have been warned!

image::views_limit2.png[alt="Hint before displaying a view with more than 5000 entries.",width=80%]

You can define both levels under [.guihint]#Global settings > User interface# with [.guihint]#Soft query limit# and [.guihint]#Hard query limit#:

image::views_limit3.png[alt="Global setting for changing the two limits."]


[#edit]
== Customizing views

=== The basics

{CMK} allows you to customize its standard views, and even to create new ones that you can incorporate into xref:reporting#[reports] and xref:glossar#dashboard[dashboards].
Thus you can define numerous different aspects for every view:

* *General items* such as title, topic, etc.
* Which *data source* is to be displayed (e.g. hosts, services, Business Intelligence (BI) data, etc.)?
* Which selection of records is to be displayed (*filtering*)?
* Which *columns* will be displayed?
* Which other views are *linked* to the text in the columns?
* What is the standard *sorting* method?
* Is there a *grouping*, and if so, how does it look?
* Where and for which user should the view be *visible*?
* Which style of *table layout* should be used?

The edit mode for views can be accessed in two ways:

. Via a menu entry in the case of an existing view. There are four variants here, depending on the origin of the view in question:
* [.guihint]#Display > Clone builtin view# -- creates a clone of the provided built-in view.
* [.guihint]#Display > Edit my view# -- opens the edit mode for your custom view.
* [.guihint]#Display > Clone view# -- creates a clone of another user's view -- if you don't have permission to edit views that are not your own.
* [.guihint]#Display > Edit view of user X# and [.guihint]#Display > Clone view# -- which lets you choose whether to edit another user's view or instead create a clone of their view -- if you have permission to edit other users' views.
. In the menu [.guihint]#Customize > Visualization > Views#. There you can create completely new views with icon:button_add_view[], or customize existing ones with icon:button_clone[]:

image::views_edit_views.png[alt="View for creating a new view."]


=== Clone first -- then modify

The views supplied as standard are a part of the software and as such cannot be changed, however {CMK} does recognize the concept of _cloning_.
When a view is first customized a copy of that view is created automatically.
This copy is added to your user profile.

This copy can then be customized as desired.
The original view is retained but is _grayed-out_ -- overlaid by your new version in effect.
You can return to the standard view later by simply deleting your clone (achieved in the table of views, as you might expect, with icon:icon_delete[alt="Symbol for deleting."]).

This concept has one further advantage:
namely, that you can define whether the view should be changed _for all users_ or just for yourself.
You specify this in the [.guihint]#General properties# of the view under [.guihint]#Visibility# with the [.guihint]#Make this view available for other users# checkbox.
Not surprisingly, you can only select this checkbox if you have xref:wato_user#roles[administrator permissions].
ifdef::onprem[]
More correctly, this function has its own permission -- [.guihint]#Publish views#.
Additionally, single views can be locked in the xref:wato_user#roles[role definitions].
endif::[]

What happens when a view has been customized and published by several users?
Each user then has their own variant of the view.
Which view will be visible for which user(s)?
This can be determined with the following rules:

. When a user creates a view for themselves, this will always have priority for them.

. After this are views that have been customized and published by an administrator.
ifdef::onprem[]
The [.guihint]#Modify builtin views# permission is required for publishing.
endif::[]

. If there are none here, then those views apply that another normal user has published.
ifdef::onprem[]
The [.guihint]#Publish Views# permission is required for publishing.
endif::[]

. And when there is also nothing here then the supplied default version will be visible.

How can you create a _real copy_ of a view, so that when done you can have both the supplied and your own views?
This is defined by using [.guihint]#Unique ID# in the [.guihint]#General Properties#.
Simply give your view a new name,
so that it will no longer be identified as a clone of the supplied view, rather it will begin its own independent life.

This ID is the decisive keyword for opening views in the URL.
The schema is very simple.
Here for example is how the global view with its ID `allhosts` is opened:

`/mysite/check_mk/view.py?view_name=allhosts`

The concepts of cloning, customizing and visibility can be found at many other locations in {CMK}, namely in:

* xref:dashboards#[dashboards]
* xref:reporting#[reports]
* xref:graphing#graph_collections[graph collections]
* xref:graphing#custom_graphs[custom graphs]
* xref:user_interface#bookmarks[bookmark lists]


=== Integrating a view into the sidebar

How and if a view will be shown in the [.guihint]#Monitor# menu of the navigation bar as well as in the [.guihint]#Views# snap-in, is defined under [.guihint]#General properties# by the following characteristics:

image::views_edit_view_general_properties.png[alt="General properties of the view."]

* [.guihint]#Title# -- the item’s name
* [.guihint]#Topic in 'Monitor menu':# -- the view will be sorted under this topic. You can also define other topics.
* [.guihint]#Sort index# -- how high up the view appears in the menu
* [.guihint]#Visibility# -- Suppress item and/or share with other users


=== Basic layout

The next block -- [.guihint]#View Properties# -- defines a view’s general appearance:

image::views_edit_view_view_properties.png[alt="Specific properties of the view."]

The [.guihint]#Number of Columns# option sets the default for the number of columns shown in the view, the [.guihint]#Automatic page reload# the default for the refresh counter.
Both values can be modified by the user in the view itself via [.guihint]#Display > Modify display options#.

Under [.guihint]#Basic Layout# there are various styles for displaying the data in tables.
Most views use [.guihint]#Table# -- a normal table that can be sorted by columns
-- or [.guihint]#Single dataset# -- which has the legend on the left and which is mostly used for single data sets.
You can however also use [.guihint]#Single dataset# for views with more than one object.
The [.guihint]#All hosts# view looks something like this when altered to [.guihint]#Single dataset#:

image::views_layout_single_dataset.png[alt="Result of the changed view."]


[#columns]
=== Columns

The [.guihint]#Columns# box defines which columns you wish to see.
The possible selection of columns depends on the selected data source.
The most columns are found in services, naturally, as all information for the particular host is available here.
The list can be quite long here, and if you are uncertain which column is the right one, there is only one thing to do -- try it out:

image::views_edit_view_columns.png[alt="Properties for the view columns."]

Depending on the column selected, there may be specific options for this.
With the column [.guihint]#Hosts: Host name#, for example, it is possible to color the host name according to its state using the [.guihint]#Coloring# option.

The [.guihint]#Link# field offers a selection of all views and dashboards.
If a view is selected here, then the column’s respective cell is _clickable_ and takes the user to the chosen view.
This really only makes sense if the targeted view has a context.
The best example is the [.guihint]#All hosts# view.
The [.guihint]#Host# column is clickable here and takes the user to this host’s [.guihint]#Services of Host#.
Alternatively, dashboards can be specified here -- which obviously do not require a context.

Under [.guihint]#Tooltip#, on the other hand, you will find a list of all columns.
Thus you can show further information for the host or service when the user moves the mouse cursor over the respective cell (the IP address in the following example):

image::views_hover_address.png[alt="Result of the changed view with a tooltip."]


[#joined_columns]
=== Information for services in a host view

Let’s imagine that you would like to display information on specific services in a table of hosts.
The following shows a very good example of such a scenario:
For each host, the current uptime, CPU load, memory usage, and execution time of the {CMK} agent are output:

image::views_joined_columns_example.png[alt="Host view with Perf-O-Meters for the services."]

Here a table of hosts has been created, in which for each host the [.guihint]#Perf-O-Meter# *service column* from each of four different services is shown.
You can also see that for one of the three hosts the [.guihint]#CPU, Memory# and [.guihint]#Uptime# services do not exist and so the columns for those services are consequently empty.

To implement a configuration to this view, add columns of the [.guihint]#Joined column# type to the view.
Here then under [.guihint]#Column# the columns for services will appear, from which you select [.guihint]#Service Perf-O-Meter# in this example.
With the [.guihint]#Title# entry further down you can then define the heading of the column as required if the default heading does not fit.

Under [.guihint]#of Service#, first select either [.guihint]#Explicit match# or [.guihint]#Regular expression match#.
For the former, enter the *exact* name (upper and lower case-sensitive).
This will determine the correct service associated with the host.

image::views_edit_view_columns_2.png[alt="Properties of a 'Joined column' with explicit specification of the service."]

If you don't know exactly what the service is called, or its name is slightly different on each host, specify a regular expression that matches to exactly *one* service per host.
This is especially useful if you want to look at a group of hosts where there is a comparable group of services, only one of which can be present on a host at any given time.
In the example below, this is the [.guihint]#CPU load# or the [.guihint]#Processor queue,# which can only exist on either Linux or Windows systems.

image::views_edit_view_columns_3.png[alt="Properties of a 'Joined column' with regular expression for the service."]

By the way, there is no need to worry if a regular expression does in fact match more than one service.
In such a case, the _first_ match will always be displayed in the column.

In both variants, such a display is of course only useful if the view shows a list of similar hosts, which also all have the selected services or have similar services.
This is also the reason why {CMK} provides only a few such views:
Which columns are useful here depends entirely on the type of hosts selected.
Linux servers are obviously interested in completely different information compared to UPSs, for example.


=== Sorting

The sorting within a view is configured in the fourth box.
It’s only a matter of the predefined sorting method.
Users can -- as described above -- determine the sorting order themselves with a click on the column heading.
In the view’s configuration however you have more possibilities
-- you can define a _multi-step_ sorting order, e.g. first by service state, and for the same state by service name.
The order so determined is retained as a subordinate sorting when the user resorts in a specific column.

image::views_edit_view_sorting.png[alt="Properties for sorting the view."]


=== Grouping

Through grouping you can divide a table into several segments -- in which each segment’s data is related in some way.
The best example of this is the [.guihint]#Service problems# view, which is easily reached via the [.guihint]#Monitor# menu.

As you can see, this table is grouped with service [.guihint]#State# (first all {CRIT}, then {UNKNOWN}, then {WARN}) - each with its own group header:

image::views_edit_view_grouping.png[alt="Grouped view."]

The grouping in a view is configured similarly to that with the columns.
Simply define which column the grouping should relate to.
It is usually only one, but can be more.
All records with the same value for all selected columns will then be displayed in a group
-- and the column heading will be shown as the group title.

It is important that you also *sort* the records by priority according to the group’s selected characteristic!
Otherwise it can be possible that the same group makes multiple appearances (which may at times be desirable).

[TIP]
====
A resorting by column performed by a user has no effect on the grouping
-- in such a case only the group’s sequence is determined and the records sorted within the group.
The groups themselves are unchanged.
====


[#filter_context]
=== Filters, contexts and searches

An important aspect of views is the data _selection_.
Which hosts or services should be displayed in a table?
{CMK} uses the *Filter* concept for this purpose.
Here are a couple of examples of host filters:

image::views_filter.png[alt="Examples of host filters."]

Every filter can be defined with search terms or other criteria by a user, thus reducing the list of results to those records meeting the criteria.
In this way the filters are AND-linked.
The filter criteria actually used for a view are assembled from three sources:

. Filters with criteria defined as standard for the view.
. Filters set interactively by the user with icon:icon_filter[] in the view.
. Filters that can be set with variables via the URL.

The filters you assemble by editing in the view’s [.guihint]#Context / Search Filters# box have two functions.
Firstly, by clicking on icon:icon_filter[] you can decide which filter will be available to a user.
Secondly, you can predefine filters using criteria, thus limiting the data to be displayed in the view (point 1 above).

When you create or edit a view by using *context* -- instead of the filter for the relevant object only an optional entry field appears.
In this an _exact_ comparison always applies (upper and lower case sensitive).
As an example we can take the `host` view, which displays all services of a specified host.
The host name can be specified by adding a context to the view.
You can also build a display in which the host to be displayed is effectively *hard-coded* directly in the view:

image::views_edit_view_context_filter.png[alt="Properties for filtering the view."]

In this way you can call the view without context, or if desired, simply add it to the [.guihint]#Views# snap-in without problem.


=== Special search views

The [.guihint]#Host search# and [.guihint]#Service search# (and other) views supplied as standard behave in a special way in relation to the filters.
When you you select one of these views, it opens with a filter form, and then only shows hosts and services when this filter is activated.

Why is this so?
Because it would simply be very impractical if you first had to go to [.guihint]#All services#, and then be forced to wait until several thousand services are displayed
before you could filter the result with a search entry.
This behavior is regulated by the [.guihint]#Show data only on search# option:

image::views_edit_view_view_properties_show_data.png[alt="The 'Show data only on search' option."]


[#new]
== Creating new views

Creating a new view with icon:button_add_view[] functions in principle just like the editing of an existing view -- with one small difference:
you must first select a *data source* and a *specific object type*.


[#datasource]
=== Data source

image::views_create_view_1.png[alt="Selecting a data source."]

The data source is what you might call a table or database view under databases.
{CMK} does not use SQL databases, but it is similarly-structured internally.
In most cases you will be correct with [.guihint]#All services# or [.guihint]#All hosts#.
There are however a few data sources that should be listed briefly here:

[cols=2]
|===
|Data source |Meaning

|Host and service groups, various |see xref:host_service_groups[below]

|[.guihint]#BI#, various |xref:bi#[Business Intelligence]

|[.guihint]#Inventory#, various |xref:inventory#[HW/SW Inventory]

ifdef::onprem[]
|[.guihint]#Alert statistics# |xref:livestatus#retrieving_statistics[Status statistics]

|[.guihint]#Event Console#, host and service events |xref:ec#[Event Console]

|[.guihint]#The Logfile# |xref:livestatus.html#logs[Livestatus data]
endif::[]
|===


[#host_service_groups]
==== Host and service groups

The [.guihint]#Host groups# and [.guihint]#Service groups# data sources -- per line -- provide the information on the group itself
-- accordingly there are no filters for individual hosts or services.
An example of this data source is the standard [.guihint]#Host groups# view.
ifdef::onprem[]
In distributed environments the [.guihint]#Host groups, merged# and [.guihint]#Service groups, merged# data sources work in exactly the same way.
endif::[]

image::views_hostgroups_summary.png[alt="View for host groups."]

However, if you want information about individual hosts, but grouped according to host groups,
you can change the [.guihint]#All hosts# default view by adding the [.guihint]#Hosts: Host groups the host is member of# option in the [.guihint]#Grouping# box.
Since hosts can be assigned to multiple groups, you will then find a single area in the view for each *host group combination,* which applies to at least one host.

image::views_hostgroups.png[alt="View with grouping by host groups."]

You can proceed in the same way with services and service groups.

Depending on the selected data source, various columns are available for building the view.


=== Object type -- global or with context

image::views_create_view_2.png[alt="Selection of a specific object type."]

Here it can be decided whether your new view should have a context or if it will be a global view.
The selections available to you depend on the data source.
The most common context by far is host.
The image above appears after selecting the [.guihint]#All services# data source.

Selecting [.guihint]#Show information of a single Host# defines that the new view describes one specific host.
You will thus have created the basis for a view that is not globally-visible, but instead visible via a link:

* For a host view with a context
* As a link in a column (see above, e.g., click on a host name in a view)

There are two options for the service context type.
If you select only [.guihint]#Show information of a single Service#, you can build a view that displays all services with the same name on _different hosts_.
If it should be a specific service for a single host, then select in addition [.guihint]#Show information of a single Host#.


[#joined_inventory_columns]
== Link inventory tables

{CMK} provides many different data on a host or a service.
Most of these can be displayed using the [.guihint]#All services# or [.guihint]#All hosts# data sources.
The xref:inventory#[HW/SW inventory] also provides additional xref:inventory#table[tables] (as data sources), which you can also display in your own views and structure individually.
You can also add columns from other tables to such views, as long as they have a column in common.

*Important:* The number of rows in the final view is the same as the number of rows in your view's underlying data source.
Linked tables only add selected columns.

In the following example you will once-only create a very compact view linking two HW/SW inventory tables.
To begin, create a xref:new[new view] and select the desired inventory table as the basic xref:datasource[data source].
For the example, search for the [.guihint]#Inventory table: Checkmk ➤ Checkmk sites# and then confirm with icon:button_continue[] [.guihint]#Continue#:

image::views_create_view_3.png[alt="Selection of the 'Checkmk sites' data source."]

You can skip the following page, as it is not necessary to restrict the data source to a single host or site.
The next step is therefore performed directly on the main configuration page, where first you enter the [.guihint]#Unique ID# and a [.guihint]#Title#.

In the [.guihint]#Macros for joining service data or inventory tables# box comes the first specific configuration to later include other data sources in the view.
For this purpose indicators are needed to identify the correct rows in the other data sources later on.
So as in the following example, create the macros for the [.guihint]#Version# and [.guihint]#Site# columns:

image::views_create_view_4.png[alt="Dialog for creating macros."]

You can now use these macros in special [.guihint]#Columns#.
In addition to the xref:columns[regular columns], which have already been used in customizing views, both the xref:joined_columns[service data source] ([.guihint]#Joined columns#), which was described earlier, and the [.guihint]#Joined inventory columns# will now be available.

The first two columns use default data from the data source.
Since data from the HW/SW inventory always belongs to a specific host and site, these tables are also available if you have selected such a data source.

image::views_create_view_5.png[alt="Dialog for selecting the columns."]

After that you can use the defined macros not only in the [.guihint]#Joined inventory columns#, but also in the [.guihint]#Joined columns,#
to display data from specific services.
This allows you to combine a wide variety of sources -- in this example, to display the Perf-O-Meter for a site's associated performance service.

By the way, you can use the macros in the same way when defining regular expressions.

image::views_create_view_6.png[alt="Selection of a 'Joined column' using a macro."]

Displaying data from other HW/SW inventory tables works quite similarly.
Only the table to be used has to be selected beforehand.
In the following example you use the table [.guihint]#Checkmk ➤ Checkmk versions# table, which automatically filters the [.guihint]#Display the column# drop-down list to a suitable selection.

Afterwards you determine how {CMK} finds the correct row in the table from which the column should be displayed.
To do this, use the [.guihint]#Add new match criteria# button to add a criterion in the form of a column that {CMK} can later use to determine the matching row.
In the example above this is the [.gui]#Version#, since this is unique in the table and can only occur once.
Conversely, this also means that while you can link any of the HW/SW inventory tables together, you must also ensure that the two tables always have a common column and that this column also always contains unique entries.
So in the above example, the [.guihint]#Sites# column would not be a suitable criterion as there could be multiple editions with the same number of sites.

image::views_create_view_7.png[alt="Selection of a 'Joined inventory column' using a macro."]

Of course you can also customize the title of the column in a [.guihint]#Joined inventory column# if the default one doesn't fit.
After all of the settings have been made, save the new view with icon:button_save_and_go_to_view[] [.guihint]#Save & go to view# and you will be taken directly to the result.
Depending on how many sites you are monitoring, a line will be inserted in the view for each site:

image::views_create_view_8.png[alt="Finished view including columns from other sources."]

As you can see here, there is always a default title for each column if it is not specified by you.
A title for the [.guihint]#Perf-O-Meter's# third column was not specified, so the name of the regular expression used by {CMK} was taken as the column title.
As with the [.guihint]#Edition# column, you can customize this column title at any time.


[#matrix]
== The matrix

When you specify the [.guihint]#Matrix# layout in one of your views you will probably see strange things at first, and ask yourself what is going on.
The matrix is certainly not intuitive on first viewing, but you can achieve good things with it.

In the supplied standard views there is e.g. [.guihint]#Search performance data#, which uses this layout.
You can find this view in the Monitor menu under [.guihint]#Monitor > History > Search performance data# and also in [.guihint]#Customize > Visualization > Views#.
In the list of views, you may first need to remove the limitation of displaying a maximum of 100 rows.

The following image shows the search for the expression `CPU|^memory|Filesystem /opt/omd/sites/mysite`:

image::views_matrix_filter_service.png[alt="Filter for the service search.",width=55%,align=center]

The result is a neat table of my hosts, in which all of the service’s metrics are listed adjacent to each other.
Not all of the hosts have the same services, so some of the fields are simply empty:

image::views_matrix_view_1.png[alt="Result of the service search in a matrix view."]

The result at first looks very similar to that described earlier -- xref:joined_columns[Information for services in a host view].
There are a couple of significant differences however:

. The list of services is dynamic and has no fixed configuration.
. Here the hosts are the columns -- not the lines.

With the matrix you can do much more.
When you look at the view’s definition you can see how it is constructed:

* [.guihint]#Matrix# is specified in [.guihint]#Basic layout#.
* The host name ([.guihint]#Hosts: Host name#) is specified as the only column in [.guihint]#Grouping#.
* In [.guihint]#Columns# the [.guihint]#Service name# and the [.guihint]#Service Perf-O-Meter# are specified.

The rule for the matrix layout is:

* The *Grouping columns* are used as headings for the vertical columns.
* The *first normal column* on the left provides the titles for the rows.
* All *further normal columns* are shown in the cells.

If, for example, you wish to display more information regarding the host, simply add more columns in the [.guihint]#Grouping# box.
Thus the table from above will look like this when you insert the [.guihint]#Host icons# and [.guihint]#Folder - just folder name# columns:

image::views_matrix_view_2.png[alt="Matrix view with additional rows."]

Further normal columns then land directly in the cells. The following example
shows (abbreviated) the matrix with the additional [.guihint]#Output of check plugin#
column:

image::views_matrix_view_3.png[alt="Matrix view with additional information in the cells."]


=== Recognizing outliers

Why do some cells have a colored background?
This points you to values *lying outside the majority*.
This is actually not so meaningful for measured data,
but there are, for instance, users with a specially-constructed matrix who can tell at a glance if an incorrect contact group has been entered for certain hosts or services.

image::views_matrix_view_4.png[alt="Matrix view with color coding of cells with different content."]


[#alarm_sounds]
== Alarm sounds

A view can sound an alarm tone over the browser if at least one problem appears in the table (a host that is not {UP}, or a service that is not {OK}).
This primitive type of alarm is, for example, interesting for control centers where there is always a list of problems on a screen that the operator doesn’t want to have to constantly stare at.

The alarm sounds are by default deactivated.
You can switch them on with the [.guihint]#Setup > General > Global settings > User interface > Sounds in views# global switch.
As (almost) always the search in the [.guihint]#Setup# menu helps here:

image::views_global_settings_sound.png[alt="Global setting for switching on alarm sounds in views."]

Sounds will not be heard in all views, rather only in those for which alarm sounds have been activated in [.guihint]#View Properties#:

image::view_properties_sounds.png[alt="Activation of alarm sounds in a view."]


// TK: Commented out as this feature depends on the Enable login via GET requests global setting that is disabled by defualt due to security reasons since 2.2.0
////
[#embed_views]
== Embedding views in external websites

Since every view is accessible via a URL you can also embed these in other websites, for example, via an `&lt;iframe&gt;`.
A number of elements in a view could however make no sense or even be distracting in such a context.
In a situation like this you can attach a `display_options=` variable to the URL, via which you can precisely control which component of the view should *not* be generated in HTML code.

*Important:* The {CMK} navigation is also usually rather undesirable when embedding.
So before you manually set options in a view, let the page be displayed without navigation and sidebar by turning off [.guihint]#Display > Show page navigation#.

Every component is coded with a letter and can accordingly be excluded using these.

The following letters have been defined:

[cols="10,~"]
|===
|Option |Effect

|`t` |Title bar (with heading, breadcrumbs, countdown symbol for page update), menu bar and actions bar are omitted.
|`b` |Menu items and action buttons that link to other views are omitted.
|`f` |Menu item [.guihint]#Display > Filter# and its corresponding icon:icon_filter[alt="Icon of a filter."] button are omitted.
|`c` |Menu [.guihint]#Commands# and its corresponding buttons are omitted.
|`o` |The options [.guihint]#Entries per row# and [.guihint]#Refresh interval# are omitted; otherwise callable via [.guihint]#Display > Modify display options#.
|`d` |Menu item [.guihint]#Display > Modify display options# is omitted
|`e` |Menu item [.guihint]#Display > Clone builtin view# is omitted.
|`r` |The page refresh countdown icon in the title bar and auto-refresh JavaScript code are removed.
|`s` |The playing of xref:views#alarm_sounds[alarm sounds] for the {WARN} and {CRIT} service states is suppressed.
|`i` |Links to other views are omitted, e.g. the links in the [.guihint]#Service# column in service views.
|`m` |The target of links is by default the HTML `main` frame -- with this option links are opened in new tabs.
|`l` |Links in column headings are omitted.
ifdef::onprem[]
|`w` |Limit and Livestatus error messages.
endif::[]
|===

For example -- if you want to switch off all control elements and buttons and only display the actual table, a link on the `allhosts` view will look like this:

`/myserver/mysite/check_mk/view.py?view_name=allhosts&display_options=til`
////

== Adding icons and actions

In views of hosts and services you will also see a column for icons, and in this the icon:icon_menu[alt="Icon of the action menu in the view."] action menu icon with which you can select host or service actions.
ifdef::onprem[]
You can also add your own icons to views.
endif::[]
ifdef::saas[]
You can also add icons to views, which you can select from the icons supplied by {CMK}.
endif::[]
These can be used simply for visualization, or your own actions can be assigned to them.

For example, hosts with a graphic web interface can be quickly identified using such an individual icon and can also be controlled directly via a link.

The procedure for adding your own icons and actions is divided into the following steps:

ifdef::onprem[]
. Upload the icons.
endif::[]
. Define the icons/actions.
. Assign the icons to hosts/services.

ifdef::onprem[]
Start with [.guihint]#Setup > General > Custom Icons# and upload a local file with a maximum size of 80 x 80 pixels.
The icon will now be in the system, but will not yet be in use.

image::views_manage_icons_upload.png[alt="Dialog for selecting and uploading your own icons."]
endif::[]

ifdef::onprem[]
Next you will need
endif::[]
ifdef::saas[]
You need  
endif::[]
to define the icon as an object that can be addressed via xref:glossar#rule[rules], and optionally, an associated action.
You can find the settings for this under [.guihint]#Setup > General > Global settings > User interface > Custom icons and actions#.
Create a new entry here using [.guihint]#Add new element#, and define [.guihint]#ID#, [.guihint]#Icon# and a [.guihint]#Title#.
The title will later be displayed as a tooltip directly on the icon via a mouse-over-effect, and is therefore indispensable for users.

image::views_global_settings_custom_icons_and_actions.png[alt="Properties for custom icons."]

Now it gets interesting with the [.guihint]#Action# option.
Action is equivalent to a URL, and for this you can make use of some variables such as `$HOSTNAME$` or `$SERVICEDESC$` (service description)
-- you can get further information from the inline help.
A valid action would be, for example:

`view.py?host=$HOSTNAME$&site=mysite&view_name=host`

This action simply calls the standard host view for the corresponding host on the site `mysite`.

With a check mark at [.guihint]#Show in column# you can then display the icon as an independent icon next to icon:icon_menu[alt="Icon of the action menu in the view."],
otherwise your action will end up in this action menu.

In the final step, you now determine which hosts or services the new icon is to be displayed for -- specifying these using rules of course.
You can find the two rule sets, [.guihint]#Custom icons or actions for hosts in status GUI# and [.guihint]#Custom icons or actions for services in status GUI# in the
[.guihint]#Setup# menu under [.guihint]#Host monitoring rules# and [.guihint]#Service monitoring rules#.
The quickest way to find the two rules is to search the [.guihint]#Setup# menu.

Create a new rule and set at least two options in it.
First select the icon just created under [.guihint]#Custom icons or actions for hosts in status GUI#:

image::views_custom_icons_or_actions.png[alt="The rule for using a custom icon."]

Then set the filter in the [.guihint]#Conditions# box for the desired hosts/services.

image::views_custom_icons_or_actions_b.png[alt="Conditions in the rule for using a custom icon."]

Finally, save and confirm the changes.

In host and service views you will now be able to see your new icon next to or in the action menu for the filtered hosts and services.

image::views_view_with_custom_icon.png[alt="Host view with your own icon."]
