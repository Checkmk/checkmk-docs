// -*- coding: utf-8 -*-
// IGNORE no_permissions
include::global_attr.adoc[]
= Users, roles and permissions
:revdate: 2025-02-03
:title: Users, roles and permissions - User and authorization configuration
:description: Each monitored object has a responsible person. Here you can learn what roles and contact groups are, and everything else important to user management.
ifdef::onprem[]
:keywords: 2fa
endif::[]

{related-start}
xref:wato#[Configuring {CMK}]
xref:wato_rules#[Rules]
ifdef::onprem[]
xref:ldap#[User management with LDAP/Active Directory]
endif::[]
{related-end}


[#intro]
== Introduction

In this article we will show you everything on the subject of user management in {CMK}.
But before we can go into the details, we first have to clarify a few terms.

In {CMK}, a *user* is someone who has access to the xref:user_interface#[user interface].
ifdef::onprem[]
A user has one or more *roles.*
These roles are the basis for *permissions*.
endif::[]
ifdef::saas[]
A user has one *role.*
This role is the basis for *permissions*.
endif::[]

As soon as a user is responsible for specified hosts and services, they are identified as a *contact*.
A contact normally only sees their own hosts and services in the xref:glossar#monitoring_environment[monitoring environment] and may be notified of any problems with these.

There are also users who are _not_ contacts.
ifdef::onprem[]
An example of this is `cmkadmin`, which is automatically generated when a site is created.
endif::[]
ifdef::saas[]
An example of this is the user with administrator rights, which is automatically created after xref:intro_setup#signup_trial[registration].
endif::[]
This user is allowed to see all hosts and services, but only because the [.guihint]#Administrator# role contains the permission [.guihint]#See all hosts and services#, and not necessarily because they would be a contact for everything.

ifdef::onprem[]
If a contact was created for the sole purpose of xref:notifications#[notification] (e.g. to forward notifications to a ticket system), then it may be useful to create it in such a way that no login to the interface is possible.
endif::[]

A contact is always a member of one or more *contact groups*.
The purpose of these groups is to assign contacts to hosts and services.
For example, the contact `hhirsch` could be in the contact group `linux` and this in turn could be assigned to all Linux hosts via a xref:wato_rules#[rule].
A direct assignment of contacts to hosts or services is not possible and could in fact create difficulties in practice (e.g. when a user leaves the organization).

In summary:

* *Users* can use the user interface.
* *Contacts* are users who are responsible for specific hosts and services.
* *Contact groups* define what a user is responsible for.
* *Roles* define what *permissions* a user has.


ifdef::saas[]
[#admin_panel]
== User administration in the admin panel

In {CE}, basic user administration takes place in the xref:admin_panel#[admin panel].
Only here can users be created or deleted, and only here can the role of a user be changed.

You can access the user administration in {CE} by clicking [.guihint]#Admin# in the left-hand xref:glossar#navigation_bar[navigation bar] in the {CMK} interface.
Then click on [.guihint]#User management# in the admin panel.

Following the initial xref:intro_setup#signup_trial[registration], the user management page will look something like this:

.The user management page in the admin panel
image::admin_panel_user_management.png[alt=“The Admin panel with the page for user management.”]

The admin panel shows the user specified during registration.

You can create a new user with the [.guihint]#Add user# button.

image::intro_new_user_saas.png[alt=“Dialog for entering the email address and role for the new user.”,width=63%]

Enter the new user's email address, select one of the predefined xref:roles[roles] and confirm by clicking [.guihint]#Create user.#

This will send an email to the specified email address.
This email contains the user name (i.e. the email address), a temporary password and a link for the first login to {CE}.
Until the new user logs in for the first time, their status remains [.guihint]#INVITE PENDING:#

image::wato_user_users_list_saas.png[alt=“List of users set up in {CE}.”]

After logging in, the new user first chooses a new password and then lands in the admin panel, where they can select the site.
Following a successful login, the status of the user changes from [.guihint]#INVITE PENDING# to [.guihint]#CONFIRMED.#
The new user will be added to the user administration in {CMK} and will now be ready to assign contact groups and receive notifications, among other things.
endif::[]


[#user_config]
== User management in the configuration environment

=== Overview

ifdef::onprem[]
The user management page can be found under [.guihint]#Setup > Users > Users#.
In a freshly created site, this page looks like this (only shortened by a few table columns in the image):

[{image-border}]
image::wato_user_users.png[alt="List of users with administrator attributes."]

The image above shows all users that were automatically created when the site was created.
These are first two xref:glossar#automation_user[automation users], followed by the single user (`cmkadmin`) for the interactive login with password.
With the {CMK} appliance, this user can have a different name as you define its name and password yourself.
This `cmkadmin` user has the following properties:

* They have the [.guihint]#Administrator# role, and therefore all permissions.
* They are not a contact for anything and receive no notifications.
* They can still see everything (because of their [.guihint]#Administrator# role).
* You should definitely change the password that was assigned when the site was created!

The form for creating a new user is opened with icon:button_new_user[alt="Button for creating a new user."] -- or to edit an existing user with icon:icon_edit[alt="Icon for editing."], is divided into five sections.
The first section deals with the identity.
endif::[]

ifdef::saas[]
The {CMK} user administration can be found under [.guihint]#Setup > Users > Users#.
For a site with the users displayed as shown in the xref:admin_panel[previous chapter], this page will look something like this (in this example only shortened by a few table columns in the image):

image::wato_user_cmk_users_list_saas.png[alt=“List of users set up in {CMK}.”]

The above image shows the users visible in the admin panel as well as all users that were automatically created when the site was created.
The first three are xref:glossar#automation_user[automation users], followed by the users for the interactive logins with password.
The user specified during registration has the following properties:

* They have the [.guihint]#Administrator# role, and therefore all permissions.
* They are not a contact for anything and receive no notifications.
* They can still see everything (because of their [.guihint]#Administrator# role).

The form for editing an existing user with icon:icon_edit[alt="Icon for editing."] is divided into several sections.
The first section deals with security.
endif::[]


ifdef::onprem[]
=== Identity

image::wato_user_identity.png[alt="Dialog for a user's identity."]

As always in {CMK}, the ID of a dataset ([.guihint]#Username# in this instance) cannot be changed later. It is used for logging-in and also as an internal key in all files and data structures.

The email address is optional and is only required if the user is to become a contact who is to be xref:notifications#[notified] by email (xref:notifications#smtp[SMTP configuration]). Likewise, the field
[.guihint]#Pager address# is intended for notification via SMS or similar systems. If you write your own notification scripts
you can access the values in these fields and use them for any purpose.

With [.guihint]#Authorized sites# you can optionally restrict which of the existing sites may be accessed.
This is particularly practical for very large environments, such as a distributed monitoring with hundreds of sites.
If a user only needs a certain number of these sites for his hosts, the GUI will only contact the authorized sites to set up views
-- which in turn greatly improves performance.
endif::[]


=== Security

ifdef::onprem[]
image::wato_user_security.png[alt="Dialog for a user's security settings."]

This box is for login and authorization.
endif::[]
ifdef::saas[]
image::wato_user_security_saas.png[alt="Dialog for security settings of an automation user."]

This box is for login and authorization and is only available for automation users.
endif::[]
The [.guihint]#Automation secret for machine accounts# option is meant for accounts that access {CMK} via HTTP/HTTPS and authenticate themselves via the URL.
We will show you how to do this xref:automation[below].

ifdef::onprem[]
For the roles, you must select at least one.
In theory you could give a user multiple roles,
and they would then get the rights from all of these roles.
With the xref:roles[predefined roles], however, this would make little sense.
endif::[]

If you *lock* users with the [.guihint]#disable the login to this account# option, they will be appear in the table with the icon:icon_user_locked[alt="Icon of a locked user."] icon.
They will no longer be able to log in, but will still remain in the system.
If a user is a contact, the notifications will not be affected and the user will continue to receive emails, etc.
If the user was logged in at the time of the lockout, they will be automatically logged off.


=== Contact groups

image::wato_user_contact_groups.png[alt="Dialog for a user's contact groups."]

As soon as you assign a user to one or more contact groups,
this user becomes a contact. When a new site is created, the
contact group [.guihint]#Everything# will also be created, which always contains all hosts and all services. A user in
this group will then be automatically responsible for _all_ hosts and services.


ifdef::onprem[]
[#user_config_notifications]
=== Notifications

image::wato_user_notifications_fallback.png[alt="Dialog for a user's notification settings."]

In the [.guihint]#Notifications# box, you can use the [.guihint]#Receive fallback notifications# option to specify that this contact will receive notifications when xref:notifications#fallback[no notification rule applies].
endif::[]


[#user_config_personal]
=== Personal settings

image::wato_user_personal_settings.png[alt="Dialog for a user's personal settings."]

ifdef::onprem[]
Users can also change all of the settings in this box xref:personal_settings[themselves] via [.guihint]#User > Edit profile# (except with the [.guihint]#Guest user# role).
endif::[]
ifdef::saas[]
Users can also change all of the settings in this box xref:personal_settings[themselves] via [.guihint]#User > Edit profile#.
endif::[]
Apart from the selection of the interface language these settings are rarely required.
Details can be found as always in the xref:user_interface#inline_help[inline help].


[#user_config_interface]
=== Interface settings

ifdef::onprem[]
image::wato_user_interface_settings.png[alt="Dialog for a user's interface settings."]
endif::[]
ifdef::saas[]
image::wato_user_interface_settings_saas.png[alt="Dialog for a user's interface settings."]
endif::[]

Users can also customize the interface settings themselves using [.guihint]#User > Edit profile#.
Of particular interest is the [.guihint]#Show more / Show less# option to determine whether {CMK} should xref:intro_gui#show_less_more[show more or show less] in the interface.
If you always want to see everything, you can force this here with [.guihint]#Enforce show more#.


[#contact_groups]
== Contact groups

=== Creating and editing contact groups

Contact groups are the link between hosts and services on the one hand and contacts on the other.
Each contact group represents a responsibility for a specific area in your IT landscape.
For example, the contact group 'SAP' could comprise all persons who maintain SAP systems and be assigned to all hosts and services that provide such services in this environment.

You manage the contact groups via [.guihint]#Setup > Users > Contact groups#.
The following figure shows this module with three manually created contact groups:

image::wato_user_contact_groups_list.png[alt="List of contact groups."]

Creating a new group is trivial.
As always, the ID is permanent and the alias is a display name that you can change later at any time:

image::wato_user_contact_groups_new.png[alt="Dialog for name and alias of contact groups."]

The new contact group is empty in two respects
-- it contains neither contacts nor hosts or services.
The assignment of contact groups to contacts is done via the user profiles, as you have already seen when editing the user.


[#visibility]
==== Setting inventory visibility

In addition, you can set the visibility of the inventory found with the xref:inventory#[HW/SW Inventory].
By default the complete inventory is visible, but it can also be completely suppressed or selectively enabled with the [.guihint]#Allowed to see parts of the tree# option and the *internal inventory paths*:

image::wato_user_contact_groups_inventory_00.png[alt="Dialog for visibility of inventory data."]

To be able to enter the required path information, you must first xref:inventory#internal_paths[read it out of the inventory data].
You can then use this information to populate the paths and keys to make, for example, only some selected inventory data of the processor (model and architecture) visible:

image::wato_user_contact_groups_inventory_03.png[alt="Dialog for visibility of inventory data with CPU filter."]


[#add_host_to_contact_group]
=== Adding hosts to a contact group

There are two methods for including hosts in contact groups: via xref:hosts_setup#folder[folder] and via xref:wato_rules#[rules].
You can also combine both methods.
In this case, an aggregation of the respective contact groups will be assigned to the host.


==== Assigning using folders

You can access the properties of a folder via [.guihint]#Folder > Properties# while you are in the folder.
There you will find the [.guihint]#Permissions# option.
Activate this checkbox to access the selection of contact groups:

image::wato_user_contact_groups_folder.png[alt="Dialog for assigning contact groups to folders."]

The real point of this option is to set permissions for maintaining hosts, which we explain in detail xref:folder_permissions[below].

As soon as you have assigned permissions for specific contact groups, you can in turn enter these groups as contact groups for the hosts in the monitoring.
In doing so, you can decide whether the assignments should also apply to hosts in subfolders and whether these hosts' services should also _explicitly_ receive these groups.
Services without explicit assignments inherit *all* of a host's contact groups -- even those assigned by rules.

[TIP]
====
The xref:hosts_setup#inheritance[inheritance] of the [.guihint]#Permissions# attribute over the folders is overridden at this point.
This allows you to add more contact groups to subfolders.
The assignment is therefore also done cumulatively via all parent folders, if in these parent folders the [.guihint]#Add these groups as contacts to all hosts in all subfolders of this folder# option has been activated.
====

By the way, you can also find the contact group options in a simplified form directly in the details for a host.
This means that you can also use them to assign contact groups to individual hosts.
However, as this can quickly become quite confusing, you should only do this in exceptional cases, and, if it becomes necessary, you may prefer to work with rules.


==== Assigning using rules

The second method -- assigning contact groups via xref:wato_rules#[rules] -- is a little more cumbersome, but much more flexible.
And it is very useful if you have not set up your folder structure according to structured organizational principles and therefore cannot clearly assign folders to contact groups.

The [.guihint]#Assignment of hosts to contact groups# rule set required for this can be found via [.guihint]#Setup > Hosts > Host monitoring rules#.
In this rule set, you will find a predefined rule that was generated when the site was created, and which assigns all hosts to the [.guihint]#Everything# contact group.

image::wato_user_contact_groups_rules_list.png[alt="Rule set for assigning hosts to contact groups."]

Note that this rule set is defined in such a way that *all* of the applicable rules are evaluated and not only the first one!
It can useful that a host belongs to more than one contact group.
In such a case you will need a rule set for each assignment.

image::wato_user_contact_groups_rules_new.png[alt="Dialog for assigning hosts to the Windows-Servers contact group."]


[#add_service_to_contact_group]
=== Including services in contact groups

It does not always make sense for a service to be in the same contact groups as its host.
You can therefore use the [.guihint]#Assignment of services to contact groups# rule set -- independently of the host's contact groups.
The following rules apply:

* If a service *is not* assigned a contact group, it automatically receives the *same contact groups as its host*.
* As soon as *at least one* contact group is explicitly assigned to a service, it *no longer* inherits the contact groups from the host.

In a simple environment, it is therefore sufficient if you only assign contact groups to the hosts.
As soon as you need more differentiation, you can also create rules for the services.


=== Controlling the assignments

You can check whether you have correctly configured all rules and folders by looking at the details for a host or service in the monitoring environment.
There you will find the entries [.guihint]#Host contact groups# and [.guihint]#Host contacts# (or [.guihint]#Service contact groups# and [.guihint]#Service contacts# respectively), which list the actual assignments for this object:

image::wato_user_contact_groups_host_details.png[alt="List of host details."]


[#visibility_host]
== Visibility of hosts and services

=== Overview

The fact that normal users (the [.guihint]#Normal monitoring user# role) only see those objects for which they are a contact is all the more important the larger your monitoring environment is.
This not only provides an uncluttered overview, but also prevents users from intervening where they have no business.

As an administrator (the [.guihint]#Administrator# role) you are of course always allowed to see everything.
This is controlled via the [.guihint]#See all host and services# permission.
In your xref:personal_settings[personal settings] you will find at [.guihint]#Visibility of hosts/services# the checkbox [.guihint]#Only show hosts and services the user is a contact for#.
With this you can voluntarily give up _see all_  and only display the hosts and services for which you are a contact.
ifdef::onprem[]
This option is intended for dual roles -- that is, for someone who is both an administrator and also a normal user.

The [.guihint]#Guest user# role is preset so that its users can also see everything.
Intervention or personal settings are disabled here.
endif::[]

For normal users, the visibility in the monitoring environment is implemented in such a way that the hosts and services for which you are not a contact for do not appear to even exist in the system.
Among other things, the following elements take visibility into account:

* xref:views#[Views] of hosts and services
* xref:dashboards#[Dashboards]
* xref:user_interface#overview[Overview] snap-in of the sidebar
* xref:reporting#[Reports] created by the user


=== Visibility of services

As we have shown above, it can be possible that you are a contact for a host but not for all of its services.
Nevertheless, in such a case you will be able to see all of the host's services in the GUI.

This exception is set by default because it is usually useful.
In practice, this means, for example, that the colleague who is responsible for the actual host can also see any services that are connected to that host -- they do not however receive any notifications for the services!

ifdef::onprem[]
If you do not like this approach, you can change it in the commercial editions via [.guihint]#Global settings > Monitoring core > Authorization settings#.
endif::[]
ifdef::saas[]
If you do not like this approach, you can change it via [.guihint]#Global settings > Monitoring core > Authorization settings#.
endif::[]
If you there change the [.guihint]#Services# setting to [.guihint]#Strict - Visible if user is contact for the service#, users will only be able to see services if they have been directly-assigned as a contact for the service.

image::wato_user_authorization_settings.png[alt="Dialog with authorization settings."]

By the way, all of this has *nothing* to do with the fact that a service inherits the contact groups of its host if no contact groups of its own have been assigned to the service,
since then you _would be_ be a contact for the service, and thus receive its notifications.


=== Host and service groups

The second option in the global [.guihint]#Authorization settings# concerns host and service groups.
You can normally see a group whenever you can see at least one element of the group, however the group will then look as if it contains only the elements that are visible to you.

Switching to [.guihint]#Strict - Visible if all members are visible# will hide all groups for which you are *not* a contact for at least one host or service.

Note that these two visibility settings have _no influence_ on the notifications.


[#notifications]
== Notifications

Contact assignments also have an influence on the notifications.
ifdef::onprem[]
{CMK} is preset so that all contacts for the affected host or service are notified in the event of a problem.
This is done by a global notification rule that is automatically generated when new sites are created.
endif::[]
ifdef::saas[]
{CMK} is preset so that all contacts of important hosts and their services are notified in the event of a problem.
This is done by global notification rules that are automatically generated when new sites are created.
endif::[]
This is a very sensible feature.

Nevertheless, if necessary, you can adapt a rule or supplement it with further rules, so that in extreme cases notifications can be made completely independently of the contact groups.
A common reason for this is that a user wishes _not_ to receive certain notifications, or vice versa, to be informed about problems with individual hosts or services, even if they are not directly responsible for them (and therefore not an explicit contact).

ifdef::onprem[]
Details on the global notification rule provided by {CMK} can be found in xref:intro_notifications#test#[Beginner's Guide].
endif::[]
ifdef::saas[]
Details on the global notification rules provided by {CMK} can be found in xref:intro_notifications#test#[Beginner's Guide].
endif::[]


[#roles]
== Roles and permissions

ifdef::onprem[]
[#predefined_roles]
=== Predefined roles
endif::[]

{CMK} always assigns permissions to users via roles -- never directly.
A role is nothing more than a list of permissions.
It is important that you understand that roles define the _level_ of permissions and not a reference to any hosts or services.
That is what contact groups are for.

ifdef::saas[]
{CE} comes with the following predefined roles:

[cols="20,~,~",options="header"]
|===
|Name of the role
|Permissions
|Function

|Administrator
|All permissions.
|The {CMK} administrator who maintains the monitoring system itself.

|Normal monitoring user
|May only see their own hosts and services, make changes in the web interface only in xref:folder_permissions[shared folders] for these, and generally may not do anything that affects other users.
|The normal {CMK} user who accesses the monitoring and reacts to any notifications.
|===

Roles are assigned to a user in the xref:admin_panel[admin panel].
The permissions for the roles cannot be changed and no new roles can be created.
endif::[]

ifdef::onprem[]
{CMK} comes with the following predefined roles, which can never be deleted, but can be customized as desired:

[cols="15,20,~,~",options="header"]
|===
|Role name
|Alias
|Permissions
|Function 

|`admin`
|Administrator
|All permissions -- especially the right to change permissions.
|The {CMK} administrator who maintains the monitoring system itself.

|`user`
|Normal monitoring user
|May only see their own hosts and services, make changes in the web interface only in xref:folder_permissions[shared folders] for these, and generally may not do anything that affects other users.
|The normal {CMK} user who accesses the monitoring and reacts to any notifications.

|`agent_registration`
|Agent registration user
|The permission to register a host's xref:wato_monitoringagents#agents[{CMK} agent] with the {CMK} server for TLS-encrypted data transmission -- nothing else.
|This role is assigned to the xref:glossar#automation_user[automation user] `agent_registration` to perform a registration with minimal rights.
In {CCE} and {CME} this role contains additional permissions for xref:hosts_autoregister#[creating hosts automatically].

|`guest`
|Guest user
|May see everything but not change anything.
|Guest is intended simply for 'looking', for which all guests share a common account.
Also useful for 'public' status monitors hanging on a wall.

|`no_permissions`
|no_permissions
|Cannot do anything.
|This role is not intended for direct assignment.
Instead, it can be used to create new roles with only the minimum required permissions.
Should new permissions be added or existing ones change in future {CMK} versions, you can still be sure that a role derived from [.guihint]#no_permissions# will not receive any new, unexpected permissions.

|===

The roles are managed via [.guihint]#Setup > Users > Roles & permissions#:

image::wato_user_roles_list.png[alt="List of user roles."]

By the way, when creating a new {CMK} site, only one user (`cmkadmin`) with the [.guihint]#Administrator# role is created for the login to the {CMK} interface.
The other possible roles will not be used for the time being.
If you require a guest user, you must create this yourself.


=== Customizing existing roles

As usual, the icon:icon_edit[alt="Icon for editing."] takes you to the edit mode for a role:

image::wato_user_roles_permissions.png[alt="List of permissions for a user role."]

You can find out what the various permissions mean (shown here in excerpts) from the xref:user_interface#inline_help[inline help].

The special feature here is that for each permission there are three choices:
[.guihint]#yes#, [.guihint]#no# and [.guihint]#default (yes)# or [.guihint]#default (no)#.
At installation all values are set to [.guihint]#default#.
For the authorization itself it makes no difference whether you have set [.guihint]#yes# or [.guihint]#default (yes)#.
It is however possible that installing a new version of {CMK} can change a default value (even if this happens very rarely).
A setting you have explicitly made would then not be affected by the installation.

In addition, this principle allows you to very quickly recognize where your {CMK} installation might have deviated from the standard.


=== Defining own roles

You may be surprised that there is no button for creating a new role.
There is a deliberate reason for this.
You create new roles by deriving them from existing roles using icon:icon_clone[alt="Icon for cloning."] [.guihint]#Clone#.
The new role is not simply created as a copy, but retains its relationship to the original role ([.guihint]#Based on role#):

image::wato_user_roles_new_role.png[alt="Basic properties of a newly created user role."]

This connection has an important function.
Because all permissions for the cloned role that are not set explicitly (i.e. are still set to [.guihint]#default#) will be inherited from the source role.
Subsequent changes in the source role will be carried-over to the new cloned role.
This is very practical if you consider how many permissions there could be in the original role.
With a simple copy, you could easily lose track of what is actually special about your own role that you have defined for yourself.

This derivation function also solves another problem:
Since we continue to develop {CMK} new permissions are continually being added.
Each time we then decide in which of the three roles [.guihint]#Administrator#, [.guihint]#Normal monitoring user# and [.guihint]#Guest user# the new permission should take.
Since each of your own roles is derived from one of the predefined roles, the new permission is automatically preset to a sensible value.
It would be very impractical if, for example, you defined your own user role and new permissions were always missing there.
You would have to adapt your role for every new feature, in order for your users to be able to use them.


=== Comparing roles with the matrix view

If you want to compare the permissions in the individual roles, you can be assisted by the matrix view, accessible via [.guihint]#Setup > Users > Roles & permissions > Roles > Permission matrix#.
This menu option creates the following view, in which you can not only compare the permissions of the individual roles,
but also see where permissions have been explicitly set (icon:icon_perm_yes[alt="Icon of an existing permission."]) or removed (icon:icon_perm_no[alt="Icon of a missing permission."] ).

image::wato_user_roles_matrix.png[alt="Matrix view with comparison of user roles."]
endif::[]


[#personal_settings]
== Personal settings

Each user can manage a small number of the user settings for their own profile.
A detailed description of all of the available options can be found in the article on the xref:user_interface#user_menu[user interface.]

ifdef::onprem[]
*An additional note for distributed monitoring*:
In a xref:distributed_monitoring#[distributed environment], any new settings are immediately transferred to all monitoring sites.
This is the only way to ensure that, in particular, a newly-assigned password also works immediately everywhere -- and not only following the next activation of changes.
However, this only works for sites that are accessible via the network at that time.
All other sites receive the updates at the next successful xref:wato#activate_changes[activation of changes.]
endif::[]


[#automation]
== Automation user (for web services)

When connecting {CMK} to other systems, there is often a desire to automate certain activities that normally take place via the GUI.
Some examples are:

* Setting and removing xref:glossar#scheduled_downtime[scheduled downtimes] using a script.
* Managing hosts via xref:rest_api#[REST API].
* Retrieving data from xref:glossar#view[views] in CSV or JSON formats for further processing.
* Retrieving the current status of xref:bi#[BI aggregations] to create them as a service.

In such situations, external software must be able to retrieve certain URLs from the {CMK} interface automatically.
This of course raises the question of how the user logs in.
The usual way via the login dialog is cumbersome and requires the retrieval of several URLs in succession and the saving of a cookie.

To simplify this, {CMK} provides the concept of xref:glossar#automation_user[automation users].
These users are exclusively for remote control and do not allow a normal login via the GUI.
Authentication is done here via HTTP Basic Authentication.

ifdef::onprem[]
Automation users are already set up in each {CMK} site: including for web services and for registering the agent with the {CMK} server for TLS-encrypted data transfer.
You can use these automation users -- or create a new one.
You create an automation user like a normal user, but do not assign a normal password, but instead an automation password ([.guihint]#Automation secret#).
You can have this password created automatically with the icon:icon_random[alt="Icon for rolling the dice."] cube:

image::wato_user_automation_user.png[alt="Automation user security settings."]

An automation user has a role just like a normal user and can also be a contact.
This means that you can restrict the permissions and visibility of hosts and services as required.
endif::[]

ifdef::saas[]
Automation users are already set up in each {CMK} site: including for web services and for registering the agent with the {CMK} server for TLS-encrypted data transfer.
You can use these.
You do not assign a normal password for an automation user, instead an automation password ([.guihint]#Automation secret#) is required.
You can have this password created automatically with the icon:icon_random[alt="Icon for rolling the dice."] cube:

image::wato_user_security_saas.png[alt=“Security settings of an automation user.”]

An automation user can be a contact just like a normal user.
This means that you can restrict the permissions and visibility of hosts and services as required.
endif::[]

For the automatic retrieval of web pages, you then enter the header of the link:https://en.wikipedia.org/wiki/Basic_access_authentication[HTTP Basic authentication^], which basically looks like this: `Authorization: Basic 1234567890abcdef`.
The character string is the Base64-encoded form of `username:password`.

Here is an example of retrieving a view in the JSON format with the automation user `automation` and the automation password from the above image -- the Base64 encoding is done by curl:

[{shell}]
----
{c-root} curl --user automation:a8075a39-e7fe-4b5c-9daa-02635 pass:['http://moni01.mycompany.net/mysite/check_mk/view.py?view_name=svcproblems&output_format=json']
 [
  "service_state",
  "host",
  "service_description",
  "service_icons",
  "svc_plugin_output",
  "svc_state_age",
  "svc_check_age",
  "perfometer"
 ],
 [
  "CRIT",
  "stable",
  "Filesystem /",
  "menu pnp",
  "CRIT - 96.0% used (207.27 of 215.81 GB), (warn/crit at 80.00/90.00%), trend: +217.07 MB / 24 hours",
  "119 min",
  "30 sec",
  "96%"
 ],
 ...
----

ifdef::onprem[]
If the script that retrieves the URL runs directly in the monitoring site, you can read the automation password for the user directly from the file system.
This is not a security vulnerability, but is intended to be so:
You can write automation scripts that do not need to contain the automation password and do not need a configuration file.
To do this, read the file `~/var/check_mk/web/myuser/automation.secret`:

[{shell}]
----
{c-omd} cat var/check_mk/web/automation/automation.secret
a8075a39-e7fe-4b5c-9daa-02635
----

You can easily store the contents of this file in a variable in the shell:

[{shell}]
----
{c-omd} SECRET=$(cat var/check_mk/web/automation/automation.secret)
{c-omd} echo "$SECRET"
a8075a39-e7fe-4b5c-9daa-02635
----

This is also used, for example, by the `downtime` script, which you will find in the {CMK} `treasures` directory, 
which you can use to set and remove script-controlled scheduled downtimes for hosts and services.
If the automation user is named `automation` as in our example, the only argument you will need is the name of the host for which you want to specify a scheduled downtime:

[{shell}]
----
{c-omd} ~/share/doc/check_mk/treasures/downtime.py myhost123
----

Further options for this script can be found in its online help:

[{shell}]
----
{c-omd} ~/share/doc/check_mk/treasures/downtime.py --help
----
endif::[]


ifdef::onprem[]
[#automatic_login_via_url]
== Automatic login via the URL

[IMPORTANT]
====
The automatic login via the URL in the browser described below has been disabled for security reasons since {CMK} {v22},
because the credentials (user name and password) passed via URL are stored in the log files of the site-specific Apache (see link:https://checkmk.com/werk/14261[Werk pass:q[#]14261^]).
If you want to use automatic login via the URL despite this security risk, 
you must explicitly enable this with the global setting [.guihint]#Setup > General > Global settings > User interface > Login via GET requests.#
====

As we have seen, you can use automation users to retrieve any URLs using a script, without the need to log in.
In situations that require a real login to the browser, however, this does not work, because the login data for any included links (e.g. to images and iframes) are not passed on.

The best example of this is the desire to hang a monitor that continuously shows a specific {CMK} dashboard on a wall.
This monitor is to be controlled by a computer that automatically opens the browser on start-up, logs on to {CMK} and calls up the required dashboard.

To achieve this, it is best to first create a special user for this purpose.
The [.guihint]#Guest user# role is well-suited for this function because it grants all read rights, but does not allow any changes or interventions.

Construct the URL for an automatic login as follows:

. Start with: `\http://mycmkserver/mysite/check_mk/login.py?_origtarget=`
. Determine the actual URL to be displayed (e.g. that of the dashboard) with your browser -- preferably without navigation -- which can be done by switching off [.guihint]#Display > Show page navigation#.
. Append this URL, leaving out everything before the `/mysite/` part.
. To the URL append the two variables `_username` and `_password` in the following form: `&_username=myuser&_password=mysecret`.
. Add another `&_login=1`.

Here is an example of such a URL:

[{shell-raw}]
----
http://mycmkserver/mysite/check_mk/login.py?_origtarget=/mysite/check_mk/dashboard.py?name=mydashboard&_username=myuser&_password=mypassword&_login=1
----

Note:

* In the example, replace the values `mycmkserver`, `mysite`, `myuser` and `mypassword` with your appropriate values.
You cannot use the automation user as `myuser`, as logging in via the GUI is not permitted for this user.

* If the special characters `&` or `%` appear in one of these values or in the value of `_origtarget`, you must replace them as follows: `&` with `%26` and `%` with `%25`.

Test the whole thing by logging out of your browser from {CMK}, and then copying the constructed URL into the address bar of your browser.
You must then go directly to the target page -- without a login dialog.
At the same time you will be logged in and can directly call the links contained in the page.

You can also try out the finished URL with `curl` on the command line.
If you have done everything correctly, you will receive the HTTP status code `302 FOUND` and be redirected to the specified `Location`, as in the following abbreviated output:

[{shell-raw}]
----
{c-omd} curl -v 'http://mycmkserver/mysite/check_mk/login.py?_origtarget=/mysite/check_mk/dashboard.py?name=mydashboard&_username=myuser&_password=mypassword&_login=1'
...
< HTTP/1.1 302 FOUND
...
< Location: /mysite/check_mk/dashboard.py?name=mydashboard
...
----

If you do not get the desired view in the browser despite this message confirming success, check the URL given under `Location`
-- even if this is incorrect, `curl` will return the HTTP status code `302 FOUND`.

If the login data is incorrect, you will receive the HTTP status code `200 OK`,
but only see the HTML code for the login page, as in the following abbreviated output:

[{shell-raw}]
----
{c-omd} curl -v 'http://mycmkserver/mysite/check_mk/login.py?_origtarget=/mysite/check_mk/dashboard.py?name=mydashboard&_username=myuser&_password=NOT&_login=1'
...
< HTTP/1.1 200 OK
...
<!DOCTYPE HTML>
<html><head><meta content="text/html; ...
...
</script>
<script type="text/javascript">
cmk.visibility_detection.initialize();
</script>
</body></html>
----
endif::[]


[#wato_permissions]
== Assigning permissions for folders

=== Function of the [.guihint]#Normal monitoring user# role

If you have a somewhat larger monitoring environment to manage, then you will want to involve fellow administrators in the configuration and especially in the management of hosts and services.
So that you retain control of _who_ is permitted to make changes, and _what_ they are allowed to do, and so that people don't get in each other's way, you can assign permissions for the {CMK} xref:wato#[Setup] on the basis of folders.

The first step to this is to have your administrator colleagues work with their own users based on the [.guihint]#Normal monitoring user# role.

This role basically has authorization for the configuration environment, but with some important restrictions:

* Only changes to hosts, services, xref:glossar#rule[rules] and xref:bi#[BI aggregations] are allowed.
* Hosts, services and rules can only be managed in xref:folder_permissions[shared folders].
* BI aggregations can only be managed in shared BI packs.
* Anything that has global implications is not allowed.

As long as you have not yet released any folders or BI packs, this means that users with the [.guihint]#Normal monitoring user# role cannot initially make any changes.
The simple [.guihint]#Setup# menu looks like this for normal monitoring users:

ifdef::onprem[]
.Setup menu for normal monitoring users in {RE}
image::wato_user_setupmenu.png[alt="Setup menu for normal monitoring users in {RE}.",width=86%]
endif::[]
ifdef::saas[]
.Setup menu for normal monitoring users
image::wato_user_setupmenu_saas.png[alt="Setup menu for normal monitoring users.",width=86%]
endif::[]


[#folder_permissions]
=== Allowing users to manage hosts

A user receives the authorization to create, edit and remove hosts via xref:contact_groups[contact groups].
The procedure is as follows:

. Add the user to a contact group.
. Designate one or more xref:hosts_setup#folder[folders] for which the user is to be authorized.
. Activate the [.guihint]#Permissions# property for these folders and select the contact group here.

The following example shows the properties of a folder in which all of the users of the contact group `Linux` are allowed to manage hosts.
The option has been activated to allow this in subfolders as well.

image::wato_user_user_folder.png[alt="Folder properties with the shared contact group Linux."]

Whether you want to automatically include the hosts in the contact group is up to you.
In this example the option [.guihint]#Add these groups as contacts to all hosts in this folder# has not been set and the hosts will not be added to the contact group `Linux`.
This means that in the monitoring environment they will not be visible to the `Linux` contact group (unless a rule takes care of this).
So, as you can see, the visibility (and responsibility in the monitoring) and the authorization for the configuration environment can be separately regulated.


ifdef::onprem[]
[#passwords]
== Passwords

=== Password security

Security is a high priority these days.
Therefore, in some companies there are general guidelines on how to deal with passwords.
{CMK} offers several settings to enforce such defaults.
Some of them can be found under [.guihint]#Global settings > User management > Password policy for local accounts#:

image::wato_user_password_policy.png[alt="Dialog for password rules."]

The first option [.guihint]#Minimum password length# is to ensure the quality of the password.

For the second option [.guihint]#Number of character groups to use# there are a total of four character groups:

* lower case letters
* upper case letters
* digits
* special characters

If you enter a `4` here, a password must contain at least one character from each of the above groups.
With a `2` it at least ensures that the password does not, for example, consist only of lower case letters.
These settings are checked each time the password is changed.

The third option [.guihint]#Maximum age of passwords# forces the user to change their password at regular intervals.
Once the time has come, the next page access will present the user with the following prompt:

image::wato_user_forced_password_change.png[alt="Forced password change dialog."]

Users may continue only after changing their password.

You can require a change of the initial password at the first login.
This is done with the [.guihint]#Enforce change: Change password at next login or access# option in the [.guihint]#Security# section in the properties for the respective user.


=== Login policies

Under [.guihint]#Global settings > User management# you will find further global settings that regulate user logins.


[#suspension]
==== Locking following invalid logins

With the [.guihint]#Lock user accounts after N logon failures# setting, you can lock an account after a series of failed login attempts:

image::wato_user_login_failures.png[alt="Dialog for automatic login deactivation."]

Unlocking is then only possible by a user with the [.guihint]#Administrator# role.
As an administrator, you can unlock other users via [.guihint]#Setup > Users > Users# and then the properties of the locked user.
Note that administrator accounts can _also_ be locked!
If you are permanently locked out as the last or only admin, you can only unlock your account via the command line.
To do this, edit the `~/etc/htpasswd` file as a site user and remove the exclamation mark from the line of the affected user, here `myuser`:

[{shell}highlight=5;12]
----
{c-omd} cat etc/htpasswd
pass:[agent_registration:$2y$12$83XzYwtQJVFizC...]
pass:[automation:$2y$12$zKF4Sasws7rDJCByZ1r5ke...]
pass:[cmkadmin:$2y$12$ZmE96frGSm9sdWiWRXtxbuyu...]
pass:[myuser:!$2y$12$8FU93yH7TFTyJsyUvKCh1eqYJG..]
{c-omd} vim etc/htpasswd
...
{c-omd} cat etc/htpasswd
pass:[agent_registration:$2y$12$83XzYwtQJVFizC...]
pass:[automation:$2y$12$zKF4Sasws7rDJCByZ1r5ke...]
pass:[cmkadmin:$2y$12$ZmE96frGSm9sdWiWRXtxbuyu...]
pass:[myuser:$2y$12$8FU93yH7TFTyJsyUvKCh1eqYJG...]
----

Then you can log in again.


==== Automatic logouts

In the [.guihint]#Session management# box, you can specify two different ways of ending a session and combine these with each other:
on the one hand depending on the session duration, on the other hand depending on the user activity.

[.guihint]#Maximum session duration# ensures that the session is ended automatically after a set period of time.
Among other things, this reduces the risk of external use of the session, as it does not remain active indefinitely:

image::wato_user_session_management.png[alt="Session termination dialog."]

Once the defined session duration has expired, the user must log in again, regardless of whether they were active at the end of the session or not.
At the same time, you can use [.guihint]#Advise re-authentication before termination# to specify when the user should be notified to save their entries, log out and log in again before a 'hard' termination of their session:

image::wato_user_session_termination.png[alt="Warning before session termination."]

The [.guihint]#Set an individual idle timeout# setting ensures that a session is ended if a user does not actively use the GUI for a longer period of time,
for example, if they have temporarily left their workstation without logging out in {CMK}.
This timeout can be stopped by actively using the GUI.
However, it is not enough just to have a view open that reloads itself regularly.


==== Preventing multiple logins

The [.guihint]#Limit login to single session at a time# setting prevents a user from logging in to {CMK} with two browsers at the same time:

image::wato_user_limit_login.png[alt="Dialog to limit the number of sessions."]

This option is also linked to a timeout for an automatic logout in the event of inactivity.
This feature also makes sense.
Let's assume, you have forgotten to log off at your workstation before closing the browser.
In this situation, without a timeout, you would not be able to log on from home while you are on call, 
since closing the browser or shutting down the computer does not automatically trigger a logout!

When attempting a second login in parallel, you will then see the following error message:

image::wato_user_another_session_is_active.png[width=60%, align=center, alt="Locked login dialog with notification of an already active session."]

In this case, the login can only be carried out if you actively terminate the existing session or wait for it to timeout.


[#2fa]
=== Two-factor authentication

To improve the security of your {CMK} sites, {CMK} provides the feature of two-factor authentication for each user. 
This two-factor authentication is based on the FIDO2/WebAuthn Internet standard.
Authentication is conventionally based on knowledge (a password) and possession (an authenticator).

You can use any FIDO2-compatible hardware supported by your browser and operating system.
USB or NFC tokens such as the YubiKey are the most widely used. 
Alternatively, it is possible to use software authenticators (authenticator apps on the smartphone) that generate a _time-based one-time password (TOTP)_.


[#2fareq]
==== Requirements for the {CMK} server

Due to the specifications of the WebAuthn standard, there are three prerequisites for the use of two-factor authentication:

* The {CMK} web interface is xref:omd_https#[secured with HTTPS]. 
* The web address is specified as a simple host name or as a fully qualified domain name -- in any case as a valid domain address.
* The URL is always entered in the same format, e.g. always `\https://www.mycompany.com/mysite`.


[#2fasetup]
==== Setup

Access two-factor authentication from the xref:user_interface#user_menu[User menu:]

image::wato_user_2fa.png[alt="Selecting two-factor authentication from the User menu.", width=65%]

You will now be given two options marked with the key icon icon:icon_2fa_add[alt="Icon of a credential."] to add the second factor: 
[.guihint]#Register authenticator app# for configuring an app that generates one-time passwords, and [.guihint]#Register security token# for using a hardware token.

image::wato_user_2fa_2.png[alt="Setup page for two-factor authentication."]

{CMK} recognizes the authentication options available on your computer.
A small dialog opens in the browser window in which you specify the authenticator.
If you are using a hardware token, the setup is completed when you touch the button.
When using one-time passwords, first scan the displayed QR code with the authenticator app and enter a code that you generate with the app for confirmation.
The session will continue seamlessly in both cases.


[#2falogin]
==== Login

Two-factor authentication will then be active in {CMK} for future login attempts.
First, enter your user name and password as usual.
Then a second login dialog appears:

image::wato_user_2fa_login.png[alt="Logging in with the second authentication factor.", width=56%]

After activating the authenticator, you can work with {CMK} as usual.


[#2fabackup]
==== Creating and using backup codes

In case you do not have your authenticator at hand, you can alternatively enter a backup code.

To do this, create a list of backup codes in advance on the [.guihint]#User > Two-factor authentication# page using icon:icon_regenerate[alt="Icon for backup codes."] [.guihint]#Generate backup codes#:

image::wato_user_2fa_backup.png[alt="Display of created backup codes.", width=85%]

Keep these codes in a secure place.

After you have generated backup codes, the additional option [.guihint]#Use backup code# is displayed in the second login dialog [.guihint]#Two-factor authentication#.
Click on this if you want to log in to {CMK} with a backup code.
The second login dialog will be replaced so that you can enter a backup code there:

image::wato_user_2fa_login2.png[alt="Prompt to enter the backup code.", width=56%]


[#2faadmin]
==== Checking and overriding two-factor authentication as an administrator

As an administrator, in the user management ([.guihint]#Setup > Users > Users#) you can see which users have had a two-factor authentication set up by looking at the entry in the [.guihint]#Authentication# column.

image::wato_user_2fa_admin.png[alt="View of two-factor authentication in user management."]

If one of these users no longer has access to {CMK} -- if they have lost or damaged their hardware token, for example -- you can remove the two-factor authentication for this user.
To do this, open the relevant entry in the user management by clicking on icon:icon_edit[alt="Icon for editing."].
Remove the two-factor authentication for this user with [.guihint]#User > Remove two-factor authentication#.

image::wato_user_2fa_remove.png[alt="Removing the two-factor authentication.", width=39%]

After your approval of the confirmation dialog, the user will be able log in to the {CMK} web interface again using 'only' the user name and password.


[#change_passwd]
=== Changing a password using the command line

In an emergency, you can also change a password via the command line.
This saves you in a situation in which you have lost the password for `cmkadmin`.
The prerequisite is, of course, that it is still possible to log in as a Linux user on the {CMK} server and that you can become a site user with `omd su mysite`.

The passwords are stored in the `~/etc/htpasswd` file, as already described xref:suspension[above].

Changing passwords is accomplished with the `cmk-passwd` command.
This will *not* ask you for the existing password.
`cmk-passwd` will always choose a secure encryption method to store your passwords in a current version of {CMK}.
Currently `cmk-passwd` uses bcrypt for this.
Unencrypted and weakly encrypted passwords (e.g. with MD5) do not allow login to the GUI.

[{shell}]
----
{c-omd} cmk-passwd cmkadmin
New password: secret
Re-type new password: secret
----
endif::[]


[#custom_user_attributes]
== Custom user attributes

ifdef::onprem[]
In addition to the field for the email address, the field [.guihint]#Pager address# is also available for notifying users.
endif::[]
ifdef::saas[]
For notifying users the email address is available.
endif::[]
If this is not sufficient and you would like to store more information about a user,
you can create your own fields via [.guihint]#Setup > Users > Custom user attributes > Add attribute#, which can then be filled with individual values for each user.

Creating such a new attribute opens the following dialog:

image::wato_user_custom_macro.png[alt="Dialog for custom attributes."]

As always, the ID ([.guihint]#Name#) cannot be changed later, but the title ([.guihint]#Title#) can.
The [.guihint]#Topic# determines in which section of the user settings the new field will be sorted.
Furthermore, you can decide whether users can edit the field themselves (it will then appear in their personal settings)
and whether the value should be displayed directly in the [.guihint]#Setup# user table.

Only if you activate the checkbox at [.guihint]#Make this variable available in notifications# can you also use this value in notifications.
ifdef::onprem[]
For this, the value must be assigned to the monitoring core (e.g. xref:cmc#[CMC]) in a variable (a so-called 'custom macro').
endif::[]
ifdef::saas[]
For this, the value must be assigned to the xref:cmc#[CMC] monitoring core in a variable (a so-called 'custom macro').
endif::[]

The name of the custom variable is derived from the ID you have chosen.
This is converted to capital letters and is prefixed by a `CONTACT_`. A `phone` then becomes `CONTACT_PHONE`.
Note that when the variable is passed via environment variables the variable will be prefixed with `NOTIFY_`.
With your own xref:notifications#scripts[notification script] the variable will arrive as `NOTIFY_CONTACT_PHONE`.


[#messages]
== Writing messages to users

In the article describing xref:notifications#[notifications], we go into great detail about how {CMK} can inform contacts about problems with hosts or services.
However, sometimes you may want to notify all users (even those who are not contacts) of internal organizational matters, for example, maintenance of the {CMK} system itself.

For such purposes {CMK} offers a small built-in message tool, which is completely separate from the notifications.
You can find the tool via [.guihint]#Setup > Users# and there in [.guihint]#Users > Send user messages#.
Here you have the facility to send a message to all or some of your users.

image::wato_user_notify_users.png[alt="Dialog for user messages."]

You can choose between four message types:

[cols="30,~"]
|===
|[.guihint]#Show popup message#
|The next time the user opens the page, a popup window with the message will be opened.

|[.guihint]#Show hint in the 'User' menu#
|The user is pointed to the message by a number symbol in the xref:user_interface#user_menu[User menu] of the navigation bar.

|[.guihint]#Send email#
|Sends an email.
ifdef::onprem[]
However, this will only reach users who also have an email address configured.
endif::[]

|[.guihint]#Show in the dashboard element 'User messages'#
|The message is displayed in an xref:dashboards#builtin_dashlets[dashlet] of the type [.guihint]#User messages#.
|===

With [.guihint]#Message expiration# you can easily delete messages that have not yet been retrieved as soon as they are no longer relevant.


ifdef::onprem[]
[#further_topics]
== Further topics

{CMK} supports more methods of logging in:

* Connection of an xref:ldap#[LDAP/Active Directory]
* Authentication with xref:saml#[SAML]
* Authentication with xref:kerberos#[Kerberos]
* Authentication in a setup with reverse proxy
* Authentication with HTTP Basic Authentication


[#files]
== Files and directories

The following list shows which files and directories on the {CMK} server are concerned with user management.
As always all entries here are relative to the site directory (e.g. `/omd/sites/mysite`).

[cols="30,~",options="header"]
|===
|Path
|Function

|`~/etc/htpasswd`
|Passwords for users in Apache `htpasswd` format.

|`~/etc/auth.secret`
|This file contains a random secret used to sign login cookies.
In distributed environments, this file should be the same for all sites -- and will be so if you set everything up with the web interface.
If this file is changed, all logins are immediately invalidated and users must log in again.
This file is privileged `660` because read access by a third party would make it possible to forge a login.

|`~/etc/auth.serials`
|Serial numbers of passwords per user.
Any change of the password increments the serial number and thus invalidates all current sessions.
This ensures that a password change reliably logs a user out.

|`~/etc/check_mk/multisite.d/wato/users.mk`
|Contains the users set up with the configuration environment.
Only the data on the users who deal purely with the GUI is stored here.
Manual changes in this file take effect immediately.

|`~/etc/check_mk/conf.d/wato/contacts.mk`
|Contact information for the users set up with the configuration environment.
All data relevant to the configuration of the monitoring core is stored here.
Only users who are also contacts are listed here.
For manual changes to take effect here, the new configuration must be loaded into the core -- e.g. with `cmk -O`.

|`~/var/check_mk/web`
|Every user who has logged in to the GUI at least once has a subfolder here where things like custom views and reports, the current sidebar configuration and much more are stored in small individual files with the extension `.mk`.
These files have Python format.

|`~/var/log/web.log`
|Log file of the user interface.
Here you will find error messages regarding authentication and LDAP connections.
|===
endif::[]