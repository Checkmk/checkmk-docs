// -*- coding: utf-8 -*-
// IGNORE % Verbindungs namen oracle_processes subfolders synchronisation →
// SKIPCOMMITS 2025-08-28
include::global_attr.adoc[]
= Services verstehen und konfigurieren
:revdate: 2024-04-24
:title: Services verstehen und konfigurieren - Elemente eines Hosts erkennen und überwachen
:description: {CMK} erkennt und konfiguriert die Services von überwachten Hosts automatisch. Lesen Sie hier, wie Sie die Überwachung von Services selbst anpassen.

{related-start}
xref:monitoring_basics#[Grundlagen des Monitorings mit {CMK}]
xref:hosts_setup#[Verwaltung der Hosts]
xref:wato_rules#[Regeln]
{related-end}


== Einleitung

Die Services sind das eigentliche Fleisch im Monitoring-System.
Jeder Einzelne von ihnen repräsentiert ein wichtiges Rädchen in Ihrer komplexen IT-Landschaft.
Der Nutzen des ganzen Monitorings steht und fällt damit, wie treffsicher und
sinnvoll die Services konfiguriert sind. Schließlich soll das Monitoring
zuverlässig melden, wenn sich irgendwo ein Problem abzeichnet, aber auf der
anderen Seite falsche und nutzlose Benachrichtigungen unbedingt vermeiden.

[{image-left}]
image::wato_services_services_illu.png[width=300]

Bei der Konfiguration der Services zeigt {CMK} seine vielleicht größte Stärke:
Es verfügt über ein einzigartiges und sehr mächtiges System für eine
_automatische Erkennung und Konfiguration von Services._ Sie müssen mit {CMK}
nicht jeden einzelnen Service über Schablonen und Einzelzuweisungen definieren.
Denn {CMK} kann die Liste der zu überwachenden Services sehr zuverlässig
automatisch ermitteln und vor allem auch _aktuell halten._  Das spart nicht nur
sehr viel Zeit -- es macht das Monitoring auch _genauer._ Denn es stellt sicher,
dass die täglichen Änderungen im Rechenzentrum auch immer zeitnah im Monitoring
abgedeckt werden und kein wichtiger Dienst ohne Monitoring bleibt.

Die Service-Erkennung in {CMK} basiert auf einem wichtigen Grundprinzip:
der Trennung des _Was_ vom _Wie_:

* *Was* soll überwacht werden? → Das Dateisystem `/var` auf dem Host `myserver01`
* *Wie* soll es überwacht werden? → Bei 90{nbsp}% belegtem Platz {WARN}, bei 95{nbsp}% {CRIT}

Das _Was_ wird bei der Service-Erkennung automatisch ermittelt. Es
setzt sich aus dem *Host-Namen* (`myserver01`), dem
xref:checkplugins[*Check-Plugin*] (`df:` Dateisystemcheck
unter Linux) und dem *Item* (`/var`) zusammen.  Check-Plugins, die auf
einem Host maximal einen Service erzeugen können, benötigen kein Item
(z.B. das Check-Plugin für die CPU-Ausnutzung). Das Ergebnis der Erkennung
ist eine Tabelle, die Sie sich so vorstellen können:

[cols=3,options="header"]
|===
|Host |Check-Plugin |Item
|`myserver01` |`df` |`/`
|`myserver01` |`df` |`/var`
|`myserver01` |`cpu.util` |
|... |... |...
|`app01cz2` |`hr_fs` |`/`
|... |... |...
|===

Das _Wie_ -- also die Schwellwerte/Check-Parameter für die
einzelnen Services -- wird unabhängig davon über xref:wato_rules#[Regeln]
konfiguriert. Sie können z.B. eine Regel aufstellen, dass alle Dateisysteme mit
dem Mount-Punkt `/var` mit den Schwellwerten 90{nbsp}% / 95{nbsp}% überwacht werden,
ohne sich dabei Gedanken machen zu müssen, auf welchen Hosts denn nun
überhaupt so ein Dateisystem existiert. Das ist es, was die Konfiguration mit
{CMK} so einfach und übersichtlich macht!

Einige wenige Services können nicht über eine automatische Erkennung eingerichtet werden.
Dazu gehören z.B. Checks, die per HTTP bestimmte Webseiten abrufen sollen.
Diese werden per Regeln angelegt; wie, erfahren Sie im Artikel über die xref:active_checks#[aktiven Checks.]

Die Möglichkeiten von {CMK}, sich selber zu überwachen, werden im Artikel xref:self_monitoring#[Das eigene System überwachen] aufgeführt.


[#discovery]
== Services eines Hosts im Setup

=== Host neu aufnehmen

ifdef::saas[]
[TIP]
====
Bei Verwendung der für Autoregistrierung xref:intro_setup_monitor#first[vorkonfigurierten Agentenpakete] von {CE} wird dieser erste Schritt – das Hinzufügen der Services – automatisch durchgeführt.
Die gezeigten Schritte sind jedoch notwendig, wenn Sie beispielsweise ein _Vanilla_ Agentenpaket verwenden, das flexibel sowohl mit {CE} als auch den On-Premises-Editionen von {CMK} genutzt werden kann.
====
endif::[]

Nachdem Sie einen neuen Host im Setup aufgenommen haben, ist der nächste Schritt, die Liste der Services aufzurufen.
Hierbei läuft bereits das erste Mal die Service-Erkennung für den Host, gleichzeitig wird die Erreichbarkeit der Datenquellen geprüft. Sie können diese Liste auch jederzeit später wieder aufrufen, um die Erkennung neu zu starten oder Anpassungen an der Konfiguration vorzunehmen.
Sie erreichen die Service-Liste auf verschiedene Arten:

* über den Knopf icon:icon_save_to_services[] [.guihint]#Save & run service discovery# in den [.guihint]#Properties of host# im Setup
* in der Menüleiste der [.guihint]#Properties of host# über [.guihint]#Host > Run service discovery#
* über das Symbol icon:icon_services[] in der Liste der Hosts in einem Ordner im Setup
* über den Eintrag icon:icon_services[] [.guihint]#Run service discovery# im Aktionsmenü des Services xref:discovery_check[[.guihint]#Check_MK Discovery#] eines Hosts

Wenn der Host gerade neu aufgenommen wurde, ist noch kein Service konfiguriert und daher erscheinen alle gefundenen Services in der Rubrik [.guihint]#Undecided services - currently not monitored#:

image::wato_services_first_service_discovery.png[alt="Ansicht der Services of host nach der ersten Service-Erkennung"]

Der übliche Weg ist nun einfach das Hinzufügen der Services über den Knopf icon:icon_accept[] [.guihint]#Accept all#.
Auf diese Weise werden zeitgleich auch alle neuen Host-Labels mit aufgenommen.
Danach ein [.guihint]#Activate changes# und schon ist der Host samt Services im Monitoring.


[#available]
=== Fehlende Services hinzufügen

Bei einem Host, der bereits überwacht wird, sieht diese Liste anders aus.
Anstelle von [.guihint]#Undecided services - currently not monitored# sehen Sie [.guihint]#Monitored services#.
Sollte {CMK} allerdings feststellen, dass es auf dem Host etwas gibt, das aktuell nicht überwacht wird, aber überwacht werden _sollte,_ dann sieht das etwa so aus:

image::wato_services_adding_newly_discovered_services.png[alt="Liste von erkannten, nicht aufgenommen Services."]

Ein Klick auf icon:icon_service_to_old[] [.guihint]#Monitor undecided services# oder auf icon:icon_accept[] [.guihint]#Accept all# fügt abermals alle fehlenden Services hinzu, so dass die Überwachung wieder vollständig ist. Wenn Sie nur manche der fehlenden Services aufnehmen möchten, können Sie in den jeweiligen Zeilen auf den Knopf icon:icon_service_to_old[] für [.guihint]#Move to monitored services# klicken.

[#vanished]
=== Verschwundene Services

Im Rechenzentrum können Dinge nicht nur neu auftauchen, sondern auch verschwinden.
Eine Datenbankinstanz wird abgeschafft, eine LUN ausgehängt, ein Dateisystem entfernt u.s.w. {CMK} erkennt solche Services dann automatisch als verschwunden _(vanished)._
In der Service-Liste sieht das z.B. so aus:

image::wato_services_vanished_services.png[alt="Listeneintrag eines verschwundenen Services."]

Der einfachste Weg um diese Services loszuwerden ist erneut ein Klick auf icon:icon_accept[] [.guihint]#Accept all#.
Alternativ können Sie die verschwundenen Services auch über den Knopf icon:icon_service_to_removed[] [.guihint]#Remove vanished services# entfernen.
*Achtung:* Der Grund für das Verschwinden kann durchaus auch ein Problem sein!
Das Verschwinden eines Dateisystems kann ja auch bedeuten, dass dieses aufgrund eines Fehlers nicht gemountet werden konnte.
Und für solche Fälle ist das Monitoring schließlich da!
Sie sollten den Service also nur dann entfernen, wenn Sie wissen, dass hier eine Überwachung auch wirklich keinen Sinn mehr macht.


[#remove_unwanted_services]
=== Ungewünschte Services loswerden

Nicht alles, was {CMK} findet, möchten Sie auch unbedingt überwachen.
Zwar arbeitet die Erkennung durchaus zielgerichtet und kann schon viel Unnützes im Vorfeld ausschließen.
Doch woher soll {CMK} z.B. wissen, dass eine bestimmte Datenbankinstanz nur zum „Herumspielen“ eingerichtet wurde und nicht produktiv ist?
Sie können solche Services auf zwei Arten loswerden:


==== Vorübergehendes Abschalten von Services

Um bestimmte Services vorübergehend aus dem Monitoring zu entfernen, klicken Sie entweder auf das Symbol icon:icon_service_to_undecided[].
Hiermit wird der Service wieder in die Liste der [.guihint]#Undecided services# verschoben.
Oder Sie deaktivieren den Service gänzlich, indem Sie am Anfang der Zeile auf icon:icon_move_to_disabled[] klicken.
Und natürlich, wie immer [.guihint]#Activate changes# nicht vergessen.

Das Ganze ist allerdings nur für vorübergehende und kleinere Maßnahmen gedacht.
Denn die so abgewählten Services werden von {CMK} dann wieder als [.guihint]#missing# angemahnt.
Und der xref:discovery_check[Discovery Check] (den wir Ihnen weiter unten zeigen) wird ebenfalls nicht glücklich damit sein.
Außerdem ist das in einer Umgebung mit ein paar zigtausend Services einfach zu viel Arbeit und nicht wirklich praktikabel{nbsp}...


[#disabled_services]
==== Permanentes Abschalten von Services

Viel eleganter und dauerhafter ist das permanente Ignorieren von Services mit
Hilfe des xref:wato_rules#[Regelsatzes] [.guihint]#Disabled services#. Hier
können Sie nicht nur einzelne Services vom Monitoring ausschließen, sondern
Regeln wie „Auf dem Host [.guihint]#myserver01# sollen keine Services überwacht
werden, die mit _myservice_ beginnen.“ formulieren.

Sie erreichen die Regel über [.guihint]#Setup > Services > Discovery rules > Discovery and {CMK} settings > Disabled services#.

image::wato_services_disabled_services_conditions.png[alt="Eingabemaske für Discovery-Bedinungen."]

Wenn Sie die Regel speichern und erneut auf die Serviceliste des Hosts gehen,
finden Sie die stillgelegten Services gemeinsam mit manuell deaktivierten
Services unter [.guihint]#Disabled services.#

image::wato_services_disabled_services.png[alt="Liste mit Services mit unterschiedlichen Status."]


[#refresh]
=== Services auffrischen

Es gibt einige Check-Plugins, die sich während der Erkennung Dinge
_merken._  So merkt sich z.B. das Plugin für Netzwerkinterfaces die
Geschwindigkeit, auf die das Interface während der Erkennung eingestellt
war. Warum? Um Sie zu warnen, falls sich diese ändert! Es ist selten ein
gutes Zeichen, wenn ein Interface mal auf 10 Mbit/s, mal auf 1 Gbit/s eingestellt
ist -- eher ein Hinweis auf eine fehlerhafte Autonegotiation.

Was aber, wenn diese Änderung gewollt ist und von nun an als OK gelten soll?
Entfernen Sie entweder den Service über das Symbol
icon:icon_service_to_undecided[] für [.guihint]#Move to undecided services# und
fügen Sie ihn anschließend wieder hinzu. Dazu müssen Sie nach dem Entfernen
einmal speichern. Oder Sie frischen _alle_ Services des Hosts auf, indem Sie in
der Menüleiste auf [.guihint]#Actions > Remove all and find new# klicken. Das
ist natürlich viel bequemer -- geht aber nur, wenn Sie nicht einzelne Services
im Fehlerzustand behalten wollen.


[#update_labels]
=== Host- und Service-Labels aktualisieren

Über die Menüleiste haben Sie über [.guihint]#Actions > Host labels > Update host labels# bzw. [.guihint]#Actions > Services > Update host labels# auch die Möglichkeit nur die Liste der zugehörigen Host- und Service-Labels zu aktualisieren.
Sollte es mal notwendig sein nur einzelne (neue) Service-Labels aufzunehmen bzw. zu aktualisieren, dann ist dies in der Zeile des jeweiligen Service im Kasten [.guihint]#Changed services# durch Anklicken von icon:button_update_service_labels[] möglich.

image::wato_services_update_service_labels.png[alt="Neue Service-Labels in der Service-Erkennung und der Knopf für deren Aufnahme ins Monitoring."]


ifdef::onprem[]
[#snmp]
=== Besonderheiten bei SNMP

Bei Geräten, die per SNMP überwacht werden, gibt es ein paar Sonderheiten.
Diese erfahren Sie im xref:snmp#services[Artikel über SNMP.]
endif::[]


[#bulk_discovery]
== Bulk-Erkennung -- Service-Erkennung für viele Hosts gleichzeitig

Wenn Sie die Erkennung für mehrere Hosts auf einmal machen wollen, können Sie sich die Arbeit mit xref:hosts_setup#bulk_operations[Bulk-Aktionen] von {CMK} erleichtern.
Wählen Sie zunächst aus, auf welchen Hosts die Erkennung durchgeführt werden soll.
Dazu haben Sie mehrere Möglichkeiten:

. In einem Ordner die Checkboxen bei einzelnen Hosts ankreuzen und dann in der Menüleiste auf [.guihint]#Hosts > On selected hosts > Run bulk service discovery# drücken.
. Mit der xref:hosts_setup#search[Host-Suche im Setup] Hosts suchen, alle gefundenen mit einem Klick auf das Kreuz icon:button_select_all[] auswählen und wieder in der Menüleiste über [.guihint]#Hosts > On selected hosts > Run bulk service discovery# gehen.
. In einem Ordner in der Menüleiste auf [.guihint]#Hosts > *In this folder* > Run bulk service discovery# klicken.

Bei der dritten Variante können Sie die Service-Erkennung auch rekursiv in allen Unterordnern ausführen lassen.
In allen drei Fällen gelangen Sie im nächsten Schritt zu folgendem Dialog:

image::wato_services_bulk_discovery.png[alt="Eingabemaske für Optionen der Service-Erkennung."]

Im Drop-down-Menü [.guihint]#Parameters# ist die Option [.guihint]#Custom service configuration update# vorausgewählt.
Die vier Checkboxen darunter bieten genau die Möglichkeiten, die Sie auch in der Service-Liste im Setup haben und die wir schon weiter oben erläutert haben.
Im Drop-down-Menü haben Sie zusätzlich noch die Möglichkeit [.guihint]#Refresh all services (tabula rasa)# auszuwählen.

Unter [.guihint]#Selection# können Sie die Auswahl der Hosts noch mal steuern.
Das ist vor allem dann sinnvoll, wenn Sie diese nicht per Checkboxen, sondern über den Ordner ausgewählt haben.
Die meisten Optionen zielen auf eine Beschleunigung der Discovery hin:

// ML: icon_inventory_failed-Icon: Konnte das nicht nachstellen, weiß nicht, ob das richtig ist (rein namentlich passt es nicht ...).

[cols=2]
|===
|[.guihint]#Include all subfolders#|Wenn Sie die Service-Erkennung für einen
Ordner gestartet haben, dann ist diese Option überhaupt nur verfügbar und
standardmäßig aktiv. Die Service-Erkennung wird dann auch bei allen Hosts in den
Unterordnern des aktuell geöffneten Ordners durchgeführt.
|[.guihint]#Only include hosts that failed on previous discovery# |Hosts, bei denen eine frühere Service-Erkennung per Bulk-Aktion fehlgeschlagen ist (z.B. weil der Host zu dem Zeitpunkt nicht erreichbar war), werden von {CMK} mit dem Symbol icon:icon_inventory_failed[] markiert. Diese Option erlaubt, die Erkennung nur genau für diese Hosts zu wiederholen.
|[.guihint]#Only include hosts with a failed discovery check# |Dies schränkt die Erkennung auf solche Hosts ein, bei denen der xref:discovery_check[Discovery Check] angeschlagen hat. Wenn Sie mit dem Discovery Check arbeiten, ist das eine gute Methode, um das Discovery von vielen Hosts massiv zu beschleunigen. Die Kombination mit der Option [.guihint]#Refresh all services (tabula rasa)# macht hier allerdings weniger Sinn, da dies den Status von bestehenden Services verfälschen kann.
|[.guihint]#Exclude hosts where the agent is unreachable# |Hosts, die nicht erreichbar sind, verursachen beim Discovery Wartezeiten durch Verbindungs-Timeouts. Dies kann das Discovery einer größeren Zahl von Hosts stark verlangsamen. Wenn die Hosts aber schon im Monitoring sind und dieses weiß, dass die Hosts {DOWN} sind, können Sie diese hiermit überspringen und die Timeouts somit vermeiden.
|===

Die [.guihint]#Performance options# sind so voreingestellt, dass immer ein
vollständiger Service-Scan durchgeführt wird. Wenn Sie nicht auf neue Plugins
aus sind, können Sie die Erkennung durch Wegnahme der Option beschleunigen.
////
Das Arbeiten ohne Cache-Dateien ist nur in Ausnahmefällen ratsam. Insbesondere bei
Hosts, die per {CMK}-Agent überwacht werden, kann es dann sogar dazu kommen,
dass, wenn es der Zufall will, neue Logmeldungen quasi von der Discovery
„verbraucht“ werden und nicht mehr beim eigentlichen Check ankommen.
////
Die eingestellte `10` unter [.guihint]#Number of hosts to handle at once#
bedeutet, dass immer zehn Hosts auf ein mal bearbeitet werden. Intern geschieht
das mit einem HTTP-Request. Sollten Sie Probleme mit Timeouts haben, weil
einzelne Hosts sehr lange zum Erkennen brauchen, können Sie versuchen,
diese Zahl kleiner einzustellen (zulasten der Gesamtdauer).

Sobald Sie den Dialog bestätigen, geht es los und Sie können den Fortschritt
beobachten:

image::wato_services_bulk_discovery_progress.png[alt="Status der laufenden Service-Erkennung."]


[#parameters]
== Check-Parameter von Services

Viele der Check-Plugins können über Parameter konfiguriert werden.
Die häufigste Anwendung ist das Setzen von Schwellwerten für
{WARN} und {CRIT}. Parameter können aber auch deutlich komplexer aufgebaut sein,
wie das Beispiel der Temperaturüberwachung mit {CMK} zeigt:

image::wato_services_example_check_parameters_temperature_levels.png[]

Die Check-Parameter für einen Service werden in drei Schritten
gebildet:

. Jedes Plugin hat Standardwerte für die Parameter.
. Manche Plugins setzen Werte während der Erkennung (siehe xref:refresh[oben]).
. Parameter können über Regeln gesetzt werden.

Dabei haben Parameter aus Regeln Vorrang vor den bei der Erkennung gesetzten
und diese wiederum Vorrang für den Defaultwerten. Bei komplexen Parametern,
bei denen per Checkbox einzelne Unterparameter festgelegt werden (wie im
Beispiel mit der Temperatur), gilt diese Vorrangregel für jeden einzelnen
Unterparameter separat. Wenn Sie also per Regel nur einen der Unterparameter
anpassen, bleiben die anderen auf ihren jeweiligen Defaultwerten.
So können Sie z.B mit einer Regel die Trendberechnung der Temperatur aktivieren
und mit einer anderen die Temperaturschwellwerte für einen konkreten Sensor einstellen.
Der komplette Parametersatz wird dann aus beiden Regeln zusammengesetzt.

Welche Parameter ein Service am Ende genau hat, erfahren Sie in der
Parameterseite des Services. Diese erreichen Sie in der Serviceliste eines Hosts
über das Symbol für die Check-Parameter icon:icon_check_parameters[]. Wenn Sie
die Parameter von allen Services direkt in der Service-Tabelle sehen möchten,
können Sie diese mit über die Menüleiste [.guihint]#Display > Details > Show
check parameters# einblenden. Das sieht dann etwa so aus:

image::wato_services_check_parameters.png[]


== Anpassen der Service-Erkennung

Wie Sie die Service-Erkennung konfigurieren, um nicht erwünschte Services auszublenden,
haben wir bereits xref:disabled_services[weiter oben] gezeigt. Es gibt aber
für etliche Check-Plugins noch weitere Regelsätze, die das Verhalten der Discovery bei diesen
Plugins beeinflussen. Dabei gibt es nicht nur Einstellungen zum _Weglassen_ von
Items, sondern auch solche, die positiv Items finden oder zu Gruppen zusammenfassen.
Auch die Benennung von Items ist manchmal ein Thema -- z.B. bei
ifdef::onprem[]
den Switchports,
endif::[]
ifdef::onprem[]
Netzwerkschnittstellen,
endif::[]
wo Sie sich entscheiden können, anstelle der Interface-ID deren Description oder Alias
als Item (und damit im Service-Namen) zu verwenden.

Alle Regelsätze, die mit der Service-Erkennung zu tun haben, finden Sie unter
[.guihint]#Setup > Services > Discovery rules#.
Bitte verwechseln Sie diese Regelsätze nicht mit denen, die zum Parametrieren
der eigentlichen Services gedacht sind. Etliche Plugins haben in der Tat zwei
Regelsätze -- einen für die Erkennung und einen für die Parameter. Dazu gleich
ein paar Beispiele.


[#processes]
=== Überwachung von Prozessen

Es wäre wenig sinnvoll, wenn {CMK} einfach für jeden Prozess,
den es auf einem Host findet, einen Service für die Überwachung einrichten
würde. Die meisten Prozesse sind entweder nicht interessant oder sogar
nur vorübergehend vorhanden. Und auf einem normalen Linux-Server laufen
mindestens Hunderte von Prozessen.

Zum Überwachen von Prozessen müssen Sie daher mit
xref:enforced_services[erzwungenen Services] arbeiten oder -- und
das ist viel eleganter -- der Service-Erkennung mit dem Regelsatz
[.guihint]#Process discovery# sagen, nach welchen Prozessen sie Ausschau halten
soll. So können Sie immer dann, wenn auf einem Host _bestimmte interessante_
Prozesse gefunden werden, dafür automatisch eine Überwachung einrichten lassen.

Folgende Abbildung zeigt eine Regel im Regelsatz [.guihint]#Process discovery#,
welche nach Prozessen sucht, die das Programm `/usr/sbin/apache2`
ausführen.  In diesem Beispiel wird für jeden unterschiedlichen
Betriebssystembenutzer, für den ein solcher Prozess gefunden wird,
ein Service erzeugt ([.guihint]#Grab user from found processes#). Der Name des Services
wird `Apache %u`, wobei das `%u` durch den Benutzernamen ersetzt
wird. Als Schwellwerte für die Anzahl der Prozessinstanzen werden 1/1 (untere)
bzw. 30/60 (obere) verwendet:

image::wato_services_process_discovery.png[]

Bitte beachten Sie, dass die festgelegten Schwellwerte [.guihint]#Default
parameters for detected services# heißen. Denn Sie können diese -- wie bei allen
anderen Services auch -- per Regel festlegen. Zur Erinnerung: Obige Regel
konfiguriert die _Erkennung_ der Services -- also das _Was._ Sind die Services
erst mal vorhanden, so ist eigentlich die Regelkette [.guihint]#State and count
of processes# für die Schwellwerte zuständig.

Die Tatsache, dass Sie schon bei der Erkennung Schwellwerte festlegen können,
ist nur der Bequemlichkeit geschuldet. Und es gibt auch einen Haken: Änderungen in
der Erkennungsregel haben erst bei der _nächsten Erkennung_ Einfluss. Wenn Sie
also Schwellwerte ändern, müssen Sie die Erkennung nochmal ausführen. Wenn Sie
aber die Regel nur zum eigentlichen Finden verwenden (also das _Was_), und den
Regelsatz [.guihint]#State and count of processes# für das _Wie_ verwenden,
haben Sie dieses Problem nicht.

Um bestimmte oder einzelne Prozesse auf einem Windows-Host zu überwachen, muss
im Feld [.guihint]#Executable# tatsächlich nur der Dateiname ohne Pfad angegeben
werden. In Windows finden Sie diesen Namen im Reiter Details des Windows Task
Managers. In der Regel [.guihint]#Process discovery# könnte das für den Prozess
`svchost` dann wie folgt aussehen:

image::wato_services_process_discovery_windows.png[]

Weitere Details zur Prozesserkennung finden Sie in der Inline-Hilfe dieses
Regelsatzes. Diese aktivieren Sie über [.guihint]#Help > Show inline
help# in der Menüleiste.


=== Überwachung von Windows-Diensten

Das Erkennen und Parametrieren der Überwachung von Windows-Services geht analog
zu den Prozessen und wird über die Regelsätze [.guihint]#Windows service discovery# _(Was)_
bzw. [.guihint]#Windows services# _(Wie)_ gesteuert. Hier ist ein Beispiel für eine
Regel, die nach zwei Diensten Ausschau hält:

image::wato_services_windows_service_discovery.png[]

Genau wie bei den Prozessen ist auch hier die Service-Erkennung nur eine Option.
Wenn Sie anhand von Host-Merkmalen und Ordnern präzise Regeln formulieren
können, auf welchen Hosts bestimmte Dienste erwartet werden, können Sie
auch mit xref:enforced_services[erzwungenen Services]
arbeiten. Das ist dann unabhängig von der tatsächlich vorgefundenen Situation --
allerdings kann das deutlich mehr Aufwand sein, da Sie unter Umständen viele
Regeln brauchen, um genau abzubilden, auf welchem Host welche Dienste erwartet
werden.


ifdef::onprem[]
[#switches]
=== Überwachung von Switchports

{CMK} verwendet für die Überwachung von Netzwerkschnittstellen von Servern und
für die Ports von Ethernet-Switches die gleiche Logik. Vor allem bei den
Switchports sind die vorhandenen Optionen für die Steuerung der Service-Erkennung
interessant, auch wenn (im Gegensatz zu den Prozessen und Windows-Diensten) die
Erkennung auch erst mal ohne Regel funktioniert. Per Default überwacht {CMK}
nämlich automatisch alle physikalischen Ports, die gerade den Zustand {UP} haben.
Der Regelsatz dazu heißt [.guihint]#Network interface and switch port discovery#
und bietet zahlreiche Einstellmöglichkeiten, die hier nur gekürzt dargestellt
sind:

image::wato_services_network_interface_switch_port_discovery.png[]

Am wichtigsten sind folgende Möglichkeiten:

* Im Abschnitt [.guihint]#Appearance of network interface# können Sie bestimmen, wie das Interface im Service-Namen erscheinen soll. Sie haben hier die Wahl zwischen [.guihint]#Use description#, [.guihint]#Use alias# und [.guihint]#Use index#.
* [.guihint]#Match port types# ermöglicht das Einschränken oder _Ausweiten_ der überwachten Interfacetypen oder -namen.
endif::[]


[#enforced_services]
== Einrichtung von Services erzwingen

Es gibt einige Situationen, in denen eine automatische Service-Erkennung
nicht sinnvoll ist. Das ist immer dann der Fall, wenn Sie das Einhalten
einer bestimmte _Richtlinie_ erzwingen möchten. Wie Sie im vorherigen
Kapitel gesehen haben, können Sie Überwachung von Windows-Diensten automatisch
einrichten lassen, wenn diese gefunden werden. Was ist aber, wenn schon das
Fehlen eines solchen Diensts ein Problem darstellt? Beispiele:

* Auf jedem Windows-Host soll ein bestimmter Virenscanner installiert sein.
* Auf jedem Linux-Host soll NTP konfiguriert sein.

In solchen Fällen können Sie das Anlegen von Services erzwingen. Den
Einstiegspunkt dafür finden Sie unter sind die [.guihint]#Setup > Services >
Enforced services#. Dahinter verbirgt sich eine Sammlung von
xref:wato_rules#[Regelsätzen], welche exakt die gleichen Namen haben, wie
diejenigen Regelsätze, mit denen auch Parameter für diese Checks konfiguriert
werden.

Die Regeln unterscheiden sich jedoch in zwei Punkten:

* Es sind Regeln für _Hosts,_ nicht für Services. Die Services werden ja erst durch die Regeln erzeugt.
* Da keine Erkennung stattfindet, müssen Sie selbst das Check-Plugin auswählen, das für den Check verwendet werden soll.

Folgendes Beispiel zeigt den Rumpf der Regel [.guihint]#State of NTP time synchronisation# unter
[.guihint]#Enforced services#:

image::wato_services_example_enforced_services_ntp.png[]

Neben den Schwellwerten legen Sie hier auch das Check-Plugin fest
(z.B. `chrony` oder `ntp_time`).  Bei Check-Plugins, die ein
Item benötigen, müssen Sie auch dieses angeben. Dies ist z.B. beim Plugin
[.guihint]#oracle_processes# notwendig, welches die Angabe der zu überwachenden
Datenbank-SID benötigt:

image::wato_services_example_enforced_services_oracle_processes.png[]

Der so definierte manuelle Service wird auf allen Hosts angelegt, auf die
diese Regel greift. Für die eigentliche Überwachung gibt es jetzt drei Fälle:

. Der Host ist korrekt aufgesetzt und der Service geht auf {OK}.
. Der Agent liefert die Information, dass der gefragte Dienst nicht läuft oder ein Problem hat. Dann geht der Service auf {CRIT} oder auf {UNKNOWN}.
. Der Agent stellt überhaupt keine Informationen bereit, z.B. weil NTP überhaupt nicht installiert ist.
Dann bleibt der Service auf {PEND} und der Service [.guihint]#Check_MK# geht auf {WARN}, mit dem Hinweis, dass die entsprechende Sektion in den Agentendaten fehlt.

//SK: Benutzen wir das Wort "Modul" noch auf diese Weise in der 2.0.0?
// ML: Ist an einigen Stellen auch neueren Datums noch so zu lesen, insofern würde ich ja tippen.

Die meisten Regelsätze im Modul [.guihint]#Enforced services# werden Sie nie
benötigen und sind nur der Vollständigkeit halber vorhanden. Die häufigsten
Fälle für erzwungene Services sind:

* Überwachung von Windows-Diensten (Regelsatz: [.guihint]#Windows Services#)
* Überwachung von Prozessen (Regelsatz: [.guihint]#State and count of processes#)


[#discovery_check]
== Der Discovery Check

In der Einleitung haben wir versprochen, dass {CMK} die Liste der
Services nicht nur automatisch ermitteln, sondern auch _aktuell halten_
kann. Natürlich wäre dafür eine Möglichkeit, dass Sie ab und zu von Hand
eine Bulk-Erkennung über alle Hosts durchführen.

[#discovery_auto]
=== Automatisches Prüfen auf nicht überwachte Services

Viel besser ist dafür aber ein regelmäßiger _Discovery Check,_ welcher von {CMK} bei neuen Instanzen automatisch eingerichtet wird.
Dieser Service [.guihint]#Check_MK Discovery# existiert für jeden Host und meldet sich mit einer Warnung, wenn er nicht überwachte Dinge findet:

image::wato_services_discovery_check_warn.png[]

Die Einzelheiten zu den nicht überwachten oder verschwundenen Services finden Sie auf der Seite mit den Details des Services [.guihint]#Check_MK Discovery# im Feld [.guihint]#Details:#

// ML: Padding in einfacher Fonthöhe fehlt.
image::wato_services_discovery_check_details.png[]

Zu der Service-Liste des Hosts im Setup gelangen Sie bequem über das icon:icon_menu[] Aktionsmenü des [.guihint]#Check_MK Discovery# Services
und den Eintrag icon:icon_services[] [.guihint]#Run service discovery.#

Das Parametrieren des Discovery Checks geht sehr einfach über den xref:glossar#rule_set[Regelsatz] [.guihint]#Periodic service discovery.#
In einer frischen Instanz werden Sie hier bereits eine global wirksame Regel mit den folgenden Einstellungen vorfinden:

image::wato_services_periodic_service_discovery.png[]

Neben dem Intervall, in dem der Check laufen soll, können Sie auch noch den Monitoring-Zustand auswählen
-- für die Fälle von nicht überwachten Services, verschwundenen Services, geänderten Service-Labels und neuen Host-Labels.


[#automatically_update_service_configuration]
=== Services automatisch hinzufügen

Sie können den Discovery Check fehlende Services automatisch hinzufügen lassen.
Dazu aktivieren Sie die Option [.guihint]#Automatically update service configuration#.
Nun werden weitere Optionen sichtbar.

image::wato_services_periodic_service_discovery_update_configuration.png[]

Neben dem Hinzufügen können Sie bei [.guihint]#Parameters# auch auswählen, verschwundene Services zu entfernen oder sogar alle bestehenden Services zu entfernen und komplett neu zu erkennen.
Letztere Option finden Sie im Drop-down-Menü unter der Bezeichnung [.guihint]#Refresh all services and host labels (tabula rasa)#.
Beide Optionen sind mit Vorsicht zu genießen!
Ein verschwundener Service kann auf ein Problem hindeuten!
Der Discovery Check wird so einen Service dann einfach entfernen und Sie im Glauben wiegen, dass alles in Ordnung ist.
Der Refresh ist besonders gefährlich.
ifdef::onprem[]
So übernimmt z.B. der Check für Switchports nur solche Ports in das Monitoring, die {UP} sind.
endif::[]
ifdef::saas[]
So übernehmen z.B. einige Checks für Netzwerkschnittstellen nur solche Ports in das Monitoring, die {UP} sind.
endif::[]
Ports mit Status {DOWN} gelten dann als verschwunden und würden vom Discovery Check ohne Rückfrage weggeräumt!


Ein weiteres Problem gilt es noch zu bedenken: Das Hinzufügen von Services oder
gar das automatische [.guihint]#Activate Changes# kann Sie als Admin bei Ihrer
Arbeit am System stören, wenn Sie gerade beim Konfigurieren sind. Es kann
theoretisch passieren, dass Sie gerade dabei sind, an Regeln und Einstellungen
zu arbeiten und just in dem Augenblick ein Discovery Check Ihre Änderungen
aktiviert. Denn in {CMK} können immer nur alle Änderungen auf einmal aktiviert
werden! Um dies zu verhindern, können Sie die Uhrzeiten, in denen so etwas
geschieht, z.B. in die Nacht legen. Die obige Abbildung zeigt dafür ein
Beispiel.

Unter [.guihint]#Vanished clustered services# können Sie xref:clustered_services#[geclusterte Services] separat handhaben.
Die Besonderheit hier: Wenn ein geclusterter Service von einem Node auf den anderen wechselt, könnte er kurzzeitig als verschwunden angesehen und entsprechend ungewollt gelöscht werden.
Verzichten Sie hingegen auf diese Option, würden wiederum tatsächlich verschwundene Services niemals gelöscht.

Die Einstellung [.guihint]#Group discovery and activation for up to# sorgt
dafür, dass nicht jeder einzelne Service, der neu gefunden wird, sofort ein
[.guihint]#Activate Changes# auslöst, sondern eine bestimmte Zeit gewartet wird,
um gleich mehrere Änderungen in einem Rutsch zu aktivieren. Denn selbst wenn der
Discovery Check auf ein Intervall von zwei Stunden oder mehr eingestellt ist,
gilt das nur für jeden Host separat. Die Checks laufen nicht für alle Hosts
gleichzeitig -- und das ist auch gut so, denn der Discovery Check braucht
erheblich mehr Ressourcen als ein normaler Check.


ifdef::onprem[]
[#passive_checks]
== Passive Services

Passive Services sind solche, die nicht von {CMK} aktiv angestoßen werden, sondern bei
denen regelmäßig von außen neue Check-Ergebnisse eingeschleust werden. Dies geschieht
in der Regel über die Kommando-Pipe des Cores. Hier ist ein Schritt-für-Schritt-Vorgehen
für das Einrichten eines passiven Services:

Zunächst müssen Sie den Service dem Kern bekannt machen.
Dies geschieht mit dem gleichen Regelsatz wie bei den xref:active_checks#nagios_plugins[eigenen aktiven Checks], nur dass Sie die [.guihint]#Command line# weglassen:

image::wato_services_passive_checks_integrate_nagios_plugins.png[]

Die Abbildung zeigt auch, wie Sie prüfen lassen können, ob regelmäßig
Check-Ergebnisse eingehen. Wenn dies für länger als 10 Minuten ausbleibt,
so wird der Service hier automatisch auf {UNKNOWN} gesetzt.

Nach einem [.guihint]#Activate Changes# beginnt der neue Service sein Leben im Zustand {PEND}:

image::wato_services_passive_checks_pending.png[]

Das Senden der Check-Ergebnisse geschieht nun auf der Kommandozeile durch
ein `echo` des Befehls `PROCESS_SERVICE_CHECK_RESULT` in die
Kommando-Pipe `~/tmp/run/nagios.cmd`.

Die Syntax entspricht den bei Nagios üblichen Konventionen -- inklusive eines
aktuellen Zeitstempels in eckigen Klammern. Als Argumente nach dem Befehl
brauchen Sie den Host-Namen (z.B. `myhost`) und den gewählten
Service-Namen (im Beispiel `BAR`). Die beiden weiteren Argumente sind
wieder der Status (`0` ... `3`) und die Plugin-Ausgabe. Den
Zeitstempel erzeugen Sie mit `$(date +%s)`:

[{shell}]
----
{c-omd} echo "[$(date +%s)] PROCESS_SERVICE_CHECK_RESULT;myhost;BAR;2;Something bad happened" > ~/tmp/run/nagios.cmd
----

Nun zeigt der Service ohne Verzögerung den neuen Status:

image::wato_services_passive_checks_crit.png[]
endif::[]


ifdef::onprem[]
[#commandline]
== Service-Erkennung auf der Kommandozeile

So schön eine GUI ist, so praktisch ist doch manchmal noch die gute alte Kommandozeile --
sei es zum Automatisieren oder einfach zum schnellen Arbeiten für den geübten Benutzer.
Die Service-Erkennung können Sie auf der Kommandozeile mit dem Befehl `cmk -I` auslösen.
Dabei gibt es ein paar verschiedene Spielarten. Bei allen empfehlen wir die Option `-v`,
damit Sie sehen, was genau passiert. Ohne `-v` verhält sich {CMK} nach guter alter
Unix-Tradition: Solange alles gut geht, schweigt es.

Mit einem einfachen `-I` suchen Sie auf *allen* Hosts nach neuen Services:

[{shell}]
----
{c-omd} cmk -vI
Discovering services and host labels on all hosts
myserver01:
+ FETCHING DATA
Using data from cache file /omd/sites/mysite/tmp/check_mk/cache/myserver01
[TCPFetcher] Use cached data
No piggyback files for 'myserver01'. Skip processing.
[PiggybackFetcher] Execute data source
+ PARSE FETCHER RESULTS
Received no piggyback data
+ EXECUTING HOST LABEL DISCOVERY
+ PERFORM HOST LABEL DISCOVERY
+ EXECUTING DISCOVERY PLUGINS (42)
SUCCESS - Found no new services, 2 host labels
myserver02:
+ FETCHING DATA
Using data from cache file /omd/sites/mysite/tmp/check_mk/cache/myserver02
[TCPFetcher] Use cached data
No piggyback files for 'myserver02'. Skip processing.
[PiggybackFetcher] Execute data source
+ PARSE FETCHER RESULTS
Received no piggyback data
+ EXECUTING HOST LABEL DISCOVERY
+ PERFORM HOST LABEL DISCOVERY
+ EXECUTING DISCOVERY PLUGINS (1900)
SUCCESS - Found no new services, 2 host labels
----

Sie können nach dem `-I` auch einen oder mehrere Host-Namen angeben, um nur diese zu untersuchen.
Das hat gleich noch einen zweiten Effekt. Während ein `-I` auf allen Hosts
grundsätzlich nur mit *zwischengespeicherten* Daten arbeitet, holt {CMK} bei der
expliziten Angabe von einem Host immer *frische* Daten!

[{shell}]
----
{c-omd} cmk -vI myserver01
----

Alternativ können Sie über Tags filtern:

[{shell}]
----
{c-omd} cmk -vI @mytag
----

Damit würde das Discovery für alle Hosts mit dem Host-Merkmal `mytag` durchgeführt.
Filtern mit Tags steht für alle cmk-Optionen zur Verfügung, die mehrere Hosts akzeptieren.

Mit den Optionen `--cache` bzw. `--no-cache` können Sie die Verwendung
von Cache auch explizit bestimmen.

Zusätzliche Ausgaben bekommen Sie mit einem zweiten `-v`. Bei SNMP-basierten Geräten
können Sie dann sogar jede einzelne OID sehen, die vom Gerät geholt wird:

[{shell}]
----
{c-omd} cmk -vvI myswitch01
Discovering services on myswitch01:
myswitch01:
  SNMP scan:
       Getting OID .1.3.6.1.2.1.1.1.0: Executing SNMP GET of .1.3.6.1.2.1.1.1.0 on switch
=> ['24G Managed Switch'] OCTETSTR
24G Managed Switch
       Getting OID .1.3.6.1.2.1.1.2.0: Executing SNMP GET of .1.3.6.1.2.1.1.2.0 on switch
=> ['.1.3.6.1.4.1.11863.1.1.3'] OBJECTID
.1.3.6.1.4.1.11863.1.1.3
       Getting OID .1.3.6.1.4.1.231.2.10.2.1.1.0: Executing SNMP GET of .1.3.6.1.4.1.231.2.10.2.1.1.0 on switch
=> [None] NOSUCHOBJECT
failed.
       Getting OID .1.3.6.1.4.1.232.2.2.4.2.0: Executing SNMP GET of .1.3.6.1.4.1.232.2.2.4.2.0 on switch
=> [None] NOSUCHOBJECT
failed.
----

Ein komplettes Erneuern der Services (Tabula Rasa) machen Sie mit einem Doppel- `-II`:

// ES: Code-Block als HTML dargestellt, weil das grüne Highlighting sonst Probleme macht.
// Für den ursprünglichen Inhalt des Blocks siehe Stand hier: https://github.com/Checkmk/checkmk-docs/blob/4f62bca782353009dda6ddfcfaa3d608b0df6c10/src/common/de/wato_services.asciidoc?plain=1#L710

++++
<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">OMD[mysite]:~$ </span><span class="tok-plaintext">cmk</span><span class="tok-w"> </span><span class="tok-plaintext">-vII</span><span class="tok-w"> </span><span class="tok-plaintext">myserver01
</span><span class="tok-go">Discovering services and host labels on: myserver01</span><span class="tok-plaintext">
</span><span class="tok-go">myserver01:</span><span class="tok-plaintext">
</span><span class="tok-go">+ FETCHING DATA</span><span class="tok-plaintext">
</span><span class="tok-go">Using data from cache file /omd/sites/mysite/tmp/check_mk/cache/myserver01</span><span class="tok-plaintext">
</span><span class="tok-go">[TCPFetcher] Use cached data</span><span class="tok-plaintext">
</span><span class="tok-go">No piggyback files for 'myserver01'. Skip processing.</span><span class="tok-plaintext">
</span><span class="tok-go">No piggyback files for '127.0.0.1'. Skip processing.</span><span class="tok-plaintext">
</span><span class="tok-go">[PiggybackFetcher] Execute data source</span><span class="tok-plaintext">
</span><span class="tok-go">+ PARSE FETCHER RESULTS</span><span class="tok-plaintext">
</span><span class="tok-go">Received no piggyback data</span><span class="tok-plaintext">
</span><span class="tok-go">+ EXECUTING HOST LABEL DISCOVERY</span><span class="tok-plaintext">
</span><span class="tok-go">+ PERFORM HOST LABEL DISCOVERY</span><span class="tok-plaintext">
</span><span class="tok-go">+ EXECUTING DISCOVERY PLUGINS (10)</span><span class="tok-plaintext">
</span><span class="tok-go">    <span class="green">1</span> cpu.loads</span><span class="tok-plaintext">
</span><span class="tok-go">    <span class="green">1</span> cpu.threads</span><span class="tok-plaintext">
</span><span class="tok-go">    <span class="green">6</span> cups_queues</span><span class="tok-plaintext">
</span><span class="tok-go">    <span class="green">3</span> df</span><span class="tok-plaintext">
</span><span class="tok-go">    <span class="green">1</span> diskstat</span><span class="tok-plaintext">
</span><span class="tok-go">    <span class="green">3</span> kernel</span><span class="tok-plaintext">
</span><span class="tok-go">    <span class="green">1</span> kernel.util</span><span class="tok-plaintext">
</span><span class="tok-go">    <span class="green">3</span> livestatus_status</span><span class="tok-plaintext">
</span><span class="tok-go">    <span class="green">1</span> lnx_if</span><span class="tok-plaintext">
</span><span class="tok-go">    <span class="green">1</span> lnx_thermal</span><span class="tok-plaintext">
</span><span class="tok-go"><span class="green">SUCCESS</span> - Found 21 services, 2 host labels</span></code></pre></div></div>
++++

Sie können das Ganze auch auf ein einzelnes Check-Plugin einschränken. Die Option dazu
lautet `--detect-plugins=` und muss vor dem Host-Namen stehen:

// ES: Code-Block als HTML dargestellt.
// Ursprünglicher Inhalt des Blocks: https://github.com/Checkmk/checkmk-docs/blob/4f62bca782353009dda6ddfcfaa3d608b0df6c10/src/common/de/wato_services.asciidoc?plain=1#L740

++++
<div class="listingblock copybutton"><div class="content"><pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">OMD[mysite]:~$ </span><span class="tok-plaintext">cmk</span><span class="tok-w"> </span><span class="tok-plaintext">-vII</span><span class="tok-w"> </span><span class="tok-plaintext">--detect-plugins</span><span class="tok-o">=</span><span class="tok-plaintext">df</span><span class="tok-w"> </span><span class="tok-plaintext">myserver01
</span><span class="tok-go">Discovering services and host labels on: myserver01</span><span class="tok-plaintext">
</span><span class="tok-go">myserver01:</span><span class="tok-plaintext">
</span><span class="tok-go">+ FETCHING DATA</span><span class="tok-plaintext">
</span><span class="tok-go">[TCPFetcher] Execute data source</span><span class="tok-plaintext">
</span><span class="tok-go">No piggyback files for 'myserver01'. Skip processing.</span><span class="tok-plaintext">
</span><span class="tok-go">No piggyback files for '127.0.0.1'. Skip processing.</span><span class="tok-plaintext">
</span><span class="tok-go">[PiggybackFetcher] Execute data source</span><span class="tok-plaintext">
</span><span class="tok-go">+ PARSE FETCHER RESULTS</span><span class="tok-plaintext">
</span><span class="tok-go">Received no piggyback data</span><span class="tok-plaintext">
</span><span class="tok-go">+ EXECUTING HOST LABEL DISCOVERY</span><span class="tok-plaintext">
</span><span class="tok-go">+ PERFORM HOST LABEL DISCOVERY</span><span class="tok-plaintext">
</span><span class="tok-go">+ EXECUTING DISCOVERY PLUGINS (1)</span><span class="tok-plaintext">
</span><span class="tok-go">  <span class="green">3</span> df</span><span class="tok-plaintext">
</span><span class="tok-go"><span class="green">SUCCESS</span> - Found 3 services, no host labels</span></code></pre><div class="cpbuttonbox"><div class="confirmcont fa-light fa-circle-check"></div><div class="symbolcont fa-light fa-copy"></div></div><div class="hoverbox noshow">Click here to copy the file/command(s) to the clipboard!</div><div class="feedbackbox noshow">Successfully copied the file/command(s) to the clipboard!</div></div></div>
++++

Wenn Sie fertig sind, können Sie mit `cmk -O` (bei Nagios als Kern `cmk -R`)
die Änderungen aktivieren:

[{shell}]
----
{c-omd} cmk -O
Generating configuration for core (type cmc)...[green]#OK#
Creating helper config...[green]#OK#
Reloading monitoring core...[green]#OK#
----

Und wenn Sie mal bei einer Discovery auf einen Fehler stoßen{nbsp}...

[{shell}]
----
{c-omd} cmk -vII --detect-plugins=df myserver01
  [yellow]#WARNING:# Exception in discovery function of check type 'df': global name 'bar' is not defined
  nothing
----

{nbsp}&#8230; dann können Sie mit einem zusätzlichen `--debug` einen genauen Python Aufrufstapel (_stack trace_) der
Fehlerstelle bekommen:

[{shell}]
----
{c-omd} cmk --debug -vII --detect-plugins=df myserver01
Discovering services and host labels on myserver01:
myserver01:
Traceback (most recent call last):
  File "/omd/sites/heute/share/check_mk/modules/check_mk.py", line 5252, in <module>
    do_discovery(hostnames, check_types, seen_I == 1)
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 76, in do_discovery
    do_discovery_for(hostname, check_types, only_new, use_caches, on_error)
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 96, in do_discovery_for
    new_items = discover_services(hostname, check_types, use_caches, do_snmp_scan, on_error)
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 677, in discover_services
    for item, paramstring in discover_check_type(hostname, ipaddress, check_type, use_caches, on_error):
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 833, in discover_check_type
    discovered_items = discovery_function(info)
  File "/omd/sites/heute/share/check_mk/checks/df", line 91, in inventory_df
    foo = bar
NameError: global name 'bar' is not defined
----


=== Optionen im Überblick

Hier noch mal alle Optionen auf einen Blick:

[cols="25,~"]
|===
|`cmk -I` |Neue Services erkennen.
|`cmk -II` |Alle Services verwerfen und neu erkennen (Tabula Rasa).
|`-v` |Verbose: Hosts und gefundene Services anzeigen.
|`-vv` |Very verbose: genaues Protokoll von allen Operationen anzeigen.
|`--detect-plugins=foo` |Erkennung (und auch Tabula Rasa) nur für das gewählte Check-Plugin durchführen.
|`@foo` |Erkennung (und auch Tabula Rasa) nur für Hosts mit dem gewählten Host-Merkmal durchführen.
|`--cache` |Verwendung von Cache-Dateien erzwingen (sonst nur bei fehlender Host-Angabe).
|`--no-cache` |Frische Daten holen (sonst nur bei Angabe von Host-Name).
|`--debug` |Im Fehlerfall abbrechen und den kompletten Aufrufstapel von Python anzeigen.
|`cmk -O` |Änderungen aktivieren (kommerzielle Editionen mit CMC als Kern).
|`cmk -R` |Änderungen aktivieren ({RE} bzw. Nagios als Kern).
|===



=== Speicherung in Dateien

Das _Ergebnis_ der Service-Erkennung -- also die eingangs genannte Tabelle
von Host-Name, Check-Plugin, Item und erkannten Parametern -- finden Sie im
Verzeichnis `var/check_mk/autochecks`. Dort existiert für jeden Host
eine Datei, welche die automatisch erkannten Services speichert. Solange
Sie die Python-Syntax der Datei nicht verletzen, können Sie einzelne Zeilen
auch von Hand löschen oder ändern. Ein Löschen der Datei entfernt
alle Services und setzt diese quasi wieder auf „unmonitored“.

.var/check_mk/autochecks/myserver01.mk
[{file}]
----
[
  {'check_plugin_name': 'cpu_loads', 'item': None, 'parameters': (5.0, 10.0), 'service_labels': {}},
  {'check_plugin_name': 'cpu_threads', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'diskstat', 'item': 'SUMMARY', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'kernel_performance', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'kernel_util', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'livestatus_status', 'item': 'myremotesite', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'lnx_thermal', 'item': 'Zone 0', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'mem_linux', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'mknotifyd', 'item': 'mysite', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'mknotifyd', 'item': 'myremotesite', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'mounts', 'item': '/', 'parameters': ['errors=remount-ro', 'relatime', 'rw'], 'service_labels': {}},
  {'check_plugin_name': 'omd_apache', 'item': 'mysite', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'omd_apache', 'item': 'myremotesite', 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'tcp_conn_stats', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'timesyncd', 'item': None, 'parameters': {}, 'service_labels': {}},
  {'check_plugin_name': 'uptime', 'item': None, 'parameters': {}, 'service_labels': {}},
]
----
endif::[]


[#service_groups]
== Service-Gruppen

=== Wofür Service-Gruppen?

Bis hierher haben Sie erfahren, wie Sie Services ins Monitoring aufnehmen. Nun
macht es wenig Sinn, sich Listen mit Tausenden Services anzuschauen oder
immer über Host-Ansichten zu gehen. Wenn Sie beispielsweise alle Dateisystem-
oder Update-Services gemeinsam beobachten wollen, können Sie in ähnlicher
Weise Gruppen bilden, wie das mit xref:glossar#host_group[Host-Gruppen]
möglich ist.

Service-Gruppen ermöglichen Ihnen auf einfache Art, 
ifdef::onprem[]
über xref:views#[Ansichten] und NagVis-Karten deutlich mehr Ordnung ins Monitoring zu bringen und gezielte xref:glossar#notification[Benachrichtigungen] und xref:alert_handlers#[Alert Handler] zu schalten.
endif::[]
ifdef::saas[]
über xref:views#[Ansichten] deutlich mehr Ordnung ins Monitoring zu bringen und gezielte xref:glossar#notification[Benachrichtigungen] zu schalten.
endif::[]

Übrigens: Sie könnten entsprechende Ansichten fast immer auch rein über
die Ansichten-Filter konstruieren -- Service-Gruppen sind aber einfacher und
übersichtlicher zu handeln.


=== Service-Gruppen anlegen

Sie finden Service-Gruppen unter [.guihint]#Setup > Services > Service groups#.

image::wato_services_service_groups_add_group.png[]

Das Anlegen einer Service-Gruppe ist simpel: Legen Sie über icon:icon_new[]
[.guihint]#Add group# eine neue Gruppe an und vergeben Sie einen später nicht
mehr veränderbaren Namen sowie einen aussagekräftigen Alias.

image::wato_services_add_service_group.png[]


=== Services in Service-Gruppe aufnehmen

Für die Zuordnung von Services in Service-Gruppen benötigen Sie den
xref:wato_rules#conditions[Regelsatz] [.guihint]#Assignment of services to
service groups#. In der Übersicht Ihrer Service-Gruppen ([.guihint]#Setup >
Services > Service Groups#), finden Sie diese Regel am schnellsten und zwar über
die Menüleiste und dort die Punkte [.guihint]#Service Groups > Assign to group > Rules#.
Alternativ können Sie die Regel natürlich auch über die Regelsuche im [.guihint]#Setup#-Menü finden,
oder sich über [.guihint]#Setup > Services > Service monitoring rules > Various > Assignment of services to service groups# durchklicken.
Erstellen Sie nun über [.guihint]#Create rule in folder# eine neue Regel im
gewünschten Ordner. Zunächst legen Sie fest, welcher Service-Gruppe Services
zugeordnet werden sollen, hier beispielsweise _myservicegroup_ beziehungsweise
dessen Alias _My service group 1._

image::wato_services_servicegroups_rule_assignment.png[]

Der spannende Teil folgt nun im Bereich [.guihint]#Conditions#. Zum einen dürfen
Sie hier über Ordner, Host-Merkmale und explizite Host-Namen Einschränkungen
abseits der Services vornehmen. Zum anderen nennen Sie eben die Services, die
Sie gerne gruppiert hätten, beispielsweise `Filesystem` und
`myservice`, um eine Gruppe mit Dateisystemen zu erstellen. Die Angabe
der Services erfolgt hier in Form xref:regexes#[Regulärer Ausdrücke]. So
können Sie Gruppen ganz exakt definieren.

image::wato_services_servicegroups_rule_conditions.png[]


===  Service-Gruppen eines Services prüfen

Die Zuordnungen von Services können Sie auf der Detailseite eines jeweiligen
Service prüfen. Hier finden Sie, standardmäßig weit unten, die Zeile
[.guihint]#Service groups the service is member of#.

image::wato_services_servicegroups_service_detail.png[]


=== Service-Gruppen einsetzen

Zum Einsatz kommen die Service-Gruppen wie bereits erwähnt an mehreren Stellen:
zum Beispiel in
ifdef::onprem[]
xref:views#[Ansichten], NagVis-Karten, xref:alert_handlers#[Alert Handler] und xref:glossar#notification[Benachrichtigungen].
endif::[]
ifdef::saas[]
xref:views#[Ansichten] und xref:glossar#notification[Benachrichtigungen].
endif::[]
Bei neuen Ansichten ist hier wichtig, dass Sie als Datenquelle die
[.guihint]#Service groups# setzen. Im [.guihint]#Views#-Widget finden Sie
natürlich auch vordefinierte Ansichten für Service-Gruppen, zum Beispiel eine
übersichtliche Zusammenfassung:

image::wato_services_servicegroups_view_summary.png[]

Mit einem Klick auf die Service-Gruppennamen gelangen Sie zur vollständigen
Ansicht aller Services der jeweiligen Gruppe.

ifdef::onprem[]
Wenn Sie Service-Gruppen in NagVis-Karten einsetzen, bekommen Sie als Ergebnis
beispielsweise Zusammenfassungen von Service-Gruppen per Hover-Menü über
ein einzelnes Icon:

image::wato_services_servicegroups_nagvis_example.png[]
endif::[]

Wenn Sie Service-Gruppen in xref:glossar#notification[Benachrichtigungen]
ifdef::onprem[]
und xref:alert_handlers#[Alert Handlers]
endif::[]
nutzen, stehen sie als
xref:wato_rules#conditions[Bedingungen/Filter] zur Verfügung, von denen Sie
einen oder mehrere nutzen können:

image::wato_services_servicegroups_notification_rule.png[]


[#checkplugins]
== Mehr über Check-Plugins

=== Kurze Beschreibung der Funktionsweise

Check-Plugins werden benötigt, um die Services in {CMK} zu erstellen. Jeder
Service greift auf ein Check-Plugin zurück, um seinen Status zu ermitteln,
Metriken zu erstellen/pflegen usw. Dabei kann ein solches Plugin einen oder
mehrere Services pro Host erstellen. Damit mehrere Services vom gleichen
Plugin unterschieden werden können, wird ein *Item* benötigt. So ist
z.B. beim Service `Filesystem /var` das Item der Text `/var`. Bei
Plugins, die pro Host maximal einen Service anlegen können (z.B. `CPU
utilization`), ist das Item leer und nicht sichtbar.


=== Verfügbare Check-Plugins

Eine Liste aller verfügbaren Check-Plugins finden Sie unter [.guihint]#Setup >
Services > Catalog of check plugins#. Hier können Sie nach verschiedenen
Kategorien gefiltert die einzelnen Plugins durchsuchen:

image::wato_services_catalog_of_check_plugins.png[]

Zu jedem Plugin werden drei Spalten ausgegeben, die die Servicebeschreibung
(Type of Check), den Namen des Check-Plugins (Plugin Name) und die kompatiblen
Datenquellen (Agents) enthalten:

image::wato_services_catalog_of_check_plugins_telephony.png[]
