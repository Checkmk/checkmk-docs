// -*- coding: utf-8 -*-
// IGNORE Aggregationen Hilfs Hostgroups backup3
include::global_attr.adoc[]
= Business Intelligence (BI)
:revdate: 2023-04-11
:title: Business Intelligence (BI) - Komplexität mit der BI reduzieren
:description: Mit der Business Intelligence (BI) können Sie komplexe Zusammenhänge einfach darstellen. Lernen Sie hier Schritt für Schritt, BIs regelbasiert und dynamisch zu erstellen.

{related-start}
xref:views#[Ansichten von Hosts und Services (Views)]
xref:availability#[Verfügbarkeit (Availability)]
xref:basics_downtimes#[Wartungszeiten]
{related-end}

//SP: Die Images im gesamten Artikel sollten laut Leitfaden alle einen Alt-Text haben. Muss bei Gelegenheit ergänzt werden.
//TK: Laut Wörterbuch heißt die englische "BI aggregation" im deutschen "BI-Aggregat". Im Artikel wird sowohl Aggregation als auch Aggregat verwendet. Umbenennung auf Aggregat steht aus.

== Einleitung

[{image-left}]
image::bi_large_icon_aggr.png[width=80]

{CMK} Business Intelligence -- das klingt zugegeben etwas hochtrabend
für eine im Grunde recht einfache Sache. Aber dieser Name trifft den Kern des
_BI_-Moduls von {CMK} recht gut. Hier geht es nämlich darum,
aus den vielen einzelnen Zustandswerten den Gesamtzustand von
*geschäftskritischen Anwendungen* abzuleiten und übersichtlich darzustellen.

Nehmen Sie als Beispiel den Dienst _E-Mail,_ der in vielen Unternehmen
noch immer unverzichtbar ist. Dieser Dienst basiert auf der korrekten
Funktion einer Vielzahl von Hardware- und Softwarekomponenten --
angefangen bei bestimmten Switches, über SMTP- und IMAP-Dienste, bis hin zu
Infrastrukturdiensten wie LDAP und DNS.

Der Ausfall eines essenziellen Bausteins ist kein Problem, wenn dieser
redundant ausgelegt ist. Umgekehrt mag ein Problem bei einem ganz anderen
Service, der auf den ersten Blick mit E-Mail nichts zu tun hat, viel
schwerwiegendere Auswirkungen haben.  Ein einfacher Blick auf eine Liste
von Services in {CMK} ist also nicht immer aussagekräftig -- zumindest
nicht für jeden!

_{CMK} BI_ ermöglicht Ihnen, aus dem aktuellen Zustand von
einzelnen Hosts und Services einen Gesamtzustand für eine Anwendung
abzuleiten. Dazu definieren Sie über BI-Regeln, wie die Dinge baumartig voneinander
abhängen. Jede Anwendung ist dann insgesamt {OK}, {WARN} oder {CRIT}. Die
Information über den Zustand und die Abhängigkeiten können Sie auf
verschiedene Weise nutzen:

* Anzeige des Gesamtzustands einer Anwendung in der GUI.
* Berechnung der xref:availability#[Verfügbarkeit] einer Anwendung.
* xref:notifications#[Benachrichtigungen] bei einem Problem oder gar einem Ausfall einer Anwendung.
* Impact-Analyse: Ein Service geht auf {CRIT} -- welche Anwendungen sind davon betroffen?
* Planung von Wartungszeiten und „Was wäre wenn ...“-Analysen.

Daneben gibt es noch die Möglichkeit, die Baumdarstellung von BI für eine
„Drill Down“-Ansicht für den Zustand eines Hosts mit allen seinen Services
zu verwenden.

Eine Besonderheit von {CMK} BI im Gegensatz zu vergleichbaren Tools im
Monitoring-Umfeld ist, dass {CMK} auch hier _regelbasiert_ arbeitet. Das
ermöglicht Ihnen z.B. mit einem generischen Satz von Regeln, dynamisch eine
unbestimmte Zahl von ähnlichen Anwendungen zu beschreiben. Das erleichtert immens
die Arbeit und hilft, Fehler zu vermeiden -- besonders in sehr dynamischen Umgebungen.

image::business_intelligence.png[]


[#first]
== Konfiguration Teil 1: Das erste Aggregat

=== Begriffe

Bevor Sie Schritt für Schritt mit der Praxis anfangen, benötigen Sie zunächst ein
paar Begriffe:

Jede mit BI formalisierte Anwendung wird als *Aggregation* bezeichnet,
da hier aus vielen Einzelzuständen ein Gesamtzustand aggregiert wird.

Eine Aggregation ist ein Baum von Objekten. Diese werden *Knoten* genannt.
Die untersten Knoten -- also die _Blätter_ des Baums -- sind Hosts und Services aus
Ihren {CMK}-Instanzen. Die übrigen Knoten sind
künstlich erzeugte BI-Objekte.

Jeder Knoten wird durch eine *Regel* erzeugt. Das gilt auch für die
Wurzel des Baums -- also den obersten Knoten.  Die Regeln legen fest, welche
Knoten unter einem Knoten hängen und wie aus deren Zuständen der Zustand
des Knotens berechnet werden soll.

Auch der oberste Knoten einer Aggregation (die Wurzel des Baums) wird mit einer
Regel erzeugt. Dabei kann eine Regel mehrere Aggregationen erzeugen.


=== Ein Beispiel

Am einfachsten geht alles mit einem konkreten Beispiel. Dafür haben wir
uns für diesen Artikel die _„Mystery Application“_ ausgedacht.
Nehmen Sie an, dass dies eine wichtige Anwendung in einem nicht näher genannten
Unternehmen ist. Dabei spielen unter anderem fünf Server und zwei Netzwerk-Switches
eine wichtige Rolle. Damit Sie das Beispiel besser nachvollziehen können,
bekommen diese einfache Namen wie `srv-mys-1` oder `switch-1`.
Folgendes Schaubild gibt den Aufbau grob wieder:

//SK: Ausnahmsweise wird hier ein jpeg verwendet, weil das Bild als png größer als 1 MB ist.
//ML: Das müsste unser Graffle-Experte bei Gelegenheit mal anfassen.
image::bi_example.jpeg[width=90%]

* Die beiden Server `srv-mys-1` und `srv-mys-2` bilden einen redundanten Cluster, auf welchem die eigentliche Anwendung läuft.
* `srv-db` ist ein Datenbankserver, welcher die Daten der Anwendung speichert.
* `switch-1` und `switch-2` sind zwei redundante Router, welche das Servernetz mit einem höheren Netz verbinden.
* In jenem befindet sich ein Zeitgeber `srv-ntp`, welcher für eine exakt synchrone Zeit sorgt.
* Außerdem arbeitet dort der Server `srv-spool`, welcher die von der Mystery Application berechneten Resultate in ein Spool-Verzeichnis befördert.
* Von dort werden die Daten von einem mysteriösen übergeordneten Dienst abgeholt.

Wenn Sie die nachfolgenden Schritte eins zu eins durchspielen möchten,
können Sie die aufgeführten Monitoring-Objekte kurz nachbauen. Zum Testen
genügt es dabei, wenn Sie einen vorhandenen Host mehrfach klonen und die
Klone entsprechend benennen.  Später kommen noch einige wenige Services
ins Spiel, die Sie dann bei Zeit für die betroffenen Hosts ins Monitoring
aufnehmen können. Auch da können Sie wieder schummeln: Mit simplen
xref:localchecks#[Dummy-Local-Checks] bekommen Sie schnell passende Services
zum Spielen.

Die Hosts im Monitoring sehen in etwa so aus:

image::bi_2_example_2.png[]


=== Ihre erste BI-Regel

Beginnen Sie mit etwas Einfachem -- quasi der einfachst möglichen sinnvollen
Aggregation überhaupt: einer Aggregation mit nur zwei Knoten. Dabei möchten
Sie den Zustand bei beiden Hosts `switch-1` und `switch-2`
zusammenfassen. Die Aggregation soll _Netzwerk_ heißen und {OK} sein,
wenn beide Switche erreichbar sind. Bei einem Teilausfall soll sie auf
{WARN} gehen und wenn beide Switche weg sind auf {CRIT}.

[{image-left}]
image::bi_aggregation_icon.png[width=80]

Legen Sie los: Das BI-Modul erreichen Sie über [.guihint]#Setup > Business Intelligence > Business Intelligence.#
Die Konfiguration der Regeln und Aggregate geschieht
innerhalb von Konfigurationspaketen: den _BI Packs_. Die Pakete
sind nicht nur deswegen praktisch, weil Sie komplexere Konfigurationen damit
besser verwalten können. Sie können auch für ein Paket Berechtigungen für
bestimmte Kontaktgruppen vergeben und somit Benutzern ohne Administratorrechte
das Editieren von Teilen der Konfiguration erlauben. Doch dazu später mehr ...

Wenn Sie das BI-Modul zum ersten Mal aufrufen, sieht das etwa so aus:

image::bi_2_default.png[]

Dort ist bereits ein Paket mit dem Titel [.guihint]#Default Pack# vorhanden. Es
enthält eine Demo für eine Aggregation, die Daten eines einzelnen
Hosts zusammenfasst.

Für das aktuelle Beispiel legen Sie am besten ein neues Paket an (Knopf [.guihint]#Add BI pack#), welches Sie _Mystery_ nennen.
Wie immer in {CMK}, vergeben Sie eine interne ID (`mystery`), welche sich später nicht ändern lässt, und einen beschreibenden Titel.
Die Option [.guihint]#Public# brauchen andere Benutzer, wenn sie Regeln in diesem Paket für ihre eigenen Regeln oder Aggregationen verwenden möchten.
Da Sie Ihre Experimente vermutlich erst mal in Ruhe alleine durchführen wollen, lassen Sie das deaktiviert:

image::bi_2_create_pack.png[]

Nach dem Anlegen finden Sie in der Hauptliste jetzt natürlich zwei Pakete:

image::bi_2_two_rulepacks.png[]

Vor jedem Eintrag steht ein Symbol zum Editieren der Eigenschaften (icon:icon_edit[]) und eines,
um zum eigentlichen _Inhalt_ des Pakets zu kommen (icon:icon_rules[]), wo Sie jetzt auch hin wollen.
Dort angelangt, legen Sie gleich Ihre erste Regel über [.guihint]#Add rule# an.

Wie immer in {CMK}, will auch diese Regel eine eindeutige ID und einen Titel haben. Der
Titel der Regel hat hier allerdings nicht nur Dokumentationscharakter, sondern wird später
auch als Name desjenigen Knotens sichtbar, den diese Regel erzeugt:

image::bi_2_create_rule_2.png[]

Der darunter folgende Kasten hat den Namen [.guihint]#Child Node Generation# und ist
der wichtigste. Hier legen Sie fest, welche Objekte in diesem Knoten
zusammengefasst werden sollen. Das können entweder andere BI-Knoten sein;
dazu würden Sie eine andere BI-Regel auswählen. Oder es sind
Monitoring-Objekte -- also Hosts oder Services.

Für das erste Beispiel wählen Sie die zweite Variante ([.guihint]#State of a host#) und legen
zwei Objekte als Kinder an, nämlich die beiden Hosts `switch-1`
und `switch-2`.  Das geschieht jeweils mit dem Knopf
[.guihint]#Add child node generator#. Hier wählen Sie dann logischerweise
[.guihint]#State of a host# und tragen jeweils den Namen des Hosts ein:

image::bi_2_create_rule_3.png[]

[#aggregationfunction]
Im dritten und letzten Kasten, [.guihint]#Aggregation Function#, geben Sie an, wie der Monitoring-Zustand des Knotens berechnet werden soll.
Grundlage dafür ist immer die Liste der Zustände der Unterknoten. Verschiedene logische
Verknüpfungen sind möglich.

Vorausgewählt ist [.guihint]#Best -- take best of all node states.# Das würde bedeuten, dass
der Knoten erst dann {CRIT} wird, wenn auch alle Unterknoten {CRIT} bzw. {DOWN} sind.
Wie oben erwähnt, soll das hier aber nicht der Fall sein. Wählen Sie stattdessen
[.guihint]#Count the number of nodes in state OK#, um die Anzahl der Unterknoten im Zustand
{OK} als Maßstab heranzuziehen. Hier werden als Schwellwerte die
beiden Zahlen 2 und 1 vorgeschlagen. Das ist prima, denn es ist genau das was
Sie brauchen:

* Wenn beide Switche {UP} sind (das wird hier als {OK} gewertet), soll der Knoten {OK} werden.
* Wenn nur ein Switch {UP} ist, wird er {WARN}.
* Und wenn beide {DOWN} sind, wird er {CRIT}.

Und so sieht die Maske ausgefüllt aus:

image::bi_2_create_rule_5.png[]

Ein Klick auf [.guihint]#Create#, und schon haben Sie Ihre erste Regel:

image::bi_2_create_rule_6.png[]


=== Ihre erste Aggregation

Nun ist es wichtig, dass Sie verstehen, dass eine Regel noch keine Aggregation
ist.  {CMK} kann ja noch nicht wissen, ob das hier alles ist oder nur
Teil eines größeren Baums! Wirkliche BI-Objekte werden erst dann erzeugt und
in der Statusoberfläche sichtbar, wenn Sie eine _Aggregation_ anlegen.
Dazu wechseln Sie in die Liste der icon:button_aggregations[] Aggregationen.

Der Knopf icon:button_add_aggregation[] bringt Sie zu einer Maske zum Anlegen einer neuen Aggregation.
Bei den [.guihint]#Aggregation groups# können Sie beliebige
Namen angeben. Diese erscheinen dann in der Statusoberfläche als Gruppen, unter denen all
diejenigen Aggregationen sichtbar werden, welche eben diese Gruppenbezeichnung teilen.
Das ist eigentlich das gleiche Konzept wie bei Hashtags oder Schlagworten.
Auch die [.guihint]#Aggregation ID# können Sie wie gewohnt frei vergeben, später aber nicht mehr ändern.

Den Inhalt der Aggregation legen Sie über [.guihint]#Add new element# fest. 
Wählen Sie hier die Einstellung [.guihint]#Call a rule# und bei [.guihint]#Rule:# die Regel, die Sie gerade angelegt haben
(und davor das Regelpaket, in dem diese sich befindet).

image::bi_2_new_aggregation.png[]

Wenn Sie die Aggregation jetzt mit icon:icon_save[] speichern, sind Sie fertig!
Ihre erste Aggregation sollte jetzt in der Statusoberfläche auftauchen -- vorausgesetzt,
Sie haben auch tatsächlich mindestens einen der Hosts `switch-1` oder `switch-2` im System!


[#statusgui]
== BI im Operating Teil 1: Die Statusansicht

=== Alle Aggregate anzeigen

Wenn Sie alles richtig gemacht haben, können Sie jetzt Ihr erstes Aggregat über die
Statusoberfläche aufrufen. Das geht am einfachsten über [.guihint]#Monitor > Business Intelligence > All Aggregations#:

image::bi_3_status_gui_1.png[]

==== Ansichten für BI erstellen
Neben den vorgefertigten BI-Ansichten können Sie auch individuell erstellte Ansichten nutzen.
Wählen Sie dazu beim xref:views#new[Anlegen einer neuen Ansicht] eine der
BI-Datenquellen. [.guihint]#BI Aggregations# liefert Informationen über die Aggregate,
[.guihint]#BI Hostname Aggregations# fügt Filter und Informationen für einzelne Hosts hinzu,
[.guihint]#BI Aggregations affected by one host# zeigt lediglich Aggregate, die sich
auf einen einzelnen Host beziehen und [.guihint]#BI Aggregations for Hosts by Hostgroups#
ermöglicht die Unterscheidung nach Host-Gruppen.

=== Mit dem Baum arbeiten

Sehen Sie sich die Darstellung des BI-Baums etwas näher an. Folgendes Beispiel
zeigt Ihr Miniaggregat in einer Situation, in der einer der beiden Switches
{DOWN} ist und der andere {UP}. Wie gewollt, geht das Aggregat dabei
in den Zustand {WARN}:

image::bi_3_tree_minimal.png[]

Dabei sehen Sie auch, dass zur Vereinheitlichung von Hosts und Services ein
Host, der {DOWN} ist, quasi wie ein Service gewertet wird, der {CRIT} ist.
Aus {UP} wird entsprechend {OK}.

Die Blätter des Baums zeigen die Zustände von Hosts und Services.
Der Host-Name -- und bei Services auch der Service-Name -- ist anklickbar
und führt Sie zum aktuellen Zustand des entsprechenden Objekts. Außerdem
sehen Sie die letzte Ausgabe des Check-Plugins.

Ganz links neben jedem Aggregat finden Sie zwei Symbole: icon:icon_showbi[]
und icon:button_availability[]. Mit dem ersten Symbol -- icon:icon_showbi[] -- kommen
Sie zu einer Seite, die nur genau dieses eine Aggregat anzeigt. Das ist natürlich
hauptsächlich dann nützlich, wenn Sie mehr als ein Aggregat angelegt haben. Es eignet
sich z.B. gut für ein Lesezeichen. icon:button_availability[] bringt Sie zur Berechnung
der Verfügbarkeit. Dazu später mehr.


=== BI ausprobieren: Was wäre wenn?

Links vom Host-Namen finden Sie noch ein interessantes Symbol: icon:icon_assume_none[].
Dies ermöglicht eine „Was wäre wenn“-Analyse. Die Idee dahinter ist einfach: Durch
einen Klick auf das Symbol schalten Sie das Objekt testweise auf einen anderen Zustand -- allerdings
nur für die BI-Oberfläche, nicht in echt!
Durch mehrfache Klicks gelangen Sie von icon:icon_assume_0[] ({OK}) über
icon:icon_assume_1[] ({WARN}), icon:icon_assume_2[] ({CRIT}) und
icon:icon_assume_3[] ({UNKNOWN}) wieder zu icon:icon_assume_none[] zurück.

BI berechnet dann den kompletten Baum anhand des angenommenen Zustands.
Folgende Abbildung zeigt das Minimalaggregat unter der Annahme, dass neben
`switch-1`, der tatsächlich ausgefallen ist, auch `switch-2` {DOWN}
wäre:

image::bi_3_assume_example_1.png[]

Der Gesamtzustand des Aggregats geht dadurch von {WARN} auf {CRIT}. Dabei wird
dessen Farbe mit einem Karomuster hinterlegt. Dieses Muster zeigt Ihnen an,
dass der *tatsächliche* Zustand eigentlich anders ist. Das ist
keineswegs immer der Fall, denn manche Änderungen bei einem Host oder Service
sind für den Gesamtzustand nicht mehr relevant, z. B. weil dieser sowieso schon
{CRIT} ist (wie hier im Bild `switch-1`).

Sie können diese „Was wäre wenn“-Analyse auf verschiedene Arten nutzen, z. B.:

* Testen, ob das BI-Aggregat so reagiert, wie Sie das wollen.
* Planung der Abschaltung einer Komponente aus Gründen der Wartung.

Bei letzterem Szenario setzen Sie das zu wartende Gerät bzw. dessen Services testweise
auf icon:icon_assume_2[]. Wenn das Gesamtaggregat dann {OK} bleibt, muss das
bedeuten, dass der Ausfall *aktuell* durch Redundanz kompensiert werden kann.


=== BI ausprobieren durch gefakte Zustände

Es gibt noch eine zweite Möglichkeit, die BI-Aggregate zu testen:
Das direkte Ändern des _tatsächlichen_ Zustands von Objekten. Das
bietet sich vor allem in einem Testsystem an.

Zu diesem Zweck gibt es bei den xref:commands#[Kommandos]
ein
Host-/Servicekommando mit dem Namen [.guihint]#Fake check results#.  Es ist per Default
nur in der Rolle Administrator verfügbar. Diese Methode wurde z. B. bei der
Erstellung der Screenshots für diesen Artikel genutzt, um `switch-1`
auf {DOWN} zu setzen. Daher kommt der verräterische Text
[.guihint]#Manually set to Down by cmkadmin#.

image::bi_3_fake_check_results.png[]

[{image-left}]
image::bi_3_master_control_checks_off.png[width=280]

Hier noch ein kleiner Tipp: Wenn Sie mit dieser Methode arbeiten, schalten
Sie am besten die aktiven Checks für die betroffenen Hosts und Services aus,
denn sonst gehen diese beim nächsten Check-Intervall sofort wieder auf den
eigentlichen Zustand zurück. Wenn Sie faul sind, machen Sie das einfach global
über das Seitenleistenelement [.guihint]#Master Control.# Vergessen Sie
nie, das später wieder zu aktivieren!


=== BI-Gruppen

Beim Anlegen des Aggregats haben wir die Eingabemöglichkeit der [.guihint]#Aggregation Groups#
kurz angesprochen. Im Beispiel hatten Sie das vorgeschlagene [.guihint]#Main# hier
einfach bestätigt. Sie sind aber bei der Vergabe der Namen völlig
frei und können ein Aggregat auch mehreren Gruppen zuweisen.

Gruppen werden dann wichtig, wenn die Anzahl der Aggregate das übersteigt, was Sie
vielleicht auf einem Bildschirm sehen möchten. Sie gelangen zu einer Gruppe, indem
Sie bei der Seite [.guihint]#All Aggregations# auf die angezeigten Namen der Gruppen klicken -- also
in unserem obigen Beispiel einfach auf die Überschrift [.guihint]#Main#. Wenn Sie bisher
nur dieses eine Aggregat haben, ändert sich natürlich nicht viel. Nur
wenn man genau hinsieht merkt man:

* Der Titel der Seite heißt jetzt [.guihint]#Aggregation group Main#.
* Die Gruppenüberschrift [.guihint]#Main# ist verschwunden.

Wenn Sie diese Ansicht öfter besuchen wollen, legen Sie doch einfach ein
Lesezeichen davon an -- am besten mit dem [.guihint]#Bookmarks#-Element in der Seitenleiste.


=== Vom Host/Service zum Aggregat

Sobald Sie BI-Aggregate eingerichtet haben, werden Sie bei Ihren Hosts und
Services im Kontextmenü ein neues icon:icon_aggr[] Symbol finden:

image::bi_3_service_popup.png[]
 
Mit diesem Symbol gelangen Sie zur Liste aller Aggregationen, in denen der
betroffene Host oder Service enthalten ist.


[#multilevel]
== Konfiguration Teil 2: Mehrstufige Bäume

Nach diesem ersten kurzen Eindruck der BI-Statusoberfläche geht es zurück
zur Konfiguration. Denn mit solch einem Miniaggregat können Sie natürlich noch niemanden
wirklich beeindrucken.

Es beginnt damit, dass Sie den Baum um eine Ebene erweitern -- also von
zwei Ebenen (Wurzel und Blätter) auf drei Ebenen (Wurzel, Zwischenebene, Blätter) gehen. Dazu kombinieren Sie Ihren vorhandenen Knoten „Switches 1 & 2“ mit dem Zustand
der NTP-Zeitsynchronisation zu einem Oberknoten „Infrastructure“.

Aber der Reihe nach -- und zunächst das Ergebnis vorweg:

image::bi_4_rule_infra_4.png[]

Voraussetzung ist, dass es einen Host `srv-ntp` gibt, der
einen Service mit dem Namen `NTP Time` hat:

image::bi_4_service_ntp.png[]

Legen Sie erst einmal eine BI-Regel an, welche als Unterknoten 1 die Regel „Switches 1 & 2“ bekommt und als Unterknoten 2 direkt den Service `NTP Time` des Hosts `srv-ntp`. Im Kopf der Regel wählen Sie `infrastructure` als Regel-ID und [.guihint]#Infrastructure# als Namen. Weitere Angaben können Sie sich erst einmal sparen:

image::bi_4_rule_infra_1.png[]

Unter [.guihint]#Child Node Generation# wird es interessant. Der erste Eintrag ist
jetzt vom Typ [.guihint]#Call a rule# und als Regel wählen Sie Ihre Regel von oben
aus. Damit „hängen“ Sie diese quasi in den Unterbaum ein.

Der zweite Unterknoten ist vom Typ [.guihint]#State of a service#, und hier wählen
Sie Ihren NTP-Host per Namen (beachten Sie hier die exakte
Schreibung, inklusive der Groß-/Kleinbuchstaben) sowie den `NTP Time`-Service per Regex:

image::bi_4_rule_infra_2.png[]

Die [.guihint]#Aggregation Function# im dritten Kasten setzen Sie dieses Mal auf
[.guihint]#Worst - take worst state of all nodes.#

Der Zustand des Knotens leitet sich bei dieser Funktion also vom schlechtesten
Zustand eines Services darunter ab. Heißt hier: Geht `NTP Time` auf {CRIT},
geht auch der Knoten auf {CRIT}.

Damit der neue größere Baum sichtbar wird, müssen Sie natürlich wieder eine
Aggregation anlegen. Am besten verändern Sie einfach die bestehende
Aggregation, so dass fortan die neue Regel verwendet wird:

image::bi_4_rule_infra_3.png[]

Auf diese Art bleiben Sie bei _einer_ Aggregation. Und die sieht dann
so aus (dieses mal sind beide Switches wieder auf {OK}):

image::bi_4_rule_infra_4.png[]


[#displayoptions]
== BI im Operating Teil 2: Alternative Darstellungen

=== Einleitung

Jetzt da Sie einen etwas interessanteren Baum haben, können Sie sich etwas genauer
mit den verschiedenen Darstellungsmöglichkeiten befassen, die {CMK} bietet. Ausgangspunkt
dafür ist die Funktion [.guihint]#Modify display options#, welche Sie im Menü [.guihint]#Display# finden. Diese öffnet einen Kasten mit Optionen. Der
Inhalt des Kastens ist immer angepasst auf die Elemente, die auf der Seite dargestellt
werden. Im Falle von BI finden Sie aktuell sechs Optionen:

image::bi_5_display_options_screen.png[]


==== Bäume sofort auf- oder zuklappen

Wenn Sie nicht nur ein Aggregat, sondern sehr viele anzeigen, dann ist die
Einstellung *Initial expansion of aggregations* hilfreich. Hier legen Sie
fest, wie weit die Bäume beim ersten Anzeigen aufgeklappt sein sollen. Die
Auswahl reicht von geschlossen ([.guihint]#collapsed#) über die ersten drei Ebenen
bis hin zu komplett geöffnet ([.guihint]#complete#).


==== Nur Probleme zeigen

Wenn Sie die Option *Show only problems* aktivieren, werden in den Bäumen nur noch solche Zweige
angezeigt, die nicht den Zustand {OK} haben. Das sieht dann z.B. so aus:

image::bi_5_only_problems.png[]


==== Art der Baumdarstellung

Unter dem Punkt *Type of tree layout* finden Sie etliche alternative
Darstellungsarten für den Baum.  Eine davon heißt [.guihint]#Table: top down#
und sieht so aus:

image::bi_5_top_down.png[]

Extrem platzsparend -- vor allem, wenn Sie viele Aggregate gleichzeitig sehen möchten --
ist die Darstellung [.guihint]#Boxes.# Hier ist jeder Knoten ein farbiger Kasten, der per
Klick aufgeklappt wird. Die Baumstruktur ist nicht mehr sichtbar, aber Sie können
sich so bei minimalem Platzbedarf schnell zu einem Problem durchklicken. Hier im Beispiel
sind die Boxen komplett aufgeklappt:

image::bi_5_boxes.png[]

=== Weitere Optionen

Letztlich können Sie ein [.guihint]#Refresh interval# von 30, 60 oder 90 Sekunden setzen und die Anzahl der Spalten über [.guihint]#Entries per row# bestimmen.


[#visualization]
=== Visualisierung von BI-Aggregaten
{CMK} beherrscht neben tabellarischen Darstellungen
auch die Visualisierung von BI-Aggregaten. So können Sie Aggregate aus
neuer Perspektive und bisweilen übersichtlicher darstellen. Sie finden die
[.guihint]#BI visualization# über icon:icon_aggr[] in der regulären
Aggregatsansicht.

image::bi_5_visualization_start.png[]

Sie können den Baum frei per Klick auf den Hintergrund bewegen und die
gesamte Darstellung per Mausrad skalieren. Sobald der Mauszeiger über
den einzelnen Knoten landet, bekommen Sie die zugehörigen Zustandsinformationen
via Hover-Fenster. Per Mausrad skalieren Sie nun die Länge der
Zweige des Baums.

image::bi_5_visualization_standard.png[]

Per Klick auf die Blatt-Knoten gelangen Sie direkt zu den Detailansichten
der Hosts oder Services. Per Rechtsklick auf die sonstigen Knoten erhalten
Sie, je nach Art des Knotens, Zugriff auf Darstellungsoptionen und
beispielsweise die verantwortliche Regel selbst; im Bild über [.guihint]#Edit rule#.

image::bi_5_visualization_context.png[]

==== Visualisierung anpassen

Wirklich interessant wird es aber erst mit dem [.guihint]#Layout Designer#, den
Sie über icon:icon_aggr[] oben neben dem Suchfeld öffnen. Zunächst
sehen Sie zwei neue Elemente: Den Kasten [.guihint]#Layout Configuration# und
zwei neue Icons an der Wurzel, icon:icon_bi_visualization_rotate[] und
icon:icon_bi_visualization_resize[].

In der Konfiguration haben Sie die Wahl
zwischen unterschiedlichen Linienarten und können die [.guihint]#Node icons#
aktivieren. Damit werden die Icons angezeigt, die Sie in den Regeln von
BI-Aggregaten im Bereich xref:bi#aggregationfunction[Aggregation Function] festlegen dürfen
(direkt zu erreichen über das Kontextmenü des Knotens). Über die Icons
icon:icon_bi_visualization_rotate[] und
icon:icon_bi_visualization_resize[] lässt sich der Baum durch Ziehen mit der Maus drehen beziehungsweise in Länge und Breite skalieren --
einmal angeklickt, erscheint zudem der Kasten [.guihint]#Style configuration# mit
weiteren Darstellungsoptionen. Welche am besten passt, finden Sie durch schlichtes Ausprobieren heraus.

image::bi_5_visualization_designer2.png[]

Die größten Anpassungen ermöglichen Ihnen jedoch die Kontextmenüs der Knoten,
die im Designer-Modus vier verschiedene Darstellungen für die Hierarchie
ab diesem Knoten bieten:

1. [.guihint]#Hierarchical style#: Standardeinstellung mit einfacher Hierarchie.
2. [.guihint]#Radial style#: Kreisförmige Anordnung mit einstellbarem Kreisausschnitt.
3. [.guihint]#Leaf-Nodes Block style#: Blatt-Knoten werden grau unterlegt als Gruppe dargestellt.
4. [.guihint]#Free-Floating style#: Dynamisches Layout mit Optionen wie Anziehung, Abständen, Länge der Äste.

image::bi_5_visualization_styles.png[]

Knoten, denen ein Stil zugeordnet wurde, lassen sich frei platzieren. Je
nach Stil unterscheiden sich auch die Optionen, beim [.guihint]#Radial style# sehen
Sie am Wurzelknoten etwa ein drittes Icon
icon:icon_bi_visualization_pie[], über das Sie die Darstellung auf einen
Kreisausschnitt beschränken können.

Über die Option [.guihint]#Detach from parent style# können Sie Knoten vom Stil des
übergeordneten Knotens lösen, um diese anders zu konfigurieren und frei
zu platzieren. In die gleiche Richtung zielt auch [.guihint]#Include parent rotation#,
womit Sie übergeordnete Knoten beim Drehen ein- und ausschließen dürfen. 

Im Grunde sind alle Stile selbsterklärend, lediglich der [.guihint]#Free-Floating style#
bedarf einiger Erklärungen. Hierbei handelt es sich um ein System aus Anziehung und
Abstoßung, wie Sie es von Gravitationssimulationen kennen. 

[cols="35,~"]
|===

|[.guihint]#Center force strength# |Anziehungskraft der Mitte auf die Knoten.
|[.guihint]#Repulsion force leaf# |Kraft des Abstoßungseffekts von Blättern auf andere Knoten.
|[.guihint]#Repulsion force branches# |Kraft der Abstoßung von Knoten auf andere Knoten im selben Zweig.
|[.guihint]#Link distance leaf# |Idealer Abstand vom Blattknoten zum vorherigen Knoten.
|[.guihint]#Link distance branches# |Idealer Abstand vom Zweigknoten zum vorherigen Knoten.
|[.guihint]#Link strength# |Stärke, mit der der ideale Abstand erzwungen wird.
|[.guihint]#Collision box leaf# |Größe des Blattknotenbereichs, der andere Knoten abstößt.
|[.guihint]#Collision box branch# |Größe des Zweigknotenbereichs, der andere Knoten abstößt.
|===

Das folgende Bild zeigt einen Zweig im [.guihint]#Free-Floating style# -- die Positionen
der einzelnen Blätter ergeben sich dynamisch gemäß der gesetzten Optionen.

image::bi_5_visualization_float.png[]

==== BI-Regeln Layout-Stil vorgeben

Sie können BI-Regeln, die Sie über das Kontextmenü der Knoten erreichen,
im Bereich [.guihint]#Rule Properties# die Layouts [.guihint]#Hierarchical#, [.guihint]#Radial#
oder [.guihint]#Leaf-Nodes Block# zuordnen sowie zugehörige Optionen festlegen.

image::bi_5_visualization_rule.png[]

==== Suchfunktion

In größeren Bäumen ist die Suchfunktion eine enorme Hilfe. Im Suchfeld [.guihint]#Search node#
können Sie einfach einen Namensteil des gewünschten Knotens eingeben und
bekommen direkt live eine Liste mit Treffern. Wenn Sie nun mit der Maus
über diese Vorschlagsliste fahren, wird der Node unter dem Mauszeiger im
Baum durch einen blauen Rand hervorgehoben -- das erleichtert eine erste
Orientierung. Klicken Sie auf einen Node in der Liste, wird der Baum auf
diesen zentriert. So lässt sich auch in Visualisierungen mit Hunderten
Nodes schnell der passende Bereich Ihrer Infrastruktur finden.

image::bi_5_visualization_search.png[]


[#config3]
== Konfiguration Teil 3: Variablen, Schablonen, Suche

=== Konfiguration mit mehr Intelligenz

Weiter geht's mit der Konfiguration. Und jetzt wird es Zeit, dass
es wirklich zur Sache geht. Bisher war das Beispiel nämlich so einfach,
dass es ohne Schwierigkeit möglich war, die Objekte in der Aggregation alle
einzeln aufzulisten. Aber was, wenn die Dinge komplexer werden? Wenn Sie
viele immer wiederkehrende gleiche oder ähnliche Abhängigkeiten formulieren
wollen? Wenn es von einer Anwendung nicht nur eine, sondern mehrere Instanzen
gibt? Oder wenn Sie mal eben hundert Einzelservices einer Datenbank zu einem
BI-Knoten zusammenfassen wollen?

Nun, dann brauchen Sie mächtigere Methoden der Konfiguration. Und die
sind genau das, was {CMK} BI gegenüber anderen Tools auszeichnet --
und leider auch die Lernkurve etwas steiler gestaltet. Es ist auch der
Grund, warum {CMK} BI sich nicht per „Drag-and-Drop“ konfigurieren
lässt. Aber wenn Sie die Möglichkeiten erst einmal kennengelernt haben, werden
Sie sie sicher nicht mehr missen wollen.


=== Parameter

Beginnen Sie mit den _Parametern._ Nehmen Sie folgende Situation: Sie
möchten bei den beiden Switches nicht nur feststellen, ob sie {UP} sind,
sondern auch den Zustand von zwei Ports wissen, die für den Uplink zuständig
sind. Insgesamt geht es um folgende vier Services:

image::bi_6_switch_service.png[]

Nun soll der Knoten [.guihint]#Switch 1 & 2# so erweitert werden, dass es anstelle
der beiden Host-Zustände für Switch 1 und 2 jeweils einen Unterknoten gibt,
der den Host-Zustand *und* die beiden Uplink-Interfaces zeigt. Diese beiden Unterknoten
sollen [.guihint]#Switch 1# bzw. [.guihint]#Switch 2# heißen.

Eigentlich bräuchten Sie jetzt also zwei neue Regeln -- für jeden Switch eine. Besser
geht das, indem Sie eine neue Regel `switch` erstellen, diese aber mit einem _Parameter_
ausstatten. Dieser Parameter ist eine Variable, die man beim Aufruf der Regel
aus dem übergeordneten Knoten, hier die alte Regel `Switch 1 & 2`,
mitgeben kann. Im Beispiel können Sie einfach entweder `1` oder
`2` übergeben. Der Parameter bekommt einen Namen, den Sie frei wählen
können. Nehmen Sie hier z. B. den Namen `NUMBER`. Die Schreibweise mit
Großbuchstaben ist rein willkürlich. Wenn Sie Kleinbuchstaben schöner finden,
können Sie gerne auch diese verwenden.

Und so sieht der Kopf der Regel aus:

image::bi_6_rule_with_parameter.png[]

Als ID für die neue Regel können Sie hier `switch` wählen. Bei [.guihint]#Parameter#
tragen Sie einfach den Namen der Variablen ein: `NUMBER`. Wichtig
ist jetzt, dass auch im [.guihint]#Rule Title# der Regel die Variable eingesetzt
wird, damit nicht beide Knoten einfach nur `Switch` heißen und so
den gleichen Namen hätten. Beim *Verwenden* der Variable wird (wie an
vielen Stellen in {CMK} üblich) vorne und hinten ein Dollarzeichen gesetzt.
Als Ergebnis werden die beiden Knoten dann `Switch 1` und
`Switch 2` heißen.


==== Präfix-Match ist für Service-Namen Default

Unter [.guihint]#Child Node Generation# fügen Sie jetzt als erstes den Host-Zustand ein.
Dabei dürfen Sie beim Host-Namen anstelle der `1` oder `2`
einfach Ihre Variable einsetzen und zwar auch hier wieder mit je einem
`$` hinten und vorne.

Das Gleiche machen Sie bei dem Host-Namen der Uplink-Interfaces. Und hier kommt
gleich noch der zweite Trick. Denn wie Sie vielleicht an der kleinen Serviceliste
oben bemerkt haben, heißen die Services für den Uplink bei beiden Switches
unterschiedlich! Das ist aber kein Problem, da BI den Service-Namen -- ganz
analog zu den bekannten Service-xref:wato_rules#[Regeln] -- immer als Präfix-Match mit
regulären Ausdrücken interpretiert. Schreiben Sie also einfach `Interface Uplink`,
erwischen Sie so alle Services _auf dem jeweiligen Host,_ die
mit `Interface Uplink` *beginnen:*

image::bi_6_rule_with_parameter_2.png[]

Übrigens: Durch das Anhängen von `$` können Sie das Präfix-Verhalten
abschalten. Ein `$` bedeutet bei regulären Ausdrücken -- im Kontext der {CMK}-Regeln -- soviel wie
„Der Text muss hier enden“. Also greift `Interface 1$` auch
nur auf `Interface 1` und nicht z.B. auch auf `Interface 10`.

Bauen Sie jetzt noch die alte Regel [.guihint]#Switch 1 & 2# so um, dass diese
anstelle der Host-Zustände die neue Regel für jeden der beiden Switche je
einmal aufruft. Und hier ist jetzt auch die Stelle, an der Sie die Werte
`1` und `2` als Parameter für die Variable `NUMBER`
übergeben:

image::bi_6_rule_with_parameter_3.png[]

Und voila: Schon haben Sie einen hübschen Baum mit drei Ebenen:

image::bi_6_rule_with_parameter_4.png[]


=== Reguläre Ausdrücke, fehlende Objekte

Die Sache mit den xref:regexes#[regulären Ausdrücken] ist nochmal
einen genaueren Blick wert.
Beim Matching der Service-Namen haben wir nämlich am Anfang
stillschweigend unterschlagen, dass es sich eben grundsätzlich um reguläre
Ausdrücke handelt. Wie gerade erwähnt, findet dabei ein Präfix-Match statt.

Wenn Sie also in einem BI-Knoten beim Service-Namen z. B. `Disk` angeben,
werden alle Services des betreffenden Hosts eingefangen, die mit
`Disk` _beginnen_.

Dabei gelten generell folgende Prinzipien:

. Wenn sich ein Knoten auf Objekte bezieht, die es (aktuell) nicht gibt, dann werden diese einfach weggelassen.
. Wenn ein Knoten dadurch leer wird, wird er selbst weggelassen.
. Ist auch der Wurzelknoten eines Aggregats leer, wird das Aggregat selbst weggelassen.

Vielleicht klingt das für Sie erst einmal etwas verwegen. Ist es nicht gefährlich,
einfach Dinge, die da sein sollten, stillschweigend wegzulassen, wenn sie fehlen?

Nun -- mit der Zeit werden Sie feststellen, wie praktisch dieses Konzept ist. Denn
dadurch können Sie „intelligente“ Regeln schreiben, die auf sehr
unterschiedliche Situationen reagieren können.  Gibt es einen Service, der
nicht bei jeder Instanz einer Anwendung vorhanden ist? Kein Problem -- er
wird einfach nur dann berücksichtigt, wenn er auch da ist. Oder werden Hosts
oder Services vorübergehend aus dem Monitoring genommen? Dann verschwinden
diese einfach aus BI, ohne dass es zu Fehlern oder dergleichen kommt. BI ist
*nicht* dafür da, um festzustellen, ob Ihre Monitoring-Konfiguration
vollständig ist!

Dieses Prinzip gilt übrigens auch bei _explizit_ definierten Services. Denn eigentlich
gibt es diese ja nicht, weil die Service-Namen ja immer als reguläre Ausdrücke
gesehen werden, auch wenn sie keine speziellen Sonderzeichen wie `pass:[.*]`
enthalten. Es handelt sich immer automatisch um ein Suchmuster.


=== Knoten als Ergebnis einer Suche anlegen

Sie können aber noch weiter automatisieren und vor allem flexibel auf Veränderungen
reagieren. Weiter geht es mit dem Beispiel der beiden Anwendungsserver
`srv-mys-1` und `srv-mys-2` aus dem Beispiel. Ihr Baum soll
weiter wachsen. Der Knoten [.guihint]#Infrastructure# soll auf Ebene 2 rutschen.
Und als endgültige Wurzel soll eine Regel mit dem
Titel [.guihint]#The Mystery Application# dienen, unter der alles hängen wird. Neben
[.guihint]#Infrastructure# soll es einen Knoten mit dem Namen [.guihint]#Mystery Servers#
geben.
Unter diesem sollen die (aktuell) zwei Mystery-Server hängen. Von jedem
kommen ein paar exemplarische Services in das Aggregat.
Das Ergebnis soll so aussehen:

image::bi_6_mystery_tree.png[]


==== Unterste Regel: Mystery Server X

Fangen Sie von unten an. Denn das ist in BI immer der einfachste Weg.
Unten gibt es die neue Regel [.guihint]#Mystery Server X#. Natürlich verwenden
Sie einen Parameter, damit Sie nicht für jeden Server eine eigene
Regel brauchen. Den Parameter nennen Sie z. B. wieder `NUMBER`.
Er soll dann später als Wert `1` oder `2` haben.
Wie bereits oben geschehen, müssen Sie `NUMBER` abermals
im Kopf der Regel bei [.guihint]#Parameters# eintragen.

Der folgende Child-Node-Generator sieht dann so aus:

image::bi_6_mystery_server_rule.png[]

Hier ist Folgendes bemerkenswert:

* Beim Host-Namen `srv-mys-$NUMBER$` wird die Nummer aus dem Parameter eingesetzt.
* Bei [.guihint]#Service Regex:# wird der raffinierte xref:regexes#[reguläre Ausdruck] `CPU|Memory` eingesetzt, der mit einem senkrechten Balken alternative Service-Namen (-Anfänge) zulässt und auf alle Services greift, die mit `CPU` oder `Memory` beginnen. Das spart eine Verdoppelung der Konfiguration!

Übrigens: Dieses Beispiel ist natürlich noch nicht unbedingt perfekt.
Zum Beispiel
wurde Zustand des Hosts selbst gar nicht aufgenommen. Wenn also einer
der Server {DOWN} geht, werden die Services auf diesem veralten ([.guihint]#stale#
gehen), aber der Zustand wird {OK} bleiben und das Aggregat von dem
Ausfall nichts „mitbekommen“. Wenn Sie so etwas aber wissen möchten, sollten Sie neben
den Services auf jeden Fall auch den Host-Zustand aufnehmen.


==== Mittlere Regel: Mystery Servers

Diese Regel wird interessant. Sie fasst die beiden Mystery-Server zu einem
Knoten zusammen. Nun soll es möglich sein, dass die Anzahl der Server
nicht festgelegt ist und durchaus später auch mal drei oder mehr sein kann.
Oder es könnte gar sein, dass es dutzende Instanzen der Mystery-Anwendung
gibt -- jede mit einer anderen Anzahl von Servern.

Der Trick liegt im Child-Node-Generator-Typ [.guihint]#Create nodes based on a host search#.
Dieser sucht nach vorhandenen Hosts und erzeugt Knoten auf Basis der gefundenen
Hosts. Er sieht hier so aus:

image::bi_6_mystery_server_rule2.png[]

Das Ganze funktioniert so:

. Sie formulieren eine Suchbedingung, um Hosts zu finden.
. Für jeden gefundenen Host wird ein Child-Node angelegt.
. Dabei können Sie aus den gefundenen Host-Namen Teile herausschneiden und als Parameter bereitstellen.

Den Anfang macht das Finden.
Hier stehen Ihnen wie üblich Host-Merkmale zur Verfügung.
Im Beispiel können Sie darauf verzichten und stattdessen den regulären Ausdruck `srv-mys-(pass:[.*])` für den Host-Namen verwenden.
Dieser greift auf alle Hosts, die mit `srv-mys-` beginnen.
Das `pass:[.*]` steht für eine beliebige Zeichenfolge.

Wichtig ist hierbei, dass das `pass:[.*]` _eingeklammert_ ist, also `(pass:[.*])`. Durch
die Klammerung bildet der Match eine sogenannte _Gruppe_. In dieser wird genau der Text eingefangen (und gespeichert),
auf den das `pass:[.*]` greift -- hier also `1` oder `2`.
Die Match-Gruppen werden intern durchnummeriert. Hier gibt es nur
eine, welche die Nummer 1 bekommt.
Auf den gematchten Text können Sie später daher mit `$1$` zugreifen.

Die Suche wird jetzt zwei Hosts finden:

[cols=2]
|===
|Host-Name |Wert von `$1$` 

|`srv-mys-1` |1
|`srv-mys-2` |2
|===

Für jeden gefundenen Host erzeugen Sie einen Unterknoten mit der
Funktion [.guihint]#Call a rule#.  Wählen Sie die Regel `Mystery Server $NUMBER$` aus,
die Sie gerade angelegt haben. Als Argument für `NUMBER`
übergeben Sie die Match-Gruppe: `$1$`.

Jetzt wird also die Unterregel `Mystery Server $NUMBER$` zweimal aufgerufen:
einmal mit `1` und einmal mit `2`.

Sollte in Zukunft einmal ein neuer Server mit dem Namen `srv-mys-3` ins Monitoring
aufgenommen werden, so wird dieser *automatisch* im BI-Aggregat auftauchen.
Der Zustand des Hosts ist dabei egal.
Auch wenn der Server  {DOWN} ist,
wird er natürlich *nicht* aus dem Aggregat entfernt!

Zugegeben, das ist hier eine sehr steile Lernkurve. Diese Methode ist
wirklich komplex. Aber wenn Sie das erst einmal ausprobiert und verstanden haben,
werden Sie auch verstehen, wie mächtig das ganze Konzept ist.
Und bislang wurden die Möglichkeiten gerade erst angekratzt!



==== Oberste Regel

Der neue oberste Knoten [.guihint]#The Mystery Application# ist jetzt einfach: Dazu
ist eine neue Regel notwendig, die zwei Unterknoten der Art [.guihint]#Call a rule#
hat. Diese beiden Regeln sind die bestehende [.guihint]#Infrastructure# und die gerade neu
angelegte Regel mit dem Namen [.guihint]#Mystery Servers.#


=== Knoten mit Servicesuche anlegen

Analog zu der Host-Suche gibt es auch einen Child-Generator-Typ der
[.guihint]#Create nodes based on a service search# heißt. Hier sehen Sie ein Beispiel:

image::bi_6_service_search.png[]

Sie können hier sowohl beim Host als auch beim Service mit `()`
Teilausdrücke einklammern. Hierbei gilt:

* Wählen Sie [.guihint]#Regex for host name#, so _müssen_ Sie genau einen Klammerausdruck definieren. Der Match-Text wird dann als `$1$` bereitgestellt.
* Wählen Sie [.guihint]#All hosts#, so wird der Host-Name komplett als `$1$` bereitgestellt.
* Im Service-Namen dürfen Sie mehrere Subgruppen verwenden. Die zugehörigen Match-Texte werden als `$2$`, `$3$` usw. bereitgestellt.

Und vergessen Sie nie, dass Sie mit icon:icon_help[] stets die Inline-Hilfe aufrufen können.


=== Alle übrigen Services

Vielleicht sind Sie bei Ihren Versuchen über den Child-Node-Generator
[.guihint]#State of remaining services# gestolpert. Dieser erzeugt für
jeden Service eines Hosts, der in Ihrem BI-Aggregat noch nirgends einsortiert
ist, einen Knoten. Dies ist nützlich, wenn Sie BI dazu verwenden, um den
Zustand aller Services eines Hosts übersichtlich zu gruppieren -- so wie
dies im mitgelieferten Beispiel gemacht wird.


[#hostaggr]
== Die vordefinierte Host-Aggregation

Wie erwähnt, können Sie BI auch dazu verwenden, die Services
eines Hosts strukturiert anzuzeigen. Dabei fassen Sie alle Services zu einem
Baum in einem Aggregat zusammen und verwenden grundsätzlich die Funktion
[.guihint]#worst#. Der Gesamtzustand eines Hosts zeigt dann nur noch, ob es irgendein
Problem bei dem Host gibt. Und Sie nutzen BI als übersichtliche „Drill Down“-Methode.

Für diesen Zweck liefert {CMK} bereits einen vordefinierten Satz an
Regeln mit, welchen Sie einfach nur freischalten müssen. Diese Regeln sind
auf die Darstellung von Services auf Windows- oder Linux-Hosts optimiert,
aber Sie können sie natürlich nach Ihren Wünschen anpassen. Sie finden
alle Regeln im Regelpaket [.guihint]#Default#. Wie üblich gelangen Sie von dort
durch einen Klick auf icon:icon_rules[] zu den Regeln:

image::bi_7_wato_start.png[]

Dort finden Sie eine Liste von zwölf Regeln (hier gekürzt):

image::bi_7_host_tree_rules.png[]

Die erste Regel ist die Regel für die Wurzel des Baums. Das Symbol
icon:icon_aggr[] bei dieser Regel bringt Sie zu einer Baumdarstellung.
Hier können Sie sehen, wie die Regeln untereinander verschachtelt sind:

image::bi_7_host_tree_tree.png[width=40%]


Zurück in der Liste der Regeln, gelangen Sie mit dem Knopf icon:button_aggregations[] [.guihint]#Aggregations#
zur Liste der Aggregationen in diesem Regelpaket -- welche nur aus einer einzigen
Aggregation besteht. Entfernen Sie in den icon:icon_edit[] Details einfach die
Checkbox bei [.guihint]#Currently disable this aggregation# und sofort bekommen Sie pro
Host eine Aggregation mit dem Titel `Host myhost123`. Diese sieht dann
z. B. so aus:

image::bi_7_host_aggregation.png[]


[#permissions]
== Berechtigungen und Sichtbarkeit

=== Berechtigungen zum Editieren

Nochmal zurück zu den Regelpaketen. Normalerweise benötigt man für
alle Editieraktionen in BI die Rolle [.guihint]#Administrator#. Genauer gesagt gibt es
für BI zwei xref:wato_user#roles[Berechtigungen,] zu finden unter [.guihint]#Setup > Users > Roles & permissions:#

image::bi_8_wato_permissions.png[]

In der Rolle [.guihint]#User# ist standardmäßig nur die erste der beiden Berechtigungen
aktiv. Normale
Benutzer können also nur in solchen Regelpaketen arbeiten, in denen sie als
Kontakt hinterlegt sind.
Dies erledigen Sie in den icon:icon_edit[] Details des Regelpakets.

Im folgenden Beispiel ist bei [.guihint]#Permitted Contact Groups# die Kontaktgruppe [.guihint]#The Mystery Admins# hinterlegt.
Alle Mitglieder dieser Gruppe dürfen jetzt in diesem Paket Regeln editieren:

image::bi_8_pack_properties.png[]

Übrigens können Sie mit
[.guihint]#Public > Allow all users to refer to rules contained in this pack#
anderen Benutzern zumindest erlauben, die hier enthaltenen Regeln
zu *verwenden* -- also (woanders) eigene Regeln zu definieren, welche
diese Regeln als Unterknoten aufrufen.


=== Berechtigungen auf Hosts und Services

Und wie ist es eigentlich mit der Sichtbarkeit der Aggregationen in der
Statusoberfläche? Welcher Kontakt darf was sehen?

Nun -- in BI-Aggregaten selbst können Sie keine Rechte vergeben. Das
geschieht indirekt über die Sichtbarkeit der Hosts und Services und wird
geregelt über die Berechtigung [.guihint]#See all hosts and services# einzelner Rollen unter
[.guihint]#Setup > Roles & Permissions:#

image::bi_8_see_all.png[]

In der Rolle [.guihint]#User# ist dieses Recht per Default ausgeknipst. Normale
Benutzer können nur für sie freigegebene Hosts und Services sehen. Und das
drückt sich bei BI so aus, dass sie genau alle BI-Aggregationen sehen, welche
mindestens einen freigegebenen Host oder Service enthalten. Diese Aggregate
enthalten aber auch *nur* diese berechtigten Objekte und sind daher
eventuell ausgedünnt. Und das wiederum bedeutet, dass sie für unterschiedliche
Benutzer unterschiedliche Zustände haben können!

Ob das jetzt gut oder schlecht ist, hängt davon ab, was Sie möchten. Im Zweifel
können Sie die Berechtigung umschalten und manchen oder allen Benutzern
erlauben, über den Umweg von BI auch Hosts und Services zu sehen, für die
sie kein Kontakt sind -- und damit sicherstellen, dass der Zustand eines
Aggregats immer für alle gleich ist.

Das ganze Thema spielt natürlich nur dann eine Rolle, wenn es überhaupt
Aggregate gibt, die so bunt zusammengewürfelt sind, dass eben manche
Benutzer nur für Teile davon Kontakte sind.


[#operating]
== BI im Operating Teil 3: Wartungszeiten, Quittierung

=== Die generelle Idee

Wie hält es BI eigentlich mit icon:icon_downtime[alt="Symbol einer Wartungszeit."] xref:glossar#scheduled_downtime[Wartungszeiten?]
Nun, hier haben wir lange nachgedacht und mit vielen Anwendern diskutiert.
Das Ergebnis ist wie folgt:

* Sie können ein BI-Aggregat nicht direkt in eine Wartungszeit versetzen -- müssen es aber auch nicht, denn ...
* die Wartungszeit eines BI-Aggregats leitet sich automatisch von den Wartungszeiten seiner Hosts und Services ab.

Um zu verstehen, nach welcher Regel BI den Zustand „in Wartung“ berechnet, hilft es, wenn Sie sich
zurückerinnern, was die eigentliche Idee hinter Wartungszeiten ist: 
_Am betreffenden Objekt wird gerade gearbeitet. Mit Ausfällen ist zu rechnen. Auch wenn das Objekt gerade {OK} ist, sollte man sich nicht darauf verlassen. Es kann jederzeit {CRIT} werden. Dies ist bekannt und dokumentiert. Es soll nicht benachrichtigt werden._

Diese Idee kann man 1:1 auf BI übertragen: Im Aggregat gibt es vielleicht ein paar Hosts und
Services, welche gerade in Wartung sind. Ob diese gerade {OK} oder {CRIT} sind, spielt keine
Rolle, denn es ist ja eigentlich Zufall, ob die Objekte während der Wartungsarbeiten ab und
zu mal wieder funktionieren oder nicht. Bloß weil im Aggregat aber ein Wartungsobjekt steckt, bedeutet
das aber auch nicht gleich, dass die Anwendung, die das Aggregat abbildet, selbst „bedroht“ ist und
als „in Wartung“ markiert sein muss. Denn es kann ja Redundanz eingebaut sein, welche den
Ausfall der Wartungsobjekte kompensiert. Nur wenn so ein Ausfall tatsächlich zum {CRIT}-Zustand des
Aggregats führen würde -- es also eben _nicht_ genug Redundanz gibt und das Aggregat wirklich bedroht
ist -- genau dann wird es von {CMK} als „in Wartung“ markiert. Wobei auch
hier der _aktuelle_ Zustand der Objekte generell keine Rolle spielt.

Knapper formuliert ist die genaue Regel wie folgt:

Wenn ein {CRIT}-Zustand eines Hosts/Services zu einem {CRIT}-Zustand der Aggregation führen *würde,*
führt ein „in Wartung“-Zustand dieses Hosts/Services zu einem „in Wartung“-Zustand der Aggregation.

Wichtig: der _wirkliche_ aktuelle Zustand der Hosts/Services spielt bei der Berechnung _keine_ Rolle - was in Wartung ist, wird in der BI-Logik als {CRIT} angenommen. Warum? Weil ein {UP}- oder {OK}-Zustand während einer Wartungszeit reiner Zufall ist, etwa, wenn ein Host zwischen mehreren Neustarts zwischenzeitlich für wenige Sekunden {UP} meldet.

Und hier haben wir jetzt noch ein Beispiel: Um Platz zu sparen ist dies eine Variante
mit nur einem Mystery-Server anstelle von zwei:

image::bi_9_downtimes.png[]

Hier ist zunächst der Host `switch-1` in Wartung.
Für den Knoten `Infrastructure` hat das aber keine Auswirkung, denn `switch-2` ist ja _nicht_ in Wartung.
Also ist `Infrastructure` auch nicht in Wartung.
Dort fehlt das Symbol icon:icon_derived_downtime[alt="Symbol einer vom Host abgeleiteten Wartungszeit bei einem Service."] für abgeleitete Wartungszeiten.

Aber: Auch der Service `Memory` auf `srv-mys-1` ist in Wartung.
Dieser ist _nicht_ redundant. Die Wartung vererbt sich daher auf den
Vaterknoten `Mystery Server 1`, dann weiter auf `Mystery Servers`
und schließlich auf den obersten Knoten `The Mystery Application`. Also
ist dieser auch in Wartung.


=== Kommando Wartungszeit

Haben wir oben geschrieben, dass Sie ein BI-Aggregat nicht manuell in eine
Wartungszeit versetzen können? Das stimmt eigentlich nur halb. Denn
Sie werden in der Tat bei BI-Aggregaten ein Kommando icon:icon_commands[]
zum Setzen von Wartungszeiten finden. Aber das macht nichts anderes, als
auf auf _jeden einzelnen Host und Service_ des Aggregats eine Wartung
einzutragen. Das führt dann natürlich in der Regel dazu, dass das Aggregat
selbst auch als in Wartung gilt. Aber das ist nur indirekt.


=== Tuning-Möglichkeiten

Oben haben Sie gesehen, dass die Wartungszeitberechnung auf Basis eines
angenommenen {CRIT}-Zustands läuft. In den Eigenschaften eines Aggregats
können Sie den Algorithmus so anpassen, dass ein Knoten bereits bei einem
angenommenen {WARN}-Zustand als in Wartung gilt. Die Option hierzu
heißt [.guihint]#Escalate downtimes based on aggregated WARN state#:

image::bi_9_downtimes_on_warn.png[]

Die Grundannahme, dass die in Wartung befindlichen Objekte {CRIT}
sind, bleibt bestehen. Einen Unterschied gibt es nur dort, wo
aufgrund der Aggregatsfunktion aus {CRIT} ein {WARN} werden kann --
so wie das z. B. beim allerersten Beispiel mit [.guihint]#Count the number of nodes in state OK#
der Fall war. Hier würde eine Wartungszeit bereits dann angenommen
werden, wenn auch nur einer der beiden Switche in Wartung wäre.


=== Quittierungen

Ganz ähnlich zu den Wartungszeiten wird auch die Information, ob ein Problem
icon:icon_ack[] xref:basics_ackn#[quittiert] ist, von BI automatisch berechnet.
Diesmal spielt der Zustand der Objekte durchaus eine Rolle.

Die Idee hier ist, folgendes Konzept auf BI zu übertragen: Ein Objekt
hat ein Problem ({WARN}, {CRIT}). Aber das ist bekannt und jemand
arbeitet daran (icon:icon_ack[]).

Sie können das für ein Aggregat wie folgt selbst berechnen:

* Nehmen Sie an, dass alle Hosts und Services, die icon:icon_ack[] quittierte Probleme haben, wieder {OK} wären.
* Würde das Aggregat dann selbst auch wieder {OK}? Genau dann gilt es ebenfalls als icon:icon_ack[] quittiert.

Würde das Aggregat jedoch {WARN} oder {CRIT} bleiben, dann gilt
es *nicht* als quittiert. Dann muss es noch mindestens ein weiteres
wichtiges Problem geben, das selbst nicht quittiert ist und den {OK}-Zustand
des Aggregats entfernt.

Übrigens wird Ihnen bei den icon:icon_commands[] Kommandos zu einem
BI-Aggregat angeboten, dessen Probleme zu quittieren. Dies bedeutet aber nur,
dass _alle_ im Aggregat erfassten Hosts und Services quittiert werden
(nur solche, die aktuell auch Probleme haben).


[#freeze]
== Veränderungen sichtbar machen

Die Knoten eines Aggregats können sich im laufenden Betrieb schon mal ändern.
Durch eingefrorene Aggregate (_frozen aggregations_) können Sie solche Änderungen sichtbar machen.

Hier ein Beispiel: 
Ein Switch mit 6 Ports soll {OK} sein, wenn 5 Services/Ports {OK} sind.
Dann werden im Rahmen eines Firmware-Updates 2 Ports umbenannt und die zugehörigen Services verschwinden aus dem Monitoring.

Das Aggregat bestünde dann aus 4 Services mit Zustand {OK}, wäre selbst aber {WARN} oder {CRIT} -- ohne einen Hinweis auf den Grund zu liefern.
Und genau hier setzt die eingefrorene Aggregate an:
Sie frieren den Ist-Zustand ein und können später jederzeit per Klick aufführen lassen, was sich seitdem geändert hat, also welche Knoten hinzugekommen beziehungsweise herausgefallen sind.
Soll heißen: Während die Regeln eines Aggregats dessen Zustand erklären, erklären eingefrorene Aggregate Zustandsänderungen.


=== Einfrieren und vergleichen

Der Einsatz der Einfrieren-Funktion ist denkbar einfach:
Aktivieren Sie die Option [.guihint]#New aggregations are frozen# in den Einstellungen von Aggregaten.

image::bi_freeze_option.png["Option zum Einfrieren einer Aggregation."]

Damit wird das Aggregat beim Speichern eingefroren - und zwar immer, wenn das Häkchen neu gesetzt wird;
auch wenn das Aggregat vorher schon bestanden hat (trotz des Hinweises auf [.guihint]#New aggregations ...#).
Um den Eingefroren-Status aufzuheben, entfernen Sie das Häkchen entsprechend.

Im Monitoring sehen Sie nun neben dem Aggregat ein neues icon:icon_bi_freeze[alt="Schneeflocken-Symbol"] Schneeflocken-Symbol.
Damit gelangen Sie zu der Differenzansicht:
Links der eingefrorene Baum, rechts der aktuelle Baum mit hervorgehobenen Veränderungen (hier der Wegfall des Services [.guihint]#backup3)#:

.Ohne eingefrorenen Zustand bliebe der Wegfall von [.guihint]#backup3# unbemerkt
image::bi_freeze_diff.png["Differenz zwischen eingefrorenem und aktuellem Zustand eines Aggregats."]

Wenn Sie nun den aktuellen Zustand abermals einfrieren wollen, erledigen Sie das über [.guihint]#Commands > Freeze aggregations.#
Aber Vorsicht: Es gibt immer nur einen eingefrorenen Ist-Zustand und keine Historie mit älteren Zuständen.


[#availability]
== Verfügbarkeit

Genauso wie bei Hosts und Services können Sie auch bei BI die xref:availability#[Verfügbarkeit]
eines oder mehrerer Aggregate für beliebige Zeiträume in der Vergangenheit berechnen lassen.
Dazu rekonstruiert das BI-Modul anhand der Historie von Hosts und Services den Zustand
des Aggregats für jeden Zeitpunkt in der Vergangenheit. Somit können Sie auch für solche
Zeiträume Verfügbarkeiten berechnen, in denen das Aggregat noch gar nicht konfiguriert war!

image::bi_10_availability_example.png[]

Alle Einzelheiten zu BI und Verfügbarkeit finden Sie im Artikel zur Verfügbarkeit im
Abschnitt zu xref:availability#bi[BI].


ifdef::onprem[]
== BI im verteilten Monitoring

Was geschieht eigentlich mit BI in einer xref:distributed_monitoring#[verteilten Umgebung]?
Also wenn die Hosts über mehrere Monitoring-Server verteilt sind?

Die Antwort ist relativ einfach: Es funktioniert -- und zwar ohne, dass Sie etwas Weiteres beachten
müssten. Da BI eine Komponente der Benutzeroberfläche ist und diese von Haus aus
eine verteilte Umgebung annimmt, ist dies für BI vollkommen transparent.

Sollte ein Standort aktuell nicht erreichbar oder durch Sie manuell aus der GUI
ausgeblendet worden sein, so sind die Hosts des Standorts für BI nicht mehr vorhanden.
Das bedeutet dann:

* BI-Aggregate, die _ausschließlich_ aus Objekten dieses Standorts aufgebaut sind, verschwinden.
* BI-Aggregate, die _teilweise_ aus Objekten dieses Standorts aufgebaut sind, werden ausgedünnt.

In letzterem Fall kann sich das natürlich auf den Zustand der betroffenen
Aggregate auswirken. Wie genau, das hängt von Ihren Aggregatsfunktionen
ab. Wenn Sie z. B. überall [.guihint]#worst# verwendet haben, kann der Zustand insgesamt
nur gleich bleiben oder besser werden. Denn Objekte des nicht mehr vorhandenen Standorts könnten
{WARN} oder {CRIT} gewesen sein. Bei anderen Aggregatsfunktionen können
sich natürlich andere Zustände ergeben.

Ob dieses Verhalten für Sie sinnvoll ist oder nicht, müssen Sie im Einzelfall beurteilen.
BI ist auf jeden Fall so aufgebaut, dass nicht vorhandene Objekte nicht in einem
Aggregat vorkommen können und auch nicht vermisst werden. Denn alle BI-Regeln arbeiten
ja, wie bereits oben erklärt, ausschließlich mit Suchmustern.
endif::[]


[#biasservice]
== Benachrichtigungen, BI als Service

=== Aktive Checks oder Spezialagent

[{image-left}]
image::bi_large_icon_notifications.png[width=80]

Kann man bei Zustandsänderungen in BI-Aggregaten eigentlich
xref:notifications#[benachrichtigen]? Nun -- auf direktem Wege geht das erst mal nicht,
denn BI ist ausschließlich in der GUI vorhanden und hat keinen Bezug zum
eigentlichen Monitoring. Aber: Sie können aus BI-Aggregaten normale Services
machen. Und diese können dann natürlich wieder Benachrichtigungen auslösen.
Dazu gibt es zwei Möglichkeiten:

* Mit dem Spezialagenten [.guihint]#Check state of BI Aggregations#
* Mit aktiven Checks vom Typ [.guihint]#Check State of BI Aggregation#


=== Benachrichtigungen über Spezialagenten

Den Anfang macht die Methode „xref:special_agents#[Spezialagent]“,
denn diese ist immer dann gut, wenn Sie mehr als nur eine Handvoll
Aggregate als Services erzeugen wollen. Dazu finden Sie unter
[.guihint]#Setup > Agents > Other integrations > BI Aggregations# den passenden Regelsatz:

image::bi_12_datasource_program.png[]

Hier können Sie sogar verschiedene Optionen angeben, zu welchen Hosts die Services hinzugefügt werden sollen.
Sie müssen nicht zwingend an dem Host kleben, welchem der Spezialagent zugeordnet ist ([.guihint]#Assign to the querying host#).
Möglich ist auch eine Zuordnung zu den Hosts, welche das Aggregat betrifft ([.guihint]#Assign to the affected hosts#).
Das macht allerdings nur dann wirklich Sinn, wenn es sich dabei immer nur um einen
Host handelt. Über reguläre Ausdrücke und Ersetzungen können Sie sogar noch flexibler
zuordnen. Das Ganze geschieht dann über den xref:piggyback#[Piggyback-Mechanismus].

*Wichtig:* Falls der Host, dem Sie diese Regel zuweisen, auch noch über den normalen Agenten überwacht
werden soll, müssen Sie unbedingt in dessen Einstellungen dafür sorgen, dass reguläre Agent *und*
Spezialagenten ausgeführt werden:

image::bi_12_agent_and_all_ds_program.png[]


=== Benachrichtigungen über einen aktiven Check

Die Benachrichtigung mit einem aktiven Check ist quasi der direktere Weg und erfordert
keinen künstlichen „Hilfs-Host“, welcher das Datenquellenprogramm ausführt.
Da er jedes Aggregat einzeln abfragen muss, ist er aber bei einer größeren
Menge von Aggregaten deutlich weniger performant und dann auch umständlicher
aufzusetzen.

Das Ganze geht so: Es gibt einen aktiven Check, welcher per HTTP von der xref:rest_api#[REST-API] von
{CMK} den Zustand von BI-Aggregaten abrufen kann.
Diesen können Sie bequem mit dem Regelsatz
[.guihint]#Setup > Services > Other services > Check State of BI Aggregation# einrichten:

image::bi_12_active_check_rule.png[]

Beachten Sie hierbei Folgendes:

* Aktivieren Sie diese Regel nur für den Host, welcher den entsprechenden neuen BI-Service bekommen soll.
* Die URL muss diejenige sein, mittels der *dieser Host* auf die GUI von {CMK} zugreifen kann.
* Der Benutzer muss ein xref:wato_user#automation[Automationsbenutzer] sein. Nur solch einer darf die REST-API abrufen. Der Benutzer `automation` bietet sich an, da dieser immer automatisch für solche Zwecke angelegt wird.
* Tragen Sie bei [.guihint]#Automation Secret# das [.guihint]#Automation secret for machine accounts# des Benutzers ein, welches Sie in der Konfigurationsmaske der Benutzereigenschaften finden (nur, wenn Sie einen anderen Automationsbenutzer verwenden als `automation`).

Im Beispiel ist [.guihint]#Automatically track downtimes of aggregation# aktiviert.
Genau genommen sind damit die _scheduled_ Downtimes gemeint,
also die geplanten Wartungszeiten. Damit wird der neue aktive Service automatisch
eine Wartungszeit bekommen, wenn auch das BI-Aggregat dies tut.

Der neue Service zeigt dann -- natürlich mit einer Verzögerung von bis zu einem
Check-Intervall -- den Zustand des Aggregats. Im Beispiel liegt der BI-Check
auf dem Host `srv-mys-1`:

image::bi_12_active_check_output.png[]

Diesen Service können Sie dann wie gewohnt Kontakten zuordnen und ihn als Basis für Benachrichtigungen verwenden.

//ML: Die Option zum Markieren von Singel-Host-Aggregationen im ersten Kapitel gibt es nicht mehr - den Werks nach _scheint_ das in die interne Optimierung geflossen zu sein, aber das eigentliche Entfernen taucht nicht aut. Falls dem so ist, ist auch das zweite Kapitel eher obsolet: Nimmt man den Hinweis auf Single-Hosts raus, bleibt kaum Nennenswerte Information übrig. Meinung?
////
== Performance

=== Single Host Aggregations

Zu guter Letzt noch ein paar Worte über das Thema Performance. Denn Performance
ist _immer_ wichtig. {CMK} hat schon viele Jahre harten Praxiseinsatz
hinter sich und man glaubt gar nicht, was unsere lieben Anwender alles so
mit BI anstellen! Daher ist schon viel Zeit in die Optimierung der
Performance geflossen, damit BI immer schnell antwortet und wenig CPU-Zeit
benötigt.

Gerade wenn Sie mit Host-Aggregationen arbeiten kann es aber ruck zuck
passieren, dass Sie ein paar tausend Aggregate haben. Damit BI dann
immer noch schnell ist, ist es wichtig, dass Sie Aggregate, von denen
Sie wissen, _dass sie nur einen Host betreffen_, also solche
markieren.

Kreuzen Sie dazu in den icon:icon_edit[] Details der Aggregation die Checkbox
[.guihint]#Optimization > The aggregation covers data from only one host and its parents#
an. BI tut sich dann wesentlich leichter bei der Suche nach den passenden Services.

=== Interner Ablauf

_Falls_ Sie an eine Grenze stoßen, wo die Berechnungszeiten langsam spürbar werden,
werden Sie das vor allem in der Zeit kurz nach einem [.guihint]#Activate Changes# feststellen.
BI ist so aufgebaut, dass die Bäume in zwei Schritten berechnet werden:

. Die _Struktur_ der Aggregate wird berechnet (wir nennen das Kompilieren).
. Der _Status_ der Aggregate wird berechnet.

Der erste Schritt ist immer dann notwendig, wenn sich die Menge der Hosts
oder Services geändert hat. Und dies kann bekanntlich nur dann passieren, wenn Änderungen an der Konfiguration aktiviert werden.
Bei den Aggregationen, die als Single Host Aggregations markiert sind,
wird der Komplierungsschritt hinausgezögert bis der betreffende Host aufgerufen wird.
Darin besteht ein wichtiger Teil der Optimierung.

Der Status von Aggregaten wird natürlich immer wieder neu berechnet, sobald
Sie sich ein Aggregat anzeigen lassen.
////
