// -*- coding: utf-8 -*-

// IGNORE ${myvar} mybot + Automationspaket Automationssoftware RCC RMK Robotmk auftürmen quelloffene →
// NONASCII →
// MFS: Bitte die hier prüfen, ob überall als Code ausgezeichnet: exe rcc rebot robotmk_agent_plugin robotmk_scheduler
include::global_attr.adoc[]
= Checkmk Synthetic Monitoring mit Robotmk
:revdate: draft
:title: Checkmk Synthetic Monitoring
:description: Checkmk Synthetic Monitoring integriert Software-Tests auf Basis von Robot Framework ins Monitoring

{related-start}
xref:wato_monitoringagents#[Monitoring-Agenten]
xref:agent_deployment#[Automatische Agenten-Updates]
{related-end}

////
Fragen fürs Review:
Umbegung vielleicht überall als Ausführungsumgebung -- oder sonstwas?
Falls Artikel arg komplex wirkt: Vielleicht zu Anfang zeigen, wie der Test am Ende im Monitoring zu sehen sein wird? Haben wir ähnlich bei BI, aber das ist da drei Nummern komplexer ...

MFS: Welche Umgebung gemeint ist, ist immer aus dem Kontext ersichtlich. Das passt also.
Was zu sehen ist, muss hier IMHO nicht gezeigt werden, auch weil in verschiedenen Szenarien verschiedene Aspekte relevanter sind: Mal geht es vor allem darum, ob etwas klappt oder nicht, mal will man sehr schnelle Antwortzeiten sicher stellen, nimmt dafür aber gelegentliche Fehlschläge (die dann erneute Ausführung bedeuten) in Kauf.
////


[#intro]
== Synthetisches Monitoring mit Robot Framework

// MFS: Hier gehört der Hinweis hin, dass dieser Artikel eine Komponente beschreibt, die Teil von Checkmk Enterprise (oder erst Cloud? in der CEE bereits in "License usage" gelistet) ist und eine zusätzliche Subskription erfordert. Mit dem Checkmk Icon und so. Hinweis, dass mit drei Gratis-Tests genug Freiheit besteht, Robotmk ausgiebig testen zu können.

Mit {CMK} können Sie Ihre eigene Infrastruktur sehr genau überwachen -- bis hin zur Frage, ob ein bestimmter Service, beispielsweise ein Webserver, ordentlich läuft.
Wird Ihre Webseite über einen Cloud-Service von Dritten betrieben, werden Sie keinen Zugriff auf den Service selbst haben, können aber über einen HTTP-Check prüfen, ob die Webseite erreichbar ist.
Aber was sagt das über die Nutzererfahrung aus? Dass ein Online-Shop erreichbar ist, heißt ja noch nicht, dass die Navigation, Bestellprozesse und dergleichen reibungslos funktionieren.

An dieser Stelle setzt das {CMK} Synthetic Monitoring an.
Mit dem Plugin Robotmk bietet {CMK} echtes End-to-End-Monitoring, also die Überwachung laufender Anwendungen aus Sicht der Nutzer.
Das eigentliche Testen übernimmt dabei die Open-Source-Software link:https://robotframework.org/[Robot Framework^] -- zu dessen Foundation auch die {CMK} GmbH gehört.
// MFS:  -- in deren Trägerverein auch {comfull} Mitglied ist... Siehe https://en.wikipedia.org/wiki/Registered_association_(Finland)
// MFS: Für den Firmennamen haben wir ein eigenes Macro, nur falls wir mal Datadog übernehmen (Checkdog GmbH) oder auf KGaA umfirmieren.
Mit der Automationssoftware lässt sich Nutzerverhalten komplett automatisieren, um beispielsweise Bestellprozesse in Online-Shops Klick für Klick nachzustellen.
Das Besondere an Robot Framework: Tests werden nicht über echten Code geschrieben, sondern über einfach zu verwendende Keywords wie `Open Browser` -- so genügt ein `Open Browser checkmk.com` zum Aufrufen der {CMK}-Webseite.
// MFS: Keywords sind echter Code! Eher: Tests werden in einer eigenen, sehr einfachen Syntax geschrieben: auf Keywords wie `Open Browser` folgen Argumente -- so genügt ein `Open Browser checkmk.com` zum Aufrufen der {CMK}-Webseite.
Mehrere Testfälle werden dann in so genannten Test-Suites zusammengefasst (in Form einer `.robot`-Datei).

Robotmk kann nun diese Robot-Framework-Test-Suites auf dem Host triggern und ihre Ausführung als Service in {CMK} monitoren.
// MFS: Hier wirkt "monitoren" etwas sperrig. Und: Nicht nur Ausführung, auch Resultate.
Für das Triggern auf dem Host ist die Agenten-Regel [.guihint]#Robotmk Scheduler# verantwortlich, für das Monitoring die Service-Regel [.guihint]#Robotmk suite status.#
Auch die einzelnen Tests werden überwacht und als Services ins Monitoring aufgenommen (über die Regel [.guihint]#Robotmk tests).#
In der {CMK}-Weboberfläche finden Sie zum einen zugehörige Performance-Graphen, zum anderen aber auch die Original-Auswertungen von Robot Framework selbst.
// MFS: Die letzten Sätze kommen IMHO zu früh. Ich würde an dieser Stelle nur bis zum groben Zusammenspiel der Komponenten, noch ohne Benennung, gehen. 

// ML: Den Absatz habe ich nach Simons Kommentar schon etwas vereinfacht -- aber guck mal bitte, ob das zu viel ist; oder gegebenenfalls in einen Unterpunkt "Voraussetzungen" oder so gehört.
// MFS: Wie oben schon angedeutet: Ja, hier ist ein Unterpunkt sinnvoll, ich würde ihn "Komponenten" nennen.
Die Robot-Framework-Test-Suites müssen auf einem *Windows-Host* bereit stehen.
Für die Ausführung benötigt Robot Framework Zugriff auf deren Abhängigkeiten, Python, Bibliotheken, Treiber und so weiter.
// MFS: Was ist mit Treiber gemeint? Die auf die Browser-APIs zugreifenden Automatisierungstreiber?
Diese Konfiguration ist unabhängig von {CMK} und kann sogar deklarativ in einem portablen Paket abgelegt werden.
Verantwortlich dafür ist das quelloffene Kommandozeilen-Werkzeug link:https://robocorp.com/docs/rcc/overview[RCC:^] Dieses baut anhand Ihrer Konfigurationsdateien im YAML-Format virtuelle Python-Umgebungen samt Abhängigkeiten und Robot Framework selbst -- und sorgt auch für die Ausführung der Tests.
Ein solches RCC-Automationspaket mit der Paketkonfiguration (`robot.yaml`), der Definition der Ausführungsumgebung (`conda.yaml`) und den Test-Suites (`tests.robot`) wird auch _Roboter_ genannt.
// MFS: Dateinamen sind Code: Backticks!
RCC wird mit dem {CMK}-Agenten ausgerollt, das Automationspaket muss auf dem Host bereitstehen.
Der große Vorteil von RCC: Der ausführende Windows-Host selbst muss nicht konfiguriert werden.
// MFS: Muss wirklich gar nichts konfiguriert werden? Wenn ich alles richtig verstanden habe, müssen RCC und die Tests vorhanden sein oder deployen wir beide auch schon? Und dann war da noch der User und sein Login...


// ML: Die Alternative wäre hier Applikationen überwachen, wie diskutiert - was noch nicht erwähnt wurde: Die Hello-World-Test-Suite testet gar keine Anwendung! Von daher: Definitiv hier Test-Suites, später mal Erweiterung/eigener ARtikel zu dem ganzen Kram.
// MFS: Das passt erstmal. Detailliert in Robot Framework und die Überwachung von Win32-Apps oder Webapps kann man sich anderswo einarbeiten.
[#ruleconfig]
== Test-Suites überwachen mit Robotmk
Im Folgenden zeigen wir, wie Sie eine Test-Test-Suite ins Monitoring aufnehmen und überwachen.
Als Beispiel dient dazu eine simple Hello-World-Suite.
// MFS: Evtl. hier anhängen ..., die letzlich nichts anderes macht, als das Zusammenspiel von RCC, Robot Framework und dem Checkmk-Server sicherzustellen.
Eine Einführung in Robot Framework ist hier freilich nicht das Thema, ein kurzer Blick in das Automationspaket und die Test-Test-Suite muss aber sein, damit Sie sehen, welche Daten wo im Monitoring landen.

Das Beispiel läuft auf Basis von RCC, so dass der Windows-Host nicht extra konfiguriert werden muss.
// MFS: Entweder gleich präziser "so dass neben RCC zunächst keine weiteren Programme installiert sein müssen" oder schwammiger "was das spätere Deployment stark vereinfacht"
Das Automationspaket basiert auf der Minimalvorlage für einen per Robot Framework deklarierten `robot`.
Ein solches Paket lässt sich mit dem Kommando `rcc create myrobot` per Assistent erstellen.
Das Verzeichnis hat anschließend mindestens folgenden Inhalt:

.C:\robot\mybot\
[{file}]
----
conda.yaml
robot.yaml
tasks.robot
----

// MFS: Admonition vom Typ "Tip" verwenden?
Wichtig: RCC könnte an dieser Stelle auch Test-Suites auf Basis von zum Beispiel Python verarbeiten, für den Einsatz in {CMK} muss es aber die Deklaration nach Robot Framework sein.

Der Suite-Ordner beinhaltet nun zwei wichtige Dateien: Die Deklaration der für die Ausführung benötigten Umgebung in der Datei `conda.yaml` und die eigentlichen Tests in der Datei `tasks.robot` (die Suite).

Für die Umgebung werden in diesem Fall lediglich die Abhängigkeiten Python, Pip und Robot Framework installiert.
Im Monitoring taucht der Umgebungsbau später als [.guihint]#RCC environment build status# auf.
Nur wenn die Umgebung erfolgreich gebaut wird, können auch die Tests abgearbeitet und gemonitort werden.
// MFS: Ist es sinnvoll, hier das Monitoring vorwegzunehmen?

.C:\robot\mybot\conda.yaml
[{file}]
----
channels:
  - conda-forge

dependencies:
  - python=3.10.12                # https://pyreadiness.org/3.10
  - pip=23.2.1                    # https://pip.pypa.io/en/stable/news
  - pip:
     - robotframework
----

Die eigentliche Test-Test-Suite sieht nun wie folgt aus:

.C:\robot\mybot\tasks.robot
[{file}]
----
*** Settings ***
Documentation       Template robot main suite.

*** Tasks ***
Mytask
    Log    ${myvar}
    Sleep    15 Seconds
    Log    Done.

----

Hier wird also lediglich der Wert der später in {CMK} zu setzenden Variable `myvar` ausgegeben, dann 15 Sekunden gewartet und abschließend `Done` ausgegeben.
// MFS: Wenn das ein "Hello World" Beispiel sein soll, warum dann "Done."?

[#agentconfig]
=== Regel für das Agentenplugin konfigurieren
// MFS: Vorweg: Hier wird weder bei Dir noch in Simons Blog-Artikel klar, was alles mit dem Agenten deployed werden kann. Ist es RCC und das kümmert sich dann um das Python-Geraffel und die Dependencies? Oder können auch Suites deployed werden? Greife ich gleich noch einmal auf.
Den Robotmk Scheduler finden Sie unter [.guihint]#Setup > Agent rules > Robotmk Scheduler (Windows).#
Da die Regel recht umfangreich ist, hier zunächst ein Blick auf die noch leere Konfiguration:

image::robotmk_scheduler_00.png[alt="Leere Robotmk-Scheduler-Regel."]

Zunächst benötigt der Scheduler die Angabe des Basisverzeichnisses, in dem all Ihre Test-Suites liegen.
Tragen Sie diesen beliebigen, absoluten Pfad unter [.guihint]#Base directory of suites# ein, beispielsweise `C:\robots`.

image::robotmk_scheduler_01.png[alt="Pfad für Test-Suites."]

Mit [.guihint]#Suite execution groups# folgt nun ein {CMK}-eigenes Konzept.
Test-Suites werden von Robot Framework nacheinander abgearbeitet.
In der Praxis geht es häufig um Tests, die auf dem Desktop ausgeführt werden und da könnten sich mehrere Test-Suites gleichzeitig in die Quere kommen (sich gegenseitig "die Maus klauen").
Die Ausführungsgruppen sind nun eine Art Kapselung für Test-Suites.
Ausführungsgruppen werden parallel verarbeitet.
So lassen sich Test-Suites, die nicht auf den Desktop angewiesen sind, ohne Wartezeiten durchführen.
Die einzige explizite Einstellung ist das Ausführungsintervall, das Sie unter [.guihint]#Group execution interval# setzen.

image::robotmk_scheduler_02.png[alt="Ausführungsintervall für Ausführungsgruppen."]

// MFS: Admonition?
Achtung: Die Test-Suites in der Ausführungsgruppe haben natürlich selbst eine gewisse Laufzeit, bestimmt durch den Timeout einer einzelnen Ausführung und die maximale Anzahl wiederholter Ausführungen im Falle fehlgeschlagener Tests. 
Das Ausführungsintervall der Gruppe muss folglich größer sein als die Summe der maximalen Laufzeiten aller Test-Suites in der Gruppe.
Die maximale Laufzeit einer Test-Suite berechnet sich wie folgt: [.guihint]#Timeout per attempt# x (1 + [.guihint]#Maximum number of re-executions#).
// MFS: × (0xd7) statt x (0x78)

Nun geht es an die Konfiguration einer ersten Suite.
Unter [.guihint]#Application name# können Sie einen beliebigen Namen eingeben.
Dieser Name muss nicht eindeutig sein!
Sinnvoll ist hier der Name der zu überwachenden Anwendung, beispielsweise `Online Shop.`
Nun kann es natürlich vorkommen, dass eben dieser Online Shop mehrfach getestet wird, sei es durch andere Test-Suites oder dieselbe Test-Suite mit unterschiedlichen Parametern.
Um in solchen Fällen trotz identischer Namen dennoch eine Eindeutigkeit in den Ergebnissen zu erzielen, gibt es das Feld [.guihint]#Variant.#
Wird die Anwendung `My Online Shop` etwa einmal auf Deutsch und einmal auf Englisch getestet (über entsprechende Parameter), könnten Sie hier entsprechende Kürzel verwenden.
Im Monitoring gibt es dann Ergebnisse für `My Online Shop - DE` und `My Online Shop - EN.`

Notwendig ist hingegen die Angabe unter [.guihint]#Path to test suite.#
Die Pfadangabe ist relativ zum oben angegebenen Basisverzeichnis, also beispielsweise schlicht `mybot` für ein Verzeichnis `C:\robot\mybot`.
Alternativ kann hier auch direkt eine robot-Datei angegeben werden, etwa `C:\robot\mybot\shopping.robot` -- je nach Aufbau Ihres Robot-Framework-Projekts.

image::robotmk_scheduler_03.png[alt="Bezeichnung und Pfad der Suite."]

Weiter geht es mit der [.guihint]#Execution configuration.#
Unter [.guihint]#Timeout per attempt# legen Sie fest, wie lange eine Test-Suite maximal laufen darf -- pro Versuch.
Mit [.guihint]#Robot Framework re-executions# können Sie nun Robot Framework anweisen, Test-Suites bei fehlgeschlagenen Tests komplett oder inkrementell zu wiederholen.
Wenn die einzelnen Tests einer Test-Suite unabhängig voneinander sind, bietet sich die inkrementelle Strategie an, um Zeit zu sparen.
Testet die Test-Suite hingegen eine logische Abfolge, etwa "Login -> Aufruf Produktseite -> Produkt in den Warenkorb -> Checkout", muss die Test-Suite natürlich komplett neu abgearbeitet werden.
Am Ende gibt es immer nur ein Ergebnis.

Bei kompletten Wiederholungen werden für das Endergebbnis nur in sich abgeschlossene Suite-Ergebnisse berücksichtigt: Schlägt ein Test bei der letzten Wiederholung fehl, wird die Test-Suite als Fehlschlag gewertet.
Bei inkrementellen Wiederholungen setzt sich das Endergebnis aus den besten Teilergebnissen zusammen: Laufen einige Tests erst im dritten Anlauf erfolgreich durch, wird auch das Endergebnis als Erfolg gewertet.
Zur Erinnerung: Die Kombination aus Versuchen und maximalen Laufzeiten aller Test-Suites einer Ausführungsgruppe bestimmt deren minimales Ausführungsintervall.

image::robotmk_scheduler_04.png[alt="Konfiguration von Ausfühungslaufzeiten und -wiederholungen."]

Standardmäßig ist die Ausführung via RCC unter [.guihint]#Automated environment setup (via RCC)# aktiviert, für die Sie zwei Werte eintragen müssen.
Zum einen benötigt RCC die Angabe, wo die Datei `robot.yaml` liegt.
Deren primärer Zweck ist der Verweis auf die Datei `conda.yaml`, die für den Aufbau der Python-Umgebung verantwortlich ist, also die Installation von Python und Abhängigkeiten.
Diese Angabe ist abhängig davon, ob Sie oben als [.guihint]#Path to test suite# ein Verzeichnis oder eine robot-Datei angegeben haben.
Für das obige Verzeichnis `C:\robot\mybot` ist es entsprechend `mybot\robot.yaml`.
Für eine robot-Datei `C:\robot\mybot\foobar\foo.robot` wäre es `robot.yaml`.
// ML: Den Pfad müsste man nochmal checken - die Inline-Hilfe ist da bislang etwas vage/falsch, was das "relativ zu" betrifft.

Beim folgenden Zeitlimit für den Bau der Python-Umgebung sollten Sie bedenken, dass bisweilen größere Datenmengen heruntergeladen und eingerichtet werden müssen.
Insbesondere für die benötigten Browser fallen hier schnell einige Hundert Megabyte an -- allerdings nur beim ersten Durchlauf.
Später wird je nach Verfügbarkeit und Bedarf auf die bereits gebauten Umgebungen zurückgegriffen.

////
// ML: Option soll wieder raus
Die letzte RCC-Option [.guihint]#Load environment variables from file# benötigen Sie eigenlich nur, wenn Test-Suites online bei Robocorp laufen und dort individuelle Umgebungsvariablen benötigen.
////
image::robotmk_scheduler_05.png[alt="RCC-Konfiguration der Suite."]

Unter [.guihint]#Robot Framework parameters# haben Sie die Möglichkeit, einige der Kommandozeilenparameter von Robot Framework zu nutzen (die auch der Befehl `robot --help` anzeigt).
Sollten Sie weitere Parameter nutzen wollen, hilft die Option [.guihint]#Argument files.#
Eine hier angegebene Datei kann beliebige robot-Parameter beinhalten.
Weitere Informationen über die einzelnen Parameter bekommen Sie über die Inline-Hilfe.

Für unser Beispielprojekt wird lediglich die Option [.guihint]#Variables# aktiviert und eine Variable `myvar` mit dem Wert `My Value` gesetzt -- Sie erinnern sich an den Befehl `Log    ${myvar}` oben in der Datei `tasks.robot`?
Dies ist die zugehörige Referenz.

image::robotmk_scheduler_06.png[alt="Kommandozeilenparameter von Robot Framework."]

Am Ende der Suite-Konfiguration gibt es noch drei simple Optionen.
[.guihint]#Execute as a specific user# ermöglicht es, Robotmk im Kontext eines bestimmten Nutzerkontos auszuführen.
Hintergrund: Standardmäßig wird Robotmk im Kontext des {CMK}-Agenten ausgeführt, der keine Berechtigung für den Zugriff auf den Desktop hat.
// MFS: Das darf präziser sein: Der {CMK}-Agent läuft unter der Kennung _Local System_
Hier kann nun ein Nutzer angegeben werden, der permanent an einer Desktop-Sitzung angemeldet ist und entsprechend Zugriff auf grafische Desktop-Anwendungen hat.
// MFS: Würde ich härter formulieren "der permanent an einer Desktop-Sitzung angemeldet sein muss"

Mit [.guihint]#Assign result to piggyback host# lassen sich die Ergebnisse der Test-Suite einem anderen Host zuweisen.
Testet Robot Framework zum Beispiel den Bestellprozess eines Online-Shops, ließen sich die Ergebnisse so dem zugehörigen Webserver zuweisen.

Jeder Testdurchlauf produziert Daten, die unter `C:\ProgramData\checkmk\agent\robotmk_output\working\suites\` abgelegt werden.
Standardmäßig werden die Ergebnisse der letzten 14 Tage behalten, allerdings sollten Sie bedenken, dass sich hier schnell große Datenberge auftürmen.
Pro Durchlauf fallen mindestens knapp 500 Kilobyte Daten an -- mit komplexeren Test-Suites und beispielsweise eingebettete Screenshots können es aber auch schnell einige Megabyte sein.
Je nach Ausführungsintervall, Größe des Reports und Anforderungen an Ihre Dokumentation sollten Sie hier eingreifen.

image::robotmk_scheduler_07.png[alt="Optionen für Nutzerkontext, Host-Zuweisung und automatische Aufräumarbeiten."]

Hier angelangt, könnten Sie nun weitere Test-Suites in dieser Ausführungsgruppe oder weitere Ausführungsgruppen erstellen.

Am Ende warten noch zwei Optionen, die sich wiederum auf die komplette Robotmk-Scheduler-Konfiguration beziehen.

[.guihint]#RCC profile configuration# erlaubt die Angabe von Proxy-Servern sowie davon auszunehmende Hosts.

Sehr nützlich kann auch [.guihint]#Grace period before scheduler starts# sein: Der Scheduler startet zusammen mit dem {CMK}-Agenten noch vor der Desktop-Anmeldung -- was freilich dazu führt, dass etwaige Tests auf dem Desktop fehlschlagen müssen.
Über eine Vorlaufzeit lässt sich der Start manuell verzögern.

image::robotmk_scheduler_08.png[alt="Optionen für Proxy-Server und eine Vorlaufszeit für den Scheduler-Start."]

Damit ist die Konfiguration abgeschlossen und Sie können das Plugin samt Konfiguration über die Agentenbäckerei verteilen.

// MFS: Der folgende Abschnitt gehört meiner Ansicht ins Troubleshooting ("Liefert der Agent die erwarteten Daten?"), denn bis eben haben wir den Agenten konfiguriert. Deployment ist noch nicht erfolgt. 
==== Daten in der Agentenausgabe
Die Ausgabe im Agenten ist recht umfangreich: In mehreren Sektionen werden Fehlermeldungen, Status, Konfiguration und Test-Daten übermittelt.
Letztere finden sich in der Sektion `robotmk_suite_execution_report`, hier ein stark gekürzter Auszug:

.mysite-robot-host-agent.txt
[{json}]
----
<<<robotmk_suite_execution_report:sep(0)>>>
{
    "attempts": [
        {
            "index": 1,
            "outcome": "AllTestsPassed",
            "runtime": 20
        }
    ],
    "rebot": {
        "Ok": {
            "xml": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n
			<robot generator=\"Rebot 6.1.1 (Python 3.10.12 on win32)\" 
			generated=\"20240319 16:23:19.944\" 
			rpa=\"true\" 
			schemaversion=\"4\">\r\n<suite id=\"s1\" 
			name=\"Mybot\" 
			source=\"C:\\ProgramData\\checkmk\\agent\\robot\\mybot\">\r\n<suite id=\"s1-s1\" 
			name=\"Tasks\" 
			source=\"C:\\ProgramData\\checkmk\\agent\\robot\\mybot\\tasks.robot\">\r\n<test id=\"s1-s1-t1\" 
			name=\"Mytask\" 
			line=\"6\">\r\n<kw 
			name=\"Sleep\" 
			library=\"BuiltIn\">\r\n<arg>2 Seconds</arg>\r\n<doc>Pauses the test executed for the given time.</doc>\r\n<msg 
			timestamp=\"20240319 16:23:02.936\" 
			level=\"INFO\">Slept 2 seconds</msg>\r\n<status 
			status=\"PASS\" 
			starttime=\"20240319 16:23:00.934\" 
			endtime=\"20240319 16:23:02.936\"/>"
        }
    },
    "suite_id": "mybot",
    "timestamp": 1710861778
}
...
"html_base64":"PCFET0NUWVBFIGh0bWw+DQo8aHRtbCBsYW ...
----

Interessant sind hier vor allem zwei Bereiche.
Zum einen "rebot": Das Tool `rebot` produziert den eigentlichen Statusbericht für Robot Framework aus gegebenenfalls mehreren Teilergebnissen (daher auch re-bot).
Zum anderen die letzte Zeile `html_base64`: Danach folgen die HTML-Berichte von Robot Framework base64-kodiert.
Auch Screenshots, die über Tests angefertigt werden, werden auf diese Weise übertragen -- entsprechend umfangreich ist die Ausgabe/Datenmenge im Agenten.

[#serviceconfig]
=== Service-Regeln konfigurieren
==== Regel für Suite-Status anlegen
Zur Erinnerung: In der Agenten-Regel oben wurden maximale Laufzeiten für Test-Suites festgelegt.
Mit der Regel [.guihint]#Robotmk suite status# lassen sich diese Laufzeiten auswerten.
So können Sie den Service etwa auf {CRIT} setzen, wenn 90 Prozent aller zusammengerechneten Timeouts erreicht werden.

image::robotmk_service_suite_status_01.png[alt="Konfigurationsdialog für Grenzwerte für Laufzeiten von Test-Suites."]

Im Bereich [.guihint]#Conditions# gibt es die Möglichkeit, die Regel auf bestimmte Test-Suites zu beschränken.

image::robotmk_service_suite_status_02.png[alt="Dialog mit Beschränkung auf die Test-Suite mybot."]

==== Regel für Test-Status anlegen
Auch für einzelne Tests in den Test-Suites lassen sich weitere Daten ins Monitoring holen, über die Regel [.guihint]#Robotmk test status.#
Hier finden Sie wieder die Möglichkeit, Laufzeiten zu überwachen, sowohl von Tests als auch von Keywords.
Die Überwachung von  Keywords ist dabei eine {CMK}-eigene Funktion.
Daher könnte auch der Suite-interne Status im Bericht `OK` sein, weil die Test-Suite innerhalb der maximal erlaubten Laufzeit verarbeitet wurde -- in {CMK} jedoch {WARN} oder {CRIT}, weil schon bei zum Beispiel 80 Prozent dieser maximal erlaubten Laufzeit ein Statuswechsel stattfindet.

Zudem können über die Option [.guihint]#Enable metrics for high-level keywords# Metriken für übergeordnete Keywords erzeugt werden.
Dies kann insbesondere bei verschachtelten Tests mit vielen (Nutzer-)Keywords nützlich sein.

Hier im Beispiel liegen die Schwellwerte für die maximale Laufzeit eines Tests bei 10 und 30 Sekunden.
Die Auswirkungen werden Sie unten im Kapitel xref:#monitoring[Robotmk im Monitoring] sehen.

image::robotmk_service_test_status_01.png[alt="Regel zum Überwachen von Keywords mit Beispielwerten."]


Abermals gibt es im Bereich [.guihint]#Conditions# eine explizite Filtermöglichkeit, hier für einzelne Tests.

image::robotmk_service_test_status_02.png[alt="Dialog mit beschränkbar auf den Test mytask."]

////
MFS: Vor dem Monitoring muss der Agent deployed werden.

Da momentan noch nicht alles automatisiert ist, halte ich hier einen Einschub

=== Windows-Host für Robotmk vorbereiten

für sinnvoll:

* RCC installieren, oder?
* Nutzer anlegen und dafür sorgen, dass der entweder lokal automatisch angemeldet wird (VM mit virtuellem Framebuffer) oder RDP konfigurieren und für Login (bspw. FreeRDP) sorgen.
* Agentenpaket installieren
* Hinweis auf automatische Agenten-Updates, damit _künftig_ alles weitere von selbst geht

Mittelfristig soll der Checkmk-Server auch FreeRDP im Hintergrund machen können und vielleicht legen wir ja auch mal User mit `net user` an.
////

[#monitoring]
=== Robotmk im Monitoring
Im Monitoring finden Sie anschließend Services für den Status des Robotmk Schedulers sowie der einzelnen Test-Suites und Tests.

==== Scheduler-Status
Der Service [.guihint]#RMK Scheduler Status# ist {OK}, wenn der Scheduler anläuft und erfolgreich die Ausführungsumgebungen bauen konnte.

image::robotmk_monitorng_scheduler.png[alt="Status des Schedulers im Monitoring."]

==== Suite-Status
Der Status der Test-Suite wird in einem nach ihr benannten Service wiedergegeben, beispielsweise [.guihint]#RMK mybot Suite.#

image::robotmk_monitorng_suite.png[alt="Status der Test-Suite im Monitoring."]

==== Test-Status
Wirklich interessant wird es bei der Auswertung der Tests.
Hier im Bild sehen Sie nun die Auswirkung oben gesetzten Schwellwerte für Laufzeit von Tests -- hier die 10 Sekunden für den Zustand {WARN}.
Da im Test selbst die Anweisung `Sleep 15 Seconds` schon für eine längere Laufzeit sorgt, muss dieser Service hier auf {WARN} gehen, obwohl der Test natürlich erfolgreich verlaufen ist.
Dass der Test erfolgreich verlaufen ist, zeigt der Bericht von Robot Framework, den Sie über das icon:icon_log[Alt="Log-Icon."] Log-Icon bekommen.

image::robotmk_monitorng_test.png[alt="Status des Tests im Monitoring."]

Der Bericht zeigt nun klar und deutlich, dass Test und Test-Suite erfolgreich durchgelaufen sind.

image::robotmk_monitorng_report_01.png[alt="Robot-Framework-Bericht für Test-Suite Mybot."]

Ganz unten in den Daten sehen Sie auch die einzelnen Keywords, hier zum Beispiel [.guihint]#Log ${myvar}# samt dem in {CMK} für `myvar` gesetzten Wert `My value`.

image::robotmk_monitorng_report_02.png[alt="Robot-Framework-Bericht auf Ebene der Keywords."]


// ML: Schau mal bitte, ob die alle rein müssen und ob die Erklärungen ausreichen -- wollte es möglichst kurz haben.
[#troubleshooting]
== Troubleshooting

=== Scheduler meldet `No Data`
Wenn der Scheduler keinerlei Daten bekommt, hat der Bau der Umgebung vermutlich nicht funktioniert.
Ein häufiger Grund dafür sind Netzwerkprobleme, aufgrund derer zum Beispiel bestimmte Abhängigkeiten nicht geladen werden können.
Schauen Sie in diesem Fall in die zugehörige Log-Datei unter `C:\ProgramData\checkmk\agent\robotmk_output\working\environment_building`.

=== Environment Building schlägt fehl: `exit status 252`
Grundsätzlich können Test-Suites auch auf zum Beispiel Ruby, Python oder anderen Sprachen aufgebaut werden.
Der Einsatz in {CMK} ist jedoch auf Robot Framework ausgelegt.
Die Meldung `exit status 252` verweist auf eine nicht unterstützte Suite.

=== Environment Building schlägt fehl: `post-install script execution`
Dies ist ein besonders interessanter Fehler, der Ihnen auf frischen Windows-Systemen begegnen könnte.
// MFS: könnte? kann! oder gleich
// Dies ist ein besonders interessanter Fehler, der gelegentlich auf frisch installierten Windows-Systemen auftritt.
In der `conda.yaml` können auch Anweisungen hinterlegt werden, die nach der Installation der Abhängigkeiten ausgeführt werden sollen -- beispielsweise die Initialisierung des Robot-Framework-Browsers.
Hier sollen also Python-Befehle ausgeführt werden.
Nun hat Windows standardmäßig Aliasse für `python.exe` und `python3.exe` vorgegeben, die auf den Microsoft-Store verweisen.
Diese Aliasse müssen Sie unter `Einstellungen/Aliase für App-Ausführung` deaktivieren.
	
[#files]
== Dateien und Verzeichnisse
	
[cols="30,~",options="header"]
|===
|Pfad |Bedeutung
|`C:\ProgramData\checkmk\agent\robotmk_output\working\suites\` |Logs und Ergebnisse der Suites
|`C:\ProgramData\checkmk\agent\robotmk_output\working\environment_building` |Logs zum Aufbau virtueller Umgebungen
|`C:\ProgramData\checkmk\agent\robotmk_output\working\rcc_setup` |Meldungen der RCC-Ausführung
|`C:\ProgramData\checkmk\agent\logs\robotmk_scheduler_rCURRENT.log` |Log des Agentenplugins
|`C:\ProgramData\checkmk\agent\bin\` |rcc.exe und robotmk_scheduler.exe
|`C:\ProgramData\checkmk\agent\plugins\` |Agentenplugin robotmk_agent_plugin.exe
|===


