// -*- coding: utf-8 -*-
// IGNORE ∨
include::global_attr.adoc[]
:keywords: REST
= Die {CMK} REST-API
:title: Die {CMK} REST-API
:description: Die REST-API von {CMK} macht den Zugriff auf alle Funktionen der gewählten Edition via HTTP-Anfragen möglich. Lesen Sie hier, wie Sie die API nutzen.


[#intro]
== Einleitung

Mit der {CMK} REST-API als Anwendungsprogrammierschnittstelle können Sie die Aufgaben, die Sie sonst in {CMK} über die GUI erledigen, per Kommando oder Skript mit HTTP-Anfragen an den {CMK}-Server übermitteln und ausführen lassen.

Das _REST_ im Namen der REST-API steht für _REpresentational State Transfer_ und beschreibt eine Architektur für den Austausch von Daten auf verteilten Systemen -- insbesondere für Web-Dienste.
Eine API, die gemäß der REST-Architektur implementiert ist, folgt bestimmten Prinzipien, z.B. dem Client-Server-Modell, der zustandslosen Kommunikation und einer einheitlichen Schnittstelle.
In der Praxis erfolgt die Umsetzung bevorzugt über das HTTP-Protokoll, wobei die Ressourcen per Uniform Resource Identifier (URI) angesprochen werden und auf diese mit HTTP-Methoden (GET, POST, PUT, DELETE) zugegriffen wird.

Soviel zu den REST-Prinzipien.
Ihre Vorteile zeigen sich in den konkreten Features, die Ihnen die {CMK} REST-API bietet:

[cols="25,~"]
|===
|Protokoll |Das Hypertext Transfer Protocol (*HTTP/1.1*) wird als Transportsystem für die Kommunikation genutzt.
|Kodierung |Als Datenformat wird die JavaScript Object Notation (*JSON*) verwendet.
Die Nutzdaten (_payload_) der Antworten werden mit JSON serialisiert und in UTF-8 kodiert.
Datums- und Zeitangaben sind im *ISO-8601*-Format mit gültigen Zeitzoneninformationen kodiert.
|Sprache |Englisch ist die Sprache für Labels, Identifiers und die API-Dokumentation.
|Authentifizierung |Der Zugriff auf die API wird einem Client nur dann gestattet, wenn er die Berechtigung mittels *HTTP-Authentifizierung* (z.B. „Bearer“) nachgewiesen hat.
|Versionierung |Die API ist versioniert und folgt den Grundprinzipien des Standards *Semantic Versioning 2.x.*
Details finden Sie im xref:versioning[Abschnitt zur Versionierung] weiter unten.
|Dokumentation |Die API wird in einem maschinenlesbaren Schema und einem menschenlesbaren Format in englischer Sprache dokumentiert, mit allen Ressourcen, ihren Eingabe- und Ausgabeparametern und den zugehörigen Wertebereichen.
Die API ist mit der *OpenAPI Specification (OAS) 3.x* erstellt, einem API-Beschreibungsformat speziell für REST-APIs.
Das mit dieser Spezifikation erstellte API-Dokument wird für den Benutzer mit ReDoc angezeigt, einem responsiven Web-Design für OpenAPI-Dokumente.
// ES: Swagger hier auch erwähnen
|Beispiel-Code |Um die Verwendung zu demonstrieren, gibt es zu jeder Anfrage Beispiel-Code für verschiedene Anwendungen (z.B. für Curl und Httpie).
// ES: Konkretisieren, was "es gibt Beispiele" bedeutet (in der API-Doku sind Beispiele hinterlegt, die du kopieren, anpassen oder direkt interaktiv ausführen kannst)
|Fehleranzeige |Die API sendet im Fehlerfall numerische *HTTP-Status-Codes* und eine Diagnosemeldung des Problems, die bei der Suche nach möglichen Ursachen für fehlerhafte Anfragen hilft.
|REST-API Klassifizierung |Die API erfüllt alle vier Ebenen (0 bis 3) des *Richardson Maturity Model (RMM)*, mit dem beurteilt werden kann, wie viel REST in einer API steckt.
In Ebene 1 wird die Einführung von Ressourcen gefordert, damit über die API statt zu einem globalen Endpunkt zu individuellen Endpunkten kommuniziert werden kann.
Ebene 2 wird erfüllt, wenn für die Anfragen HTTP-Methoden verwendet werden.
Auf der (höchsten) Ebene 3 dokumentiert sich die API quasi selbst, indem der Server mit der Antwort auf eine Anfrage die nächsten möglichen Aktionen und die dabei anzusprechenden Ressourcen mitteilt, und es dem Client so ermöglicht, die verfügbare Funktionalität selbst zu entdecken.
Diese Bereitstellung von Zusatzinformationen wird auch „Hypermedia as the Engine of Application State“ (*HATEOAS*) genannt.
|===

// Ein nach der OpenAPI Spezifikation erstelltes OpenAPI-Dokument kann im JSON- oder im YAML-Format vorliegen. Der Benutzer kann aus der API-Dokumentation das zugrundeliegende OpenAPI-Dokument im JSON-Format herunterladen.

Neben diesen generellen Komfortfunktionen soll die REST-API die komplette Funktionalität abdecken, die {CMK} über die GUI und über Kommandoschnittstelle bietet.

// ES: Es gibt in CMK 2.5.0 nur eine einzige API-Doku, die mit allen Editionen ausgeliefert wird. Man muss dann für jede Funktion, die man nutzen will, nachlesen, ob sie für die vorhandene Edition verfügbar ist. Ich habe Zweifel daran, ob die Informationen akkurat sind, weil von 217 derartigen Hinweisen bei insgesamt 5 steht "all commercial editions", die Funktion "Get a custom graph" ist markiert als Available in the following editions: Pro, Ultimate, Ultimate with multi-tenancy, und alle 211 anderen Funktionen sind angeblich in jeder Edition vorhanden
ifdef::onprem[]
{cee-only}
Für Funktionen, die es nur in den kommerziellen Editionen gibt, wie z.B. Service Level Agreement (SLA) oder Agentenbäckerei, werden die zugehörigen Methoden der REST-API auch nur in diesen Editionen angeboten.
In der Dokumentation für die REST-API finden Sie für jede Funktion Hinweise dazu, in welchen Editionen sie verfügbar ist.
// ES: WH erstellt ein Ticket, um sicherzustellen, dass diese Hinweise tatsächlich für jeden Endpunkt korrekt sind
endif::[]

[#api_doc]
== Die API-Dokumentation

[#versioning]
=== Versionierung

Einer der Vorteile der REST-API ist, dass Software und Dokumentation aus der gleichen Quelle stammen: dem OpenAPI-Dokument.
Daher passt die API-Dokumentation stets zur Software und beschreibt genau das, was die API kann.
Daher ist es auch nicht nötig, den Referenzteil der verfügbaren Ressourcen, Methoden, Parameter etc. im {CMK}-Handbuch zu beschreiben:
stattdessen finden Sie die API-Dokumentation außerhalb dieses Handbuchs, direkt in Ihrer {CMK}-Instanz.
// ES: Verweis auf den Mirror der API-Doku auf docs.checkmk.com einfügen
// ES: blocked by KNW-1719

Die API mit ihrer Dokumentation ist versioniert.
Seit {CMK} {v25} wird die REST-API in der Version `v1` mit der {CMK}-Software zusammen ausgeliefert.
// TK: Auf https://janux.lan.checkmk.net/master/ seh ich in ReDoc und Swagger nach wie vor nur die 1.0 und nicht die v1 in der URL. Ändert sich das noch?
// ES: Habe einen entsprechenden Hinweis in die Beschreibung zu CMK-29243 eingefügt. Dieser Artikel kann erst dann sinnvoll weiter editiert werden, wenn die blockierenden Tickets gelöst sind.
Diese Version der API ist kompatibel mit der Version `1.0`, die bis {CMK} {v24} zur Verfügung gestellt wurde.
Die Versionsnummer ist Bestandteil der URL, mit der eine API-Anfrage an den Server gesendet wird.

Das Schema für die Versionierung ab `v1` basiert auf den Grundprinzipien der Spezifikation für link:https://semver.org/[*Semantic Versioning 2.x*^].
Für die REST-API von {CMK} werden nur Aktualisierungsschritte auf der Ebene der Major-Version gekennzeichnet.
Das bedeutet, dass Bug Fixes (Patch-Versionen) und kompatible Änderungen (Minor-Versionen) für die Version `v1` und danach nur „unter der Haube“ stattfinden und keine Änderung des Pfads für API-Anfragen erfordern.

Die Versionierung der REST-API für {CMK} ist unabhängig von der Versionierung der {CMK}-Software selbst.
Änderungen von API-Funktionen -- in Form von Bug Fixes, kompatiblen Änderungen oder sogar als neue Major-Versionen mit inkompatiblen Änderungen -- können in jeder Patch-Version von {CMK} ausgeliefert werden.
Hierüber werden Sie wie gewohnt über link:https://checkmk.com/de/werks[Werks^] informiert.
// TK: Werk-Link ist hier besser als Glossar-Link. Kann man hier im Werk-Link auf Component=REST API vorfiltern?

Erscheint eine neue Major-Version der REST-API, können Sie vorübergehend weiterhin die vorige Version der REST-API nutzen.
Abkündigungen veralteter Versionen der REST-API werden mit genügend Vorlauf bekanntgegeben.
Erst mit der nächsten Major-Version von {CMK} werden abgekündigte API-Versionen entfernt.
So liegt es in Ihrer Hand, wann Sie Ihre Skripte auf die neue REST-API-Version aktualisieren.
Im Artikel zum xref:update_major#rest_api[Update auf Version {current-major}] finden Sie jederzeit aktuelle Informationen über den empfohlenen Umgang mit den in einer {CMK}-Major-Version jeweils unterstützten REST-API-Versionen.
// ES: todo in update_major

[TIP]
====
Zusätzlich zu den unterstützten Major-Versionen der REST-API haben Sie auch die Möglichkeit, die Version `unstable` mit Ihren API-Anfragen anzusteuern.
Diese Version bietet Ihnen beispielsweise experimentelle Funktionen und Backports, die in älteren {CMK}-Versionen sonst nicht zur Verfügung stehen würden.
Auch Funktionen der REST-API, die sich aktuell noch in der Entwicklung befinden, sind möglicherweise über die `unstable`-Version bereits teilweise nutzbar.

Wie der Name schon andeutet, wird die `unstable`-Version nicht unterstützt und bietet keine Garantie auf Kompatibilität.
Der Funktionsumfang dieser API-Version kann für jede {CMK}-Version unterschiedlich sein.
====
// ES: edit after CMK-29126 has been completed


[#access]
=== Zugriff
// ES: blocked by KNW-1719
// ES: blocked by CMK-29126

Die REST-API-Dokumentation steht im HTML-Format zur Ansicht im Web-Browser bereit.

In der {CMK}-GUI öffnen Sie die API-Dokumentation über die Navigationsleiste mit [.guihint]#Help > Developer resources > REST API documentation.#
Die API-Dokumentation wird in einem neuen Browser-Fenster (bzw. Browser-Tab) angezeigt.
Wir gehen darauf im nächsten Kapitel genauer ein.

image::restapi_help_menu.png[alt="Help-Menü in der Navigationsleiste.",width=60%]
// ES: Screenshot neu erzeugen

[TIP]
====
Sicher ist Ihnen aufgefallen, dass es im [.guihint]#Help#-Menü noch weitere Einträge zur REST-API gibt.
Mit [.guihint]#REST API introduction# können Sie diesen Artikel öffnen.
Mit [.guihint]#REST API interactive GUI# öffnen Sie eine weitere Sicht auf die REST-API.
[.guihint]#GUI# heißt dieser Eintrag, weil Ihnen nicht nur die REST-API-Funktionen angezeigt werden, sondern weil Sie aus dem Browser heraus direkt mit der API interagieren können, indem Sie z.B. Anfragen an den Server senden.
Wir stellen die REST-API GUI als Alternative zur Ausführung per Skript im xref:rest_api_gui[Kapitel zur REST-API GUI] später vor.
====
// ES: Admonition neu schreiben, falls nötig, sonst löschen


[#structure]
=== Struktur und Inhalt

Die API-Dokumentation nutzt ein responsives Web-Design mit 3 Bereichen:

[{image-border}]
image::restapi_redoc.png[alt="API-Dokumentation im responsiven Web-Design mit drei Bereichen.",fullscreen=1]
// ES: Screenshot neu erzeugen

* Der linke Navigationsbereich dient der Orientierung, der Suche und dem schnellen Sprung zur genauen Beschreibung der Einträge im mittleren Bereich.
Das Inhaltsverzeichnis enthält für jeden API-Endpunkt einen Eintrag.
Ein Endpunkt bezeichnet per URL die Ressource, die die API zur Verfügung stellt (z.B. Hosts), zusammen mit der Methode, um auf die Ressource zuzugreifen (z.B. GET zur Anzeige eines Hosts).
Die Endpunkte sind in mehrere Ordner organisiert.

* Der mittlere Inhaltsbereich enthält die harten Fakten der Dokumentation:
alle Informationen zur Definition einer Anfrage (mit Parametern, Wertebereichen, Default-Werten und Beschreibungen) und die zugehörigen Antworten (ebenfalls mit allen Details).
Die möglichen Antworten werden in unterschiedlichen Farben dargestellt, je nachdem ob der zurückgelieferte xref:http-status-code[HTTP-Status-Code] Erfolg oder einen Fehler signalisiert.

* Der rechte Beispielbereich ([.guihint]#Request samples#) zeigt für den im Inhaltsbereich ausgewählten Endpunkt die Methode und die URL, gefolgt von mehreren Beispielen zu Anfragen:
die Payload im JSON-Format (falls relevant für den Endpunkt) und Code-Beispiele z.B. für Python mit `requests`, Python mit `urllib`, Httpie und Curl.
Darunter folgen die Antworten passend zum HTTP-Status-Code.
Alle Code-Beispiele können über den Knopf [.guihint]#Copy# in die Zwischenablage kopiert werden.

Der Navigationsbereich ist scroll-synchronisiert zu den anderen beiden Bereichen, das heißt, wenn Sie im Inhaltsbereich nach oben oder unten scrollen, scrollt der Navigationsbereich automatisch zum passenden Eintrag des Inhaltsverzeichnisses mit.

Das responsive Web-Design sorgt dafür, dass in einem Browser-Fenster mit geringer Breite der Beispielbereich verschwindet (dafür werden dann die Beispiele unterhalb der zugehörigen Methode angezeigt) und der Navigationsbereich in ein Menü umgewandelt wird.

In allen Bereichen finden Sie Inhalte, die Sie ein- und ausblenden können, zum Beispiel im Navigationsbereich die Einträge für die Endpunkte und im Inhaltsbereich verschachtelte Parameter.
Durch Anklicken von > oder [.guihint]#Expand all# blenden Sie die verborgenen Inhalte ein und mit ∨ oder [.guihint]#Collapse all# wieder aus.

Wie Sie die API-Dokumentation nutzen können, um aus den Informationen konkrete Anfragen zu erstellen, an den {CMK}-Server zu senden, ausführen zu lassen und den Erfolg zu kontrollieren:
all das erfahren Sie im nächsten Kapitel.


[#using_the_api]
== Die API nutzen


[#auth]
=== Authentifizierung

Um von einem Client aus die REST-API des {CMK}-Servers nutzen zu können, muss der Client seine Identität nachweisen.
Die REST-API unterstützt die folgenden Methoden zur Authentifizierung: *Bearer*, *Webserver* und *Cookie* -- in dieser Rangfolge.
Das heißt zum Beispiel, dass bei einer erfolgreichen Authentifizierung mit Bearer keine der anderen Methoden mehr geprüft wird.


[#bearerauth]
==== Bearer- oder Header-Authentifizierung

„Bearer“ bezeichnet den Träger oder Inhaber einer Identität.
Der Client authentisiert sich mit den Zugangsdaten eines auf dem {CMK}-Server eingerichteten Benutzers.
Idealerweise ist dies der sogenannte xref:glossar#automation_user[Automationsbenutzer], der in {CMK} für die Ausführung von Aktionen über eine API vorgesehen ist.
ifdef::onprem[]
Die Bearer-Authentifizierung wird für die Verwendung in Skripten empfohlen.
endif::[]
ifdef::saas[]
Für die Verwendung in Skripten ist Bearer-Authentifizierung die einzig sinnvolle Methode.
endif::[]

Für die Authentifizierung benötigen Sie den Benutzernamen und das zugehörige, sogenannte _automation secret for machine accounts_, das heißt das Passwort des Automationsbenutzers.
Beide Informationen müssen im Header jeder Anfrage an den {CMK}-Server übermittelt werden.

Sie finden Automationsbenutzer, wie andere Benutzer auch, unter [.guihint]#Setup > Users > Users.#
ifdef::saas[]
Bei einer neu erstellten xref:glossar#site[Instanz] ist der Automationsbenutzer `api_user` bereits angelegt.
endif::[]
ifdef::onprem[]
Achten Sie darauf, dass die Rollen und die damit verbundenen Berechtigungen für den Automationsbenutzer so gesetzt sind, dass sie die Ausführung Ihrer Anfragen erlauben.
endif::[]

Für die in diesem Artikel vorgestellten Skripte wird immer der Automationsbenutzer namens `automation` als Beispiel genommen.


ifdef::onprem[]
[#webserverauth]
==== Webserver-Authentifizierung

Bei der Webserver-Authentifizierung nutzt die REST-API die HTTP-Authentifizierung, die für den Webserver konfiguriert ist („Basic“ oder „Digest“).

Diese Authentifizierungsmethode ist gedacht für große {CMK}-Installationen mit speziellen Anforderungen, die durch den Einsatz und die Konfiguration von Software-Modulen für die Authentifizierung des Apache Webservers realisiert werden.
Wenn Sie die Webserver-Authentifizierung nutzen möchten, müssen Sie den Apache Webserver der {CMK}-Instanz selbst neu konfigurieren.

////
Beachten Sie, dass Sie mit dem Kommando xref:omd_basics#omd_config[omd config] die Möglichkeit haben, die Basic HTTP-Authentifizierung der {CMK}-Instanz einzuschalten ([.guihint]#Web GUI > MULTISITE_COOKIE_AUTH > off#).
Bei eingeschalteter Basic-Authentifizierung muss sich jeder Benutzer vor dem Zugriff auf eine {CMK}-Website anmelden.
////
endif::[]

[#cookieauth]
==== Cookie-Authentifizierung

Die Cookie-Authentifizierung ist ein Spezialfall der Authentifizierung per API-Schlüssel.
Jeder {CMK}-Benutzer, der in {CMK} angemeldet ist und dadurch ein HTTP Cookie zugewiesen bekommen hat, kann die REST-API nutzen.
Die Cookie-Authentifizierung dient zum Ausprobieren und Testen mit der xref:rest_api_gui[REST-API GUI].
Ob Anfragen ausgeführt werden können, hängt davon ab, ob Ihr {CMK}-Benutzerkonto die entsprechenden Berechtigungen besitzt.


[#http-status-code]
=== HTTP-Status-Code

Die REST-API gibt zu jeder Anfrage den link:https://de.wikipedia.org/wiki/HTTP-Statuscode[HTTP-Status-Code^] zurück, mit dem Sie überprüfen können, ob die Anfrage erfolgreich war.
Alle für die Anfrage möglichen HTTP-Status-Codes werden in der API-Dokumentation gelistet.

Beachten Sie, dass der HTTP-Status-Code nur Auskunft über die erfolgreiche Übermittlung der Anfrage gibt, aber nicht über die erfolgreiche Ausführung.
ifdef::onprem[]
Ausgeführt werden die Befehle auf dem {CMK}-Server mit xref:glossar#livestatus[Livestatus.]
endif::[]
Um sicher zu sein, dass die Anfrage über die REST-API auch wirklich das bewirkt, was Sie beabsichtigt haben, müssen Sie die Erfolgskontrolle selbst übernehmen. 
Die API-Dokumentation, die Sie mit [.guihint]#Help > Developer resources > REST API interactive GUI# öffnen können, enthält im Abschnitt „Queries through the REST API“ ein Beispiel eines Skripts für diese Aufgabe.
// ES: Klickpfad korrigieren, hier auch den Link zum Mirror platzieren mit Anker auf genau diesem Abschnitt
// ES: blocked by KNW-1719

ifdef::onprem[]
[#testing]
=== Die API lokal testen
// ES: Dieser Abschnitt ist für onprem fertig überarbeitet. Saas folgt später

Um die REST-API zu testen, bietet es sich an, die Anfragen direkt vom {CMK}-Server aus zu stellen, das heißt, in diesem Fall befinden sich der Client, der die Anfrage sendet, und der Server, der diese empfängt, auf dem gleichen Rechner.
Wenn Sie als Instanzbenutzer arbeiten, können Sie zudem lokale Variablen wie z.B. `$OMD_SITE` verwenden, die auf den Namen der Instanz verweist.

Im Folgenden zeigen wir für einige einfache Beispiele Python-Skripte, in denen die HTTP-Anfragen an die API mit dem Modul `requests` umgesetzt sind.
Alternativ dazu finden Sie für jedes Beispiel auch eine Curl-Variante.
Inhaltlich sind die alternativen Implementierungen deckungsgleich.

Zur Vorbereitung erstellen Sie für jede der im nächsten Abschnitt auszuführenden Anfragen jeweils eine Skript-Datei, in die später der Beispiel-Code kopiert wird:

[.tabs]
====
[#intro_requests]#requests#::
+
--
Für die `requests`-Beispiele legen Sie eine Reihe von Python-Skripten an und machen diese ausführbar.

[{shell}]
----
{c-omd} touch create_host.py service_discovery.py show_pending_changes.py activate_changes.py
{c-omd} chmod +x create_host.py service_discovery.py show_pending_changes.py activate_changes.py
----
--
[#intro_curl]#curl#::
+
--
Für die `curl`-Beispiele legen Sie eine Reihe von Bash-Skripten an und machen diese ausführbar.

[{shell}]
----
{c-omd} touch create_host.sh service_discovery.sh show_pending_changes.sh activate_changes.sh
{c-omd} chmod +x create_host.sh service_discovery.sh show_pending_changes.sh activate_changes.sh
----
--
====

endif::[]

ifdef::saas[]
[#testing]
=== Die API testen

// ES: Auch hier editieren und Konsistenz zur onprem-Variante des Abschnitts herstellen

Die im weiteren Verlauf dieses Artikels gezeigten API-Aufrufe verwenden den in der API-Dokumentation enthaltenen Beispiel-Code für das Kommandozeilenprogramm Curl, das es ermöglicht, ohne Benutzerinteraktion Daten von oder zu einem Server zum Beispiel per HTTP zu übertragen.

Curl ist unter Linux, Windows und macOS vorinstalliert, allerdings ist die hier gezeigte Kapselung in Shell-Skripten mit Variablen nur unter Linux und macOS _Out-of-the-Box_ möglich.
Unter Windows können Sie mit dem link:https://learn.microsoft.com/en-us/windows/wsl/install[Windows Subsystem for Linux^] eine vergleichbare Umgebung installieren.

[TIP]
====
Insbesondere bei komplexen Anfragen kann es vorkommen, dass die Curl-Beispiele Inkonsistenzen enthalten und daher nicht immer verlässlich sind.
Mit link:https://httpie.io/[Httpie^] steht eine Alternative zur Verfügung, die konsistent, leicht zu verstehen und gut für die Verwendung in Skripten geeignet ist.
====

Das `curl`-Kommando wird innerhalb eines Bash-Skripts ausgeführt.
Zur Vorbereitung erstellen Sie für jede der im nächsten Abschnitt auszuführenden Anfragen jeweils eine Skript-Datei, in die später der Beispiel-Code kopiert wird:

[{shell}]
----
{c-user} touch create_host.sh service_discovery.sh show_pending_changes.sh activate_changes.sh
{c-user} chmod +x create_host.sh service_discovery.sh show_pending_changes.sh activate_changes.sh
----
endif::[]

Die REST-API gibt alle Antworten im JSON-Format einzeilig aus.
Da eine formatierte Ausgabe die Lesbarkeit doch erheblich erleichtert, wird in den folgenden Beispielen die einzeilige Ausgabe mehrzeilig formatiert dargestellt.
Zur Aufbereitung des JSON-Formats gibt es diverse Websites und Werkzeuge, zum Beispiel den Kommandozeilen-JSON-Prozessor `jq`.

Bevor es los geht, sammeln Sie einige grundlegende Informationen, die spezifisch für Ihre {CMK}-Konfiguration sind:

[cols="25,25,~",options="header"]
|===
|Variable |Beispielwert |Bedeutung 
|`HOST_NAME` |`myserver` |Name des {CMK}-Servers
|`SITE_NAME` |`mysite` |Name der {CMK}-Instanz
|`USERNAME` |`automation` |Name des Automationsbenutzers
|`PASSWORD` |`theautomationsecret` |Passwort des Automationsbenutzers
|===

Diese Variablen werden im Beispiel-Code verwendet und müssen von Ihnen geändert werden, bevor Sie eine Anfrage absenden.
In der obigen Tabelle finden Sie auch die Beispielwerte, die im Folgenden verwendet werden.


[#making_requests]
=== Anfragen stellen per Skript

// ES: Gesamte Anleitung durchspielen, dabei neue Screenshots erzeugen und genau darauf achten, ob hier in diesem Abschnitt Text geändert, gelöscht oder ergänzt werden muss

Wir werden nun den Umgang mit der REST-API an einem übersichtlichen Beispiel demonstrieren:
Sie erstellen einen Host mit seinen Services mit insgesamt vier Anfragen.
Prinzipiell gehen Sie dabei genauso vor, wie Sie es auch mit der {CMK}-GUI tun würden:

. Einen Host erstellen
. Eine Service-Erkennung auf dem Host durchführen
. Die ausstehenden Änderungen anzeigen
. Die Änderungen aktivieren


[#create_host]
==== Einen Host erstellen

Öffnen Sie die API-Dokumentation und suchen Sie im linken Navigationsbereich den Eintrag zum Erstellen eines Hosts ([.guihint]#Create a host#):
// ES: Hier einen Direktlink zu diesem Anker im API-Docs-Mirror einfügen
// ES: blocked by KNW-1719

[{image-border}]
image::restapi_redoc_2pane.png[alt="Der Eintrag in der API-Dokumentation zum Erstellen eines Hosts.",fullscreen=1]
// ES: Neuen Screenshot erzeugen

Im mittleren Bereich sehen Sie die Details zur gewählten Anfrage: welche HTTP-Authentifizierung gefordert ist (diese ist identisch für alle Anfragen über die REST-API) und die notwendigen und optionalen Parameter. Notwendig (_required_) sind der Name des Hosts und der Ordner, in dem er angelegt werden soll.
Standardmäßig wird der Host im Hauptordner ([.guihint]#Main#) erstellt.
Falls Sie den Host in einem anderen Ordner anlegen wollen, müssen Sie sich eventuell zuerst über eine andere API-Anfrage ([.guihint]#Show all folders#) die existierenden Ordner anzeigen lassen, um die ID des gewünschten herauszufinden.

Im rechten Bereich sehen Sie für den aktuell sichtbaren Endpunkt den Pfad für die API-Anfrage sowie eine Reihe von Beispielanfragen (_Request samples_) und Beispielantworten (_Response samples_).
Für Ihre oben vorbereiteten Skripte können Sie die passende Beispielanfrage mit einem Klick auf [.guihint]#Copy# in die Zwischenablage kopieren.


[.tabs]
====
[#create_host_requests]#requests#::
+
--
In der API-Dokumentation klicken Sie im rechten Beispielbereich auf den Knopf [.guihint]#requests# und dann auf [.guihint]#Copy#, um den requests-Beispiel-Code in die Zwischenablage zu kopieren.
Öffnen Sie das vorbereitete Skript `create_host.py` und fügen Sie den Inhalt der Zwischenablage ein:

.create_host.py
[{python}]
----
#!/usr/bin/env python3
import pprint
import requests

HOST_NAME = "localhost"
SITE_NAME = "checkmk"
PROTO = "http" #[http|https]
API_URL = f"{PROTO}://{HOST_NAME}/{SITE_NAME}/check_mk/api/1.0"

USERNAME = "automation"
PASSWORD = "test123"

session = requests.session()
session.headers['Authorization'] = f"Bearer {USERNAME} {PASSWORD}"
session.headers['Accept'] = 'application/json'
session.max_redirects = 100  # increase if necessary

resp = session.post(
    f"{API_URL}/domain-types/host_config/collections/all",
    params={  # goes into query string
        "bake_agent": False,  # Tries to bake the agents for the just created hosts.
    },
    headers={
        "Content-Type": 'application/json',  # (required) A header specifying which type of content is in the request/response body.
    },
    json={
        "host_name": "example.com",
        "folder": "/",
        "attributes": {
            "ipaddress": "192.168.0.123",
        },
    },
    allow_redirects=True,
)
if resp.status_code == 200:
    pprint.pprint(resp.json())
elif resp.status_code == 201:
else:
    raise RuntimeError(pprint.pformat(resp.json()))
----

Im ersten Teil des Beispiel-Codes finden Sie die Umgebungsvariablen sowie die Konfiguration für die HTTP-Authentifizierung.
Darunter folgt der `post`-Befehl auf die Ressource, die unter dem angegebenen Pfad zu finden ist, hier also auf den REST-API-Endpunkt `/domain-types/host_config/collections/all`.
Innerhalb des `post`-Aufrufs werden die Parameter für den Request angegeben, in diesem Fall unter anderem der Name für den neu zu erzeugenden Host, der Ordner, in dem er angelegt werden soll und seine IP-Adresse.
Nach dem `post`-Befehl folgt eine Ausgabe des xref:http-status-code[HTTP-Status-Codes], den die API als Antwort auf den Request zurückgegeben hat.
--
[#create_host_curl]#curl#::
+
--
In der API-Dokumentation klicken Sie im rechten Beispielbereich auf den Knopf [.guihint]#curl# und dann auf [.guihint]#Copy#, um den Curl-Beispiel-Code in die Zwischenablage zu kopieren.
Öffnen Sie das vorbereitete Skript `create_host.sh` und fügen Sie den Inhalt der Zwischenablage ein:

// TK: Aus dem API-Dok Sample Code in 2.3.0p7 die Zeile "-G \" manuell gelöscht
.create_host.sh
[{bash}]
----
#!/bin/bash

# NOTE: We recommend all shell users to use the "httpie" examples instead.
#       `curl` should not be used for writing large scripts.
#       This code is provided for debugging purposes only.

HOST_NAME="localhost"
SITE_NAME="mysite"
PROTO="http" #[http|https]
API_URL="$PROTO://$HOST_NAME/$SITE_NAME/check_mk/api/1.0"

USERNAME="automation"
PASSWORD="test123"

curl \
  --request POST \
  --write-out "\nxxx-status_code=%{http_code}\n" \
  --header "Authorization: Bearer $USERNAME $PASSWORD" \
  --header "Accept: application/json" \
  --header "Content-Type: application/json" \
  --data '{
          "attributes": {
            "ipaddress": "192.168.0.123"
          },
          "folder": "/",
          "host_name": "example.com"
        }' \
  "$API_URL/domain-types/host_config/collections/all"
----

Im ersten Teil des Beispiel-Codes finden Sie die Umgebungsvariablen, dann folgt das `curl`-Kommando mit der POST-Methode auf die Ressource, deren URL in der letzten Zeile steht.
Durch die Option `-write-out` wird abschließend eine Zeile mit dem xref:http-status-code[HTTP-Status-Code] ausgegeben.
Nach den Header-Zeilen (eine davon definiert die HTTP-Authentifizierung) folgt der Datenteil, in dem die Parameter für den neuen Host festgelegt werden.
--
====

In unserem Beispiel soll der Host `myhost123` mit der IP-Adresse `192.168.0.42` im Hauptordner erstellt werden.

Beachten Sie, dass der Beispiel-Code aus der API-Dokumentation mehr Parameter enthalten kann, als Sie im konkreten Fall vielleicht benötigen.
Für unser Beispiel ist dies aber nicht der Fall, und Sie müssen nur die beiden vorhandenen Parameter `host_name` und `ipaddress` ändern.
Fügen Sie außerdem die richtigen Werte für die Umgebungsvariablen ein, um Ihre spezifische {CMK}-Konfiguration korrekt anzusteuern.
Das Resultat sollte ungefähr so aussehen:

[.tabs]
====
[#create_specific_host_requests]#requests#::
+
--
.create_host.py
[{python},highlight=5;6;10;11;27;30]
----
#!/usr/bin/env python3
import pprint
import requests

HOST_NAME = "myserver"
SITE_NAME = "mysite"
PROTO = "http" #[http|https]
API_URL = f"{PROTO}://{HOST_NAME}/{SITE_NAME}/check_mk/api/1.0"

USERNAME = "automation"
PASSWORD = "theautomationsecret"

session = requests.session()
session.headers['Authorization'] = f"Bearer {USERNAME} {PASSWORD}"
session.headers['Accept'] = 'application/json'
session.max_redirects = 100  # increase if necessary

resp = session.post(
    f"{API_URL}/domain-types/host_config/collections/all",
    params={  # goes into query string
        "bake_agent": False,  # Tries to bake the agents for the just created hosts.
    },
    headers={
        "Content-Type": 'application/json',  # (required) A header specifying which type of content is in the request/response body.
    },
    json={
        "host_name": "myhost123",
        "folder": "/",
        "attributes": {
            "ipaddress": "192.168.0.42",
        },
    },
    allow_redirects=True,
)
if resp.status_code == 200:
    pprint.pprint(resp.json())
elif resp.status_code == 201:
else:
    raise RuntimeError(pprint.pformat(resp.json()))
----
--
[#create_specific_host_curl]#curl#::
+
--

.create_host.sh
[{bash},highlight=7;8;12;13;23;26]
----
#!/bin/bash

# NOTE: We recommend all shell users to use the "httpie" examples instead.
#       `curl` should not be used for writing large scripts.
#       This code is provided for debugging purposes only.

HOST_NAME="myserver"
SITE_NAME="mysite"
PROTO="http" #[http|https]
API_URL="$PROTO://$HOST_NAME/$SITE_NAME/check_mk/api/1.0"

USERNAME="automation"
PASSWORD="theautomationsecret"

curl \
  --request POST \
  --write-out "\nxxx-status_code=%{http_code}\n" \
  --header "Authorization: Bearer $USERNAME $PASSWORD" \
  --header "Accept: application/json" \
  --header "Content-Type: application/json" \
  --data '{
          "attributes": {
            "ipaddress": "192.168.0.42"
          },
          "folder": "/",
          "host_name": "myhost123"
        }' \
  "$API_URL/domain-types/host_config/collections/all"
----
--
====


Führen Sie das Skript aus:

[.tabs]
====
[#create_host_run_requests]#requests#::
+
--

// ES: WIP. Inhalt der Rückgabe kürzen und erklären, dass das hier ein Dictionary ist, mit dem weitergearbeitet werden kann
// ES: blocked by CMK-29219
[{shell}]
----
OMD[api250]:~$ ./create_host.py 
{'domainType': 'host_config',
 'extensions': {'attributes': {'ipaddress': '192.168.0.42',
                               'meta_data': {'created_at': '2026-01-14T09:50:29.308690+00:00',
                                             'created_by': 'automation',
                                             'updated_at': '2026-01-14T09:50:29.317404+00:00'}},
                'cluster_nodes': None,
                'effective_attributes': None,
                'folder': '/',
                'is_cluster': False,
                'is_offline': False},
 'id': 'myhost123',
 'links': [{'domainType': 'link',
            'href': 'http://localhost/api250/check_mk/api/1.0/objects/host_config/myhost123',
            'method': 'GET',
            'rel': 'self',
            'type': 'application/json'},
           {'domainType': 'link',
            'href': 'http://localhost/api250/check_mk/api/1.0/objects/host_config/myhost123',
            'method': 'PUT',
            'rel': 'urn:org.restfulobjects:rels/update',
            'type': 'application/json'},
           {'domainType': 'link',
            'href': 'http://localhost/api250/check_mk/api/1.0/objects/host_config/myhost123',
            'method': 'DELETE',
            'rel': 'urn:org.restfulobjects:rels/delete',
            'type': 'application/json'},
           {'domainType': 'link',
            'href': 'http://localhost/api250/check_mk/api/1.0/objects/folder_config/~',
            'method': 'GET',
            'rel': 'urn:com.checkmk:rels/folder_config',
            'title': 'The folder config of the host.',
            'type': 'application/json'},
           {'domainType': 'link',
            'href': 'http://localhost/api250/check_mk/api/1.0/domain-types/agent/actions/download/invoke?os_type=aix_tgz&host_name=myhost123',
            'method': 'GET',
            'rel': 'urn:com.checkmk:rels/download',
            'title': 'Download the aix_tgz agent of the host.',
            'type': 'application/json'},
           {'domainType': 'link',
            'href': 'http://localhost/api250/check_mk/api/1.0/domain-types/agent/actions/download/invoke?os_type=linux_deb&host_name=myhost123',
            'method': 'GET',
            'rel': 'urn:com.checkmk:rels/download',
            'title': 'Download the linux_deb agent of the host.',
            'type': 'application/json'},
           {'domainType': 'link',
            'href': 'http://localhost/api250/check_mk/api/1.0/domain-types/agent/actions/download/invoke?os_type=linux_rpm&host_name=myhost123',
            'method': 'GET',
            'rel': 'urn:com.checkmk:rels/download',
            'title': 'Download the linux_rpm agent of the host.',
            'type': 'application/json'},
           {'domainType': 'link',
            'href': 'http://localhost/api250/check_mk/api/1.0/domain-types/agent/actions/download/invoke?os_type=linux_tgz&host_name=myhost123',
            'method': 'GET',
            'rel': 'urn:com.checkmk:rels/download',
            'title': 'Download the linux_tgz agent of the host.',
            'type': 'application/json'},
           {'domainType': 'link',
            'href': 'http://localhost/api250/check_mk/api/1.0/domain-types/agent/actions/download/invoke?os_type=solaris_pkg&host_name=myhost123',
            'method': 'GET',
            'rel': 'urn:com.checkmk:rels/download',
            'title': 'Download the solaris_pkg agent of the host.',
            'type': 'application/json'},
           {'domainType': 'link',
            'href': 'http://localhost/api250/check_mk/api/1.0/domain-types/agent/actions/download/invoke?os_type=solaris_tgz&host_name=myhost123',
            'method': 'GET',
            'rel': 'urn:com.checkmk:rels/download',
            'title': 'Download the solaris_tgz agent of the host.',
            'type': 'application/json'},
           {'domainType': 'link',
            'href': 'http://localhost/api250/check_mk/api/1.0/domain-types/agent/actions/download/invoke?os_type=windows_msi&host_name=myhost123',
            'method': 'GET',
            'rel': 'urn:com.checkmk:rels/download',
            'title': 'Download the windows_msi agent of the host.',
            'type': 'application/json'}],
 'members': {},
 'title': 'myhost123'}
----
--
[#create_host_run_curl]#curl#::
+
--

[{shell},highlight=22;23;28;30;43]
----
{c-omd} ./create_host.sh
{
  "links":[
    {
      "domainType":"link",
      "rel":"self",
      "href":"\http://myserver/mysite/check_mk/api/1.0/objects/host_config/myhost123",
      "method":"GET",
      "type":"application/json"
    },
...
    {
      "domainType":"link",
      "rel":"urn:com.checkmk:rels/folder_config",
      "href":"\http://myserver/mysite/check_mk/api/1.0/objects/folder_config/~",
      "method":"GET",
      "type":"application/json",
      "title":"The folder config of the host."
    }
  ],
  "domainType":"host_config",
  "id":"myhost123",
  "title":"myhost123",
  "members":{
    
  },
  "extensions":{
    "folder":"/",
    "attributes":{
      "ipaddress":"192.168.0.42",
      "meta_data":{
        "created_at":"2024-07-03T12:55:29.165920+00:00",
        "updated_at":"2024-07-03T12:55:29.174520+00:00",
        "created_by":"automation"
      }
    },
    "effective_attributes":null,
    "is_cluster":false,
    "is_offline":false,
    "cluster_nodes":null
  }
}
xxx-status_code=200
----
--
====


Zur Erinnerung: Die eine, durch die geschweiften Klammern begrenzte Zeile im JSON-Format wird hier mehrzeilig dargestellt.

Die API liefert unter `links` eine Auswahl von (im obigen Beispiel gekürzten) Anfragen zurück, die auf den gerade erstellten Host angewendet werden können -- wie es sich für eine REST-API gehört.
Abschließend liefert die API ID und Namen (`title`) des erstellten Hosts, unter `folder` den Ordner (`/` für den Hauptordner) und unter `attributes` die dem Host zugewiesenen Attribute inklusive der IP-Adresse.
// ES: Nach dem Testen sicherstellen, dass die Beschreibung exakt richtig ist

Als letzte wird die Zeile mit dem xref:http-status-code[HTTP-Status-Code] ausgegeben.
Dabei steht die `200` für `OK` und bedeutet, dass die Aktion erfolgreich durchgeführt wurde.


[#service_discovery]
==== Eine Service-Erkennung auf dem Host durchführen

Nachdem der Host `myhost123` erstellt wurde, können die Services ermittelt werden.
Damit eine xref:glossar#service_discovery[Service-Erkennung] auch tatsächlich die erwarteten Services liefert, müssen Sie zuvor auf Linux- und Windows-Hosts die zugehörigen xref:glossar#agent[Agenten] installieren und registrieren.

Für die Ausführung einer Service-Erkennung via REST-API wählen Sie in der API-Dokumentation den entsprechenden Eintrag aus ([.guihint]#Execute a service discovery on a host#), kopieren den Beispiel-Code in die dafür erstellte Skript-Datei und passen ihn an.

Den ersten Teil mit den Umgebungsvariablen können Sie 1:1 aus dem vorherigen Beispiel übernehmen.
Im `curl`-Kommando ändern Sie den Namen des Hosts zu `myhost123` und bei Bedarf mit dem Parameter `mode` die Art der Service-Erkennung.

.service_discovery.sh
[{bash},highlight=7;8;12;13;22;23]
----
#!/bin/bash

# NOTE: We recommend all shell users to use the "httpie" examples instead.
#       `curl` should not be used for writing large scripts.
#       This code is provided for debugging purposes only.

HOST_NAME="myserver"
SITE_NAME="mysite"
PROTO="http" #[http|https]
API_URL="$PROTO://$HOST_NAME/$SITE_NAME/check_mk/api/1.0"

USERNAME="automation"
PASSWORD="theautomationsecret"

curl \
  --request POST \
  --write-out "\nxxx-status_code=%{http_code}\n" \
  --header "Authorization: Bearer $USERNAME $PASSWORD" \
  --header "Accept: application/json" \
  --header "Content-Type: application/json" \
  --data '{
          "host_name": "myhost123",
          "mode": "tabula_rasa"
        }' \
  "$API_URL/domain-types/service_discovery_run/actions/start/invoke"
----

Führen Sie auch dieses Skript aus:

[{shell}]
----
{c-omd} ./service_discovery.sh

xxx-status_code=303
----

In diesem Fall bedeutet der HTTP-Status-Code `303`, dass der Hintergrundauftrag (_background job_) für die Service-Erkennung initialisiert wurde.


[#show_pending_changes]
==== Die ausstehenden Änderungen anzeigen

Vor der Aktivierung der Änderungen ist noch ein Zwischenschritt notwendig: die Anzeige der ausstehenden Änderungen mit der Anfrage [.guihint]#Show all pending changes.#
Zusätzlich zu den Änderungen, die sich angesammelt haben, liefert die REST-API dabei das HTTP ETag (_entity tag_), das Sie benötigen, um diese Änderungen zu aktivieren.
Die Änderung eines Objekts via REST-API erfolgt nicht über die ID oder den Titel des Objekts.
Stattdessen wird das generierte ETag genutzt, mit dem verhindert werden soll, dass mehrere konkurrierende Anfragen Werte desselben Objekts gegenseitig überschreiben.

Das ETag wird im Antwort-Header (_response header_) zurückgeliefert.
Damit dieser Header angezeigt wird, erweitern Sie den Beispiel-Code für diese Anfrage, indem Sie `curl` mit der Option -i (für _include response headers_) aufrufen.
Die geänderten Zeilen sind auch im folgenden Beispiel wieder markiert:

.show_pending_changes.sh
[{bash},highlight=7;8;12;13;16]
----
#!/bin/bash

# NOTE: We recommend all shell users to use the "httpie" examples instead.
#       `curl` should not be used for writing large scripts.
#       This code is provided for debugging purposes only.

HOST_NAME="myserver"
SITE_NAME="mysite"
PROTO="http" #[http|https]
API_URL="$PROTO://$HOST_NAME/$SITE_NAME/check_mk/api/1.0"

USERNAME="automation"
PASSWORD="theautomationsecret"

curl \
  -i \
  --request GET \
  --write-out "\nxxx-status_code=%{http_code}\n" \
  --header "Authorization: Bearer $USERNAME $PASSWORD" \
  --header "Accept: application/json" \
  "$API_URL/domain-types/activation_run/collections/pending_changes"
----

Nach der Ausführung des Skripts werden in der Ausgabe nun zuerst die Header-Zeilen gezeigt:

[{shell},highlight=5;15-17;22]
----
{c-omd} ./show_pending_changes.sh
HTTP/1.1 200 OK
Date: Wed, 03 Jul 2024 13:23:26 GMT
...
ETag: "2156db7032754ec778c75123ec12cdd897592b0a574760fa0963a1782c22472c"
...
Content-Type: application/json

{
...
  "domainType":"activation_run",
  "value":[
    {
      "id":"8cb85882-cdae-4d43-b5af-362b4c1cb717",
      "user_id":"automation",
      "action_name":"create-host",
      "text":"Created new host myhost123.",
      "time":"2024-07-03T13:05:07.466406+00:00"
    }
  ]
}
xxx-status_code=200
----

Die Ausgabe ist gekürzt und markiert sind nur die wichtigen Zeilen: die Header-Zeile mit dem ETag, die Attribute der einen ausstehenden Änderung zum Erstellen eines Hosts und der HTTP-Status-Code für `OK`.
Das ETag benötigen Sie im nächsten und letzten Schritt.


[#activate_changes]
==== Die Änderungen aktivieren

Zum Abschluss müssen die Änderungen aktiviert werden.
Die passende Anfrage heißt [.guihint]#Activate pending changes.#

Im `curl`-Kommando ändern Sie die Header-Zeile `If-Match` und setzen Sie dort das im vorherigen Abschnitt ausgelesene ETag ein.
Im Datenteil geben Sie für den Parameter `sites` den Namen der Instanz ein -- dort, wo die Änderungen aktiviert werden sollen:

.activate_changes.sh
[{bash},highlight=7;8;12;13;19;25]
----
#!/bin/bash

# NOTE: We recommend all shell users to use the "httpie" examples instead.
#       `curl` should not be used for writing large scripts.
#       This code is provided for debugging purposes only.

HOST_NAME="myserver"
SITE_NAME="mysite"
PROTO="http" #[http|https]
API_URL="$PROTO://$HOST_NAME/$SITE_NAME/check_mk/api/1.0"

USERNAME="automation"
PASSWORD="1234567890"

curl -L \
  --write-out "\nxxx-status_code=%{http_code}\n" \
  --header "Authorization: Bearer $USERNAME $PASSWORD" \
  --header "Accept: application/json" \
  --header "If-Match: "2156db7032754ec778c75123ec12cdd897592b0a574760fa0963a1782c22472c"" \
  --header "Content-Type: application/json" \
  --data '{
          "force_foreign_changes": false,
          "redirect": false,
          "sites": [
            "mysite"
          ]
        }' \
  "$API_URL/domain-types/activation_run/actions/activate-changes/invoke"
----

Führen Sie das Skript aus:

[{shell},highlight=21;43]
----
{c-omd} ./activate_changes.sh
{
  "links":[
    {
      "domainType":"link",
      "rel":"self",
      "href":"\http://myserver/mysite/check_mk/api/1.0/objects/activation_run/eddbef05-438b-4108-9a02-0d010da2b290",
      "method":"GET",
      "type":"application/json"
    },
    {
      "domainType":"link",
      "rel":"urn:com.checkmk:rels/wait-for-completion",
      "href":"\http://myserver/mysite/check_mk/api/1.0/objects/activation_run/eddbef05-438b-4108-9a02-0d010da2b290/actions/wait-for-completion/invoke",
      "method":"GET",
      "type":"application/json"
    }
  ],
  "domainType":"activation_run",
  "id":"eddbef05-438b-4108-9a02-0d010da2b290",
  "title":"Activation status: In progress.",
  "members":{
    
  },
  "extensions":{
    "sites":[
      "mysite"
    ],
    "is_running":true,
    "force_foreign_changes":false,
    "time_started":"2024-07-03T13:45:07.031741+00:00",
    "changes":[
      {
        "id":"8cb85882-cdae-4d43-b5af-362b4c1cb717",
        "user_id":"automation",
        "action_name":"create-host",
        "text":"Created new host myhost123.",
        "time":"2024-07-03T13:05:07.466406+00:00"
      }
    ]
  }
}
xxx-status_code=200
----

Der Text im `title` zeigt, dass die Aktivierung gestartet wurde.
Wieder schlägt die REST-API unter `links` zwei sinnvolle Folgeanfragen vor:
um den Status dieser Aktivierung abzufragen und auf deren Abschluss zu warten.


[#rest_api_gui]
=== Anfragen stellen mit der interaktiven REST-API GUI

// ES: Klären, welche Bezeichnung die Swagger-GUI bekommt, und im gesamten Abschnitt vereinheitlichen. Bezeichnung sollte genau diejenige sein, die im Hilfemenü angezeigt wird.

Zusätzlich zur ausführlichen Dokumentation der REST-API, die oben vorgestellt wurde, wird noch eine weitere Ressource aus der Spezifikation der API erzeugt:
die interaktive REST-API GUI, die einen direkten API-Zugriff auf eine {CMK}-Instanz aus dem Browser heraus ermöglicht.
Die interaktive GUI wird mit Swagger erzeugt und ist im Hilfe-Menü Ihrer {CMK}-Instanz verlinkt.

Während die API-Dokumentation selbst auch hier auf docs.checkmk.com zur Verfügung gestellt wird, bieten wir keinen Mirror für die interaktive GUI an.
// ES: Link einfügen und sinnvoll darstellen, sobald das möglich ist
// ES: blocked by KNW-1719
Die interaktive GUI ist genau auf _Ihre_ Instanz von {CMK} zugeschnitten -- und somit kann sie auch nur innerhalb von Ihrer Umgebung genutzt werden.

In der interaktiven GUI können Sie einzelne Anfragen an konkrete API-Endpunkte Ihrer {CMK}-Instanz mit Parameterwerten füllen und abschicken.
Daraufhin erhalten Sie direkt in der interaktiven GUI die übersichtlich aufbereitete Antwort der API auf diese Anfrage.

Da bestimmte Endpunkte nicht in isolierter Form ohne Kontext angesprochen werden können, bildet die interaktive GUI nur eine Teilmenge der API-Funktionalität ab.

// ES: Klickpfad genau angeben/besser beschreiben
// ES: check back in when CMK-29126 is completed
Sie öffnen die interaktive GUI in der {CMK}-GUI über die Navigationsleiste im Menü [.guihint]#Help > Developer resources > REST API interactive GUI.#
Die interaktive GUI wird in einem neuen Browser-Fenster (bzw. Browser-Tab) angezeigt:

[{image-border}]
image::restapi_swaggerui.png[alt="Der Eintrag in der REST API GUI zum Erstellen eines Hosts.",fullscreen=1]
// ES: Screenshot neu erzeugen

Im Folgenden skizzieren wir, wie Sie die erste Anfrage aus dem obigen Beispiel (einen Host erstellen) statt per Skript auch mit der REST-API GUI ausführen können:
// ES: Gesamtes Beispiel durchspielen und Texte anpassen, wo nötig (vor allem die guihints und Feldnamen genau prüfen)

. Authentisieren:
Die REST-API GUI bietet nach dem Anklicken des Knopfs [.guihint]#Authorize# (auf der rechten Seite über dem Eintrag des ersten Endpunkt-Ordners) eine Dialogbox zur Eingabe der Authentifizierungsinformationen.
Sofern Sie als Instanzbenutzer angemeldet sind, brauchen Sie dort aber *keine* Eingaben zu machen, da Sie als {CMK}-Benutzer per xref:auth[Cookie-Authentifizierung] berechtigt zur Nutzung der REST-API sind.

. Endpunkt auswählen:
Wählen Sie im Ordner [.guihint]#Hosts# den Endpunkt [.guihint]#Create a host# aus und klicken Sie [.guihint]#Try it out#.

. Parameterwerte eingeben:
Überschreiben Sie im [.guihint]#Request body# die Beispielwerte für `host_name` und `ipaddress`.

. Anfrage senden:
Klicken Sie [.guihint]#Execute#.

. Antwort überprüfen:
Unter [.guihint]#Responses# sehen Sie zunächst das gesendete Curl-Kommando und die URL des Endpunkts.
Anschließend wird unter [.guihint]#Server response# die Antwort angezeigt mit HTTP-Status-Code und in [.guihint]#Responses# die (mehrzeilig formatierte) REST-API Antwort.

Die REST-API GUI bietet Ihnen also die Möglichkeit, schnell und unkompliziert die Funktionen der API auszuprobieren und sich mit den Details der Eingabewerte und mit konkreten Antworten vertraut zu machen.


[#error_correction]
=== Fehler korrigieren

// ES: Dieser Abschnitt braucht eine bessere Überschrift!

Im Gegensatz zu den bisher gezeigten Ausgaben bei erfolgreichen Kommandos per Skript, zeigt Ihnen die REST-API Fehler in der folgenden Art an:

// ES: Szenario nachstellen (cmkadmin macht eine Änderung, automation versucht Changes zu aktivieren) -> bekomme ich dann in beiden Skriptvarianten den sprechenden Fehler, der hier versprochen wird?
[{shell}]
----
{
  "title": "The operation has failed.",
  "status": 401,
  "detail": "There are changes from other users and foreign changes are not allowed in this API call."
}
xxx-status_code=401
----

Je nach Fehler können die in der Ausgabe angezeigten Parameter unterschiedlich sein.
Immer erhalten Sie aber in `status` den xref:http-status-code[HTTP-Status-Code] und in `title` eine Kurzbeschreibung der Fehlerursache.

In den meisten Fällen zeigt Ihnen `detail`, wie der Name schon vermuten lässt, detaillierte Informationen an.
Im obigen Beispiel erfahren Sie, dass es zwar ausstehende Änderungen in {CMK} gibt, diese aber von einem anderen Benutzer veranlasst wurden.
Über die API können standardmäßig nur Änderungen aktiviert werden, die auch über die API durchgeführt wurden.
// ES: Prüfen, ob das hier wirklich stimmt oder ob es darum geht, welcher _Benutzer_ die Änderungen getriggert hat

Auch im nächsten Beispiel stecken die hilfreichen in den detaillierten Informationen:

[{shell}]
----
{
  "title":"Bad Request",
  "status":400,
  "detail":"These fields have problems: host_name",
  "fields":{
    "host_name":[
      "'my/host123' does not match pattern '^[-0-9a-zA-Z_.]+\\\\Z'."
    ]
  }
}
xxx-status_code=400
----

Hier liegt das Problem darin, dass ein Parameterwert sich nicht an den gültigen Wertebereich hält (wegen eines Schrägstrichs im Host-Namen).

Die Anzahl der möglichen Fehler ist natürlich sehr viel länger als die beiden, die wir vorgestellt haben.
An den gezeigten Beispielen sehen Sie aber, dass die REST-API in der Ausgabe meist genügend Informationen über die Ursache liefert und Ihnen so Anhaltspunkte für den Einstieg in die Analyse und die Fehlerbehebung gibt.

[#unstable]
== Die `unstable`-Version der API nutzen

// ES: blocked by CMK-29126
// ES: motivieren, warum
// ES: erklären, wie
// ES: abgrenzen, dass wir nicht supporten
// ES: Hinweise, wo man herausfindet, was die unstable so kann

[#securing]
== Die API absichern

Da beim Zugriff über die REST-API sensible Daten übertragen  und -- je nach Berechtigung des Automationsbenutzers -- umfassende Änderungen an {CMK} durchgeführt werden können, sollten Sie den Zugriff entsprechend absichern.
Hier finden Sie einige der Möglichkeiten:

ifdef::onprem[]
* xref:omd_https#[{CMK} über HTTPS]:
Nutzen Sie die API ausschließlich über das Hypertext Transfer Protocol Secure (HTTPS), da Benutzername, Passwort und auch Konfigurationsdaten sonst im Klartext im Netz übertragen werden.
endif::[]

* Geben Sie dem Automationsbenutzer ein Passwort mit einer ausreichenden Länge.
Da das Passwort in der Regel nur in einem Skript hinterlegt wird, können Sie problemlos ein sehr langes vergeben.

* Achten Sie auf das Berechtigungskonzept zu den Skripten, mit denen Sie die Anfragen an die API stellen.
In den Skripten können sensible Daten, wie Konfigurationsdaten, Passwörter usw. enthalten sein.
Stellen Sie daher sicher, dass ausschließlich berechtigte Benutzer und Gruppen diese Skripte lesen können.
