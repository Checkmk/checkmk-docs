// -*- coding: utf-8 -*-
// IGNORE Usb Gnomovision Yoyodyne
// NONASCII
include::global_attr.adoc[]
= HW/SW-Inventur-Plugins entwickeln
:title: HW/SW-Inventur-Plugins entwickeln
:description: Bei Bedarf k√∂nnen Sie Ihre eigenen Inventur-Plugins mit Python entwickeln. Lesen Sie hier, wie Sie ein Plugin selbst erstellen und nutzen.
:experimental:

{related-start}
xref:devel_intro#[Erweiterungen f√ºr {CMK} entwickeln]
xref:devel_check_plugins#[Agentenbasierte Check-Plugins entwickeln]
xref:inventory#[Die HW/SW-Inventur]
xref:wato_monitoringagents#[Monitoring-Agenten]
xref:agent_linux#[Linux √ºberwachen]
xref:agent_windows#[Windows √ºberwachen]
xref:wato_services#[Services verstehen und konfigurieren]
xref:cmk_commandline#[{CMK} auf der Befehlszeile]
xref:mkps#[{CMK}-Erweiterungspakete (MKPs)]
{related-end}


[#intro]
== Einleitung

Die xref:inventory#[HW/SW-Inventur] hilft, den √úberblick √ºber vorhandene Hardware zu behalten und jederzeit Kontrolle √ºber installierte Software zu haben.
// ES: Im Glossar steht nichts √ºber HW/SW-Inventur, w√§re das evtl. eine sinnvolle Erg√§nzung? Und dann Glossar-Link bei der ersten Erw√§hnung hier einf√ºgen.
{CMK} liefert fertige Plugins f√ºr viele Basis-Anwendungsf√§lle mit.
Allerdings werden Sie in vielen F√§llen bei spezieller Hard- und Software detailliertere Informationen ermitteln wollen.
An dieser Stelle kommen eigene Plugins f√ºr die HW/SW-Inventur ins Spiel.

F√ºr diesen Artikel setzen wir voraus, dass Sie bereits Grundkenntnisse in der Programmierung von agentenbasierten Check-Plugins haben.
// An Stellen, wo der Zugriff die APIs denen agentenbasierter Check-Plugins sehr √§hnlich ist, fallen die Erl√§uterungen in diesem Artikel daher etwas sp√§rlicher aus.
// ES: Ich kann den obigen Satz nicht parsen und daher auch keinen Verbesserungsvorschlag machen. Geht es um den Zugriff auf die Inventory-API, der dem Zugriff auf die Check-API sehr √§hnlich ist?
// MFS: So besser?
Wo sich die Verwendung der Inventur-API nicht wesentlich von der Check-API unterscheidet, fallen Erkl√§rungen daher sp√§rlich aus.
Daf√ºr weisen wir an Stellen mit signifikanten Unterschieden umso deutlicher auf diese hin. 

[TIP]
====
Bitte ber√ºcksichtigen Sie die Differenzierung zwischen Check- und Inventur-Plugin.
Check-Plugins eignen sich vorrangig f√ºr sich schnell √§ndernde Daten, Inventur-Plugins f√ºr selten ge√§nderte Daten.
In diesem Artikel verwenden wir zur Veranschaulichung ein √ºbersichtlich gehaltenes Beispiel mit USB-Ger√§ten.
Wollen Sie beispielsweise sicherstellen, dass niemand an irgendeinen Rechner im Monitoring USB-Ger√§te anschlie√üt, die nicht auf einer Positivliste stehen, ist daf√ºr ein Check-Plugin geeigneter.
====


[#check_api_doc]
=== Die Check-API-Dokumentation

Die Inventur-API ist Teil der Check-API.
F√ºr den Zugriff auf die Dokumentation gilt dasselbe wie bei xref:devel_check_plugins#check_api_doc[agentenbasierten Check-Plugins].

Sie k√∂nnen auf die mit Ihrer {CMK}-Instanz mitgelieferte Dokumentation zugreifen.
Dazu navigieren Sie in der {CMK}-GUI zu [.guihint]#Help > Developer resources > Plug-in API references#.
W√§hlen Sie im neuen Browserfenster in der linken Navigationsleiste [.guihint]#Agent based ("Check API") > Version 2# aus.
Auch ohne laufende {CMK}-Instanz k√∂nnen Sie sich die Plugin-API-Dokumentation als Kopie auf link:https://docs.checkmk.com/plugin-api/{gitbranch}/cmk.agent_based/index.html#version-2-cmk-agent-based-v2[docs.checkmk.com/plugin-api^] ansehen.
// ES: Link ge√§ndert, um genau auf v2 zu verweisen
// MFS: ‚úî

[#preparation]
== Vorbereitung

Die Standardeinstellung von {CMK} sieht vor, Inventardaten nur einmal t√§glich zu aktualisieren.
Dies steht nat√ºrlich im Widerspruch zu einer schnellen Sichtbarkeit von Ergebnissen bei eigenen Programmierversuchen.
Daher raten wir zu zwei vorbereitenden Ma√ünahmen f√ºr mehr Geschwindigkeit ohne signifikante Systemlast:

// . Verwenden Sie einen Host f√ºr Entwicklung und eines m√∂glicherweise ben√∂tigten Agenten-Plugins, der auf das umfangreiche Plugin `mk_inventory` verzichtet.
. Verzichten Sie bei dem Host, der die Daten f√ºr das neu zu erstellende Plugin liefert, auf das viel Last verursachende Plugin `mk_inventory`.
// ES: Im obigen Satz fehlt irgendwas oder es ist irgendwas zuviel, ich verstehe ihn nicht.
// MFS: So besser?
. Setzen Sie f√ºr diesen Host das xref:inventory#set_interval[Ausf√ºhrungsintervall des aktiven Checks] auf eine oder wenige Minuten. 

[#agentplugin]
== Das Agentenplugin

Wenn Sie ein agentenbasiertes Check-Plugin um Inventur-Funktionalit√§t erweitern wollen, k√∂nnen Sie m√∂glicherweise eine f√ºr Ihr Check-Plugin geschriebene Agentensektion mitverwenden.
F√ºr unser Beispiel erstellen wir eine eigene.
Die Grundlage hierf√ºr ist der Befehl `lsusb`.
Ohne Parameter aufgerufen, gibt er eine Liste aller angeschlossenen USB-Ger√§te aus.
Das k√∂nnte so aussehen:


[{shell}]
----
{c-omd} lsusb
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 002 Device 002: ID 0bda:0409 Realtek Semiconductor Corp. USB3.2 Hub
Bus 002 Device 003: ID 0bda:0409 Realtek Semiconductor Corp. USB3.2 Hub
Bus 002 Device 004: ID 0bda:8153 Realtek Semiconductor Corp. RTL8153 Gigabit Ethernet Adapter
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 003 Device 002: ID 0c45:6a09 Microdia Integrated_Webcam_HD
----

Die hier verwendete Kurzausgabe zeigt in den ersten Feldern, an welchem Bus und Port ein Ger√§t angeschlossen ist.
Es folgt ‚Äì durch einen Doppelpunkt getrennt ‚Äì zuerst die Hersteller-ID, dann die Ger√§te-ID.
Der Rest der Zeile enth√§lt beschreibenden Text.

=== Das resultierende Skript

Da {CMK} mit zeilenweisen Ausgaben gut klarkommt, gen√ºgen f√ºr das ben√∂tigte Check-Plugin drei Zeilen:

./usr/lib/check_mk_agent/plugins/lsusb
[{bash}]
----
#!/bin/bash
echo '<<<lsusb_demo>>>'
lsusb
----

Vergessen Sie nicht, das Plugin als ausf√ºhrbar zu markieren:

[{shell-raw}]
----
{c-root} chmod 0755 /usr/lib/check_mk_agent/plugins/lsusb
----

// ES: Wenn die Hinweise zum VM-Setup im Artikel bleiben, k√∂nnte das ein Kandidat f√ºr ein/mehrere Collapsibles sein, oder?
// MFS: Ich w√ºrde es gerne drin lassen, weil das eher der Standardfall ist: Man zieht es einmal mit lsusb und erstellt dann zwei, drei Varianten, die man abwechselnd ins Spool-Verzeichnis kopiert...
Falls der Host, auf dem Sie das das Agenten-Plugin testen, eine virtuelle Maschine ist, oder Sie nicht st√§ndig Ger√§te ab- und anst√∂pseln wollen, speichern Sie das folgende Beispiel einfach in einer Spool-Datei.
Spool-Dateien werden in die Agentenausgabe aufgenommen und mit √ºbertragen.
Achten Sie daher darauf, dass die Datei mit einem Zeilenumbruch endet.

[.copybutton]
./var/lib/check_mk_agent/spool/lsusb.txt
[{file}]
----
<<<lsusb_demo>>>
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 002 Device 002: ID 0bda:0409 Realtek Semiconductor Corp. USB3.2 Hub
Bus 002 Device 003: ID 0bda:0409 Realtek Semiconductor Corp. USB3.2 Hub
Bus 002 Device 004: ID 0bda:8153 Realtek Semiconductor Corp. RTL8153 Gigabit Ethernet Adapter
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 003 Device 002: ID 0c45:6a09 Microdia Integrated_Webcam_HD
Bus 003 Device 004: ID 8087:0032 Intel Corp. AX210 Bluetooth
Bus 003 Device 005: ID 0bda:5409 Realtek Semiconductor Corp. USB2.1 Hub
Bus 003 Device 006: ID 0bda:5409 Realtek Semiconductor Corp. USB2.1 Hub
Bus 003 Device 007: ID 0bda:1100 Realtek Semiconductor Corp. HID Device
Bus 003 Device 071: ID 046d:c093 Logitech, Inc. M500s Optical Mouse
Bus 003 Device 096: ID 1a40:0101 Terminus Technology Inc. Hub
Bus 003 Device 108: ID 6964:0075 MT ID75 Rev
Bus 003 Device 109: ID 0c45:636b Microdia USB 2.0 Camera
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
----

Das Anschlie√üen und Entfernen von USB-Ger√§ten k√∂nnen Sie dann simulieren, indem Sie der Textdatei Zeilen hinzuf√ºgen oder welche entfernen.

[#test_agent]
=== Agent ausprobieren

Testen Sie die Agentenausgabe lokal mit dem folgenden Befehl:

[{shell-raw}]
----
{c-root} cmk-agent-ctl dump | grep -A25 '^<<<lsusb'
----

Sie sollten nun je nach Zahl angeschlossener USB-Ger√§te (oder Zahl der Zeilen in der Spool-Datei) die Ausgabe von `lsusb` und ein paar Zeilen der folgenden Agentensektion sehen.
Achten Sie auf den korrekten Zeilenumbruch am Ende der Agentensektion.

[#inventory_plugin]
== Das Inventur-Plugin

Inventur-Plugins leben in der regul√§ren xref:devel_check_plugins#scaffold[Verzeichnisstruktur] neben den normalen Check-Plugins.
// ES: Querverweis eingef√ºgt, kannst du aber auch gerne anders platzieren
// MFS: üëç
Sie k√∂nnen Inventur-Plugins entweder als separate Dateien ablegen, dann empfehlen wir, als Pr√§fix `inventory_` zu verwenden.
Oder Sie integrieren Inventur-Plugins in gemeinsamen Dateien mit Check-Plugins, dann verzichten Sie auf das Pr√§fix ganz.
F√ºr welche Methode Sie sich entscheiden, sollten Sie von der √úbersichtlichkeit und dem Bedarf nach gemeinsam verwendeten Funktionen abh√§ngig machen.

Um ein reines Inventur-Plugin zu erstellen, m√ºssen Sie daher ein passendes Verzeichnis anlegen:

[{shell}]
----
{c-omd} mkdir -p local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based
{c-omd} cd local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based
----

// ES: Die Pfade sind inkonsistent. Hier arbeiten wir in `local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based`, bei den ganzen Beispieldateien unten steht in den Pfaden `local/lib/python3/cmk/plugins/lsusb_demo/agent_based`
// MFS: Ich √§ndere alles auf cmk_addons...

[#scaffold]
=== Ein minimales Plugin

Sie k√∂nnen nun ein minimales Inventur-Plugin erstellen, welches Sie mit einem beliebigen Text-Editor bearbeiten:

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python}]
----
#!/usr/bin/env python3

from cmk.agent_based.v2 import InventoryPlugin, Attributes

def inventory_lsusb_demo(section):
    yield Attributes(
        path = [ "hardware", "usb", "general" ],
        inventory_attributes = { "Max standard": "3.2" },
    )

inventory_plugin_lsusb_demo = InventoryPlugin( 
    name = "lsusb_demo",
    inventory_function = inventory_lsusb_demo,
)
----

Der Aufbau √§hnelt dem von xref:devel_check_plugins#check_plug-in[Check-Plugins].
// ES: Querverweis eingef√ºgt, bitte pr√ºfen, ob das die passendste Stelle in devel_check_plugins ist
Auch das Inventur-Plugin importiert aus dem Namensraum `cmk.agent_based.v2`.
Die Inventur-Funktion entspricht der Check-Funktion, und die Erstellung des `InventoryPlugin`-Objektes erfolgt analog zu der eines `CheckPlugin`-Objektes.
// ES: Ich finde "entspricht" hier zu ungenau. Wie w√§re es mit Folgendem:
// Ein instanziiertes `CheckPlugin`-Objekt wird mit einer konkreten Check-Funktion verkn√ºpft, die ein `Result`-Objekt via `yield` zur√ºckgibt.
// Analog dazu wird ein instanziiertes `InventoryPlugin`-Objekt mit einer konkreten Inventory-Funktion verkn√ºpft, die ein `Attributes`-Objekt via `yield` zur√ºckgibt.

Die `Attributes`, welche per `yield` zur√ºckgegeben werden, implementieren das minimal sinnvolle Blatt eines Inventurbaumes:

* Der Pfad (`path`) beschreibt den relevanten Knoten in der Hierarchie des Baums, hier [.guihint]#Hardware > Usb > General#
* Die Schl√ºssel-Wert-Paare im Objekt `inventory_attributes` werden als Schl√ºssel-Wert-Tabelle dargestellt

Testen Sie zun√§chst, ob das Plugin syntaktisch korrekt ist und bei der Inventur gestartet werden kann:

[{shell-raw},highlight=8]
----
{c-omd} cmk-validate-plugins 
Agent based plugins loading succeeded, Active checks loading succeeded, Special agents
loading succeeded, Rule specs loading succeeded, Rule specs forms creation succeeded,
Referenced rule specs validation succeeded, Loaded rule specs usage succeeded
{c-omd} cmk -vv --inventory localhost | grep lsusb_demo
<<<lsusb_demo>>> / Transition HostSectionParser -> HostSectionParser
  HostKey(hostname='localhost', source_type=<SourceType.HOST: 1>)  -> Add sections: ['check_mk', 'local', 'lsusb_demo', ...]
 lsusb_demo: ok
 lsusb_demo: skipped (no data)
----
// ES: Wenn ich es richtig verstehe, kann man hier jeden beliebigen Host eingeben - dann w√§re ich daf√ºr, im Beispielaufruf `myhost` statt `localhost` einzuf√ºgen (ggf. auch f√ºr sp√§ter folgende Beispiele im Artikel relevant)

Ist das der Fall, aktualisieren Sie die Konfiguration f√ºr den Monitoring-Kern und starten dann Ihre Instanz neu:

[{shell}]
----
{c-omd} cmk -U
Generating configuration for core (type cmc)...
Starting full compilation for all hosts
 Creating global helper config...OK
 Creating cmc protobuf configuration...OK
{c-omd} omd restart
Stopping crontab...OK
Stopping dcd...killing 153645....OK
Stopping apache...killing 153387.................OK
Stopping cmc...killing 153300.....OK
Stopping ui-job-scheduler...killing 153285...OK
...
----

Ein Blick in das Inventar des Test-Hosts zeigt nun -- sobald der n√§chste regul√§re Check erfolgt ist -- ein neues Blatt im Inventarbaum:

// ES: Screenshot hier nicht vergessen


[#parse_function]
=== Die Parse-Funktion schreiben

// ES: K√∂nnen wir hier lieber von Tokens sprechen statt von Worten? Wenn irgendwo in der Zeile Zahlen stehen, die von Whitespaces umgeben sind, werden die doch auch abgetrennt. Deshalb w√ºrde ich hier auch lieber nicht den Zusammenhang "ohne Separator = Aufteilung in Worte" darstellen, sondern besser explizit "ohne Angabe eines Separators = Aufteilung anhand des Default-Separators (Leerzeichen)"
Agentensektionen ohne Angabe eines Separators werden vor der √úbergabe an die Inventurfunktion in eine zweidimensionale Liste von Worten umgewandelt:
Je Zeile entsteht eine Liste von Worten.
Jede dieser Listen wiederum ist Element einer Liste von Zeilen.
Wird ein Separator angegeben, definiert dieser die Wortgrenze.
Das erleichtert beispielsweise die Verarbeitung von als CSV formatierten Daten.

Eine Parse-Funktion wie bei xref:devel_check_plugins#parse_function[agentenbasierten Check-Plugins] ist nicht zwingend erforderlich.
Dennoch kann die Verwendung einer separaten Parse-Funktion einige Vorteile haben.
So erh√∂ht sie √úbersichtlichkeit und Erweiterbarkeit.
Und wenn ein bereits vorhandenes Plugin eines agentenbasierten Checks weiterverwendet werden soll, stellt sich die Frage ohnehin nicht:
Dann verwenden Sie einfach die vorhandene Parse-Funktion weiter.

In unserem Beispiel interessiert nicht, wo ein USB-Ger√§t angeschlossen ist.
F√ºr das Plugin sollen die Hersteller- und Ger√§te-ID ermittelt werden (an sechster Stelle der Liste), sowie die Beschreibung (ab der siebten Stelle bis zum Ende der Liste).

W√§hrend wir oben im simplen Beispiel die maximal unterst√ºtzte USB-Version noch einfach hart kodiert haben, k√∂nnen Sie sich gerne Gedanken machen, wie Sie diese mittelfristig mit regul√§ren Ausdr√ºcken aus der Beschreibung ermitteln.
Daf√ºr wird die Beschreibung komplett ben√∂tigt, also alles ab dem siebten, bis zum letzten Wort der Liste:

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python}]
----
def parse_lsusb_demo(string_table):
    parsed = { "devices": [] }
    for line in string_table:
        vendor = line[5].split(":")[0]
        device = line[5].split(":")[1]
        description = ""
        for i in range(6, len(line)):
            description = description + " " + line[i]
        parsed["devices"].append({ "vendor": vendor, "device": device, "description": description })
    return parsed
----

[#inventory_function]
=== Die Inventurfunktion schreiben

Hier k√∂nnen Sie ein wenig abk√ºrzen: Im Gegensatz zu agentenbasierten Check-Plugins wird die Parse-Funktion nicht √ºber die Erzeugung eines `AgentSection`-Objektes eingebunden, sondern muss aus der Inventurfunktion selbst aufgerufen werden.
Das Prinzip des `yield` zur fortw√§hrenden √úbergabe von Elementen kennen Sie aus agentenbasierten Check-Plugins:

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python},highlight=2;9]
----
def inventory_lsusb_demo(section):
    section = parse_lsusb_demo(section)
    yield Attributes(
        path = [ "hardware", "usb", "general" ],
        # FIXME: dynamically calculate from agent section
        inventory_attributes = { "Max standard": "3.2" },
    )
    for d in section["devices"]:
        yield TableRow(
            path = [ "hardware", "usb", "devices" ],
            key_columns = {
                "vendor": d["vendor"],
                "device": d["device"]
            },
            inventory_columns = {
                "description": d["description"]
            }
        )
----

Hier wird pro Zeile der Ausgabe von `lsusb` ein Objekt des Typs `TableRow` zur√ºckgegeben.
Dieses enth√§lt drei Spalten: Vendor- und Device-ID dienen gemeinsam als Schl√ºssel.
Die dritte, rein informative Spalte enth√§lt die Beschreibung.

Schl√ºsselspalten haben die Besonderheit, dass sie zur Erkennung von √Ñnderungen herangezogen werden, die wiederum im Monitoring zu einem Statuswechsel des Dienstes [.guihint]#HW/SW Inventory# f√ºhren k√∂nnen.
Des weiteren m√ºssen Schl√ºssel eindeutig sein.
Weitere Zeilen mit derselben Kombination aus Vendor- und Device-ID werden folglich ignoriert.

Neben Schl√ºssel- und Inventarspalten k√∂nnen Sie Statusspalten (`status_columns`) und analog Statusattribute (`status_attributes`) verwenden, welche den _Zustand_ eines Objektes abbilden.
F√ºr den Wert des Zustands stehen die einfachen Datentypen (`int`, `float`, `str`, `bool` oder `None`) zur Verf√ºgung.
Wollen Sie beispielsweise eine Tabelle erstellen, in der verzeichnet ist, welcher Anschluss (`Bus/Device`) belegt ist, dann k√∂nnen Sie `key_columns` (`Bus` und `Device`) und `status_columns` (hier: `bool`) verwenden.

[#finished_plugin]
=== Das fertige Plugin

Das fertige Plugin f√ºgt alles zusammen.
Hier wird zus√§tzlich noch die `TableRow`-Klasse importiert:

// ES: War das Absicht, dass du hier das letzte Token jeder Beschreibung abges√§belt hattest? Jedenfalls w√ºrde dann der Check mit dem .*?hub$ nicht mehr funktionieren.
// MFS: Haha, zuviel Ruby gemacht in letzter Zeit! War auf meinem Testsystem f√ºr .*?hub$ bereits korrigiert... Danke f√ºrs finden im Artikel!
.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python},highlight=3]
----
#!/usr/bin/env python3

from cmk.agent_based.v2 import InventoryPlugin, Attributes, TableRow

def parse_lsusb_demo(string_table):
    parsed = { "devices": [] }
    for line in string_table:
        vendor = line[5].split(":")[0]
        device = line[5].split(":")[1]
        description = ""
        for i in range(6, len(line)):
            description = description + " " + line[i]
        parsed["devices"].append({ "vendor": vendor, "device": device, "description": description })
    return parsed

def inventory_lsusb_demo(section):
    section = parse_lsusb_demo(section)
    yield Attributes(
        path = [ "hardware", "usb", "general" ],
        inventory_attributes = { "Plugin version": "0.1.0" },
    )
    for d in section["devices"]:
        yield TableRow(
            path = [ "hardware", "usb", "devices" ],
            key_columns = {
                "vendor": d["vendor"],
                "device": d["device"],
            },
            inventory_columns = {
                "description": d["description"],
            }
        )

inventory_plugin_lsusb_demo = InventoryPlugin( 
    name = "lsusb_demo",
    inventory_function = inventory_lsusb_demo,
)
----

// ES: Hier h√§tte ich gerne noch einen Screenshot von der gef√ºllten Tabelle auf der HW/SW-Seite in der Weboberfl√§che. √úberrascht hat mich, dass die Key-Spalten rechts zu sehen sind und die Beschreibung ganz links - haben wir Kontrolle dar√ºber?
// MFS: Tja, Inventory sortiert alphabetisch... Es gibt ein API, um die Darstellung zu verbessern, das ist bis 2.4 internal und wird dann in der 2.5 Version dieses Artikels gezeigt. Damit sind dann weniger peinliche Screenshots m√∂glich...

[#rulesets]
== Regels√§tze f√ºr die Inventur

Da die Inventur-API Teil der Check-Plugin-API ist, gestaltet sich die Erstellung und Anwendung von Regels√§tzen exakt wie bei der Entwicklung regul√§rer Check-Plugins.
Aus diesem Grund zeigen wir hier nur ein minimales Beispiel.

=== Regelsatz definieren

In der Ausgabe von `lsusb` tauchen einige Zeilen f√ºr Hubs (externe und Root-Hubs) auf.
Diese Ger√§te ohne eigene Funktionalit√§t erschweren es, den √úberblick zu behalten.

Daher wollen wir den Nutzenden die M√∂glichkeit geben, selbst zu entscheiden, ob Hubs erfasst werden sollen oder nicht.
Die Einstellung soll √ºber eine Checkbox in einer Regel erfolgen.
// ES: Wie ist das, k√∂nnen wir diese selbstgestrickte Regel auch in der Weboberfl√§che sehen und konfigurieren? Wie?
// MFS: Guter Punkt, die Regeln sind n√§mlich woanders zu finden als normale Monitoring-Regeln:
Sie k√∂nnen diese Regel dann in der GUI unter [.guihint]#Setup > Hosts > HW/SW inventory rules# einsehen und anpassen.
Ist der Name einer Regel bekannt (hier [.guihint]#Lsusb inventory demo# k√∂nnen Sie diesen direkt ins Suchfeld tippen.
Abgelegt wird diese im Ordner `rulesets` der Plugin-Familie, den Sie zun√§chst anlegen m√ºssen:

[{shell}]
----
{c-omd} mkdir -p local/lib/python3/cmk_addons/plugins/lsusb_demo/rulesets
{c-omd} cd local/lib/python3/cmk_addons/plugins/lsusb_demo/rulesets
----

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/rulesets/ruleset_lsusb_demo_inventory.py
[{python}]
----
#!/usr/bin/env python3

from cmk.rulesets.v1 import Label, Title, Help
from cmk.rulesets.v1.form_specs import (
    BooleanChoice,
    DefaultValue,
    DictElement,
    Dictionary,
)
from cmk.rulesets.v1.rule_specs import (
    InventoryParameters,
    Topic
)
from cmk.rulesets.v1 import Label

def _parameter_form():
    return Dictionary(
        elements = {
            "hubs": DictElement(
                parameter_form = BooleanChoice(
                    title = Title("USB hubs"),
                    label = Label("Consider USB hubs in the inventory table"),
                    prefill=DefaultValue(True),
                ),
                required = True,
            ),
        }
    )

rule_spec_lsusb_demo_inventory = InventoryParameters(
    name = "lsusb_demo",
    title = Title("Lsusb inventory demo"),
    topic = Topic.GENERAL,
    parameter_form = _parameter_form,
)
----

=== Regelsatz anwenden

Um den Regelsatz anzuwenden, erg√§nzen Sie zwei weitere [.notranslate]#_Named Arguments_# bei der Erstellung der `InventoryPlugin`-Klasse.

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python},highlight=6-7]
----
# ...

inventory_plugin_lsusb_demo = InventoryPlugin( 
    name = "lsusb_demo",
    inventory_function = inventory_lsusb_demo,
    inventory_default_parameters = { "hubs": True },
    inventory_ruleset_name = "lsusb_demo",
)
----

Zus√§tzlich muss der Inventur-Funktion als erstes Argument das Parameter-Dictionary √ºbergeben werden.
Hier erg√§nzen Sie auch einen regul√§ren Ausdruck, um zu erkennen, welche Ger√§t-Beschreibungen mit ‚Äûhub‚Äú enden.
Beachten Sie, dass Sie daf√ºr eine weitere `import`-Zeile zu Beginn des Skripts einf√ºgen m√ºssen:

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python}]
----
# ...

import re

# ...

def inventory_lsusb_demo(params, section):
    section = parse_lsusb_demo(section)
    yield Attributes(
        path = [ "hardware", "usb", "general" ],
        inventory_attributes = { "Plugin version": "0.1.0" },
    )
    h = re.compile('.*?hub$', re.IGNORECASE)
    for d in section["devices"]:
        if params['hubs'] or not h.match(d["description"]):
            yield TableRow(
                path = [ "hardware", "usb", "devices" ],
                key_columns = {
                    "vendor": d["vendor"],
                    "device": d["device"],
                },
                inventory_columns = {
                    "description": d["description"],
                }
            )
# ...
----

// MFS: Ich ziehe diesen Kommentar hoch ^
//                                      |
// ES: Wie ist das, k√∂nnen wir diese selbstgestrickte Regel auch in der Weboberfl√§che sehen und konfigurieren? Wie?

[#extending]
== Erweiterungsm√∂glichkeiten

[#multiple_sections]
=== Mehrere Sektionen abonnieren

// ES: Als Motivation f√ºr diesen Abschnitt f√§nde ich es hilfreich, wenn du zu Beginn einmal das Standardverhalten benennst: Wenn ich keine Sektionen explizit angebe, schaut das Plugin nach einer Sektion, die vom Namen des von mir angelegten Objekts oder der Funktionen abgeleitet wird, oder? Und wenn ich will, kann ich stattdessen explizit 1 bis n Sektionen angeben, die ber√ºcksichtigt werden sollen, sodass die von mir vergebenen Namen nicht mehr die Sektion bestimmen.
Wenn Sie vorhandene Agentensektionen mitverwenden wollen, die bereits von einem vorhandenen Inventur-Plugin ausgewertet werden, ist die Wahrscheinlichkeit hoch, dass bereits ein Inventur-Plugin existiert, das den Namen der Agentensektion verwendet.
Klarheit schafft die Ausgabe von:

[{shell}]
----
{c-omd} cmk -vv --inventory localhost
Doing HW/SW Inventory on: localhost
localhost:
+ INVENTORIZING
+ FETCHING DATA
  Source: SourceInfo(hostname='localhost', ipaddress='127.0.0.1', ident='agent' ...)
...
+ EXECUTING INVENTORY PLUGINS
 mssql_instance: skipped (no data)
 mssql_instance: skipped (no data)
 azure_app_gateway: skipped (no data)
 azure_app_gateway: skipped (no data)
 redfish_firmware: skipped (no data)
 redfish_firmware: skipped (no data)
 redfish_firmware_hpe_ilo4: skipped (no data)
 redfish_firmware_hpe_ilo4: skipped (no data)
 robotmk: skipped (no data)
 robotmk: skipped (no data)
----

In diesem Fall und dem Fall, dass ein Inventur-Plugin mehrere Agentensektionen auswerten soll, k√∂nnen Sie die abonnierten Sektionen als Liste angeben.
Gehen wir beispielsweise davon aus, dass Sie zwei Agentensektionen auswerten wollen, die sich auf fiktionale Dinge beziehen:

[.copybutton]
./var/lib/check_mk_agent/spool/fictional.txt
[{file}]
----
<<<zorg>>>
ZF1 23.0
<<<yoyodyne>>>
Gnomovision 42.1
----

In diesem Fall m√ºssen die abonnierten Agentensektionen explizit angegeben werden.
Der Name des Plugins muss mit den Agentensektionen nicht mehr √ºbereinstimmen:

.~/local/lib/python3/cmk_addons/plugins/fictional/agent_based/fictional.py
[{python}]
----
inventory_plugin_lsusb_demo = InventoryPlugin( 
    name = "fictional",
    sections = [ "yoyodyne", "zorg" ],
    inventory_function = inventory_fictional,
)
----

Die Inventurfunktion bekommt dann die String-Tabellen als Variablen nach dem Muster `section_sectionname` √ºbergeben:

.~/local/lib/python3/cmk_addons/plugins/fictional/agent_based/fictional.py
[{python}]
----
def inventory_fictional(section_yoyodyne, section_zorg):
    # Do something with the two two-dimensional arrays...
----

Das vollst√§ndige Plugin, welches die Versionen von link:https://www.gnu.org/licenses/old-licenses/gpl-2.0.html[Yoyodyne Gnomovision^] und link:https://fictionalcompanies.fandom.com/wiki/Zorg_Industries#Zorg_ZF-1_Pod_Weapon[Zorg ZF1^] im Inventarbaum abbildet, kann dann so aussehen:

.~/local/lib/python3/cmk_addons/plugins/fictional/agent_based/fictional.py
[{python}]
----
#!/usr/bin/env python3

from cmk.agent_based.v2 import InventoryPlugin, Attributes

def inventory_fictional(section_yoyodyne, section_zorg):
    yoyo = section_yoyodyne
    zorg = section_zorg
    yield Attributes(
        path = [ "software", "fictional", "example" ],
        inventory_attributes = { "Yoyodyne " + yoyo[0][0]: yoyo[0][1] },
    )
    yield Attributes(
        path = [ "hardware", "fictional", "example" ],
        inventory_attributes = { "Zorg " + zorg[0][0]: zorg[0][1] },
    )

inventory_plugin_lsusb_demo = InventoryPlugin( 
    name = "fictional",
    sections = [ "yoyodyne", "zorg" ],
    inventory_function = inventory_fictional,
)
----

// ES: Hier yielden wir immer nur die Eintr√§ge aus der ersten Zeile der beiden Sektionen, kannst du das mit wenig Aufwand zu einer richtigen Iteration √ºber die gesamten Sektionen umbauen? Oder ist das "left as an exercise for the reader"? Im Beispiel gibt es ja eh nur eine Zeile, aber wenn jemand l√§ngere Sektionen mit verarbeiten m√∂chte, w√§re eine vorbereitete Schleife schon hilfreich.

// ES: Hier auch gerne noch einen Screenshot einf√ºgen, der die fiktionalen Ergebnisse auf der HW/SW-Seite in der Weboberfl√§che zeigt

////
---


[#parse_function]
=== Die Parse-Funktion schreiben

Die Parse-Funktion hat die Aufgabe, die ‚Äûrohen‚Äú Agentendaten zu ‚Äûparsen‚Äú, das hei√üt zu analysieren und zu zerteilen, und in eine logisch aufger√§umte Form zu bringen, die f√ºr alle weiteren Schritte einfach zu verarbeiten ist.

Wie im Abschnitt zum xref:test_agent[Testen des Agenten] gezeigt, hat die vom Agentenplugin gelieferte Sektion die folgende Struktur:

[{shell-raw}]
----
<<<myhostgroups:sep(59)>>>
Hamburg;myhost11,myhost22,myhost33
Munich;myhost1,myhost2,myhost3
check_mk;localhost
----

{CMK} zerlegt bereits die Zeilen der vom Agentenplugin gelieferten Sektion anhand des Trennzeichens im Sektions-Header (im Beispiel `;`) in eine Liste von Zeilen, die ihrerseits wiederum Listen von Worten sind.
In {CMK} steht daher statt der Rohdaten des Agentenplugins die folgende Datenstruktur zur Verf√ºgung:

[{python}]
----
[
    ['Hamburg', 'myhost11,myhost22,myhost33'],
    ['Munich', 'myhost1,myhost2,myhost3'],
    ['check_mk', 'localhost']
]
----

In der inneren Liste enth√§lt das jeweils erste Element den Namen der Host-Gruppe und das zweite die Namen der der Gruppe angeh√∂renden Hosts.

Diese Informationen k√∂nnen Sie zwar alle ansprechen, aber jeweils nur √ºber ihre Position im Datensatz.
Sie m√ºssten also immer angeben, die wievielte eckige Klammer und den wievielten Inhalt innerhalb der jeweiligen Klammer Sie brauchen.
Bei gr√∂√üeren Datenmengen gestaltet sich dies komplex und es wird immer schwieriger, den √úberblick zu behalten.

An diesem Punkt bietet eine Parse-Funktion durch die von ihr erzeugte Struktur deutliche Vorteile.
Durch sie wird der Code leichter lesbar, die Zugriffe werden performanter und Sie behalten viel einfacher den √úberblick.
Sie transformiert die von {CMK} gelieferte Datenstruktur so, dass man jeden der einzelnen Werte wahlfrei durch einen Namen (oder Schl√ºssel) ansprechen kann und nicht darauf angewiesen ist, den Bereich (_array_) iterativ zu durchlaufen, um das zu finden, was man sucht:

[{python}]
----
{
    'Hamburg': {'members': 'myhost11,myhost22,myhost33'},
    'Munich': {'members': 'myhost1,myhost2,myhost3'},
    'check_mk': {'members': 'localhost'}
}
----

Konvention ist, dass die Parse-Funktion nach der Agentensektion benannt wird und mit `parse_` beginnt.
Sie bekommt als einziges Argument `string_table` √ºbergeben.
Beachten Sie, dass Sie hier nicht frei in der Wahl des Arguments sind.
Es _muss_ exakt so hei√üen.

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
def parse_myhostgroups(string_table):
    # print(string_table)
    parsed = {}
    for line in string_table:
        parsed[line[0]] = {"members": line[1]}
    # print(parsed)
    return parsed
----

Mit `def` geben Sie in Python an, dass nachfolgend eine Funktion definiert wird.
`parsed = {}` erzeugt das _Dictionary_ mit der verbesserten Datenstruktur.
In unserem Beispiel wird jede Zeile Element f√ºr Element durchgegangen.
Aus jeder Zeile wird die Host-Gruppe gefolgt von den Mitgliedern der Host-Gruppe genommen und zu einem Eintrag f√ºr das Dictionary zusammengesetzt.

Mit `return parsed` wird dann das Dictionary zur√ºckgegeben.

[TIP]
====
Im oben gezeigten Beispiel finden Sie zwei auskommentierte Zeilen.
Wenn Sie diese sp√§ter beim xref:test[Testen des Check-Plugins] einkommentieren, werden Ihnen die Daten vor und nach der Ausf√ºhrung der Parse-Funktion auf der Befehlszeile angezeigt.
So k√∂nnen Sie √ºberpr√ºfen, ob die Funktion auch wirklich das tut, was sie soll.
====


[#agent_section]
=== Die Agentensektion erstellen

Damit das Ganze auch etwas bewirken kann, m√ºssen Sie die neue Agentensektion mit der neuen Parse-Funktion erzeugen.
Nur so wird sie von {CMK} erkannt und ber√ºcksichtigt.
Dazu erstellen Sie die Agentensektion als Instanz der Klasse `AgentSection`:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
agent_section_myhostgroups = AgentSection(
    name = "myhostgroups",
    parse_function = parse_myhostgroups,
)
----

Hier ist es wichtig, dass der Name der Sektion wirklich exakt mit dem Sektions-Header in der Agentenausgabe √ºbereinstimmt.
Von diesem Moment an bekommt jedes Check-Plugin, das die Sektion `myhostgroups` benutzt, den R√ºckgabewert der Parse-Funktion √ºbergeben.
In der Regel wird das das gleichnamige Check-Plugin sein.
Aber auch andere Check-Plugins k√∂nnen dieses Sektion abonnieren, wie wir bei der xref:discovery[Erweiterung des Check-Plugins] noch zeigen werden.

√úbrigens: Wenn Sie es ganz genau wissen wollen, k√∂nnen Sie an dieser Stelle einen Blick in die xref:check_api_doc[Check-API-Dokumentation] werfen.
Dort finden Sie die detaillierte Beschreibung dieser Klasse -- und auch der Klassen, Funktionen und Objekte, die sp√§ter im Artikel noch verwendet werden.

[{image-border}]
image::devel_cpi_checkapi_doc_agent_section.png[alt="Check-API-Dokumentation f√ºr die Klasse 'AgentSection'."]


[#check_plug-in]
=== Das Check-Plugin erstellen

Damit {CMK} erkennen kann, dass es ein neues Check-Plugin gibt, muss dieses erzeugt werden.
Dies geschieht durch die Erstellung einer Instanz der Klasse `CheckPlugin`.

Dabei m√ºssen Sie immer mindestens vier Dinge angeben:

. `name`: Der Name des Check-Plugins.
Am einfachsten ist es, wenn Sie hier den gleichen Namen wie bei Ihrer neuen Agentensektion nehmen.
Damit wei√ü der sp√§ter in der Check-Funktion definierte Check automatisch, welche Sektion er auswerten soll.

. `service_name`:
Der Name des Services, wie er dann im Monitoring erscheinen soll.

. `discovery_function`:
Die Funktion zum Erkennen von Services dieses Typs (dazu gleich mehr).

. `check_funktion`:
Die Funktion zum Durchf√ºhren des eigentlichen Checks (auch dazu gleich mehr).

Der Name der Instanz muss dabei mit `check_plugin_` beginnen.
Das sieht dann so aus:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
check_plugin_myhostgroups = CheckPlugin(
    name = "myhostgroups",
    service_name = "Host group check_mk",
    discovery_function = discover_myhostgroups,
    check_function = check_myhostgroups,
)
----

Versuchen Sie am besten noch nicht, das gleich auszuprobieren, denn Sie m√ºssen die Funktionen `discover_myhostgroups` und `check_myhostgroups` vorher noch schreiben.
Und diese m√ºssen im Quellcode _vor_ obiger Erstellung von Agentensektion und Check-Plugin erscheinen.

include::include_special_chars.asciidoc[]


[#discovery_function]
=== Die Discovery-Funktion schreiben

Eine Besonderheit von {CMK} ist die automatische Erkennung von zu √ºberwachenden Services.
Damit dies klappt, muss jedes Check-Plugin eine Funktion definieren, welche anhand der Agentenausgabe erkennt, _ob_ ein Service dieses Typs bzw. _welche_ Services des Typs f√ºr den betreffenden Host angelegt werden sollen.

Die Discovery-Funktion wird immer dann aufgerufen, wenn f√ºr einen Host die Service-Erkennung durchgef√ºhrt wird.
Sie entscheidet dann ob, bzw. welche Services angelegt werden sollen.
Im Standardfall bekommt sie genau ein Argument mit dem Namen `section`.
Dieses enth√§lt die Daten der Agentensektion in einem durch die xref:parse_function[Parse-Funktion] aufbereiteten Format.

Daher implementieren Sie folgende simple Logik:
_Wenn_ die Agentensektion `myhostgroups` vorhanden ist, dann legen Sie auch einen passenden Service an.
Dann erscheint dieser automatisch auf allen Hosts, auf denen das Agentenplugin verteilt ist.

Bei Check-Plugins, die pro Host nur einen Service erzeugen, ben√∂tigt man keine weiteren Angaben:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
def discover_myhostgroups(section):
    yield Service()
----

Die Discovery-Funktion muss f√ºr jeden anzulegenden Service mittels `yield` ein Objekt vom Typ `Service` zur√ºckgeben (nicht mit `return`).
`yield` hat in Python die gleiche Aufgabe wie `return` ‚Äì beide geben einen Wert an die aufrufende Funktion zur√ºck.
Der entscheidende Unterschied besteht darin, dass sich bei einem `yield` gemerkt wird, wie weit die Funktion in einer Datenverarbeitung gekommen ist.
Beim n√§chsten Aufruf wird _nach_ der letzten `yield`-Anweisung weiter gemacht - und nicht wieder am Anfang begonnen.
Dadurch wird nicht nur der erste Treffer ausgelesen (wie es beim `return` der Fall w√§re), sondern sukzessive alle Treffer (dieser Vorteil wird sp√§ter in unserem Beispiel bei der xref:discovery[Service-Erkennung] noch relevant).


[#check_function]
=== Die Check-Funktion schreiben

Somit k√∂nnen Sie nun zur eigentlichen Check-Funktion kommen, welche anhand der aktuellen Agentenausgabe entscheidet, welchen Zustand der Service annehmen soll und weitere Informationen ausgeben kann.

Ziel der Check-Funktion ist es, eine Pr√ºfung aufzusetzen, mit der kontrolliert werden kann, ob f√ºr keinen Host vergessen wurde, eine Host-Gruppe zuzuweisen.
Dazu wird √ºberpr√ºft, ob die Host-Gruppe `check_mk` Hosts enth√§lt.
Wenn das der Fall ist, soll der Service den Zustand {CRIT} erhalten.
Wenn nicht, ist alles {OK} und der Zustand des Services auch.

Hier ist die Implementierung:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups(section):
    attr = section.get("check_mk")
    hosts = attr["members"] if attr else ""
    if hosts:
        yield Result(state=State.CRIT, summary=f"Default group is not empty; Current member list: {hosts}")
    else:
        yield Result(state=State.OK, summary="Everything is fine")
----

Und nun die Erkl√§rung dazu:
Die Funktion `check_myhostgroups()` holt als erstes den zum Schl√ºssel `check_mk` geh√∂renden Wert in die Variable `attr`.
Dann wird die Variable `hosts` mit dem `members`-Wert verkn√ºpft, wenn dieser vorhanden ist.
Gibt es keine `members`, so bleibt `hosts` leer.

Jetzt folgt eine `if`-Abfrage f√ºr die eigentliche Auswertung:

* Enth√§lt die Variable `hosts` Inhalte, ist also die Host-Gruppe `check_mk` nicht leer, so geht der Status des Services auf {CRIT} und es wird ein Hinweistext ausgegeben.
Dieser enth√§lt zus√§tzlich eine Auflistung der Host-Namen aller Hosts, die sich in der Host-Gruppe `check_mk` befinden.
F√ºr die Ausgabe des Textes mit Ausdr√ºcken wird der Python link:https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals[F-String^] verwendet, der so hei√üt, weil vor der String-Zeichenfolge der Buchstabe `f` steht.

* Ist die Variable `hosts` leer, sind also keine Hosts in der Host-Gruppe `check_mk`, so geht stattdessen der Status des Services auf {OK}.
Dann wird zudem ein passender Hinweistext ausgegeben.

Mit der Erstellung der Check-Funktion ist das Check-Plugin fertig.

Das link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/check_plugin_simple_myhostgroups.py[Check-Plugin^]
und auch das link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/agent_plugin_simple_myhostgroups[Agentenplugin^]
haben wir auf GitHub bereitgestellt.


[#test]
=== Das Check-Plugin testen und aktivieren

Test und Aktivierung werden auf der Befehlszeile mit dem Befehl `cmk` erledigt.

Probieren Sie zun√§chst die xref:wato_services#commandline[Service-Erkennung] mit der Option `-I` aus.
Durch Zugabe der Option `v` (f√ºr _verbose_) werden ausf√ºhrliche Ausgaben angefordert.
Das `--detect-plugins` beschr√§nkt die Befehlsausf√ºhrung auf dieses Check-Plugin und durch `localhost` auf eben diesen Host:

[{shell},highlight=10-12]
----
{c-omd} cmk -vI --detect-plugins=myhostgroups localhost
Discovering services and host labels on: localhost
localhost:
+ FETCHING DATA
No piggyback files for 'localhost'. Skip processing.
Get piggybacked data
+ ANALYSE DISCOVERED HOST LABELS
SUCCESS - Found no new host labels
+ ANALYSE DISCOVERED SERVICES
+ EXECUTING DISCOVERY PLUGINS (1)
  1 myhostgroups
SUCCESS - Found 1 services
----

Wie geplant, erkennt die Service-Erkennung einen neuen Service im Check-Plugin `myhostgroups`.

Jetzt k√∂nnen Sie den im Check-Plugin enthaltenen xref:cmk_commandline#execute_checks[Check ausprobieren:]

[{shell},highlight=5]
----
{c-omd} cmk --detect-plugins=myhostgroups -v localhost
+ FETCHING DATA
No piggyback files for 'localhost'. Skip processing.
Get piggybacked data
Host group check_mk  [red]#Default group is not empty; Current member list: localhost#
No piggyback files for 'localhost'. Skip processing.
[agent] Success, [piggyback] Success (but no data found for this host), execution time 1.8 sec | execution_time=1.800 user_time=0.030 system_time=0.000 children_user_time=0.000 children_system_time=0.000 cmk_time_agent=1.780
----

Durch Ausf√ºhrung des Checks wird der Zustand des zuvor gefundenen Services bestimmt.

Wenn soweit alles wie erwartet abgelaufen ist, k√∂nnen Sie die √Ñnderungen aktivieren.
Falls nicht, finden Sie im Kapitel zur xref:errors[Fehlerbehebung] Hinweise.

Aktivieren Sie zum Abschluss die √Ñnderungen durch einen xref:cmk_commandline#commands_core[Neustart des Monitoring-Kerns:]

[{shell}]
----
{c-omd} cmk -R
Generating configuration for core (type nagios)...
Precompiling host checks...OK
Validating Nagios configuration...OK
Restarting monitoring core...OK
----

Im Monitoring von {CMK} finden Sie nun beim Host `localhost` den neuen Service [.guihint]#Host group check_mk#.

.Da die Host-Gruppe `check_mk` nicht leer ist, ist der Service {CRIT}
image::devel_cpi_service_simple.png[alt="Der vom Check-Plugin erzeugte neue Service im Monitoring."]

Wir gratulieren Ihnen zur erfolgreichen Erstellung des ersten Check-Plugins!


[#extend]
== Das Check-Plugin erweitern

[#prepare]
=== Vorbereitungen

Das gerade frisch fertiggestellte erste Check-Plugin soll nun schrittweise erweitert werden.
Bisher hat das Agentenplugin nur die Informationen √ºber die Namen und die Mitglieder der Host-Gruppen geliefert.
Um etwa die Zust√§nde der Hosts und der auf ihnen laufenden Services auswerten zu k√∂nnen, braucht es mehr Daten.


==== Agentenplugin erweitern

Sie werden zun√§chst das Agentenplugin _einmal_ erweitern, um all die Informationen einzusammeln, die f√ºr die Erweiterung des Check-Plugins in den n√§chsten Abschnitten ben√∂tigt werden.

Um herauszubekommen, welche Informationen {CMK} denn f√ºr Host-Gruppen so bietet, 
k√∂nnen Sie alle verf√ºgbaren Spalten der Host-Gruppentabelle mit xref:livestatus#columns[folgendem Befehl] als Instanzbenutzer abfragen:

[{shell}]
----
{c-omd} lq "GET columns\nFilter: table = hostgroups\nColumns: name"
action_url
alias
members
members_with_state
name
notes
notes_url
num_hosts
...
----

Die Ausgabe geht noch weiter.
Fast 30 Spalten bietet die Tabelle -- und unter den meisten Spaltennamen kann man sich sogar etwas vorstellen.
Hier interessieren die folgenden Spalten:
Anzahl der Hosts pro Gruppe (Spalte `num_hosts`), Anzahl der Hosts im Zustand {UP} (`num_hosts_up`), Anzahl der Services aller Hosts in der Gruppe (`num_services`) und Anzahl der Services im Zustand {OK} (`num_services_ok`).

Jetzt m√ºssen diese neuen Spalten nur noch vom Agenten geliefert werden.
Das erreichen Sie durch Erweiterung des im vorherigen Kapitel erstellten xref:agentplugin[Agentenplugins.]

Editieren Sie als root-Benutzer das Skript des Agentenplugins.
Da das Skript die konfigurierbaren Werte bereits in Variablen gesteckt hat, reicht es aus, nur die mit `columns` beginnende Zeile zu √§ndern und dort die zus√§tzlich abgerufenen vier Spalten einzutragen:

./usr/lib/check_mk_agent/plugins/myhostgroups
[{bash},highlight=3]
----
#!/bin/bash

columns="name members num_hosts num_hosts_up num_services num_services_ok"
site="mysite"

echo '<<<myhostgroups:sep(59)>>>'
su - ${site} lq "GET hostgroups\nColumns: ${columns}"
----

F√ºhren Sie zur Kontrolle das Skript aus:

[{shell-raw}]
----
{c-root} /usr/lib/check_mk_agent/plugins/myhostgroups
<<<myhostgroups:sep(59)>>>
Munich;myhost3,myhost2,myhost1;3;3;180;144
Hamburg;myhost22,myhost33,myhost11;3;2;132;105
check_mk;localhost;1;1;62;45
----

Am Ende jeder Zeile stehen nun, durch Semikolon abgetrennt, die vier neuen Werte.

Mit dieser √Ñnderung liefert das Agentenplugin nun andere Daten als vorher.
An dieser Stelle ist es wichtig, sich zu vergewissern, dass das Check-Plugin auch mit den ge√§nderten Daten immer noch das tut, was es soll.


==== Parse-Funktion erweitern

Im Check-Plugin ist die Parse-Funktion f√ºr die Umwandlung der vom Agentenplugin gelieferten Daten verantwortlich.
Beim xref:parse_function[Schreiben der Parse-Funktion] haben Sie nur zwei Spalten der Host-Gruppentabelle ber√ºcksichtigt.
Nun werden sechs statt zwei Spalten geliefert.
Die Parse-Funktion muss also fit gemacht werden, um auch die zus√§tzlichen vier Spalten zu verarbeiten.

√Ñndern Sie als Instanzbenutzer die Parse-Funktion in der Datei `myhostgroups.py`, die das Check-Plugin enth√§lt:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python},highlight=3-10;11-14]
----
def parse_myhostgroups(string_table):
    parsed = {}
    column_names = [
        "name",
        "members",
        "num_hosts",
        "num_hosts_up",
        "num_services",
        "num_services_ok",
    ]
    for line in string_table:
        parsed[line[0]] = {}
        for n in range(1, len(column_names)):
            parsed[line[0]][column_names[n]] = line[n]
    return parsed
----

Ge√§ndert wurde hier alles zwischen `parsed = {}` und `return parsed`.
Zuerst werden die zu verarbeitenden Spalten unter ihren Namen als Liste `column_names` definiert.
In der `for`-Schleife wird dann ein Dictionary aufgebaut, indem in jeder Zeile aus Spaltenname und ausgelesenem Wert die Schl√ºssel-Wert-Paare erzeugt werden.

F√ºr die existierende xref:check_function[Check-Funktion] ist diese Erweiterung unkritisch, denn die Datenstruktur f√ºr die ersten beiden Spalten bleibt unver√§ndert.
Es werden nur zus√§tzliche Spalten bereitgestellt, die in der Check-Funktion (noch) gar nicht ausgewertet werden.

Nun, da die neuen Daten verarbeitet werden k√∂nnen, werden Sie sie auch nutzen.


[#discovery]
=== Service-Erkennung

Im xref:check_function[vorherigen Kapitel] haben Sie einen sehr einfachen Check gebaut, der auf einem Host einen Service erzeugt.
Ein sehr √ºblicher Fall ist aber auch, dass es von einem Check mehrere Services auf einem Host geben kann.

Das h√§ufigste Beispiel daf√ºr sind die Dateisysteme eines Hosts.
Das Check-Plugin mit dem Namen `df` legt pro Dateisystem auf dem Host einen Service an.
Um diese Services zu unterscheiden, wird der Mount-Punkt des Dateisystems (zum Beispiel `/var`) bzw. der Laufwerksbuchstabe (zum Beispiel `C:`) in den Namen des Services eingebaut.
Das ergibt dann als Service-Name zum Beispiel `Filesystem /var` oder `Filesystem C:`.
Das Wort `/var` bzw. `C:` wird hier als _Item_ bezeichnet.
Wir sprechen also auch von einem _Check mit Items._

Wenn Sie einen Check mit Items bauen m√∂chten, m√ºssen Sie folgende Dinge umsetzen:

* Die Discovery-Funktion muss f√ºr jedes der Items, die auf dem Host sinnvollerweise √ºberwacht werden sollen, einen Service generieren.

* Im Service-Namen m√ºssen Sie das Item mithilfe des Platzhalters `%s` einbauen (also zum Beispiel `"Filesystem %s"`).

* Die Check-Funktion wird pro Item einmal separat aufgerufen und bekommt dieses als Argument.
Sie muss dann aus den Agentendaten die f√ºr dieses Item relevanten Daten herausfischen.

Um dies praktisch auszuprobieren, werden Sie f√ºr jede existierende Host-Gruppe einen eigenen Service erzeugen.

Da das im vorherigen Kapitel erstellte Check-Plugin `myhostgroups` zur √úberpr√ºfung der Standardgruppe `check_mk` weiterhin funktionieren soll, bleibt dieses Check-Plugin so, wie es ist.
F√ºr die Erweiterung erstellen Sie in der bestehenden Datei `myhostgroups.py` das neue Check-Plugin `myhostgroups_advanced`
-- im ersten Schritt so wie xref:check_plug-in[zuvor] durch die Erstellung einer Instanz der Klasse `CheckPlugin`.

Hier finden Sie den alten und markiert den neuen Code:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python},highlight=7-14]
----
check_plugin_myhostgroups = CheckPlugin(
    name = "myhostgroups",
    service_name = "Host group check_mk",
    discovery_function = discover_myhostgroups,
    check_function = check_myhostgroups,
)

check_plugin_myhostgroups_advanced = CheckPlugin(
    name = "myhostgroups_advanced",
    sections = [ "myhostgroups" ],
    service_name = "Host group %s",
    discovery_function = discover_myhostgroups_advanced,
    check_function = check_myhostgroups_advanced,
)
----

Damit man das neue vom alten Check-Plugin unterscheiden kann, erh√§lt es mit `myhostgroups_advanced` einen eindeutigen Namen.
Der Parameter `sections` bestimmt die Sektionen der Agentenausgabe, die das Check-Plugin abonniert.
Mit `myhostgroups` wird hier festgelegt, dass das neue Check-Plugin die gleichen Daten nutzt wie das alte: die durch die Parse-Funktion aufbereitete Sektion des Agentenplugins.
Der Service-Name enth√§lt jetzt den Platzhalter `%s`.
An dieser Stelle wird sp√§ter dann von {CMK} der Name des Items eingesetzt.
In den letzten beiden Zeilen werden schlie√ülich die Namen f√ºr die neue Discovery-Funktion und die neue Check-Funktion festgelegt, die beide noch geschrieben werden wollen.

Zuerst zur Discovery-Funktion, die jetzt die Aufgabe hat, die zu √ºberwachenden Items zu ermitteln ‚Äì auch diese wird _zus√§tzlich_ zur vorhandenen eingetragen:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
def discover_myhostgroups_advanced(section):
    for group in section:
        if group != "check_mk":
            yield Service(item=group)
----

Wie xref:discovery_function[zuvor] bekommt die Discovery-Funktion das Argument `section`.
Mit einer Schleife werden die einzelnen Host-Gruppen durchlaufen.
Hier interessieren alle Host-Gruppen -- mit Ausnahme von `check_mk`, denn um diese spezielle Host-Gruppe k√ºmmert sich bereits das existierende Check-Plugin `myhostgroups`.
Immer, wenn ein Item gefunden wurde, wird es mit `yield` zur√ºck gegeben, wobei ein Objekt vom Typ `Service` erzeugt wird, das den Host-Gruppennamen als Item √ºbergeben bekommt.

Wenn sp√§ter der Host √ºberwacht wird, dann wird die Check-Funktion f√ºr jeden Service -- und damit f√ºr jedes Item -- separat aufgerufen.
Womit Sie bereits bei der Definition der Check-Funktion f√ºr das neue Check-Plugin `myhostgroups_advanced` angekommen sind.
Die Check-Funktion bekommt zus√§tzlich zur Sektion das Argument `item` √ºbergeben.
Die erste Zeile der Funktion sieht dann so aus:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups_advanced(item, section):
----

Der Algorithmus f√ºr die Check-Funktion ist einfach:
Wenn die Host-Gruppe existiert, wird der Service auf {OK} gesetzt und Anzahl und Namen der Hosts in der Gruppe aufgelistet.
Die komplette Funktion dazu:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups_advanced(item, section):
    attr = section.get(item)
    if attr:
        yield Result(state=State.OK, summary=f"{attr['num_hosts']} hosts in this group: {attr['members']}")
----

Das Check-Ergebnis wird geliefert, indem ein Objekt der Klasse `Result` per `yield` zur√ºckgeben wird.
Dieses ben√∂tigt die Parameter `state` und `summary`.
Dabei legt `state` den Zustand des Services fest (im Beispiel `OK`) und `summary` den Text, der in dem [.guihint]#Summary# des Services angezeigt wird.
Er ist rein informativ und wird von {CMK} nicht weiter ausgewertet.
Mehr dazu erfahren Sie im xref:summary_details[n√§chsten Abschnitt.]

So weit, so gut.
Was passiert aber, wenn das gesuchte Item nicht gefunden wird?
Das kann passieren, wenn in der Vergangenheit ein Service f√ºr eine Host-Gruppe bereits erzeugt wurde, diese Host-Gruppe aber nun verschwunden ist
-- entweder weil die Host-Gruppe in {CMK} noch existiert, aber keinen Host mehr enth√§lt, oder weil sie gleich ganz gel√∂scht wurde.
In beiden F√§llen ist diese Host-Gruppe in der Agentenausgabe nicht (mehr) pr√§sent.

Die gute Nachricht:
{CMK} k√ºmmert sich darum!
Wird ein gesuchtes Item nicht gefunden, so erzeugt {CMK} _automatisch_ f√ºr den Service das Resultat `UNKNOWN - Item not found in monitoring data`.
Das ist so gewollt und gut so.
Wenn ein gesuchtes Item nicht gefunden wird, so k√∂nnen Sie Python einfach aus der Funktion herauslaufen und {CMK} seine Arbeit erledigen lassen.

{CMK} wei√ü nur, dass das Item, das vorher da war, nun weg ist.
Den Grund daf√ºr kennt {CMK} nicht -- Sie aber schon.
Darum ist es legitim, Ihr Wissen nicht f√ºr sich zu behalten und diesen Fall in der Check-Funktion abzufangen und dabei eine hilfreiche Meldung ausgeben zu lassen.

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python},highlight=3-5]
----
def check_myhostgroups_advanced(item, section):
    attr = section.get(item)
    if not attr:
        yield Result(state=State.CRIT, summary="Group is empty or has been deleted")
        return

    yield Result(state=State.OK, summary=f"{attr['num_hosts']} hosts in this group: {attr['members']}")
----

Was hat sich ge√§ndert?
Der Fehlerfall wird jetzt zuerst abgehandelt.
Daher √ºberpr√ºfen Sie im `if`-Zweig, ob das Item _nicht_ existiert, setzen den Status auf {CRIT} und verlassen mit `return` die Funktion.
In allen anderen F√§llen geben Sie, wie zuvor, {OK} zur√ºck.

Damit haben Sie in der Check-Funktion den Fall der verschwundenen Host-Gruppen √ºbernommen.
Statt {UNKNOWN} wird der zugeh√∂rige Service nun {CRIT} sein und die Information √ºber die Ursache des kritischen Zustands beinhalten.

Damit ist das neue Check-Plugin als Erweiterung des alten fertiggestellt.
Das erweiterte link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/agent_plugin_advanced_myhostgroups[Agentenplugin^]
und die erweiterte Datei f√ºr die link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/check_plugin_advanced_myhostgroups_step01.py[Check-Plugins^]
finden Sie wieder auf GitHub.
Letztere enth√§lt das einfache Check-Plugin `myhostgroups` aus dem xref:write_check_plugin[vorherigen Kapitel], die erweiterte Parse-Funktion und die Komponenten des neuen Check-Plugins `myhostgroups_advanced` mit der Erstellung des Check-Plugins, der Discovery-Funktion und der Check-Funktion.
Beachten Sie, dass die Funktionen immer vor der Erstellung von Check-Plugins oder Agentensektionen definiert werden m√ºssen, damit es keine Fehler wegen nicht definierter Funktionsnamen gibt.

Da das neue Check-Plugin `myhostgroups_advanced` neue Services zur Verf√ºgung stellt, m√ºssen Sie eine Service-Erkennung f√ºr dieses Check-Plugin durchf√ºhren und die √Ñnderungen aktivieren, um die Services im Monitoring zu sehen:

.Zwei neue Services im Monitoring
image::devel_cpi_service_advanced_01.png[alt="Die vom erweiterten Check-Plugin erzeugten zwei neuen Services im Monitoring."]

Gehen Sie dabei so vor, wie es im Kapitel f√ºr das xref:test[einfache Check-Plugin] beschrieben ist.
F√ºhren Sie dabei die ersten beiden Befehle nicht f√ºr `myhostgroups`, sondern f√ºr das neue Check-Plugin `myhostgroups_advanced` aus.


[#summary_details]
=== Summary und Details

Im Monitoring von {CMK} hat jeder Service neben dem Status -- {OK}, {WARN} usw. -- auch eine Zeile Text.
Diese steht in der Spalte [.guihint]#Summary# -- wie im vorherigen Screenshot zu sehen ist -- und hat also die Aufgabe einer knappen Zusammenfassung des Zustands.
Die Idee ist, dass dieser Text eine L√§nge von 60 Zeichen nicht √ºberschreitet.
Das sorgt dann immer f√ºr eine √ºbersichtliche Tabellendarstellung ohne st√∂rende Zeilenumbr√ºche.

Daneben gibt es noch das Feld [.guihint]#Details#, in dem alle Details zum Zustand des Services angezeigt werden, wobei alle Informationen des Summary auch in den Details enthalten sind.
Nach Anklicken des Services wird die Service-Seite ge√∂ffnet, in der neben vielen anderen auch die beiden Felder [.guihint]#Summary# und [.guihint]#Details# zu sehen sind.

Beim Aufruf von `yield Result(pass:[...])` k√∂nnen Sie bestimmen, welche Informationen so wichtig sind, dass sie im Summary angezeigt werden sollen, und bei welchen es gen√ºgt, dass diese in den Details erscheinen.

In unserem Beispiel haben Sie bisher immer einen Aufruf der folgenden Art verwendet:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
    yield Result(state=State.OK, summary=f"{attr['num_hosts']} hosts in this group: {attr['members']}")
----

Dieser f√ºhrt dazu, dass der als `summary` festgelegte Text immer im [.guihint]#Summary# erscheint -- und zus√§tzlich auch in den [.guihint]#Details#.
Dies sollten Sie also nur f√ºr wichtige Informationen verwenden.
Enth√§lt eine Host-Gruppe viele Hosts, kann die Liste sehr lang werden -- l√§nger als die empfohlenen 60 Zeichen.
Ist eine Information eher untergeordnet, so k√∂nnen Sie mit `details` festlegen, dass der Text _nur_ in den Details erscheint:

[#summary_details_yield]
.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
    yield Result(
        state = State.OK,
        summary = f"{attr['num_hosts']} hosts in this group",
        details = f"{attr['num_hosts']} hosts in this group: {attr['members']}",
    )
----

Im obigen Beispiel wird die Liste der Hosts daher nur noch in den [.guihint]#Details# angezeigt.
Im [.guihint]#Summary# steht dann nur die Anzahl der Hosts in der Gruppe:

.Unterschiedliche Inhalte f√ºr Summary und Details im Monitoring
image::devel_cpi_service_summary_details.png[alt="'Summary' und 'Details' in den Service-Details."]

[#notice]
Es gibt neben `summary` und `details` noch einen dritten Parameter.
Mit `notice` bestimmen Sie, dass ein Text f√ºr einen Service im Zustand {OK} _nur_ in den Details angezeigt wird -- aber zus√§tzlich im Summary f√ºr alle anderen Zust√§nde.
Somit wird dann aus dem Summary sofort klar, warum der Service nicht {OK} ist.
Der Parameter `notice` ist nicht besonders sinnvoll, wenn Texte fest an Zust√§nde gebunden sind, wie bisher in unserem Beispiel.

Zusammengefasst bedeutet das:

* Der Gesamttext f√ºr das Summary sollte bei Services, die {OK} sind, nicht l√§nger als 60 Zeichen sein.
* Verwenden Sie immer entweder `summary` oder `notice` -- nicht beides und nicht keines davon.
* F√ºgen Sie bei Bedarf `details` hinzu, wenn der Text f√ºr die Details ein alternativer sein soll.


[#partial_results]
=== Mehrere Teilresultate pro Service

Um die Anzahl der Services auf einem Host nicht ins Unermessliche steigen zu lassen, sind in einem Service oft mehrere Teilresultate zusammengefasst.
So pr√ºft zum Beispiel der Service [.guihint]#Memory# unter Linux nicht nur RAM- und Swap-Nutzung, sondern auch geteilten Speicher (_shared memory_), Page-Tabellen und alles M√∂gliche andere.

Die Check-API bietet daf√ºr eine sehr komfortable Schnittstelle.
So darf eine Check-Funktion einfach beliebig oft ein Ergebnis mit `yield` erzeugen.
Der Gesamtstatus des Services richtet sich dann nach dem schlechtesten Teilergebnis in der Reihenfolge {OK} ‚Üí {WARN} ‚Üí {UNKNOWN} ‚Üí {CRIT}.

Nutzen Sie diese M√∂glichkeit, um im Beispiel f√ºr jeden Service der Host-Gruppen zu dem bestehenden Resultat zwei weitere zu definieren.
Diese werten den Prozentsatz der Hosts im Zustand {UP} und der Services im Zustand {OK} aus.
Dabei nutzen Sie die xref:prepare[zuvor] in der Agentenausgabe und der Parse-Funktion festgelegten zus√§tzlichen Spalten der Host-Gruppentabelle.

Erweitern Sie die Check-Funktion nun sukzessive von oben nach unten:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups_advanced(item, section):
    attr = section.get(item)
    if not attr:
        yield Result(state=State.CRIT, summary="Group is empty or has been deleted")
        return

    members = attr["members"]
    num_hosts = int(attr["num_hosts"])
    num_hosts_up = int(attr["num_hosts_up"])
    num_services = int(attr["num_services"])
    num_services_ok = int(attr["num_services_ok"])
----

Der `if`-Zweig bleibt unver√§ndert, das hei√üt auch die neuen Teilresultate gelten nur f√ºr Host-Gruppen, die auch existieren.
Anschlie√üend definieren Sie f√ºnf Variablen f√ºr die in der Sektion enthaltenen Spalten der Host-Gruppentabelle.
Dies erh√∂ht zum einen im Folgenden die Lesbarkeit und nebenbei k√∂nnen Sie f√ºr die vier Spalten, mit denen noch gerechnet werden soll, die ausgelesenen Strings mit `int()` in Zahlen umwandeln.

Auch das bisher einzig existierende Resultat bleibt (fast) unver√§ndert:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
    yield Result(
        state = State.OK,
        summary = f"{num_hosts} hosts in this group",
        details = f"{num_hosts} hosts in this group: {members}",
    )
----

Nur der Zugriff im Python-‚ÄûF-String‚Äú auf den Ausdruck, der den Wert liefert, ist nun einfacher als xref:summary_details_yield[zuvor], da das `attr` bereits in den Variablendefinitionen steckt.

Nun zum eigentlichen Kern der Erweiterung, der Definition eines Resultats, das die folgende Aussage umsetzt:
‚ÄûDer Service der Host-Gruppe ist {WARN}, wenn 90{nbsp}% der Hosts {UP} sind, und {CRIT} bei 80{nbsp}% der Hosts.‚Äú
Dabei gilt die Konvention, dass der Check bereits beim _Erreichen_ der Schwelle -- und nicht erst beim √úberschreiten -- auf {WARN} bzw. {CRIT} geht.
F√ºr den Vergleich eines ermittelten Werts mit Schwellwerten stellt die Check-API die Hilfsfunktion `check_levels` bereit.

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
    hosts_up_perc = 100.0 * num_hosts_up / num_hosts
    yield from check_levels(
        hosts_up_perc,
        levels_lower = ("fixed", (90.0, 80.0)),
        label = "UP hosts",
        notice_only = True,
    )
----

In der ersten Zeile wird aus Gesamtzahl und Zahl der Hosts im Zustand {UP} der Prozentsatz berechnet und in der Variablen `hosts_up_perc` gespeichert.
Durch den einfachen Schr√§gstrich (`/`) wird eine Gleitkommadivison ausgef√ºhrt, die sicherstellt, das das Ergebnis ein Float-Wert ist.
Das ist sinnvoll, weil einige im weiteren Verlauf verwendete Funktionen Float als Eingabe erwarten.

In der zweiten Zeile wird dann das Ergebnis der Funktion `check_levels` als Objekt vom Typ `Result` zur√ºckgegeben, was in der API-Dokumentation nachgelesen werden kann.
Die Funktion wird gef√ºttert mit dem gerade berechneten Prozentsatz als Wert (`hosts_up_perc`), den beiden unteren Schwellwerten (`levels_lower`), einer Bezeichnung, die der Ausgabe vorangestellt wird (`label`) und schlie√ülich mit `notice_only=True`.

Der letzte Parameter nutzt den im xref:notice[vorherigen Abschnitt] f√ºr das Objekt `Result()` bereits vorgestellten Parameter `notice`.
Mit `notice_only = True` legen Sie fest, dass der Text f√ºr den Service nur dann im [.guihint]#Summary# angezeigt wird, wenn der Zustand nicht {OK} ist.
Allerdings werden Teilergebnisse, die zu einem {WARN} oder {CRIT} f√ºhren, sowieso _immer_ im Summary sichtbar werden -- unabh√§ngig davon, welchen Wert `notice_only` hat.

Schlie√ülich definieren Sie analog zum zweiten das dritte Resultat, das den Prozentsatz der Services im Zustand {OK} auswertet:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
    services_ok_perc = 100.0 * num_services_ok / num_services
    yield from check_levels(
        services_ok_perc,
        levels_lower = ("fixed", (90.0, 80.0)),
        label = "OK services",
        notice_only = True,
    )
----

Damit ist die Check-Funktion komplett.

Der Service f√ºr eine Host-Gruppe wertet jetzt drei Resultate aus und zeigt aus diesen den schlechtesten Zustand im Monitoring an, wie im folgenden Beispiel:

.Das Summary zeigt den Text zum kritischen Zustand
image::devel_cpi_service_partial_results.png[alt="Das Summary zeigt den Text zum kritischen Zustand."]


[#metrics]
=== Metriken

Nicht immer, aber oft befassen sich Checks mit Zahlen.
Und sehr oft handelt es sich bei diesen Zahlen um gemessene oder berechnete Werte.
In unserem Beispiel sind die Zahl der Hosts in der Host-Gruppe (`num_hosts`) und die Zahl der Hosts im Zustand {UP} (`num_hosts_up`) die Messwerte.
Der Prozentsatz der Hosts im Zustand {UP} (`hosts_up_perc`) ist ein daraus berechneter Wert.
Wenn dann solch ein Wert im zeitlichen Verlauf dargestellt werden kann, wird er auch als xref:glossar#metric[Metrik] bezeichnet.

Mit seinem xref:graphing#[Graphing-System] hat {CMK} eine Komponente, um solche Zahlen zu speichern, auszuwerten und darzustellen.
Das geht dabei v√∂llig unabh√§ngig von der Berechnung der Zust√§nde {OK}, {WARN} und {CRIT}.

Sie werden in diesem Beispiel die beiden berechneten Werte `hosts_up_perc` und `services_ok_perc` als Metriken definieren.
Metriken werden in der grafischen Benutzeroberfl√§che von {CMK} sofort sichtbar, ohne dass Sie etwas daf√ºr tun m√ºssen.
Pro Metrik wird automatisch ein Graph erzeugt.

Metriken werden von der Check-Funktion ermittelt und als zus√§tzliches Ergebnis zur√ºckgegeben.
Am einfachsten ist es, der Funktion `check_levels()` im Aufruf die Metrikinformationen mitzugeben.

Zur Erinnerung folgen die Zeilen mit dem Funktionsaufruf von `check_levels()` aus dem xref:partial_results[vorherigen Abschnitt:]

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
    yield from check_levels(
        hosts_up_perc,
        levels_lower = ("fixed", (90.0, 80.0)),
        label = "UP hosts",
        notice_only = True,
    )
----

Die beiden neuen Argumente f√ºr die Metrik sind `metric_name` und `boundaries`:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python},highlight=4;6]
----
    yield from check_levels(
        hosts_up_perc,
        levels_lower = ("fixed", (90.0, 80.0)),
        metric_name = "hosts_up_perc",
        label = "UP hosts",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
----

Um es sch√∂n einfach und aussagekr√§ftig zu halten, nehmen Sie als Namen der Metrik den Namen der Variablen, in der der Prozentsatz als Wert gespeichert ist.

Mit `boundaries` k√∂nnen Sie dem Graphing-System die Information √ºber den m√∂glichen Wertebereich mitgeben.
Damit ist der kleinste und gr√∂√üte m√∂gliche Wert gemeint.
Bei einem Prozentsatz sind die Grenzen mit `0.0` und `100.0` nicht allzu schwer zu bestimmen.
Es sind sowohl Gleitkommazahlen (_Float_) als auch Ganzzahlen (_Integer_, die intern wiederum in Gleitkommazahlen umgewandelt werden) erlaubt, aber keine Strings.
Falls nur eine Grenze des Wertebereichs definiert ist, tragen Sie f√ºr die andere einfach `None` ein, also zum Beispiel `boundaries = (0.0, None)`.

Durch diese Erweiterung gibt die Funktion `check_levels` nun per `yield` zus√§tzlich zum `Result` auch noch ein Objekt vom Typ `Metric` zur√ºck.

Analog k√∂nnen Sie jetzt auch die Metrik `services_ok_perc` definieren.
Die letzten Zeilen der Check-Funktion sehen dann so aus:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
    hosts_up_perc = 100.0 * num_hosts_up / num_hosts
    yield from check_levels(
        hosts_up_perc,
        levels_lower = ("fixed", (90.0, 80.0)),
        metric_name = "hosts_up_perc",
        label = "UP hosts",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
    services_ok_perc = 100.0 * num_services_ok / num_services
    yield from check_levels(
        services_ok_perc,
        levels_lower = ("fixed", (90.0, 80.0)),
        metric_name = "services_ok_perc",
        label = "OK services",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
----

Mit der so erweiterten Check-Funktion sind die beiden Graphen im Monitoring sichtbar.
In der Service-Liste zeigt nun das Symbol icon:icon_service_graph[alt="Symbol zur Anzeige der Graphen eines Services."], dass es Graphen zum Service gibt.
Wenn Sie mit der Maus auf das Symbol zeigen, werden die Graphen als Vorschau eingeblendet.
// Die beiden Graphen werden (anders als im folgenden, alten Screenshot) ohne die gelben und roten Linien f√ºr die levels_lower angezeigt. Beim n√§chsten Test erneut checken.

.Die Namen der Metriken werden als Titel der Graphen verwendet
image::devel_cpi_service_graphs.png[alt="Die Service-Liste mit 2 Graphen als Vorschau."]

Eine √úbersicht aller Graphen inklusive Legende und mehr finden Sie in den Service-Details.

Was macht man aber, wenn der Wert f√ºr die gew√ºnschte Metrik gar nicht mit der Funktion `check_levels()` definiert wurde?
Sie k√∂nnen selbstverst√§ndlich eine Metrik auch unabh√§ngig von einem Funktionsaufruf festlegen.
Dazu dient das Objekt `Metric()`, welches Sie auch direkt √ºber seinen Konstruktor erzeugen k√∂nnen.
Die alternative Definition einer Metrik f√ºr den Wert `hosts_up_perc` sieht so aus:

[{python}]
----
    yield Metric(
        name = "hosts_up_perc",
        value = hosts_up_perc,
        levels = (80.0, 90.0),
        boundaries = (0.0, 100.0),
    )
----

Die Argumente von `Metric()` sind sehr √§hnlich zu denen im oben gezeigten Funktionsaufruf:
Verpflichtend sind die ersten beiden Argumente f√ºr den Metriknamen und den Wert.
Zus√§tzlich gibt es noch zwei optionale Argumente: `levels` f√ºr die Schwellwerte {WARN} und {CRIT} und `boundaries` f√ºr den Wertebereich.

[TIP]
====
Die Angabe von `levels` dient hier lediglich als Information f√ºr die Darstellung des Graphen.
Im Graphen werden die Schwellwerte √ºblicherweise als gelbe und rote Linien eingezeichnet.
F√ºr die _√úberpr√ºfung_ ist die Funktion `check_levels` mit den dort festgelegten Schwellwerten verantwortlich.
====

Nutzen Sie nun die M√∂glichkeit, nicht nur die beiden berechneten Werte, sondern mit `Metric()` _alle_ Messwerte als Metriken zu definieren
-- in unserem Beispiel also die vier Messwerte aus der Host-Gruppentabelle.
Beschr√§nken Sie sich dabei auf die beiden obligatorischen Angaben von Metrikname und Wert.
Die vier neuen Zeilen komplettieren die Erweiterung der Check-Funktion f√ºr Metriken:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
    hosts_up_perc = 100.0 * num_hosts_up / num_hosts
    yield from check_levels(
        hosts_up_perc,
        levels_lower = (90.0, 80.0),
        metric_name = "hosts_up_perc",
        label = "UP hosts",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
    services_ok_perc = 100.0 * num_services_ok / num_services
    yield from check_levels(
        services_ok_perc,
        levels_lower = (90.0, 80.0),
        metric_name = "services_ok_perc",
        label = "OK services",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
    
    yield Metric(name="num_hosts", value=num_hosts)
    yield Metric(name="num_hosts_up", value=num_hosts_up)
    yield Metric(name="num_services", value=num_services)
    yield Metric(name="num_services_ok", value=num_services_ok)
----

Das erh√∂ht schon einmal die Zahl der Graphen pro Service, bietet Ihnen aber zum Beispiel auch die M√∂glichkeit, mehrere Metriken in einem Graphen zu kombinieren.
Wir zeigen diese und andere M√∂glichkeiten im Abschnitt xref:metrics_advanced[Darstellung von Metriken anpassen] weiter unten.

In der Beispieldatei auf
link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/check_plugin_advanced_myhostgroups_step02.py[GitHub^]
finden Sie wieder die gesamte Check-Funktion.


[#rule_set]
== Regels√§tze f√ºr Check-Parameter

Im erweiterten Check-Plugin `myhostgroups_advanced` haben Sie den Zustand {WARN} erzeugt, wenn nur 90{nbsp}% der Hosts {UP} sind, und {CRIT} bei 80{nbsp}%.
Dabei sind die Zahlen `90` und `80` in der Check-Funktion fest einprogrammiert oder, wie Programmierer sagen w√ºrden, _hart codiert._
In {CMK} ist man allerdings als Benutzer gewohnt, dass man solche Schwellwerte und andere Check-Parameter per xref:glossar#rule[Regel] konfigurieren kann.
Denn hat zum Beispiel eine Host-Gruppe nur vier Mitglieder, dann passen die beiden Schwellwerte von 90 und 80{nbsp}% nicht wirklich gut,
da bereits beim Ausfall des ersten Hosts der Prozentsatz auf 75{nbsp}% sinkt und der Zustand -- ohne Umweg √ºber {WARN} -- direkt auf {CRIT} geht.

Daher soll das Check-Plugin nun so verbessert werden, dass es √ºber die [.guihint]#Setup#-Oberfl√§che konfigurierbar ist.
Dazu ben√∂tigen Sie einen xref:glossar#rule_set[Regelsatz.]

Mit der Erstellung eines Regelsatzes _f√ºr_ ein Check-Plugin verlassen Sie die Check-Plugin-Entwicklung und wechseln Dateiverzeichnis, Datei und API.
Seit {CMK} {v23} unterst√ºtzt Sie die *Rulesets-API* bei der Erstellung solcher Regels√§tze f√ºr Check-Plugins.
Die API-Dokumentation f√ºr Regels√§tze finden Sie in Ihrer {CMK}-Instanz auf der gleichen Seite wie die der xref:check_api_doc[Check-API] unter [.guihint]#Rulesets > Version 1#.


[#new_ruleset]
=== Neuen Regelsatz definieren

Um einen neuen Regelsatz zu erstellen, legen Sie im Verzeichnis Ihrer Plugin-Familie `~/local/lib/python3/cmk_addons/plugins/myhostgroups/` zuerst ein neues Unterverzeichnis an.
Der Name `rulesets` dieses Unterverzeichnisses ist dabei vorgegeben:

[{shell}]
----
{c-omd} mkdir -p local/lib/python3/cmk_addons/plugins/myhostgroups/rulesets
{c-omd} cd local/lib/python3/cmk_addons/plugins/myhostgroups/rulesets
----

In diesem Verzeichnis erstellen Sie dann eine Datei f√ºr die Definition des Regelsatzes.
Der Name der Datei sollte sich an dem des Check-Plugins orientieren und muss wie alle Plugin-Dateien die Endung `.py` haben.
F√ºr unser Beispiel passt der Dateiname `ruleset_myhostgroups.py`.

Sehen Sie sich den Aufbau dieser Datei Schritt f√ºr Schritt an.
Zun√§chst kommen einige Importbefehle:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/rulesets/ruleset_myhostgroups.py
[{python}]
----
#!/usr/bin/env python3

from cmk.rulesets.v1 import Label, Title
from cmk.rulesets.v1.form_specs import BooleanChoice, DefaultValue, DictElement, Dictionary, Float, LevelDirection, SimpleLevels
from cmk.rulesets.v1.rule_specs import CheckParameters, HostAndItemCondition, Topic
----
// Label und BooleanChoice werden bei uns aber nicht verwendet.

Zuerst werden die Klassen f√ºr die Texte importiert.

Die zweite Zeile trifft eine Auswahl aus den _Form Specs,_ das hei√üt, den Basiselementen f√ºr die GUI, die im Regelsatz genutzt werden, 
z. B. f√ºr die bin√§re Auswahl (`BooleanChoice`), die Mehrfachauswahl (`Dictionary`, `DictElement`), die Festlegung von Schwellwerten (`SimpleLevel`, `LevelDirection`, `DefaultValue`) und die Eingabe von Gleitkommazahlen (`Float`).
Dabei fordern Sie hier lediglich die logischen Formularelemente an und √ºberlassen {CMK} die Gestaltung der GUI.

Die letzte Zeile importiert die _Rule Specs,_ die das Anwendungsgebiet der Regel in {CMK} bestimmen, also hier die Festlegung von Check-Parametern, die Zuordnung zu Hosts und Items und die Ablage unter einem Thema (_topic_).
Da Ihr Check-Plugin `myhostgroups_advanced` mehrere Services erzeugt, importieren Sie hier `HostAndItemCondition`.
Falls Ihr Check keinen Service erzeugt, mit anderen Worten kein Item hat, importieren Sie stattdessen `HostCondition`.

Nun kommen die eigentlichen Definitionen des Formulars f√ºr die Eingabe der Check-Parameter.
Der Benutzer soll die beiden Schwellwerte f√ºr {WARN} und {CRIT} festlegen k√∂nnen und zwar getrennt f√ºr die Anzahl der Hosts im Zustand {UP} und der Services im Zustand {OK}:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/rulesets/ruleset_myhostgroups.py
[{python}]
----
def _parameter_form():
    return Dictionary(
        elements = {
            "hosts_up_lower": DictElement(
                parameter_form = SimpleLevels(
                    title = Title("Lower percentage threshold for host in UP status"),
                    form_spec_template = Float(),
                    level_direction = LevelDirection.LOWER,
                    prefill_fixed_levels = DefaultValue(value=(90.0, 80.0)),
                ),
                required = True,
            ),
            "services_ok_lower": DictElement(
                parameter_form = SimpleLevels(
                    title = Title("Lower percentage threshold for services in OK status"),
                    form_spec_template = Float(),
                    level_direction = LevelDirection.LOWER,
                    prefill_fixed_levels = DefaultValue(value=(90.0, 80.0)),
                ),
                required = True,
            ),
        }
    )
----

Hierf√ºr legen Sie eine Funktion an, welche das Dictionary erzeugt.
Den Namen der Funktion k√∂nnen Sie frei w√§hlen, er wird nur bei der Erstellung der Regel weiter unten ben√∂tigt.
Damit die Funktion nicht √ºber die Modulgrenze hinaus sichtbar wird, sollte der Name mit einem Unterstrich beginnen.

Das `return Dictionary()` ist vorgeschrieben.
Innerhalb dessen erstellen Sie mit `elements={}` die Elemente des Dictionaries, im Beispiel `hosts_up_lower` und `services_ok_lower`.
Das Parameterformular `SimpleLevels` dient der Eingabe von festen Schwellwerten.
Im Formular bestimmen Sie zuerst den Titel (`title`) und Gleitkommazahlen f√ºr die einzugebenden Werte (`form_spec_template`).
Dass sich der Zustand bei _Unterschreitung_ der Werte √§ndert, legen Sie mit `LevelDirection.LOWER` fest.

Schlie√ülich k√∂nnen Sie mit `prefill_fixed_levels` den Benutzern des Regelsatzes statt leerer Eingabefelder bereits Werte vorgeben.
Beachten Sie, dass diese in der GUI angezeigten Werte _nicht_ die Standardwerte sind, die weiter unten bei der xref:ruleset_defaults[Erstellung des Check-Plugins] per `check_default_parameters` gesetzt werden.
Wollen Sie die gleichen Standardwerte in der GUI anzeigen lassen, die auch f√ºr die Check-Funktion gelten, dann m√ºssen Sie die Werte an beiden Stellen selbst konsistent halten.

Zu guter Letzt erstellen Sie jetzt mithilfe der importierten und selbst definierten Dinge den neuen Regelsatz.
Dies geschieht durch die Erstellung einer Instanz der Klasse `CheckParameters`.
Der Name dieser Instanz muss dabei mit `rule_spec_` beginnen:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/rulesets/ruleset_myhostgroups.py
[{python}]
----
rule_spec_myhostgroups = CheckParameters(
    name = "myhostgroups_advanced",
    title = Title("Host group status"),
    topic = Topic.GENERAL,
    parameter_form = _parameter_form,
    condition = HostAndItemCondition(item_title=Title("Host group name")),
)
----

Dazu die folgenden Erkl√§rungen:

* Der Name des Regelsatzes `name` stellt die Verbindung zu den Check-Plugins her.
Ein Check-Plugin, das diesen Regelsatz verwenden will, muss beim Erstellen diesen Namen als `check_ruleset_name` verwenden.
Um bei mehreren neuen Regels√§tzen den √úberblick zu behalten, empfiehlt es sich im Namen einen Pr√§fix zu verwenden.

* `title` legt den Titel des Regelsatzes fest, so wie er auch in der {CMK}-GUI erscheint.

* Das `topic` legt fest, wo im [.guihint]#Setup# der Regelsatz auftauchen soll.
Mit dem im Beispiel gew√§hlten Wert finden Sie den Regelsatz unter [.guihint]#Setup > Services > Service monitoring rules# im Kasten [.guihint]#Various#, wo er in aller Regel gut aufgehoben ist.

* Als `parameter_form` geben Sie den Namen der zuvor erstellten Funktion ein.

* Falls Ihr Check kein Item verwendet, lautet die Bedingung `HostCondition` und nicht `HostAndItemCondition`, wie im obigen Beispiel.
Mit dem Titel `"Host group name"` des Items legen Sie das Label in der GUI fest, mit dem Sie die Regel auf bestimmte Host-Gruppen einschr√§nken k√∂nnen.


[#test_ruleset]
=== Regelsatz testen

Wenn Sie die Datei f√ºr den Regelsatz angelegt haben, sollten Sie ausprobieren, ob alles soweit funktioniert -- noch ohne Verbindung zum Check-Plugin.
Dazu m√ºssen Sie zuerst den Apache der Instanz neu starten, damit die neue Datei gelesen wird.
Das macht der Befehl:   

[{shell}]
----
{c-omd} omd restart apache
----

Danach sollte der Regelsatz im [.guihint]#Setup# auf der oben genannten Seite zu finden sein.
Mit der Suchfunktion im Setup-Men√º finden Sie den Regelsatz auch -- aber erst nach einem Neustart von Redis:

[{shell}]
----
{c-omd} omd restart redis
----

Der soeben definierte Regelsatz sieht in der GUI so aus:

image::devel_cpi_ruleset.png[alt="Der neu erstellte Regelsatz im Setup."]

In Kasten [.guihint]#Conditions# finden Sie das per `HostAndItemCondition` definierte Eingabefeld [.guihint]#Host group name# wieder zur Einschr√§nkung der Regel f√ºr Host-Gruppen.

Legen Sie eine Regel an und probieren Sie verschiedene Werte aus, wie im obigen Screenshot gezeigt.
Wenn das ohne Fehler geht, k√∂nnen Sie die Check-Parameter jetzt in der Check-Funktion verwenden.


[#use_ruleset]
=== Regelsatz mit Check-Plugin verbinden

Der frisch erstellte Regelsatz wird nun mit dem im xref:extend[vorherigen Kapitel] vorl√§ufig fertiggestellten Check-Plugin verbunden.
Damit die Regel zum Greifen kommt, m√ºssen Sie dem Check-Plugin erlauben, Check-Parameter entgegenzunehmen und ihm sagen, welche Regel benutzt werden soll.
Dazu f√ºgen Sie in der Datei des Check-Plugins zwei neue Zeilen bei der Erstellung des Check-Plugins `myhostgroups_advanced` ein:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python},highlight=7-8]
----
check_plugin_myhostgroups_advanced = CheckPlugin(
    name = "myhostgroups_advanced",
    sections = [ "myhostgroups" ],
    service_name = "Host group %s",
    discovery_function = discover_myhostgroups_advanced,
    check_function = check_myhostgroups_advanced,
    check_default_parameters = {},
    check_ruleset_name = "myhostgroups_advanced",
)
----

Mit dem Eintrag `check_default_parameters` k√∂nnen Sie die Standardwerte setzen, die gelten, solange noch keine Regel angelegt ist.
Bei der Umstellung des Check-Plugins f√ºr Check-Parameter muss diese Zeile unbedingt vorhanden sein.
Im einfachsten Fall √ºbergeben Sie ein leeres Dictionary `{}`.

Als zweites tragen Sie noch `check_ruleset_name` ein, also den Namen des Regelsatzes.
So wei√ü {CMK} aus welchem Regelsatz die Parameter bestimmt werden sollen.

Nun wird {CMK} versuchen, der Check-Funktion Parameter zu √ºbergeben.
Damit das klappen kann, m√ºssen Sie die Check-Funktion so erweitern, dass sie das Argument `params` erwartet, welches sich zwischen `item` und `section` schiebt:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups_advanced(item, params, section):
----

Falls Sie einen Check ohne Item bauen, entf√§llt das `item` und `params` steht am Anfang.

Es ist sehr empfehlenswert, sich jetzt als ersten Test den Inhalt der Variable `params` mit einem `print` ausgeben zu lassen:

[{python}]
----
def check_myhostgroups_advanced(item, params, section):
    print(params)
----

Bei der Ausf√ºhrung des Check-Plugins sehen die ausgedruckten Zeilen (f√ºr jeden Service eine) mit den per Regel festgelegten Werten dann etwa so aus:

[{shell}]
----
{c-omd} cmk --detect-plugins=myhostgroups_advanced -v localhost
Parameters({'hosts_up_lower': ('fixed', (75.0, 60.0)), 'services_ok_lower': ('fixed', (75.0, 60.0))})
Parameters({'hosts_up_lower': ('fixed', (75.0, 60.0)), 'services_ok_lower': ('fixed', (75.0, 60.0))})
Parameters({'hosts_up_lower': ('fixed', (75.0, 60.0)), 'services_ok_lower': ('fixed', (75.0, 60.0))})
----

[IMPORTANT]
====
Wenn alles fertig ist und funktioniert, entfernen Sie die `print`-Aufrufe wieder.
Diese k√∂nnen die interne Kommunikation von {CMK} durcheinanderbringen.
Alternativ k√∂nnen Sie die Ausgabe von Debug-Informationen auf deren xref:custom_debug[explizite Anforderung] beschr√§nken.
====

Nun passen Sie Ihre Check-Funktion weiter an, so dass die √ºbergebenen Parameter ihre Wirkung entfalten k√∂nnen.
Holen Sie sich die beiden in der Regel festgelegten Dictionary-Elemente mit dem dort gew√§hlten Namen aus den Parametern:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups_advanced(item, params, section):
    hosts_up_lower = params["hosts_up_lower"]
    services_ok_lower = params["services_ok_lower"]
----

Weiter unten in der Check-Funktion werden dann die bisher hart kodierten Schwellwerte `"fixed", (90.0, 80.0)` durch die Variablen `hosts_up_lower` und `services_ok_lower` ersetzt:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python},highlight=4;13]
----
    hosts_up_perc = 100.0 * num_hosts_up / num_hosts
    yield from check_levels(
        hosts_up_perc,
        levels_lower = (hosts_up_lower),
        metric_name = "hosts_up_perc",
        label = "UP hosts",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
    services_ok_perc = 100.0 * num_services_ok / num_services
    yield from check_levels(
        services_ok_perc,
        levels_lower = (services_ok_lower),
        metric_name = "services_ok_perc",
        label = "OK services",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
----

Falls eine Regel konfiguriert ist, k√∂nnen Sie nun die Host-Gruppen des Beispiels mit den √ºber die GUI gesetzten Schwellwerten √ºberwachen.
Wenn allerdings keine Regel definiert ist, wird diese Check-Funktion abst√ºrzen:
Da die Default-Parameter des Check-Plugins nicht bef√ºllt sind, wird das Plugin bei Abwesenheit einer Regel einen `KeyError` erzeugen.
// Bei cmk --detect-plugins=myhostgroups_advanced -v localhost gibt es ohne Regel f√ºr jeden Host-Gruppen-Service: check failed - please submit a crash report!

[#ruleset_defaults]
Dieses Problem kann aber behoben werden, wenn bei der Erstellung des Check-Plugins die Standardwerte gesetzt sind:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python},highlight=7]
----
check_plugin_myhostgroups_advanced = CheckPlugin(
    name = "myhostgroups_advanced",
    sections = [ "myhostgroups" ],
    service_name = "Host group %s",
    discovery_function = discover_myhostgroups_advanced,
    check_function = check_myhostgroups_advanced,
    check_default_parameters = {"hosts_up_lower": ("fixed", (90, 80)), "services_ok_lower": ("fixed", (90, 80))},
    check_ruleset_name = "myhostgroups_advanced",
)
----

Sie sollten Standardwerte immer auf diese Weise √ºbergeben (und den Fall fehlender Parameter nicht im Check-Plugin abfangen), da diese Standardwerte auch in der [.guihint]#Setup#-Oberfl√§che angezeigt werden k√∂nnen.
Dazu gibt es zum Beispiel bei der Service-Erkennung eines Hosts, auf der Seite [.guihint]#Services of host#, im Men√º [.guihint]#Display# den Schalter [.guihint]#Show check parameters#.

[TIP]
====
Auf GitHub finden Sie sowohl die Datei mit dem
link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/ruleset_myhostgroups.py[Regelsatz^]
als auch das um den Regelsatz erweiterte
link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/check_plugin_advanced_myhostgroups.py[Check-Plugin^].
====


[#metrics_advanced]
== Darstellung von Metriken anpassen

Im xref:metrics[obigen Beispiel] haben Sie das Check-Plugin `myhostgroups_advanced` xref:glossar#metric[Metriken] f√ºr alle gemessenen und berechneten Werte erzeugen lassen.
Dazu haben wir zwei Wege vorgestellt.
Zuerst wurden die Metriken der berechneten Werte als Bestandteil der Funktion `check_levels()` mit dem Argument `metric_name` erstellt, zum Beispiel so:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
    yield from check_levels(
        services_ok_perc,
        levels_lower = ("fixed", (90.0, 80.0)),
        metric_name = "services_ok_perc",
        label = "OK services",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
----

Dann haben Sie die gemessenen Metriken direkt mit dem Objekt `Metric()` erzeugt -- f√ºr die Anzahl der Services im Zustand {OK} zum Beispiel so:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py
[{python}]
----
    yield Metric(name="num_services_ok", value=num_services_ok)
----

Metriken werden in der grafischen Benutzeroberfl√§che von {CMK} zwar sofort sichtbar, ohne dass Sie etwas daf√ºr tun m√ºssen.
Allerdings gibt es dabei ein paar Einschr√§nkungen:

* Es werden nicht automatisch passende Metriken in einem Graphen kombiniert, sondern jede erscheint einzeln.

* Die Metrik hat keinen richtigen Titel, sondern es wird der interne Variablenname der Metrik gezeigt.

* Es wird keine Einheit verwendet, die eine sinnvolle Darstellung erlaubt (zum Beispiel GB anstelle von einzelnen Bytes).

* Es wird zuf√§llig eine Farbe ausgew√§hlt.

* Es erscheint nicht automatisch ein ‚ÄûPerf-O-Meter‚Äú, also die grafische Vorschau der Metrik als Balken in der Service-Liste (zum Beispiel in der Ansicht, die alle Services eines Hosts darstellt).

Um die Darstellung Ihrer Metriken in diesen Belangen zu vervollst√§ndigen, ben√∂tigen Sie _Metrikdefinitionen._

So wie f√ºr xref:rule_set[Regels√§tze] gibt es seit {CMK} {v23} mit der *Graphing-API* auch eine eigene API f√ºr Metriken, Graphen und Perf-O-Meter.
Die Dokumentation der Graphing-API finden Sie in Ihrer {CMK}-Instanz auf der gleichen Seite wie die der xref:check_api_doc[Check-API] unter [.guihint]#Graphing > Version 1#.


[#new_metricdefinition]
=== Neue Metrikdefinition erstellen

Das Vorgehen bei der Erstellung von xref:new_ruleset[Regels√§tzen] und Metrikdefinitionen ist sehr √§hnlich.
Legen Sie im Verzeichnis Ihrer Plugin-Familie `~/local/lib/python3/cmk_addons/plugins/myhostgroups/` zuerst ein neues Unterverzeichnis mit dem vorgegeben Namen `graphing` an.

[{shell}]
----
{c-omd} mkdir -p local/lib/python3/cmk_addons/plugins/myhostgroups/graphing
{c-omd} cd local/lib/python3/cmk_addons/plugins/myhostgroups/graphing
----

In diesem Verzeichnis erstellen Sie dann eine Graphing-Datei, z. B. `graphing_myhostgroups.py`.

Zun√§chst kommen wieder einige Importbefehle:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/graphing/graphing_myhostgroups.py
[{python}]
----
#!/usr/bin/env python3

from cmk.graphing.v1 import Title
from cmk.graphing.v1.graphs import Graph, MinimalRange
from cmk.graphing.v1.metrics import Color, DecimalNotation, Metric, Unit
from cmk.graphing.v1.perfometers import Closed, FocusRange, Open, Perfometer
----

F√ºr unser Beispiel definieren Sie nun eine eigene Metrik f√ºr den Prozentsatz der Services im Zustand {OK}.
Dies geschieht durch die Erstellung einer Instanz der Klasse `Metric`.
Der Name dieser Instanz muss dabei mit `metric_` beginnen

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/graphing/graphing_myhostgroups.py
[{python}]
----
metric_myhostgroups_services_ok_perc = Metric(
    name = "services_ok_perc",
    title = Title("Percentage of services in OK state"),
    unit = Unit(DecimalNotation("%")),
    color = Color.ORANGE,
)
----

Hier die Erkl√§rung dazu:

* Der Metrikname (hier `services_ok_perc`) muss dem entsprechen, was die Check-Funktion ausgibt.

* Der `title` ist die √úberschrift im Metrikgraphen und ersetzt den bisher verwendeten internen Variablennamen.

* Die verf√ºgbaren Einheiten (`unit`) k√∂nnen Sie in der API-Dokumentation nachlesen, sie enden alle auf `Notation`, z. B. `DecimalNotation`, `EngineeringScientificNotation` oder `TimeNotation`.

* Die in {CMK} verwendeten Farbnamen f√ºr die Farbdefinition `color` finden Sie auf link:https://github.com/Checkmk/checkmk/blob/master/packages/cmk-plugin-apis/cmk/graphing/v1/metrics.py[GitHub^].

Diese Definition in der Graphing-Datei sorgt jetzt daf√ºr, dass Titel, Einheit und Farbe der Metrik angepasst dargestellt werden.

Analog zur Erstellung einer xref:test_ruleset[Regelsatzdatei] muss die Graphing-Datei erst gelesen werden, bevor die √Ñnderung in der GUI sichtbar ist.
Das macht der Neustart des Apache der Instanz:

[{shell}]
----
{c-omd} omd restart apache
----

Der Metrikgraph sieht dann in der {CMK}-GUI ungef√§hr so aus:

image::devel_cpi_new_metric.png[alt="Die neue Metrikdefinition in den Service-Details."]


[#graph_multiple_metrics]
=== Graph mit mehreren Metriken

M√∂chten Sie mehrere Metriken in einem Graphen kombinieren (was oft sehr sinnvoll ist), ben√∂tigen Sie eine Graphdefinition, die Sie der im vorherigen Abschnitt erstellten Graphing-Datei hinzuf√ºgen k√∂nnen.

F√ºr unser Beispiel sollen die beiden Metriken `num_services` und `num_services_ok` in einem Graphen dargestellt werden.
Die Metrikdefinitionen dazu werden analog wie im vorherigen Abschnitt f√ºr `services_ok_perc` erstellt und sehen wie folgt aus:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/graphing/graphing_myhostgroups.py
[{python}]
----
metric_myhostgroups_services = Metric(
    name = "num_services",
    title = Title("Number of services in group"),
    unit = Unit(DecimalNotation("")),
    color = Color.PINK,
)

metric_myhostgroups_services_ok = Metric(
    name = "num_services_ok",
    title = Title("Number of services in OK state"),
    unit = Unit(DecimalNotation("")),
    color = Color.BLUE,
)
----

F√ºgen Sie nun einen Graphen an, der diese beiden Metriken als Linien einzeichnet.
Dies geschieht √ºber eine Instanz der Klasse `Graph`, wobei der Instanzname auch hier wieder mit einem vorgegebenen Pr√§fix (`graph_`) beginnen muss:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/graphing/graphing_myhostgroups.py
[{python}]
----
graph_myhostgroups_combined = Graph(
    name = "services_ok_comparison",
    title = Title("Services in OK state out of total"),
    simple_lines=[ "num_services", "num_services_ok" ],
    minimal_range=MinimalRange(0, 50),
)
----

Der Parameter `minimal_range` beschreibt, was die vertikale Achse des Graphen mindestens abdeckt, unabh√§ngig von den Werten der Metrik.
Die vertikale Achse wird erweitert, wenn die Werte den minimalen Bereich √ºberschreiten, aber sie wird nie kleiner sein.

Das Resultat ist der kombinierte Graph in der {CMK}-GUI:

image::devel_cpi_graph_two_metrics.png[alt="Der Graph zeigt beide Metriken in den Service-Details."]


[#perfometer]
=== Metriken im Perf-O-Meter

M√∂chten Sie zu einer Metrik noch ein Perf-O-Meter in der Zeile der Service-Liste anzeigen?
Das k√∂nnte zum Beispiel so aussehen:

.Das Perf-O-Meter zeigt den Prozentsatz der Services im Status {OK}
image::devel_cpi_perfometer_percentage.png[alt="Das Perf-O-Meter zeigt den Prozentsatz der Services im Status 'OK'."]

Um so ein Perf-O-Meter zu erstellen, ben√∂tigen Sie eine weitere Instanz, diesmal der Klasse `Perfometer`, deren Name mit dem Pr√§fix `perfometer_` beginnt:

.~/local/lib/python3/cmk_addons/plugins/myhostgroups/graphing/graphing_myhostgroups.py
[{python}]
----
perfometer_myhostgroups_advanced = Perfometer(
    name = "myhostgroups_advanced",
    focus_range = FocusRange(Closed(0), Closed(100)),
    segments = [ "services_ok_perc" ],
)
----

Perf-O-Meter sind etwas trickreicher als Graphen, da es keine Legende gibt.
Daher ist die Darstellung des Wertebereichs schwierig, insbesondere, wenn es um die Darstellung absoluter Werte geht.
Einfacher ist es, einen Prozentsatz darzustellen.
Dies ist auch im obigen Beispiel der Fall:

* In `segments` werden die Metriknamen eingetragen, hier der Prozentsatz der Services im Zustand {OK}.

* In `focus_range` wird die untere und obere Grenze eingetragen.
Geschlossene (`Closed`) Grenzen sind vorgesehen f√ºr Metriken, die nur Werte zwischen den angegebenen Grenzen annehmen k√∂nnen (hier also `0` und `100`).

Weitere, noch ausgefeiltere M√∂glichkeiten zur Umsetzung von Metriken in Perf-O-Metern finden Sie in der Dokumentation der Graphing-API,
z. B. mit den Klassen `Bidirectional` und `Stacked`, die es erlauben mehrere Perf-O-Meter in einem darzustellen.

Die Graphing-Datei dieses Kapitels finden Sie wieder auf link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/graphing_myhostgroups.py[GitHub^].
Sie enth√§lt unter anderem die Metrikdefinitionen der vier gemessenen und der zwei berechneten Werte.


[#format_numbers]
== Zahlen formatieren

Im [.guihint]#Summary# und den [.guihint]#Details# eines Services werden oft Zahlen ausgegeben.
Um Ihnen eine sch√∂ne und korrekte Formatierung m√∂glichst einfach zu machen,
und auch um die Ausgaben von allen Check-Plugins zu vereinheitlichen, gibt es Hilfsfunktionen f√ºr die Darstellung von verschiedenen Arten von Gr√∂√üen.
All diese sind Unterfunktionen vom Modul `render` und werden folglich mit `render.` aufgerufen.
Zum Beispiel ergibt `render.bytes(2000)` den Text `1.95 KiB`.

All diesen Funktionen ist gemein, dass sie ihren Wert in einer sogenannten _kanonischen_ oder nat√ºrlichen Einheit bekommen.
So muss man nie nachdenken und es gibt keine Schwierigkeiten oder Fehler bei der Umrechnung.
Beispielsweise werden Zeiten immer in Sekunden angegeben und Gr√∂√üen von Festplatten, Dateien etc. immer in Bytes und nicht in Kilobytes, Kibibytes, Bl√∂cken oder sonstigem Durcheinander.

Verwenden Sie diese Funktionen auch dann, wenn Ihnen die Darstellung nicht so gut gef√§llt.
Immerhin ist diese dann f√ºr den Benutzer einheitlich.
Und zuk√ºnftige Versionen von {CMK} k√∂nnen die Darstellung m√∂glicherweise √§ndern oder sogar konfigurierbar f√ºr den Benutzer machen, wie es zum Beispiel bereits bei der Anzeige der Temperatur der Fall ist.
Davon wird dann Ihr Check-Plugin auch profitieren.

Bevor Sie die `render`-Funktion in Ihrem Check-Plugin nutzen k√∂nnen, m√ºssen Sie sie zus√§tzlich importieren:

[{python}]
----
from cmk.agent_based.v2 import render
----

Nach der ausf√ºhrlichen Beschreibung aller Darstellungsfunktionen (Render-Funktionen) finden Sie eine xref:numbers_summary[Zusammenfassung] in Form einer √ºbersichtlichen Tabelle.


[#time]
=== Zeiten, Zeitr√§ume, Frequenzen

Absolute Zeitangaben (Zeitstempel) werden mit `render.date()` oder `render.datetime()` formatiert.
Die Angaben erfolgen immer als _Unix-Zeit,_ also in Sekunden ab dem 1. Januar 1970, 00:00:00 UTC -- dem Beginn der _Unix-Epoche._
Dies ist auch das Format, mit dem die Python-Funktion `time.time()` arbeitet.

Vorteil an dieser Darstellung ist, dass sich damit sehr einfach rechnen l√§sst, also zum Beispiel die Berechnung des Zeitraums, wenn Start- und Endzeit bekannt sind.
Die Formel ist dann einfach `duration = end - start`.
Und diese Berechnungen funktionieren unabh√§ngig von der Zeitzone, Sommerzeitumstellungen oder Schaltjahren.

`render.date()` gibt nur das Datum aus, `render.datetime()` f√ºgt noch die Uhrzeit hinzu.
Die Ausgabe erfolgt dabei gem√§√ü der aktuellen Zeitzone desjenigen {CMK}-Servers, welcher den Check ausf√ºhrt.
Beispiele:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.date(0)` |`1970-01-01`
|`render.datetime(0)` |`1970-01-01 01:00:00`
|`render.date(1700000000)` |`2023-11-14`
|`render.datetime(1700000000)` |`2023-11-14 23:13:20`
|===

Wundern Sie sich jetzt nicht, dass `render.datetime(0)` als Uhrzeit nicht `00:00`, sondern `01:00` ausgibt.
Das liegt daran, dass wir dieses Handbuch in der Zeitzone von Deutschland schreiben -- und die ist der Standardzeit UTC eine Stunde voraus (zumindest w√§hrend der Normalzeit, denn der 1. Januar liegt ja bekanntlich nicht in der Sommerzeit).

F√ºr Zeitr√§ume (oder _Zeitspannen_) gibt es noch die Funktion `render.timespan()`.
Diese bekommt eine Dauer in Sekunden und gibt das menschenlesbar aus.
Bei gr√∂√üeren Zeitspannen werden Sekunden oder Minuten weggelassen.
Wenn Sie eine Zeitspanne in einem `TimeDelta`-Objekt vorliegen haben, lesen Sie aus diesem mit der Funktion `total_seconds()` die Zahl der Sekunden als Flie√ükommazahl aus.

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.timespan(1)` |`1 second`
|`render.timespan(123)` |`2 minutes 3 seconds`
|`render.timespan(12345)` |`3 hours 25 minutes`
|`render.timespan(1234567)` |`14 days 6 hours`
|===

Eine _Frequenz_ ist quasi der Kehrwert der Zeit.
Die kanonische Einheit ist _Hz_, was das gleiche bedeutet wie 1 / sec.
Einsatzgebiet ist zum Beispiel die Taktrate einer CPU:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.frequency(111222333444)` |`111 GHz`
|===


[#byte]
=== Bytes

√úberall wo es um Arbeitsspeicher, Dateien, Festplatten, Dateisysteme und dergleichen geht, ist die kanonische Einheit das _Byte._
Da Computer so etwas meist in Zweierpotenzen organisieren, also zum Beispiel in Einheiten zu 512, 1024 oder 65 536 Bytes, hatte sich dabei von Beginn an eingeb√ºrgert,
dass ein _Kilobyte_ nicht 1000, und damit das Tausendfache der Einheit ist, sondern 1024 (2 hoch 10) Bytes.
Das ist zwar unlogisch, aber sehr praktisch, weil so meist runde Zahlen herauskommen.
Der legend√§re Commodore C64 hatte eben 64 Kilobytes Speicher und nicht 65,536.

Leider kamen irgendwann Festplattenhersteller auf die Idee, die Gr√∂√üen ihrer Platten in 1000er-Einheiten anzugeben.
Da bei jeder Gr√∂√üenordnung der Unterschied zwischen 1000 und 1024 immerhin 2,4{nbsp}% ausmacht, und diese sich aufmultiplizieren,
wird so aus einer Platte der Gr√∂√üe 1 GB (1024 mal 1024 mal 1024) auf einmal 1,07 GB.
Das verkauft sich besser.

Diese l√§stige Verwirrung besteht bis heute und sorgt immer wieder f√ºr Fehler.
Als Linderung wurden von der internationalen elektrotechnischen Kommission (IEC) neue Pr√§fixe auf Grundlage des Bin√§rsystems festgelegt.
Demnach ist heute offiziell ein Kilobyte 1000 Bytes und ein _Kibibyte_ 1024 Bytes (2 hoch 10).
Au√üerdem soll man _Mebibyte,_ _Gibibyte_ und _Tebibyte_ sagen.
Die Abk√ºrzungen lauten dann KiB, MiB, GiB und TiB.

{CMK} passt sich an diesen Standard an und hilft Ihnen mit mehreren angepassten Render-Funktionen dabei, dass Sie immer korrekte Ausgaben machen.
So gibt es speziell f√ºr Festplatten und Dateisysteme die Funktion `render.disksize()`, welche die Ausgabe in 1000er-Potenzen macht.

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.disksize(1000)` |`1.00 kB`
|`render.disksize(1024)` |`1.02 kB`
|`render.disksize(2000000)` |`2.00 MB`
|===

Bei der Gr√∂√üe von Dateien ist es oft √ºblich, die genaue Gr√∂√üe in Bytes _ohne Rundung_ anzugeben.
Dies hat den Vorteil, dass man so sehr schnell sehen kann, wenn sich eine Datei auch nur minimal ge√§ndert hat oder dass zwei Dateien (wahrscheinlich) gleich sind.
Hierf√ºr ist die Funktion `render.filesize()` verantwortlich:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.filesize(1000)` |`1,000 B`
|`render.filesize(1024)` |`1,024 B`
|`render.filesize(2000000)` |`2,000,000 B`
|===

Wenn Sie eine Gr√∂√üe ausgeben m√∂chten, die keine Festplatten- oder Dateigr√∂√üe ist, dann verwenden Sie einfach das generische `render.bytes()`.
Hier bekommen Sie die Ausgabe in klassischen 1024er-Potenzen in der offiziellen Schreibweise:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.bytes(1000)` |`1000 B`
|`render.bytes(1024)` |`1.00 KiB`
|`render.bytes(2000000)` |`1.91 MiB`
|===


[#bandwith]
=== Bandbreiten, Datenraten

Die Netzwerker haben ihre eigenen Begriffe und Arten, Dinge auszudr√ºcken.
Und wie immer gibt sich {CMK} M√ºhe, in jeder Dom√§ne die dort √ºbliche Art zu kommunizieren, zu √ºbernehmen.
Deswegen gibt es f√ºr Datenraten und Geschwindigkeiten gleich drei verschiedene Render-Funktionen.
Alle haben gemeinsam, dass die Raten in _Bytes pro Sekunde_ √ºbergeben werden, selbst dann, wenn die Ausgabe in Bits erfolgt!

`render.nicspeed()` stellt die Maximalgeschwindigkeit einer Netzwerkkarte oder eines Switchports dar.
Da es keine Messwerte sind, muss auch nicht gerundet werden.
Obwohl kein Port einzelne Bits versenden kann, sind die Angaben aus historischen Gr√ºnden in Bits.

*Wichtig:* Trotzdem m√ºssen Sie auch hier Bytes pro Sekunde √ºbergeben!

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.nicspeed(12500000)` |`100 MBit/s`
|`render.nicspeed(100000000)` |`800 MBit/s`
|===

`render.networkbandwidth()` ist gedacht f√ºr eine tats√§chlich gemessene √úbertragungsgeschwindigkeit im Netzwerk.
Eingabewert ist wieder Bytes pro Sekunde:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.networkbandwidth(123)` |`984 Bit/s`
|`render.networkbandwidth(123456)` |`988 kBit/s`
|`render.networkbandwidth(123456789)` |`988 MBit/s`
|===

Wo es nicht ums Netzwerk geht und dennoch Datenraten ausgegeben werden, sind wieder Bytes √ºblich.
Prominentester Fall sind IO-Raten von Festplatten.
Daf√ºr gibt es die Funktion `render.iobandwidth()`, die in {CMK} mit 1000er-Potenzen arbeitet:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.iobandwidth(123)` |`123 B/s`
|`render.iobandwidth(123456)` |`123 kB/s`
|`render.iobandwidth(123456789)` |`123 MB/s`
|===


[#percentage]
=== Prozents√§tze

Die Funktion `render.percent()` stellt einen Prozentsatz dar -- auf zwei Nachkommastellen gerundet.
Sie ist insofern eine Ausnahme zu den anderen Funktionen, als hier nicht der eigentlich nat√ºrliche Wert -- also das Verh√§ltnis -- √ºbergeben wird, sondern wirklich die Prozentzahl.
Wenn also etwas zum Beispiel zur H√§lfte voll ist, m√ºssen Sie nicht `0.5`, sondern `50` √ºbergeben.

Weil es manchmal interessant sein kann, zu wissen, ob ein Wert beinahe Null oder exakt Null ist, werden Werte durch Anf√ºgen eines ‚Äû`<`‚Äú Zeichens markiert,
die gr√∂√üer als Null, aber kleiner als 0,01 Prozent sind.

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.percent(0.004)` |`<0.01%`
|`render.percent(18.5)` |`18.50%`
|`render.percent(123)` |`123.00%`
|===


[#numbers_summary]
=== Zusammenfassung

Hier folgt zum Abschluss die √úbersicht √ºber alle Render-Funktionen:

[cols="20,20,~,20",options="header"]
|===
|Funktion |Eingabe |Beschreibung |Beispielausgabe 
|`date()` |Unix-Zeit |Datum |`2023-11-14`
|`datetime()` |Unix-Zeit |Datum und Uhrzeit |`2023-11-14 23:13:20`
|`timespan()` |Sekunden |Dauer / Alter |`3 hours 25 minutes`
|`frequency()` |Hz |Frequenz (z. B. Taktrate) |`111 GHz`
|`disksize()` |Bytes |Gr√∂√üe einer Festplatte, Basis 1000 |`1,234 GB`
|`filesize()` |Bytes |Gr√∂√üe einer Datei, volle Genauigkeit |`1,334,560 B`
|`bytes()` |Bytes |Gr√∂√üe, Basis 1024 |`23,4 KiB`
|`nicspeed()` |Bytes pro Sekunde |Geschwindigkeit von Netzwerkkarten |`100 MBit/s`
|`networkbandwidth()` |Bytes pro Sekunde |√úbertragungsgeschwindigkeit |`23.50 GBit/s`
|`iobandwidth()` |Bytes pro Sekunde |IO-Bandbreiten |`124 MB/s`
|`percent()` |Prozentzahl |Prozentsatz, sinnvoll gerundet |`99.997%`
|===


[#errors]
== Fehler beheben

Die korrekte Behandlung von Fehlern nimmt (leider) einen gro√üen Teil der Programmierarbeit ein.
Dabei ist die gute Nachricht, dass Ihnen die Check-API hinsichtlich der Fehlerbehandlung bereits viel Arbeit abnimmt.
Bei einigen Arten von Fehlern ist es daher richtig, diese gar nicht selbst zu behandeln.

Wenn Python in eine Situation kommt, die in irgendeiner Form _unerwartet_ ist, reagiert es mit einer sogenannten Ausnahme (_Exception_).
Hier sind ein paar Beispiele:

* Sie konvertieren mit `int()` einen String in eine Zahl, aber der String enth√§lt keine Zahl, zum Beispiel `int("foo")`.
* Sie greifen mit `bar[4]` auf das f√ºnfte Element von `bar` zu, aber das hat nur vier Elemente.
* Sie rufen eine Funktion auf, die es nicht gibt.

Um entscheiden zu k√∂nnen, wie Sie Fehler angehen, ist es zun√§chst wichtig, die exakte Stelle im Code zu kennen, an der ein Fehler auftritt.
Hierf√ºr k√∂nnen Sie sowohl die GUI als auch die Befehlszeile verwenden -- je nachdem, wo Sie gerade arbeiten.


[#error_exception_gui]
=== Exceptions und Absturzberichte in der GUI

Tritt eine Exception im Monitoring oder w√§hrend der Service-Erkennung im [.guihint]#Setup# auf, enth√§lt das [.guihint]#Summary# Hinweise auf den eben erstellten Absturzbericht (_crash report_).
Das sieht dann zum Beispiel so aus:

image::devel_cpi_service_crash_report.png[alt="Ein Service, dessen Check-Plugin abgest√ºrzt ist."]

Durch einen Klick auf das Symbol icon:icon_crash[alt="Symbol f√ºr ein abgest√ºrztes Check-Plugin."] wird eine Seite mit Details angezeigt, auf der Sie:

* die Datei angezeigt bekommen, in der der Absturz stattgefunden hat,
* alle Informationen √ºber den Absturz erhalten, wie die Auflistung der aufgetretenen Fehler im Programm (_Traceback_), aktuelle Werte lokaler Variablen, Agentenausgabe und vieles mehr sowie
* den Report zu uns ({comfull}) als Feedback einsenden k√∂nnen.

Der Traceback hilft Ihnen als Programmierer zu entscheiden, ob ein Fehler im Programm vorliegt (beispielsweise der Aufruf einer nicht vorhandenen Funktion) oder Agentendaten vorliegen, die nicht wie erwartet verarbeitet werden konnten.
Im ersten Fall werden Sie den Fehler beheben wollen, im zweiten Fall ist es h√§ufig sinnvoll, nichts zu tun.

Das Einsenden des Reports ist nat√ºrlich nur f√ºr Check-Plugins sinnvoll, die offiziell Teil von {CMK} sind.
Falls Sie eigene Plugins Dritten zug√§nglich machen, k√∂nnen Sie Ihre Anwender bitten, Ihnen die Daten zukommen zu lassen.


[#error_exception_cli]
=== Exceptions auf der Befehlszeile ansehen

Wenn Sie Ihr Check-Plugin auf der Befehlszeile ausf√ºhren, erhalten Sie keinen Hinweis auf die ID des erzeugten Absturzberichts.
Sie sehen nur die zusammengefasste Fehlermeldung:

[{shell}]
----
{c-omd} cmk --detect-plugins=myhostgroups_advanced localhost
Error in agent based plugin: cmk_addons.plugins.myhostgroups.agent_based.myhostgroups: name 'agent_section_myhostgroups' is not defined
----

H√§ngen Sie die Option `--debug` als zus√§tzlichen Aufrufparameter an, dann bekommen Sie den Traceback des Python-Interpreters:

[{shell}]
----
{c-omd} cmk --debug --detect-plugins=myhostgroups_advanced localhost
Traceback (most recent call last):
  File "/omd/sites/mysite/lib/python3/cmk/discover_plugins/_python_plugins.py", line 195, in add_from_module
    module = importer(mod_name, raise_errors=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/omd/sites/mysite/lib/python3/cmk/discover_plugins/_python_plugins.py", line 156, in _import_optionally
    return importlib.import_module(module_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/omd/sites/mysite/lib/python3.12/importlib/__init__.py", line 90, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<frozen importlib._bootstrap>", line 1387, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1360, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1331, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 935, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 995, in exec_module
  File "<frozen importlib._bootstrap>", line 488, in _call_with_frames_removed
  File "/omd/sites/mysite/local/lib/python3/cmk_addons/plugins/myhostgroups/agent_based/myhostgroups.py", line 110, in <module>
    agent_section_myhostgroups == AgentSection(
    ^^^^^^^^^^^^^^^^^^^^^^^^^^
NameError: name 'agent_section_myhostgroups' is not defined
----

Tritt der Fehler beim Aufruf mit `--debug` beim n√§chsten Mal nicht mehr auf, zum Beispiel, weil eine neue Agentenausgabe bereitsteht, k√∂nnen Sie die letzten Absturzberichte auch im Dateisystem einsehen:

[{shell}]
----
{c-omd} ls -lhtr ~/var/check_mk/crashes/check/ | tail -n 5
drwxrwxr-x 2 mysite mysite 4.0K Aug  6 17:56 7b59a49e-540c-11ef-9595-7574c603ce8d/
drwxrwxr-x 2 mysite mysite 4.0K Aug  6 17:56 7c8870c0-540c-11ef-9595-7574c603ce8d/
drwxrwxr-x 2 mysite mysite 4.0K Aug  6 17:56 7cf9626c-540c-11ef-9595-7574c603ce8d/
drwxrwxr-x 2 mysite mysite 4.0K Aug  6 17:56 7d192d68-540c-11ef-9595-7574c603ce8d/
drwxrwxr-x 2 mysite mysite 4.0K Aug  6 17:56 7e2d5ec2-540c-11ef-9595-7574c603ce8d/
----

In jedem dieser Ordner liegen zwei Dateien:

. `crash.info` enth√§lt ein Python-Dictionary mit Traceback und vielen weiteren Informationen. Oft gen√ºgt der Blick in die Datei mit dem Pager.
. `agent_output` enth√§lt die vollst√§ndige Agentenausgabe, die zum Zeitpunkt des Absturzes aktuell war.


[#custom_debug]
=== Eigene Debug-Ausgabe

In den oben gezeigten Beispielen verwenden wir die Funktion `print()`, um f√ºr Sie als Programmierer den Inhalt von Variablen oder die Struktur von Objekten auszugeben.
Diese Funktionen f√ºr Debug-Ausgaben m√ºssen aus dem fertigen Check-Plugin wieder entfernt werden.

Alternativ zur Entfernung k√∂nnen Sie Ihre Debug-Ausgabe auch nur ausgeben lassen, wenn das Check-Plugin in der Konsole im Debug-Modus aufgerufen wird.
Daf√ºr importieren Sie das Debug-Objekt aus der {CMK}-Werkzeugkiste und gegebenenfalls die Formatierungshilfe `pprint()`.
Sie k√∂nnen nun Debug-Ausgaben abh√§ngig vom Wert des Debug-Objektes vornehmen:

[TIP]
====
Das Debug-Objekt √§nderte von {CMK} {v23} nach {v24} seinen Pfad.
Statt bisher unter `cmk.utils` ist es nun unter `cmk.ccc` zu finden.
Portabler Code versucht zuerst, aus dem neuen Pfad zu importieren und f√§llt im Fehlerfall auf den alten zur√ºck.
====

[{python}]
----
try:
    from cmk.ccc import debug
except ImportError:
    from cmk.utils import debug

from pprint import pprint

def check_mystuff(section):
    if debug.enabled():
        pprint(section)
----

Beachten Sie, dass verbleibende Debug-Ausgaben sparsam verwendet und auf Hinweise beschr√§nkt sein sollten, die den sp√§teren Benutzern bei der Fehlersuche helfen.
Offensichtliche und abzusehende Fehler des Benutzers (zum Beispiel, dass die Inhalte der Agentensektion darauf hindeuten, dass das Agentenplugin falsch konfiguriert ist) sollten Sie mit dem Zustand {UNKNOWN} und aussagekr√§ftigen Hinweisen im Summary beantworten.


[#error_invalid_agent]
=== Ung√ºltige Agentenausgabe

Die Frage ist, wie Sie reagieren sollen, wenn die Ausgaben vom Agenten nicht die Form haben, die Sie eigentlich erwarten -- egal ob vom {CMK}-Agenten oder per xref:devel_check_plugins_snmp#[SNMP] erhalten.
Angenommen, Sie erwarten pro Zeile immer drei Worte.
Was sollen Sie tun, falls nur zwei kommen?

Nun, wenn das ein _erlaubtes und bekanntes_ Verhalten des Agenten ist, dann m√ºssen Sie das nat√ºrlich abfangen und mit einer Fallunterscheidung arbeiten.
Falls das aber eigentlich nicht sein darf, dann tun Sie am besten so, als ob die Zeile immer aus drei Worten besteht, also zum Beispiel mit folgender Parse-Funktion:

[{python}]
----
def parse_foobar(string_table):
    for foo, bar, baz in string_table:
        # ...
----

Sollte jetzt mal eine Zeile dabei sein, die nicht aus genau drei Worten besteht, wird eine Exception erzeugt und Sie bekommen den gerade erw√§hnten sehr hilfreichen Absturzbericht.

Falls Sie auf Schl√ºssel in einem Dictionary zugreifen, die gelegentlich erwartbar fehlen, kann es nat√ºrlich sinnvoll sein, darauf entsprechend zu reagieren.
Das kann erfolgen, indem _Sie_ den Service auf {CRIT} oder {UNKNOWN} setzen und im Summary einen Hinweis auf die nicht auswertbare Agentenausgabe unterbringen.
In jedem Fall ist es besser, Sie verwenden hierf√ºr die `get()`-Funktion des Dictionaries als die `KeyError` Exception abzufangen.
Denn `get()` liefert bei Nichtvorhandensein des Schl√ºssels ein Objekt vom Typ `None` oder einen optional als zweiten Parameter zu √ºbergebenden Ersatz:

[{python}]
----
def check_foobar(section):
    foo = section.get("bar")
    if not foo:
        yield Result(state=State.CRIT, summary="Missing key in section: bar")
        return
    # ...
----


[#error_missing_item]
=== Fehlende Items

Was ist, wenn der Agent korrekte Daten ausgibt, aber das Item fehlt, das √ºberpr√ºft werden soll?
Also zum Beispiel auf diese Art:

[{python}]
----
def check_foobar(item, section):
    # Try to access the item as key in the section:
    foo = section.get(item)
    if foo:
        yield Result(state=State.OK, summary="Item found in monitoring data")
    # If foo is None, nothing is yielded here
----

Ist das gesuchte Item nicht dabei, so wird die Schleife durchlaufen und Python f√§llt am Ende der Funktion einfach hinten raus, ohne dass ein Resultat per `yield` zur√ºckgegeben wurde.
Und das ist genau das Richtige!
Denn daran erkennt {CMK}, dass das zu √ºberwachende Item fehlt und erzeugt mit {UNKNOWN} den richtigen Status und einen passenden Standardtext dazu.


[#error_spool]
=== Test mit Spool-Dateien

Wenn Sie bestimmte Agentenausgaben simulieren wollen, sind Dateien im xref:spool_directory#[Spool-Verzeichnis] sehr hilfreich.
Diese k√∂nnen Sie nutzen, um sonst schwer nachzustellende Grenzf√§lle zu testen.
Oder Sie verwenden direkt die Agentenausgabe, welche zu einem Absturzbericht gef√ºhrt hat, zur Pr√ºfung von √Ñnderungen an einem Check-Plugin.

Deaktivieren Sie zun√§chst Ihr regul√§res Agentenplugin, beispielsweise indem Sie ihm die Ausf√ºhrungsberechtigung entziehen.
Erstellen Sie dann eine Datei im Verzeichnis `/var/lib/check_mk_agent/spool/`, welche die von Ihrem Check-Plugin erwartete Agentensektion (oder erwarteten _Agentensektionen_) inklusive Sektions-Header enth√§lt und auf Newline endet.
Beim n√§chsten Aufruf des Agenten wird dann der Inhalt der Spool-Datei statt der Ausgabe des Agentenplugins √ºbertragen.


[#performance]
=== Alte Check-Plugins werden bei vielen Services langsam

Bei einigen Check-Plugins, die Items nutzen, ist es auf gr√∂√üeren Servern durchaus m√∂glich, dass einige hundert Services erzeugt werden.
Wenn keine eigene Parse-Funktion verwendet wird, hat dies zur Folge, dass f√ºr jedes der hunderten Items die gesamte Liste von hunderten Zeilen durchlaufen werden muss.
Die zum Suchen ben√∂tigte Zeit steigt also im Quadrat mit der Zahl der Listenelemente, bei hunderten Services bedeutet das zigtausende Vergleiche.
Ist dagegen die geschachtelte Liste in ein Dictionary √ºberf√ºhrt, steigt der Aufwand f√ºr die Suche eines Elements nur linear mit der Gr√∂√üe des Dictionaries. 

Im Python-Wiki finden Sie eine link:https://wiki.python.org/moin/TimeComplexity[√úbersicht der Kosten^] f√ºr die Suche in verschiedenen Datentypen, inklusive Erl√§uterung und _O-Notation._
Mit der Parse-Funktion reduzieren die Komplexit√§t der Suche von _O(n)_ auf _O(1)_.

Da √§ltere Versionen dieses Artikels keinen Gebrauch von der Parse-Funktion gemacht haben, sollten Sie derartige Check-Plugins identifizieren und diese auf Verwendung einer Parse-Funktion umschreiben.


[#migration]
== Migration

Die in der {CMK}-Version {v20} eingef√ºhrte Check-API V1 wurde noch in der Version {v23} weiterhin unterst√ºtzt, aber nicht mehr in der aktuellen Version {v24}.
Um Ihre Check-Plugins weiter nutzen zu k√∂nnen m√ºssen Sie diese noch unter {v23} auf die neuen APIs migrieren.

Die folgenden Informationen helfen Ihnen bei der Migration von Check-Plugins der Check-API V1 auf die V2:

* Die neue Verzeichnisstruktur und Namenskonvention zur Ablage der Dateien f√ºr alle Plugin-APIs finden Sie in der xref:check_api_doc[API-Dokumentation] auf der Hauptseite [.guihint]#{CMK}'s Plug-in APIs#.

* Die Zusammenfassung der √Ñnderungen in der Check-API V2 steht ebenfalls in der API-Dokumentation in [.guihint]#{CMK}'s Plug-in APIs > Agent based ("Check API") > Version 2 > New in this version#.
Dort finden Sie auch den Link zu einem GitHub-Commit, der das bestehende Check-Plugin `apt` zur Check-API V2 migriert.

* Auf link:https://github.com/Checkmk/checkmk/tree/master/doc/treasures/migration_helpers/[GitHub^] finden Sie im `treasures`-Verzeichnis von {CMK} Skripte, die Ihnen bei der Migration auf die neuen APIs helfen.

include::include_treasures_admonition.asciidoc[]


[#files]
== Dateien und Verzeichnisse

[cols="50,~",options="header"]
|===
|Pfad |Bedeutung
|`~/local/lib/python3/cmk_addons/plugins/` |Basisverzeichnis zur Ablage von Plugin-Dateien.
|`~/local/lib/python3/cmk_addons/plugins/<plug-in_family>/agent_based/` |Ablageort f√ºr nach der Check-API V2 selbst geschriebene Check-Plugins.
|`~/local/lib/python3/cmk_addons/plugins/<plug-in_family>/rulesets/` |Ablageort f√ºr nach der Rulesets-API erstellte Regelsatzdateien.
|`~/local/lib/python3/cmk_addons/plugins/<plug-in_family>/graphing/` |Ablageort f√ºr nach der Graphing-API erstellte Graphing-Dateien.
|`/usr/lib/check_mk_agent/plugins/` |Dieses Verzeichnis liegt auf einem √ºberwachten Linux-Host. Hier erwartet der {CMK}-Agent f√ºr Linux Erweiterungen des Agenten (Agentenplugins).
|===

////
