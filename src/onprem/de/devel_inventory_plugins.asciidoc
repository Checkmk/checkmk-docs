// -*- coding: utf-8 -*-
// IGNORE Usb Gnomovision Yoyodyne
// NONASCII
include::global_attr.adoc[]
= HW/SW-Inventur-Plugins entwickeln
:title: HW/SW-Inventur-Plugins entwickeln
:description: Bei Bedarf k√∂nnen Sie Ihre eigenen Inventur-Plugins mit Python entwickeln. Lesen Sie hier, wie Sie ein Plugin selbst erstellen und nutzen.
:experimental:

{related-start}
xref:devel_intro#[Erweiterungen f√ºr {CMK} entwickeln]
xref:devel_check_plugins#[Agentenbasierte Check-Plugins entwickeln]
xref:inventory#[Die HW/SW-Inventur]
xref:wato_monitoringagents#[Monitoring-Agenten]
xref:agent_linux#[Linux √ºberwachen]
xref:agent_windows#[Windows √ºberwachen]
xref:wato_services#[Services verstehen und konfigurieren]
xref:cmk_commandline#[{CMK} auf der Befehlszeile]
xref:mkps#[{CMK}-Erweiterungspakete (MKPs)]
{related-end}


[#intro]
== Einleitung

Die xref:inventory#[HW/SW-Inventur] hilft, den √úberblick √ºber vorhandene Hardware zu behalten und jederzeit Kontrolle √ºber installierte Software zu haben.
// ES: Im Glossar steht nichts √ºber HW/SW-Inventur, w√§re das evtl. eine sinnvolle Erg√§nzung? Und dann Glossar-Link bei der ersten Erw√§hnung hier einf√ºgen.
{CMK} liefert fertige Plugins f√ºr viele Basis-Anwendungsf√§lle mit.
Allerdings werden Sie in vielen F√§llen bei spezieller Hard- und Software detailliertere Informationen ermitteln wollen.
An dieser Stelle kommen eigene Plugins f√ºr die HW/SW-Inventur ins Spiel.

F√ºr diesen Artikel setzen wir voraus, dass Sie bereits Grundkenntnisse in der Programmierung von agentenbasierten Check-Plugins haben.
// An Stellen, wo der Zugriff die APIs denen agentenbasierter Check-Plugins sehr √§hnlich ist, fallen die Erl√§uterungen in diesem Artikel daher etwas sp√§rlicher aus.
// ES: Ich kann den obigen Satz nicht parsen und daher auch keinen Verbesserungsvorschlag machen. Geht es um den Zugriff auf die Inventory-API, der dem Zugriff auf die Check-API sehr √§hnlich ist?
// MFS: So besser?
Wo sich die Verwendung der Inventur-API nicht wesentlich von der Check-API unterscheidet, fallen Erkl√§rungen daher sp√§rlich aus.
Daf√ºr weisen wir an Stellen mit signifikanten Unterschieden umso deutlicher auf diese hin. 

[TIP]
====
Bitte ber√ºcksichtigen Sie die Differenzierung zwischen Check- und Inventur-Plugin.
Check-Plugins eignen sich vorrangig f√ºr sich schnell √§ndernde Daten, Inventur-Plugins f√ºr selten ge√§nderte Daten.
In diesem Artikel verwenden wir zur Veranschaulichung ein √ºbersichtlich gehaltenes Beispiel mit USB-Ger√§ten.
Wollen Sie beispielsweise sicherstellen, dass niemand an irgendeinen Rechner im Monitoring USB-Ger√§te anschlie√üt, die nicht auf einer Positivliste stehen, ist daf√ºr ein Check-Plugin geeigneter.
====


[#check_api_doc]
=== Die Check-API-Dokumentation

Die Inventur-API ist Teil der Check-API.
F√ºr den Zugriff auf die Dokumentation gilt dasselbe wie bei xref:devel_check_plugins#check_api_doc[agentenbasierten Check-Plugins].

Sie k√∂nnen auf die mit Ihrer {CMK}-Instanz mitgelieferte Dokumentation zugreifen.
Dazu navigieren Sie in der {CMK}-GUI zu [.guihint]#Help > Developer resources > Plug-in API references#.
W√§hlen Sie im neuen Browserfenster in der linken Navigationsleiste [.guihint]#Agent based ("Check API") > Version 2# aus.
Auch ohne laufende {CMK}-Instanz k√∂nnen Sie sich die Plugin-API-Dokumentation als Kopie auf link:https://docs.checkmk.com/plugin-api/{gitbranch}/cmk.agent_based/index.html#version-2-cmk-agent-based-v2[docs.checkmk.com/plugin-api^] ansehen.
// ES: Link ge√§ndert, um genau auf v2 zu verweisen
// MFS: ‚úî

[#preparation]
== Vorbereitung

Die Standardeinstellung von {CMK} sieht vor, Inventardaten nur einmal t√§glich zu aktualisieren.
Dies steht nat√ºrlich im Widerspruch zu einer schnellen Sichtbarkeit von Ergebnissen bei eigenen Programmierversuchen.
Daher raten wir zu zwei vorbereitenden Ma√ünahmen f√ºr mehr Geschwindigkeit ohne signifikante Systemlast:

// . Verwenden Sie einen Host f√ºr Entwicklung und eines m√∂glicherweise ben√∂tigten Agenten-Plugins, der auf das umfangreiche Plugin `mk_inventory` verzichtet.
. Verzichten Sie bei dem Host, der die Daten f√ºr das neu zu erstellende Plugin liefert, auf das viel Last verursachende Plugin `mk_inventory`.
// ES: Im obigen Satz fehlt irgendwas oder es ist irgendwas zuviel, ich verstehe ihn nicht.
// MFS: So besser?
. Setzen Sie f√ºr diesen Host das xref:inventory#set_interval[Ausf√ºhrungsintervall des aktiven Checks] auf eine oder wenige Minuten. 

[#agentplugin]
== Das Agentenplugin

Wenn Sie ein agentenbasiertes Check-Plugin um Inventur-Funktionalit√§t erweitern wollen, k√∂nnen Sie m√∂glicherweise eine f√ºr Ihr Check-Plugin geschriebene Agentensektion mitverwenden.
F√ºr unser Beispiel erstellen wir eine eigene.
Die Grundlage hierf√ºr ist der Befehl `lsusb`.
Ohne Parameter aufgerufen, gibt er eine Liste aller angeschlossenen USB-Ger√§te aus.
Das k√∂nnte so aussehen:


[{shell}]
----
{c-omd} lsusb
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 002 Device 002: ID 0bda:0409 Realtek Semiconductor Corp. USB3.2 Hub
Bus 002 Device 003: ID 0bda:0409 Realtek Semiconductor Corp. USB3.2 Hub
Bus 002 Device 004: ID 0bda:8153 Realtek Semiconductor Corp. RTL8153 Gigabit Ethernet Adapter
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 003 Device 002: ID 0c45:6a09 Microdia Integrated_Webcam_HD
----

Die hier verwendete Kurzausgabe zeigt in den ersten Feldern, an welchem Bus und Port ein Ger√§t angeschlossen ist.
Es folgt ‚Äì durch einen Doppelpunkt getrennt ‚Äì zuerst die Hersteller-ID, dann die Ger√§te-ID.
Der Rest der Zeile enth√§lt beschreibenden Text.

=== Das resultierende Skript

Da {CMK} mit zeilenweisen Ausgaben gut klarkommt, gen√ºgen f√ºr das ben√∂tigte Check-Plugin drei Zeilen:

./usr/lib/check_mk_agent/plugins/lsusb
[{bash}]
----
#!/bin/bash
echo '<<<lsusb_demo>>>'
lsusb
----

Vergessen Sie nicht, das Plugin als ausf√ºhrbar zu markieren:

[{shell-raw}]
----
{c-root} chmod 0755 /usr/lib/check_mk_agent/plugins/lsusb
----

// ES: Wenn die Hinweise zum VM-Setup im Artikel bleiben, k√∂nnte das ein Kandidat f√ºr ein/mehrere Collapsibles sein, oder?
// MFS: Ich w√ºrde es gerne drin lassen, weil das eher der Standardfall ist: Man zieht es einmal mit lsusb und erstellt dann zwei, drei Varianten, die man abwechselnd ins Spool-Verzeichnis kopiert...
Falls der Host, auf dem Sie das das Agenten-Plugin testen, eine virtuelle Maschine ist, oder Sie nicht st√§ndig Ger√§te ab- und anst√∂pseln wollen, speichern Sie das folgende Beispiel einfach in einer Spool-Datei.
Spool-Dateien werden in die Agentenausgabe aufgenommen und mit √ºbertragen.
Achten Sie daher darauf, dass die Datei mit einem Zeilenumbruch endet.

[.copybutton]
./var/lib/check_mk_agent/spool/lsusb.txt
[{file}]
----
<<<lsusb_demo>>>
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 002 Device 002: ID 0bda:0409 Realtek Semiconductor Corp. USB3.2 Hub
Bus 002 Device 003: ID 0bda:0409 Realtek Semiconductor Corp. USB3.2 Hub
Bus 002 Device 004: ID 0bda:8153 Realtek Semiconductor Corp. RTL8153 Gigabit Ethernet Adapter
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 003 Device 002: ID 0c45:6a09 Microdia Integrated_Webcam_HD
Bus 003 Device 004: ID 8087:0032 Intel Corp. AX210 Bluetooth
Bus 003 Device 005: ID 0bda:5409 Realtek Semiconductor Corp. USB2.1 Hub
Bus 003 Device 006: ID 0bda:5409 Realtek Semiconductor Corp. USB2.1 Hub
Bus 003 Device 007: ID 0bda:1100 Realtek Semiconductor Corp. HID Device
Bus 003 Device 071: ID 046d:c093 Logitech, Inc. M500s Optical Mouse
Bus 003 Device 096: ID 1a40:0101 Terminus Technology Inc. Hub
Bus 003 Device 108: ID 6964:0075 MT ID75 Rev
Bus 003 Device 109: ID 0c45:636b Microdia USB 2.0 Camera
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
----

Das Anschlie√üen und Entfernen von USB-Ger√§ten k√∂nnen Sie dann simulieren, indem Sie der Textdatei Zeilen hinzuf√ºgen oder welche entfernen.

[#test_agent]
=== Agent ausprobieren

Testen Sie die Agentenausgabe lokal mit dem folgenden Befehl:

[{shell-raw}]
----
{c-root} cmk-agent-ctl dump | grep -A25 '^<<<lsusb'
----

Sie sollten nun je nach Zahl angeschlossener USB-Ger√§te (oder Zahl der Zeilen in der Spool-Datei) die Ausgabe von `lsusb` und ein paar Zeilen der folgenden Agentensektion sehen.
Achten Sie auf den korrekten Zeilenumbruch am Ende der Agentensektion.

[#inventory_plugin]
== Das Inventur-Plugin

Inventur-Plugins leben in der regul√§ren xref:devel_check_plugins#scaffold[Verzeichnisstruktur] neben den normalen Check-Plugins.
// ES: Querverweis eingef√ºgt, kannst du aber auch gerne anders platzieren
// MFS: üëç
Sie k√∂nnen Inventur-Plugins entweder als separate Dateien ablegen, dann empfehlen wir, als Pr√§fix `inventory_` zu verwenden.
Oder Sie integrieren Inventur-Plugins in gemeinsamen Dateien mit Check-Plugins, dann verzichten Sie auf das Pr√§fix ganz.
F√ºr welche Methode Sie sich entscheiden, sollten Sie von der √úbersichtlichkeit und dem Bedarf nach gemeinsam verwendeten Funktionen abh√§ngig machen.

Um ein reines Inventur-Plugin zu erstellen, m√ºssen Sie daher ein passendes Verzeichnis anlegen:

[{shell}]
----
{c-omd} mkdir -p local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based
{c-omd} cd local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based
----

// ES: Die Pfade sind inkonsistent. Hier arbeiten wir in `local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based`, bei den ganzen Beispieldateien unten steht in den Pfaden `local/lib/python3/cmk/plugins/lsusb_demo/agent_based`
// MFS: Ich √§ndere alles auf cmk_addons...

[#scaffold]
=== Ein minimales Plugin

Sie k√∂nnen nun ein minimales Inventur-Plugin erstellen, welches Sie mit einem beliebigen Text-Editor bearbeiten:

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python}]
----
#!/usr/bin/env python3

from cmk.agent_based.v2 import InventoryPlugin, Attributes

def inventory_lsusb_demo(section):
    yield Attributes(
        path = [ "hardware", "usb", "general" ],
        inventory_attributes = { "Max standard": "3.2" },
    )

inventory_plugin_lsusb_demo = InventoryPlugin( 
    name = "lsusb_demo",
    inventory_function = inventory_lsusb_demo,
)
----

Der Aufbau √§hnelt dem von xref:devel_check_plugins#check_plug-in[Check-Plugins].
// ES: Querverweis eingef√ºgt, bitte pr√ºfen, ob das die passendste Stelle in devel_check_plugins ist
Auch das Inventur-Plugin importiert aus dem Namensraum `cmk.agent_based.v2`.
Die Inventur-Funktion entspricht der Check-Funktion, und die Erstellung des `InventoryPlugin`-Objektes erfolgt analog zu der eines `CheckPlugin`-Objektes.
// ES: Ich finde "entspricht" hier zu ungenau. Wie w√§re es mit Folgendem:
// Ein instanziiertes `CheckPlugin`-Objekt wird mit einer konkreten Check-Funktion verkn√ºpft, die ein `Result`-Objekt via `yield` zur√ºckgibt.
// Analog dazu wird ein instanziiertes `InventoryPlugin`-Objekt mit einer konkreten Inventory-Funktion verkn√ºpft, die ein `Attributes`-Objekt via `yield` zur√ºckgibt.

Die `Attributes`, welche per `yield` zur√ºckgegeben werden, implementieren das minimal sinnvolle Blatt eines Inventurbaumes:

* Der Pfad (`path`) beschreibt den relevanten Knoten in der Hierarchie des Baums, hier [.guihint]#Hardware > Usb > General#
* Die Schl√ºssel-Wert-Paare im Objekt `inventory_attributes` werden als Schl√ºssel-Wert-Tabelle dargestellt

Testen Sie zun√§chst, ob das Plugin syntaktisch korrekt ist und bei der Inventur gestartet werden kann:

[{shell-raw},highlight=8]
----
{c-omd} cmk-validate-plugins 
Agent based plugins loading succeeded, Active checks loading succeeded, Special agents
loading succeeded, Rule specs loading succeeded, Rule specs forms creation succeeded,
Referenced rule specs validation succeeded, Loaded rule specs usage succeeded
{c-omd} cmk -vv --inventory localhost | grep lsusb_demo
<<<lsusb_demo>>> / Transition HostSectionParser -> HostSectionParser
  HostKey(hostname='localhost', source_type=<SourceType.HOST: 1>)  -> Add sections: ['check_mk', 'local', 'lsusb_demo', ...]
 lsusb_demo: ok
 lsusb_demo: skipped (no data)
----
// ES: Wenn ich es richtig verstehe, kann man hier jeden beliebigen Host eingeben - dann w√§re ich daf√ºr, im Beispielaufruf `myhost` statt `localhost` einzuf√ºgen (ggf. auch f√ºr sp√§ter folgende Beispiele im Artikel relevant)

Ist das der Fall, aktualisieren Sie die Konfiguration f√ºr den Monitoring-Kern und starten dann Ihre Instanz neu:

[{shell}]
----
{c-omd} cmk -U
Generating configuration for core (type cmc)...
Starting full compilation for all hosts
 Creating global helper config...OK
 Creating cmc protobuf configuration...OK
{c-omd} omd restart
Stopping crontab...OK
Stopping dcd...killing 153645....OK
Stopping apache...killing 153387.................OK
Stopping cmc...killing 153300.....OK
Stopping ui-job-scheduler...killing 153285...OK
...
----

Ein Blick in das Inventar des Test-Hosts zeigt nun -- sobald der n√§chste regul√§re Check erfolgt ist -- ein neues Blatt im Inventarbaum:

// ES: Screenshot hier nicht vergessen


[#parse_function]
=== Die Parse-Funktion schreiben

// ES: K√∂nnen wir hier lieber von Tokens sprechen statt von Worten? Wenn irgendwo in der Zeile Zahlen stehen, die von Whitespaces umgeben sind, werden die doch auch abgetrennt. Deshalb w√ºrde ich hier auch lieber nicht den Zusammenhang "ohne Separator = Aufteilung in Worte" darstellen, sondern besser explizit "ohne Angabe eines Separators = Aufteilung anhand des Default-Separators (Leerzeichen)"
Agentensektionen ohne Angabe eines Separators werden vor der √úbergabe an die Inventurfunktion in eine zweidimensionale Liste von Worten umgewandelt:
Je Zeile entsteht eine Liste von Worten.
Jede dieser Listen wiederum ist Element einer Liste von Zeilen.
Wird ein Separator angegeben, definiert dieser die Wortgrenze.
Das erleichtert beispielsweise die Verarbeitung von als CSV formatierten Daten.

Eine Parse-Funktion wie bei xref:devel_check_plugins#parse_function[agentenbasierten Check-Plugins] ist nicht zwingend erforderlich.
Dennoch kann die Verwendung einer separaten Parse-Funktion einige Vorteile haben.
So erh√∂ht sie √úbersichtlichkeit und Erweiterbarkeit.
Und wenn ein bereits vorhandenes Plugin eines agentenbasierten Checks weiterverwendet werden soll, stellt sich die Frage ohnehin nicht:
Dann verwenden Sie einfach die vorhandene Parse-Funktion weiter.

In unserem Beispiel interessiert nicht, wo ein USB-Ger√§t angeschlossen ist.
F√ºr das Plugin sollen die Hersteller- und Ger√§te-ID ermittelt werden (an sechster Stelle der Liste), sowie die Beschreibung (ab der siebten Stelle bis zum Ende der Liste).

W√§hrend wir oben im simplen Beispiel die maximal unterst√ºtzte USB-Version noch einfach hart kodiert haben, k√∂nnen Sie sich gerne Gedanken machen, wie Sie diese mittelfristig mit regul√§ren Ausdr√ºcken aus der Beschreibung ermitteln.
Daf√ºr wird die Beschreibung komplett ben√∂tigt, also alles ab dem siebten, bis zum letzten Wort der Liste:

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python}]
----
def parse_lsusb_demo(string_table):
    parsed = { "devices": [] }
    for line in string_table:
        vendor = line[5].split(":")[0]
        device = line[5].split(":")[1]
        description = ""
        for i in range(6, len(line)):
            description = description + " " + line[i]
        parsed["devices"].append({ "vendor": vendor, "device": device, "description": description })
    return parsed
----

[#inventory_function]
=== Die Inventurfunktion schreiben

Hier k√∂nnen Sie ein wenig abk√ºrzen: Im Gegensatz zu agentenbasierten Check-Plugins wird die Parse-Funktion nicht √ºber die Erzeugung eines `AgentSection`-Objektes eingebunden, sondern muss aus der Inventurfunktion selbst aufgerufen werden.
Das Prinzip des `yield` zur fortw√§hrenden √úbergabe von Elementen kennen Sie aus agentenbasierten Check-Plugins:

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python},highlight=2;9]
----
def inventory_lsusb_demo(section):
    section = parse_lsusb_demo(section)
    yield Attributes(
        path = [ "hardware", "usb", "general" ],
        # FIXME: dynamically calculate from agent section
        inventory_attributes = { "Max standard": "3.2" },
    )
    for d in section["devices"]:
        yield TableRow(
            path = [ "hardware", "usb", "devices" ],
            key_columns = {
                "vendor": d["vendor"],
                "device": d["device"]
            },
            inventory_columns = {
                "description": d["description"]
            }
        )
----

Hier wird pro Zeile der Ausgabe von `lsusb` ein Objekt des Typs `TableRow` zur√ºckgegeben.
Dieses enth√§lt drei Spalten: Vendor- und Device-ID dienen gemeinsam als Schl√ºssel.
Die dritte, rein informative Spalte enth√§lt die Beschreibung.

Schl√ºsselspalten haben die Besonderheit, dass sie zur Erkennung von √Ñnderungen herangezogen werden, die wiederum im Monitoring zu einem Statuswechsel des Dienstes [.guihint]#HW/SW Inventory# f√ºhren k√∂nnen.
Des weiteren m√ºssen Schl√ºssel eindeutig sein.
Weitere Zeilen mit derselben Kombination aus Vendor- und Device-ID werden folglich ignoriert.

Neben Schl√ºssel- und Inventarspalten k√∂nnen Sie Statusspalten (`status_columns`) und analog Statusattribute (`status_attributes`) verwenden, welche den _Zustand_ eines Objektes abbilden.
F√ºr den Wert des Zustands stehen die einfachen Datentypen (`int`, `float`, `str`, `bool` oder `None`) zur Verf√ºgung.
Wollen Sie beispielsweise eine Tabelle erstellen, in der verzeichnet ist, welcher Anschluss (`Bus/Device`) belegt ist, dann k√∂nnen Sie `key_columns` (`Bus` und `Device`) und `status_columns` (hier: `bool`) verwenden.

[#finished_plugin]
=== Das fertige Plugin

Das fertige Plugin f√ºgt alles zusammen.
Hier wird zus√§tzlich noch die `TableRow`-Klasse importiert:

// ES: War das Absicht, dass du hier das letzte Token jeder Beschreibung abges√§belt hattest? Jedenfalls w√ºrde dann der Check mit dem .*?hub$ nicht mehr funktionieren.
// MFS: Haha, zuviel Ruby gemacht in letzter Zeit! War auf meinem Testsystem f√ºr .*?hub$ bereits korrigiert... Danke f√ºrs finden im Artikel!
.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python},highlight=3]
----
#!/usr/bin/env python3

from cmk.agent_based.v2 import InventoryPlugin, Attributes, TableRow

def parse_lsusb_demo(string_table):
    parsed = { "devices": [] }
    for line in string_table:
        vendor = line[5].split(":")[0]
        device = line[5].split(":")[1]
        description = ""
        for i in range(6, len(line)):
            description = description + " " + line[i]
        parsed["devices"].append({ "vendor": vendor, "device": device, "description": description })
    return parsed

def inventory_lsusb_demo(section):
    section = parse_lsusb_demo(section)
    yield Attributes(
        path = [ "hardware", "usb", "general" ],
        inventory_attributes = { "Plugin version": "0.1.0" },
    )
    for d in section["devices"]:
        yield TableRow(
            path = [ "hardware", "usb", "devices" ],
            key_columns = {
                "vendor": d["vendor"],
                "device": d["device"],
            },
            inventory_columns = {
                "description": d["description"],
            }
        )

inventory_plugin_lsusb_demo = InventoryPlugin( 
    name = "lsusb_demo",
    inventory_function = inventory_lsusb_demo,
)
----

// ES: Hier h√§tte ich gerne noch einen Screenshot von der gef√ºllten Tabelle auf der HW/SW-Seite in der Weboberfl√§che. √úberrascht hat mich, dass die Key-Spalten rechts zu sehen sind und die Beschreibung ganz links - haben wir Kontrolle dar√ºber?
// MFS: Tja, Inventory sortiert alphabetisch... Es gibt ein API, um die Darstellung zu verbessern, das ist bis 2.4 internal und wird dann in der 2.5 Version dieses Artikels gezeigt. Damit sind dann weniger peinliche Screenshots m√∂glich...

[#rulesets]
== Regels√§tze f√ºr die Inventur

Da die Inventur-API Teil der Check-Plugin-API ist, gestaltet sich die Erstellung und Anwendung von Regels√§tzen exakt wie bei der Entwicklung regul√§rer Check-Plugins.
Aus diesem Grund zeigen wir hier nur ein minimales Beispiel.

=== Regelsatz definieren

In der Ausgabe von `lsusb` tauchen einige Zeilen f√ºr Hubs (externe und Root-Hubs) auf.
Diese Ger√§te ohne eigene Funktionalit√§t erschweren es, den √úberblick zu behalten.

Daher wollen wir den Nutzenden die M√∂glichkeit geben, selbst zu entscheiden, ob Hubs erfasst werden sollen oder nicht.
Die Einstellung soll √ºber eine Checkbox in einer Regel erfolgen.
// ES: Wie ist das, k√∂nnen wir diese selbstgestrickte Regel auch in der Weboberfl√§che sehen und konfigurieren? Wie?
// MFS: Guter Punkt, die Regeln sind n√§mlich woanders zu finden als normale Monitoring-Regeln:
Sie k√∂nnen diese Regel dann in der GUI unter [.guihint]#Setup > Hosts > HW/SW inventory rules# einsehen und anpassen.
Ist der Name einer Regel bekannt (hier [.guihint]#Lsusb inventory demo# k√∂nnen Sie diesen direkt ins Suchfeld tippen.
Abgelegt wird diese im Ordner `rulesets` der Plugin-Familie, den Sie zun√§chst anlegen m√ºssen:

[{shell}]
----
{c-omd} mkdir -p local/lib/python3/cmk_addons/plugins/lsusb_demo/rulesets
{c-omd} cd local/lib/python3/cmk_addons/plugins/lsusb_demo/rulesets
----

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/rulesets/ruleset_lsusb_demo_inventory.py
[{python}]
----
#!/usr/bin/env python3

from cmk.rulesets.v1 import Label, Title, Help
from cmk.rulesets.v1.form_specs import (
    BooleanChoice,
    DefaultValue,
    DictElement,
    Dictionary,
)
from cmk.rulesets.v1.rule_specs import (
    InventoryParameters,
    Topic
)
from cmk.rulesets.v1 import Label

def _parameter_form():
    return Dictionary(
        elements = {
            "hubs": DictElement(
                parameter_form = BooleanChoice(
                    title = Title("USB hubs"),
                    label = Label("Consider USB hubs in the inventory table"),
                    prefill=DefaultValue(True),
                ),
                required = True,
            ),
        }
    )

rule_spec_lsusb_demo_inventory = InventoryParameters(
    name = "lsusb_demo",
    title = Title("Lsusb inventory demo"),
    topic = Topic.GENERAL,
    parameter_form = _parameter_form,
)
----

=== Regelsatz anwenden

Um den Regelsatz anzuwenden, erg√§nzen Sie zwei weitere [.notranslate]#_Named Arguments_# bei der Erstellung der `InventoryPlugin`-Klasse.

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python},highlight=6-7]
----
# ...

inventory_plugin_lsusb_demo = InventoryPlugin( 
    name = "lsusb_demo",
    inventory_function = inventory_lsusb_demo,
    inventory_default_parameters = { "hubs": True },
    inventory_ruleset_name = "lsusb_demo",
)
----

Zus√§tzlich muss der Inventur-Funktion als erstes Argument das Parameter-Dictionary √ºbergeben werden.
Hier erg√§nzen Sie auch einen regul√§ren Ausdruck, um zu erkennen, welche Ger√§t-Beschreibungen mit ‚Äûhub‚Äú enden.
Beachten Sie, dass Sie daf√ºr eine weitere `import`-Zeile zu Beginn des Skripts einf√ºgen m√ºssen:

.~/local/lib/python3/cmk_addons/plugins/lsusb_demo/agent_based/inventory_lsusb_demo.py
[{python}]
----
# ...

import re

# ...

def inventory_lsusb_demo(params, section):
    section = parse_lsusb_demo(section)
    yield Attributes(
        path = [ "hardware", "usb", "general" ],
        inventory_attributes = { "Plugin version": "0.1.0" },
    )
    h = re.compile('.*?hub$', re.IGNORECASE)
    for d in section["devices"]:
        if params['hubs'] or not h.match(d["description"]):
            yield TableRow(
                path = [ "hardware", "usb", "devices" ],
                key_columns = {
                    "vendor": d["vendor"],
                    "device": d["device"],
                },
                inventory_columns = {
                    "description": d["description"],
                }
            )
# ...
----

// MFS: Ich ziehe diesen Kommentar hoch ^
//                                      |
// ES: Wie ist das, k√∂nnen wir diese selbstgestrickte Regel auch in der Weboberfl√§che sehen und konfigurieren? Wie?

[#extending]
== Erweiterungsm√∂glichkeiten

[#multiple_sections]
=== Mehrere Sektionen abonnieren

// ES: Als Motivation f√ºr diesen Abschnitt f√§nde ich es hilfreich, wenn du zu Beginn einmal das Standardverhalten benennst: Wenn ich keine Sektionen explizit angebe, schaut das Plugin nach einer Sektion, die vom Namen des von mir angelegten Objekts oder der Funktionen abgeleitet wird, oder? Und wenn ich will, kann ich stattdessen explizit 1 bis n Sektionen angeben, die ber√ºcksichtigt werden sollen, sodass die von mir vergebenen Namen nicht mehr die Sektion bestimmen.
Wenn Sie vorhandene Agentensektionen mitverwenden wollen, die bereits von einem vorhandenen Inventur-Plugin ausgewertet werden, ist die Wahrscheinlichkeit hoch, dass bereits ein Inventur-Plugin existiert, das den Namen der Agentensektion verwendet.
Klarheit schafft die Ausgabe von:

[{shell}]
----
{c-omd} cmk -vv --inventory localhost
Doing HW/SW Inventory on: localhost
localhost:
+ INVENTORIZING
+ FETCHING DATA
  Source: SourceInfo(hostname='localhost', ipaddress='127.0.0.1', ident='agent' ...)
...
+ EXECUTING INVENTORY PLUGINS
 mssql_instance: skipped (no data)
 mssql_instance: skipped (no data)
 azure_app_gateway: skipped (no data)
 azure_app_gateway: skipped (no data)
 redfish_firmware: skipped (no data)
 redfish_firmware: skipped (no data)
 redfish_firmware_hpe_ilo4: skipped (no data)
 redfish_firmware_hpe_ilo4: skipped (no data)
 robotmk: skipped (no data)
 robotmk: skipped (no data)
----

In diesem Fall und dem Fall, dass ein Inventur-Plugin mehrere Agentensektionen auswerten soll, k√∂nnen Sie die abonnierten Sektionen als Liste angeben.
Gehen wir beispielsweise davon aus, dass Sie zwei Agentensektionen auswerten wollen, die sich auf fiktionale Dinge beziehen:

[.copybutton]
./var/lib/check_mk_agent/spool/fictional.txt
[{file}]
----
<<<zorg>>>
ZF1 23.0
<<<yoyodyne>>>
Gnomovision 42.1
----

In diesem Fall m√ºssen die abonnierten Agentensektionen explizit angegeben werden.
Der Name des Plugins muss mit den Agentensektionen nicht mehr √ºbereinstimmen:

.~/local/lib/python3/cmk_addons/plugins/fictional/agent_based/fictional.py
[{python}]
----
inventory_plugin_lsusb_demo = InventoryPlugin( 
    name = "fictional",
    sections = [ "yoyodyne", "zorg" ],
    inventory_function = inventory_fictional,
)
----

Die Inventurfunktion bekommt dann die String-Tabellen als Variablen nach dem Muster `section_sectionname` √ºbergeben:

.~/local/lib/python3/cmk_addons/plugins/fictional/agent_based/fictional.py
[{python}]
----
def inventory_fictional(section_yoyodyne, section_zorg):
    # Do something with the two two-dimensional arrays...
----

Das vollst√§ndige Plugin, welches die Versionen von link:https://www.gnu.org/licenses/old-licenses/gpl-2.0.html[Yoyodyne Gnomovision^] und link:https://fictionalcompanies.fandom.com/wiki/Zorg_Industries#Zorg_ZF-1_Pod_Weapon[Zorg ZF1^] im Inventarbaum abbildet, kann dann so aussehen:

.~/local/lib/python3/cmk_addons/plugins/fictional/agent_based/fictional.py
[{python}]
----
#!/usr/bin/env python3

from cmk.agent_based.v2 import InventoryPlugin, Attributes

def inventory_fictional(section_yoyodyne, section_zorg):
    yoyo = section_yoyodyne
    zorg = section_zorg
    yield Attributes(
        path = [ "software", "fictional", "example" ],
        inventory_attributes = { "Yoyodyne " + yoyo[0][0]: yoyo[0][1] },
    )
    yield Attributes(
        path = [ "hardware", "fictional", "example" ],
        inventory_attributes = { "Zorg " + zorg[0][0]: zorg[0][1] },
    )

inventory_plugin_lsusb_demo = InventoryPlugin( 
    name = "fictional",
    sections = [ "yoyodyne", "zorg" ],
    inventory_function = inventory_fictional,
)
----

// ES: Hier yielden wir immer nur die Eintr√§ge aus der ersten Zeile der beiden Sektionen, kannst du das mit wenig Aufwand zu einer richtigen Iteration √ºber die gesamten Sektionen umbauen? Oder ist das "left as an exercise for the reader"? Im Beispiel gibt es ja eh nur eine Zeile, aber wenn jemand l√§ngere Sektionen mit verarbeiten m√∂chte, w√§re eine vorbereitete Schleife schon hilfreich.
// MFS: Exercise to the reader. Mir ging es in erster Linie darum, ein Beispiel zu schaffen, das zeigt, wie es geht, mehrere Agentensektionen zu abonnieren. Das unterscheidet sich ja signifikant von der entsprechenden Herangehensweise bei Check-Plugins.

// ES: Hier auch gerne noch einen Screenshot einf√ºgen, der die fiktionalen Ergebnisse auf der HW/SW-Seite in der Weboberfl√§che zeigt
// MFS: Problem siehe oben. Sieht doof aus, im 2.5er Artikel dann.

