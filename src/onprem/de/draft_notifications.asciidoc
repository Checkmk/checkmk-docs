// -*- coding: utf-8 -*-
// IGNORE % Benachrichtigungs → ➤ Zeiträume ereignisabhängig
// NONASCII ö …​
include::global_attr.adoc[]
= Benachrichtigungen
:revdate: draft
:title: Grundlagen und Steuerung von Benachrichtigungen (notifications)
:description: Um Benachrichtigungen zu konfigurieren, gibt es grundlegende Konzepte und Gedankengänge, die zielführend sind. Gleichzeitig gibt es verschiedene Steuerungsmöglichkeiten. Lesen Sie hier mehr dazu.

{related-start}
xref:notification_rules#[Benachrichtigungen per Regel steuern]
xref:personal_notifications#[Persönliche Benachrichtigungsregeln]
xref:commands#[Kommandos]
xref:wato_user#[Benutzer, Zuständigkeiten, Berechtigungen]
{related-end}


[#intro]
== Einleitung

[{image-left}]
image::notifications_large_icon_notifications.png[alt="Symbol einer Benachrichtigung.",width=80]

Benachrichtigung bedeutet, dass Benutzer im Falle von Problemen oder anderen Ereignissen im Monitoring von {CMK} aktiv informiert werden.
Im häufigsten Fall geschieht das durch E-Mails.
Es gibt aber auch viele andere Methoden, wie z.B. das Versenden von SMS oder die Weiterleitung an ein Ticketsystem.
{CMK} bietet eine einfache Schnittstelle, um für eigene Benachrichtigungsmethoden Skripte zu schreiben.

Ausgangspunkt für jede Benachrichtigung an einen Benutzer ist ein vom Monitoring-Kern gemeldetes Ereignis.
ifdef::saas[]
Wir nennen dies im folgenden *Monitoring-Ereignis*.
endif::[]
ifdef::onprem[]
Wir nennen dies im folgenden *Monitoring-Ereignis*, um Verwechslungen mit den Ereignissen zu vermeiden, die von der xref:ec#[Event Console] verarbeitet werden.
endif::[]
Ein Monitoring-Ereignis bezieht sich immer auf einen bestimmten Host oder Service.
Mögliche Typen von Monitoring-Ereignissen sind:

* Ein Zustandswechsel, z.B. {OK} → {WARN}
* Der Wechsel zwischen einem stetigen und einem icon:icon_flapping[alt="Symbol zur Anzeige des unstetigen Zustands."] unstetigen (_flapping_) Zustand
* Start oder Ende einer icon:icon_downtime[alt="Symbol einer Wartungszeit."] xref:basics_downtimes#[Wartungszeit]
* Die icon:icon_ack[alt="Symbol zur Anzeige der Quittierung."] xref:basics_ackn.html[Quittierung eines Problems] durch einen Benutzer
* Eine durch ein icon:icon_commands[alt="Symbol zur Anzeige eines Kommandos."] xref:commands#[Kommando] manuell ausgelöste Benachrichtigung
ifdef::onprem[]
* Die Ausführung eines icon:icon_alert_handlers[alt="Symbol eines Alert Handlers."] xref:alert_handlers#[Alert Handlers]
* Ein Ereignis, das von der icon:icon_event_console[alt="Symbol der Event Console."] xref:ec#[Event Console] zur Benachrichtigung übergeben wurde
endif::[]

{CMK} verfügt über ein regelbasiertes System, mit dem Sie aus diesen Monitoring-Ereignissen Benutzerbenachrichtigungen erstellen lassen können, und mit dem Sie auch sehr anspruchsvolle Anforderungen umsetzen können.
Eine einfache Benachrichtigung per E-Mail -- wie sie in vielen Fällen zunächst völlig ausreicht -- ist trotzdem schnell eingerichtet.


[#notify_or_not]
== Benachrichtigen oder (noch) nicht benachrichtigen?

Grundsätzlich sind Benachrichtigungen optional und Sie können {CMK} durchaus auch ohne diese sinnvoll nutzen.
Manche großen Unternehmen haben eine Art Leitstand, in der das Monitoring-Team die {CMK}-Oberfläche ständig im Blick hat und keine zusätzlichen Benachrichtigungen benötigt.
Wenn Sie noch im Aufbau Ihrer {CMK}-Umgebung sind, sollten Sie außerdem bedenken, dass Benachrichtigungen erst dann für Ihre Kollegen eine Hilfe sind, wenn keine oder nur selten *Fehlalarme* (_false positives_) produziert werden.
Dazu müssen Sie erst einmal die Schwellwerte und alle anderen Einstellungen soweit im Griff haben, dass im Normalfall alle Zustände {OK} / {UP} sind oder mit anderen Worten: alles „grün“ ist.

Die Akzeptanz für das neue Monitoring ist schnell dahin, wenn es den Posteingang jeden Tag mit Hunderten nutzloser E-Mails flutet.

Folgendes Vorgehen hat sich bewährt:

*Schritt 1:* Feinjustieren Sie das Monitoring, indem Sie einerseits die durch {CMK} neu aufgedeckten, tatsächlichen Probleme beheben und andererseits Fehlalarme eliminieren.
Tun Sie das, bis im Normalfall alles {OK} / {UP} ist.
Im xref:intro_finetune#filesystems[Leitfaden für Einsteiger] finden Sie einige Empfehlungen, um typische Fehlalarme zu reduzieren.

*Schritt 2:* Schalten Sie Benachrichtigungen zunächst nur für sich selbst ein.
Reduzieren Sie das „Rauschen“, welches durch sporadisch kurz auftretende Probleme verursacht wird.
Passen Sie dazu weitere Schwellwerte an, nutzen Sie ggf. das xref:predictive_monitoring#[prognosebasierte Monitoring], erhöhen Sie die xref:repeated_check_attempts[Anzahl der Check-Versuche] oder versuchen Sie es mit der xref:delaying[verzögerten Benachrichtigung].
Wenn es sich allerdings um tatsächliche Probleme handelt, sollten Sie deren Ursache finden, um sie in den Griff zu bekommen.

*Schritt 3:* Erst wenn in Ihrem eigenen Posteingang einigermaßen Ruhe eingekehrt ist, schalten Sie die Benachrichtigungen für Ihre Kollegen ein.
Richten Sie dazu sinnvolle Kontaktgruppen ein, so dass jeder nur solche Benachrichtigungen bekommt, die ihn auch wirklich etwas angehen.

Das Ergebnis ist ein sehr nützliches System, das Ihnen und Ihren Kollegen hilft, mit relevanten Informationen Ausfallzeiten zu reduzieren.


[#conditions]
== Wann Benachrichtigungen erzeugt werden und wie man damit umgeht

=== Einleitung

Ein großer Teil der Komplexität im Benachrichtigungssystem von {CMK} liegt in den zahlreichen Tuning-Möglichkeiten, mit denen unwichtige Benachrichtigungen vermieden werden können.
Die meisten davon betreffen Situationen, in denen bereits beim Auftreten der Monitoring-Ereignisse Benachrichtigungen verzögert oder unterdrückt werden.
Auch gibt es eine im Monitoring-Kern eingebaute Intelligenz, die bestimmte Benachrichtigungen von Haus aus unterdrückt.
Alle diese Aspekte wollen wir Ihnen in diesem Kapitel vorstellen.


=== Wartungszeiten

[{image-left}]
image::notifications_large_icon_downtime.png[alt="Symbol einer Wartungszeit.",width=50]

Während sich ein Host oder Service in einer xref:glossar#scheduled_downtime[Wartungszeit] befindet, sind für dieses Objekt die Benachrichtigungen unterdrückt.
Das ist -- neben einer korrekten Berechnung von Verfügbarkeiten -- der wichtigste Grund, warum man überhaupt eine Wartungszeit im Monitoring hinterlegt.
Interessant sind dabei folgende Details:

* Ist ein Host in Wartung, dann gelten automatisch auch alle seine Services als in Wartung, ohne dass man explizit eine Wartung für diese eintragen muss.
* Endet die Wartungszeit eines Objekts, das _während_ der Wartungszeit in einen Problemzustand gewechselt hat, dann werden für dieses Problem exakt beim Ablauf der Wartung _nachträglich_ Benachrichtigungen ausgelöst.
* Der Beginn und das Ende einer Wartungszeit selbst sind auch Monitoring-Ereignisse, für die Benachrichtigungen ausgelöst werden.


=== Benachrichtigungsperioden

[{image-left}]
image::notifications_large_icon_outofnot.png[alt="Symbol einer inaktiven Benachrichtigungsperiode.",width=50]

Per Konfiguration können Sie für jeden Host und Service eine Benachrichtigungsperiode festlegen.
Dies ist eine xref:glossar#time_period[Zeitperiode], welche die Zeiträume festlegt, auf die Benachrichtigungen beschränkt werden sollen.

Die Konfiguration geschieht über die Regelsätze [.guihint]#Notification period for hosts# bzw. [.guihint]#Notification period for services#, die Sie schnell über die xref:user_interface#search_setup[Suche im Setup-Menü] finden können.
Ein Objekt, welches sich gerade *nicht* in seiner Benachrichtigungsperiode befindet, wird durch ein graues Pause-Zeichen icon:icon_outofnot[alt="Symbol einer inaktiven Benachrichtigungsperiode."] markiert.

Monitoring-Ereignisse zu einem Objekt, das sich gerade außerhalb seiner Benachrichtigungsperiode befindet, lösen keine Benachrichtigungen aus.
Benachrichtigungen werden nachgeholt, wenn die Benachrichtigungsperiode wieder aktiv wird und der Host/Service sich immer noch in einem Problemzustand befindet.
Dabei löst nur der jeweils letzte Zustand eine Benachrichtigung aus, auch wenn es außerhalb der Periode mehrere Zustandswechsel gab.

Übrigens gibt es auch bei den Benachrichtigungsregeln die Möglichkeit, Benachrichtigungen auf eine bestimmte Zeitperiode zu beschränken.
Damit können Sie die Zeiträume _zusätzlich_ einschränken.
Allerdings werden Benachrichtigungen, die durch eine Regel mit Zeitbedingung verworfen wurden, später *nicht* automatisch nachgeholt!


[#state_host]
=== Der Zustand des Hosts, auf dem ein Service läuft

Wenn ein Host komplett ausfällt oder zumindest für das Monitoring nicht erreichbar ist, können natürlich auch die Services des Hosts nicht mehr überwacht werden.
xref:active_checks#[Aktive Checks] werden dann in der Regel {CRIT} oder {UNKNOWN}, weil diese gezielt versuchen, den Host zu erreichen und dabei in einen Fehler laufen.
Alle anderen Checks -- also die überwiegende Mehrheit -- werden in so einem Fall ausgelassen und verharren in ihrem alten Zustand.
Sie werden mit der Zeit icon:icon_stale[] [.guihint]#stale#.

Natürlich wäre es sehr lästig, wenn alle Probleme von aktiven Checks in so einem Zustand Benachrichtigungen auslösen würden.
Denn wenn z. B. ein Webserver nicht erreichbar ist -- und dies auch schon als Benachrichtigung kommuniziert wurde -- wäre es wenig informativ, wenn nun auch für jeden einzelnen HTTP-Dienst, den dieser bereit stellt, eine E-Mail generiert würde.

Um dies zu vermeiden, erzeugt der Monitoring-Kern für Services grundsätzlich nur dann Benachrichtigungen, wenn der Host den Zustand {UP} hat.
Das ist auch der Grund, warum die Erreichbarkeit von Hosts separat überprüft wird.
Wenn Sie nichts anderes konfiguriert haben, geschieht dies durch einen xref:cmc_differences.html#smartping[Smart Ping] bzw. Ping.

ifdef::onprem[]
{cre-only}
Wenn Sie {RE} verwenden (oder eine der kommerziellen Editionen mit Nagios als Kern), dann kann es in seltenen Fällen bei einem Host-Problem trotzdem zu einer Benachrichtigung aufgrund eines aktiven Services kommen.
Der Grund liegt darin, dass Nagios die Resultate von Host-Checks für eine kurze Zeit in der Zukunft als gültig betrachtet.
Wenn zwischen dem letzten erfolgreichen Ping an den Server und dem nächsten aktiven Check nur wenige Sekunden vergehen, kann es sein, dass Nagios den Host noch als {UP} wertet, obwohl dieser bereits {DOWN} ist.
Der xref:cmc#[{CMK} Micro Core (CMC)] hingegen hält die Service-Benachrichtigung solange in Wartestellung, bis der Zustand des Hosts geklärt ist und vermeidet die unerwünschte Benachrichtigung so zuverlässig.
endif::[]


[#parents]
=== Parent-Hosts

Stellen Sie sich vor, ein wichtiger Netzwerk-Router zu einem Unternehmensstandort mit Hunderten von Hosts fällt aus.
Alle Hosts sind dann für das Monitoring nicht mehr erreichbar und gehen auf {DOWN}.
Hunderte Benachrichtigungen werden ausgelöst.
Nicht sehr schön.

Um das zu vermeiden, können Sie den Router als xref:hosts_structure#parents[Parent-Host] der Hosts definieren.
Wenn es redundante Routen gibt, kann man auch mehrere Parents definieren.
Sobald alle Parents auf {DOWN} gehen, werden die nicht mehr erreichbaren Hosts auf den Zustand {UNREACH} gesetzt und die darauf basierenden Benachrichtigungen werden unterdrückt.
Das Problem mit dem Router selbst löst hingegen durchaus eine Benachrichtigung aus.

ifdef::onprem[]
{cee-only}
Der CMC verhält sich intern übrigens geringfügig anders als Nagios.
endif::[]
Um Fehlalarme zu vermeiden, richtige Benachrichtigungen aber korrekt abzusetzen, achtet der xref:cmc#[CMC] sehr genau auf die exakten Zeitpunkte der jeweiligen Host-Checks.
Scheitert ein Host-Check, so wartet der Kern zunächst das Ergebnis des Host-Checks der Parent-Hosts ab, bevor eine Benachrichtigung erzeugt wird.
Dieses Warten geschieht asynchron und ohne das übrige Monitoring zu beeinträchtigen.
Benachrichtigungen von Hosts können sich dadurch geringfügig verzögern.


== Die Steuerung von Benachrichtigungen


=== Das Prinzip

{CMK} ist „ab Werk“ so eingerichtet, dass es bei einem Monitoring-Ereignis an jeden xref:wato_user#contact_groups[Kontakt] des betroffenen Hosts oder Services eine Benachrichtigung per E-Mail versendet.
Das ist sicher erst einmal sinnvoll, aber in der Praxis tauchen viele weitergehende Anforderungen auf, z. B.:

* Unterdrücken bestimmter, wenig nützlicher Benachrichtigungen.
* „Abonnieren“ von Benachrichtigungen zu Services, für die man kein Kontakt ist.
* Benachrichtigen per E-Mail, SMS oder Pager, abhängig von der Tageszeit.
* Eskalieren von Problemen nach einer bestimmten Zeit ohne xref:basics_ackn#[Quittierung.]
* Eventuell keine Benachrichtigungen für {WARN} oder {UNKNOWN} erhalten.
* und vieles mehr{nbsp}...

{CMK} bietet Ihnen über einen regelbasierten Mechanismus maximale Flexibilität bei der Umsetzung solcher Anforderungen.

In der Benachrichtigungskonfiguration verwalten Sie die *Kette der Benachrichtigungsregeln,* welche festlegen, _wer_  _wie_ benachrichtigt werden soll.
Bei jedem Monitoring-Ereignis wird diese Regelkette von _oben nach unten_ durchlaufen.
Jede Regel hat eine Bedingung, die entscheidet, ob die Regel überhaupt zur Anwendung kommt.

Ist die Bedingung erfüllt, legt die Regel zwei Dinge fest:

* Eine Auswahl von Kontakten (_Wer_ soll benachrichtigt werden?)
* Eine Benachrichtigungsmethode (_Wie_ soll benachrichtigt werden?), z. B. HTML-E-Mail, und dazu optional Parameter für die Methode

*Wichtig:* Anders als bei den xref:wato_rules#[Regeln] für Hosts und Services geht die Auswertung hier auch nach einer zutreffenden Regel weiter.
Die nachfolgenden Regeln können weitere Benachrichtigungen hinzufügen.
Auch können Sie Benachrichtigungen wieder xref:notifications#cancel[löschen], welche vorherige Regeln generiert haben.

Das Endergebnis der Regelauswertung ist eine Tabelle, die etwa folgenden Aufbau hat:

[cols="30,30,~",options="header"]
|===
|Wer (Kontakt) |Wie (Methode) |Parameter der Methode
|Harry Hirsch |E-Mail |`Reply-To: \linux.group@example.com`
|Bruno Weizenkeim |E-Mail |`Reply-To: \linux.group@example.com`
|Bruno Weizenkeim |SMS |
|===

Nun wird pro Eintrag in dieser Tabelle das zur Methode gehörende xref:scripts[Benachrichtigungsskript] aufgerufen, welches die eigentliche Benutzerbenachrichtigung durchführt.


=== Zwei Wege, um Benachrichtigungen einzustellen

Generell unterscheidet {CMK} zwei Formen der Einstellung von Benachrichtigungen.
Einerseits werden die Regeln für Benachrichtigungen global definiert.
Diese Regeln gelten ereignisabhängig für alle betroffenen Benutzer und Gruppen.
Die Erstellung dieser Benachrichtigungen wird unter xref:notification_rules#[Benachrichtigungen (notifications) per Regel steuern] beschrieben.

Gleichzeitig hat jeder Benutzer die Möglichkeit, die Einstellung der Benachrichtigungen individuell zu beeinflussen.
So kann jemand zum Beispiel während einer Urlaubsperiode die Zustellung von Benachrichtigungen an die eigene Person deaktivieren.
Wie diese persönlichen Einstellungen umgesetzt werden können, lesen Sie im Artikel xref:personal_notifications#[Persönliche Benachrichtigungen (personal notifications).]


=== Benachrichtigungen abschalten

==== Per Regel

Über die Regelsätze [.guihint]#Enable/disable notifications for hosts# bzw. [.guihint]#Enable/disable notifications for services# können Sie Hosts und Services bestimmen, aufgrund derer grundsätzlich keine Benachrichtigungen erzeugt werden sollen.
Wie oben erwähnt, unterbindet dann bereits der Kern die Benachrichtigungen.
Eine Benachrichtigungsregel für ein „Abonnieren“ solcher Benachrichtigungen wäre wirkungslos, da diese ja gar nicht erzeugt werden.


==== Per Kommando

[{image-left}]
image::notifications_large_icon_notif_man_disabled.png[alt="Symbol einer deaktivierten Benachrichtigung.",width=50]

Es ist grundsätzlich möglich, die Benachrichtigungen bezogen auf einzelne Hosts und Services auch per xref:commands.html[Kommando] vorübergehend abzuschalten.

Voraussetzung dafür ist allerdings, dass die xref:wato_user#roles[Berechtigung] [.guihint]#Commands on host and services > Enable/disable notifications# der Benutzerrolle zugewiesen ist. Standardmäßig ist dies für *keine* Rolle der Fall.

Mit zugewiesener Berechtigung können Sie Benachrichtigungen in den Host- oder Serviceansichten mit dem Kommando [.guihint]#Commands > Enable/disable notifications# abschalten (und später auch wieder einschalten):

image::notifications_commands_disable.png[alt="Kommando zur Aktivierung und Deaktivierung der Benachrichtigungen."]

Solche Hosts oder Services werden dann mit dem Symbol icon:icon_notif_man_disabled[] markiert.

Da Kommandos im Gegensatz zu Regeln weder eine Konfigurationsberechtigung noch ein xref:wato#activate_changes[Aktivieren der Änderungen] benötigen, können sie daher eine Lösung sein, um auf eine Situation schnell zu reagieren.

*Wichtig:* Im Gegensatz zu icon:icon_downtime[alt="Symbol einer Wartungszeit."] Wartungszeiten haben abgeschaltete Benachrichtigungen keinen Einfluss auf die Berechnung der xref:availability#[Verfügbarkeit.]
Wenn Sie also während eines ungeplanten Ausfalls einfach nur die Benachrichtigungen abschalten, aber Ihre Verfügbarkeitsberechnung nicht verfälschen möchten, sollten Sie keine Wartungszeiten dafür eintragen!


[#global]
==== Global

Im Snapin [.guihint]#Master control# der Seitenleiste finden Sie einen Hauptschalter für die Benachrichtigungen ([.guihint]#Notifications#):

image::notifications_master_control.png[alt="Das Snapin Master control.",width=50%]

Dieser Schalter ist ausgesprochen nützlich, wenn Sie am System größere Änderungen vornehmen, durch die bei einem Fehler unter Umständen eine Vielzahl von Services auf {CRIT} geht.
Sie ersparen sich so den Unmut Ihrer Kollegen über die vielen nutzlosen E-Mails.
Vergessen Sie aber nicht, die Benachrichtigungen später wieder einzuschalten.

ifdef::onprem[]
Im xref:distributed_monitoring#[verteilten Monitoring] gibt es diesen Schalter einmal pro Instanz.
Ein Abschalten der Benachrichtigungen auf der Zentralinstanz lässt Benachrichtigungen auf den Remote-Instanzen weiterhin aktiviert -- selbst wenn diese zur Zentralinstanz weitergeleitet und von dort zugestellt werden.
endif::[]

*Wichtig:* Benachrichtigungen, die angefallen wären, während die Benachrichtigungen abgeschaltet waren, werden beim Wiedereinschalten *nicht* nachgeholt.


[#delaying]
=== Benachrichtigungen verzögern

Vielleicht haben Sie Services, die gelegentlich für kurze Zeit in einen Problemzustand gehen, der aber nur sehr kurz anhält und für Sie nicht kritisch ist.
In solchen Fällen sind Benachrichtigungen sehr lästig, aber auch einfach zu unterdrücken.
Dazu dienen die Regelsätze [.guihint]#Delay host notifications# und [.guihint]#Delay service notifications.#

Sie legen hier einen Zeitraum fest. Eine Benachrichtigung wird dann solange zurückgehalten, bis diese Zeit abgelaufen ist.
Tritt vorher der {OK} / {UP}-Zustand wieder ein, so wird keine Benachrichtigung erzeugt.
Natürlich bedeutet das aber dann auch, dass Sie im Falle eines _wirklichen_ Problems erst mit einer Verzögerung benachrichtigt werden.

Viel besser als eine Verzögerung der Benachrichtigungen ist es natürlich, den eigentlichen Grund der sporadischen Probleme loszuwerden. Aber das ist eine andere Geschichte ...


[#repeated_check_attempts]
=== Mehrere Check-Versuche

Eine zur Verzögerung der Benachrichtigungen sehr ähnliche Methode ist es, mehrere Check-Versuche zu erlauben, wenn ein Service in einen Problemzustand geht.
Dies geschieht über die Regelsätze [.guihint]#Maximum number of check attempts for host# bzw. [.guihint]#Maximum number of check attempts for service.#

Wenn Sie hier z. B. eine `3` einstellen, dann führt ein Check mit dem Resultat {CRIT} zunächst zu keiner Benachrichtigung.
Man spricht dann zunächst von einem weichen {CRIT}-Zustand (_soft state_).
Der harte Zustand (_hard state_) ist dann immer noch {OK}.
Erst wenn drei Versuche in Folge zu keinem {OK}-Zustand führen, wechselt der Service den harten Zustand und eine Benachrichtigung wird ausgelöst.

Im Gegensatz zur verzögerten Benachrichtigung haben Sie hier noch die Möglichkeit, sich Tabellenansichten zu definieren, welche solche Probleme ausblenden.
Auch xref:bi#[BI-Aggregate] können so gebaut werden, dass nur die harten Zustände berücksichtigt werden, nicht die weichen.


[#flapping]
=== Unstetige Hosts und Services

[{image-left}]
image::notifications_large_icon_flapping.png[alt="Symbol zur Anzeige des unstetigen Zustands.",width=50]

Wenn ein Host oder Service binnen kurzer Zeit mehrfach den Zustand ändert, so gilt er als unstetig (_flapping_).
Dies ist sozusagen ein eigener Zustand.
Die Idee dabei ist das Vermeiden von exzessiven Benachrichtigungen in Phasen, in denen ein Service nicht (ganz) stabil läuft.
Auch in der xref:availability#[Verfügbarkeitsberechnung] können Sie solche Phasen speziell auswerten.

Unstetige Objekte werden mit dem Symbol icon:icon_flapping[alt="Symbol zur Anzeige des unstetigen Zustands."] markiert.
Während ein Objekt unstetig ist, erzeugen weitere Zustandswechsel keine Benachrichtigungen mehr.
Dafür wird aber jeweils eine Benachrichtigung ausgelöst, wenn das Objekt in den Zustand unstetig ein- oder austritt.

Sie können die Erkennung von Unstetigkeiten auf folgende Arten beeinflussen:

* Die [.guihint]#Master control# hat einen Hauptschalter für die Erkennung von Unstetigkeiten: [.guihint]#Flap Detection#
* Über die Regelsätze [.guihint]#Enable/disable flapping detection for hosts# bzw. [.guihint]#Enable/disable flapping detection for services# können Sie Objekte von der Erkennung ausklammern.
ifdef::onprem[]
* In den kommerziellen Editionen können Sie 
endif::[]
ifdef::saas[]
* Sie können 
endif::[]
mit [.guihint]#Global settings > Monitoring core > Tuning of flap detection# die Parameter der Unstetigkeitserkennung festlegen und sie mehr oder weniger empfindlich einstellen:

image::notifications_tuning_flap_detection.png[alt="Globale Einstellungen zur Unstetigkeitsbehandlung."]

Blenden Sie die kontextsensitive Hilfe ein mit [.guihint]#Help > Show inline help# für Details zu den einstellbaren Werten.

////
[#repeat_escalate]
=== Periodisch wiederholte Benachrichtigungen und Eskalationen

Bei manchen Systemen kann es sinnvoll sein, es nicht bei einer einzelnen Benachrichtigung zu belassen, falls das Problem über einen längeren Zeitraum weiterhin besteht, z. B. bei Hosts, deren xref:glossar#host_tag[Host-Merkmal] [.guihint]#Criticality# auf [.guihint]#Business critical# gesetzt ist.


==== Periodisch wiederholte Benachrichtigungen einrichten

Sie können {CMK} so einrichten, dass es in einem festen Intervall immer weitere Benachrichtigungen versendet, solange bis das Problem entweder icon:icon_ack[alt="Symbol zur Anzeige der Quittierung."] xref:basics_ackn#[quittiert] oder behoben wurde.

Die Einstellung dafür finden Sie in den Regelsätzen [.guihint]#Periodic notifications during host problems# bzw. [.guihint]#Periodic notifications during service problems:#

image::notifications_periodic.png[alt="Regel für periodisch wiederholte Benachrichtigungen."]

Sobald diese Option aktiv ist, wird {CMK} für ein fortbestehendes Problem im konfigurierten Intervall weitere Benachrichtigungen erzeugen.
Die Benachrichtigungen bekommen eine laufende Nummer, welche bei 1 (für die erste Benachrichtigung) beginnt.

Periodische Benachrichtigungen haben nicht nur den Nutzen, das Problem immer wieder in Erinnerung zu rufen (also den Operator damit zu _nerven_), sondern sie bilden auch die Grundlage für _Eskalationen._
Dies bedeutet, dass nach Ablauf einer bestimmten Zeit die Benachrichtigung an andere Personen eskaliert werden kann.


==== Eskalationen aufbauen und verstehen

Um eine Eskalation einzurichten, erzeugen Sie zusätzlich eine Benachrichtigungsregel, welche die Bedingung [.guihint]#Restrict to notification number# verwendet.

image::notifications_escalation.png[alt="Regel zur Einstellung der Häufigkeit von Benachrichtigungen."]

Tragen Sie hier als Bereich für den Zähler 3 bis 99999 ein, so greift diese Regel ab der dritten Benachrichtigung.
Diese Eskalation kann dann entweder durch die Wahl einer anderen Methode (z.B. SMS) erfolgen oder durch die Benachrichtigung von anderen Personen (Kontaktauswahl).

Mit der Option [.guihint]#Throttle periodic notifications# können Sie die Rate der wiederholten Benachrichtigungen nach einer bestimmten Zeit reduzieren. So können Sie z.B. zunächst jede Stunde eine E-Mail senden lassen und später das Ganze auf einmal am Tag beschränken.

Mit mehreren Benachrichtigungsregeln können Sie ein Eskalationsmodell aufbauen.
Aber wie läuft diese Eskalation dann ab?
Wer wird wann informiert?
Hierzu ein Beispiel, umgesetzt mit einer Regel für periodisch wiederholte Benachrichtigungen und drei Benachrichtigungsregeln:

* Ein Service löst im Problemfall alle 60 Minuten eine Benachrichtigung, z.B. in Form einer E-Mail, aus, solange bis das Problem behoben oder bestätigt wird.
* Die Benachrichtigungen eins bis fünf gehen an die zwei zuständigen Mitarbeiter.
* Die Benachrichtigungen sechs bis zehn gehen zusätzlich an den betreffenden Teamleiter.
* Ab Benachrichtigung elf geht stattdessen täglich eine Mail an die Firmenleitung.

Morgens um 9 Uhr tritt im Betrieb ein Problem auf.
Die beiden Mitarbeiter werden benachrichtigt, reagieren aber nicht (aus welchen Gründen auch immer).
So bekommen sie um 10, 11, 12 und 13 Uhr jeweils eine weitere E-Mail.
Ab der sechsten Benachrichtigung um 14 Uhr bekommt nun zusätzlich auch der Teamleiter eine E-Mail -- trotzdem ändert sich weiterhin nichts am Problem.
So werden um 15, 16, 17 und 18 Uhr weitere E-Mails an die Mitarbeiter und an den Teamleiter verschickt.

Um 19 Uhr greift die dritte Eskalationsstufe:
ab jetzt werden keine E-Mails mehr an die Mitarbeiter oder den Teamleiter verschickt.
Stattdessen bekommt die Firmenleitung bis zur Problembehebung nun täglich um 19 Uhr eine E-Mail.

Sobald das Problem behoben ist und der Service in {CMK} wieder auf {OK} geht, wird automatisch eine „Entwarnung“ an den zuletzt benachrichtigten Personenkreis versandt:
Im obigen Beispiel also bei einer Problembehebung vor 14 Uhr an die beiden Mitarbeiter, bei einer Problembehebung zwischen 14 und 19 Uhr an die Mitarbeiter und den Teamleiter und nach 19 Uhr nur noch an die Firmenleitung.
////

[#path]
== Der Weg einer Benachrichtigung von Anfang bis Ende


[#history]
=== Die Benachrichtigungshistorie

Zum Einstieg zeigen wir Ihnen, wie Sie sich in {CMK} die Historie der Benachrichtigungen auf Host- und Service-Ebene anzeigen lassen und so den Benachrichtigungsprozess nachverfolgen können.

Ein Monitoring-Ereignis, das {CMK} veranlasst, eine Benachrichtigung auszulösen, ist z. B. der Zustandswechsel eines Services.
Diesen Zustandswechsel können Sie mit dem xref:commands#[Kommando] [.guihint]#Fake check results# zu Testzwecken manuell veranlassen.

Für einen Benachrichtigungstest können Sie einen Service auf diese Weise vom Zustand {OK} nach {CRIT} versetzen.
Wenn Sie sich jetzt auf der Seite der Service-Details die Benachrichtigungen für diesen Service mit [.guihint]#Service > Service notifications# anzeigen lassen, sehen Sie die folgenden Einträge:

image::notifications_list.png[alt="Liste aufgelaufener Benachrichtigungen für einen Service."]

Der aktuellste Eintrag steht ganz oben in der Liste. Los ging es aber mit dem untersten, daher sehen wir uns die einzelnen Einträge von unten nach oben an:

. Der Monitoring-Kern protokolliert das Monitoring-Ereignis des Zustandswechsels.
Dabei zeigt das icon:icon_alert_crit[] Symbol in der 1. Spalte den Zustand an (im Beispiel {CRIT}).

. Der Monitoring-Kern erzeugt eine icon:icon_alert_cmk_notify[] Rohbenachrichtigung (_raw notification_).
Diese wird vom Kern an das Benachrichtigungsmodul übergeben, welches die Auswertung der Benachrichtigungsregeln durchführt.

. Die Auswertung der Regeln ergibt eine icon:icon_alert_notify[] Benutzerbenachrichtigung (_user notification_) an den Benutzer `hh` mit der Methode `mail`.

. Das icon:icon_alert_notify_result[] Benachrichtigungsergebnis (_notification result_) zeigt, dass die E-Mail erfolgreich an den SMTP-Server zur Auslieferung übergeben wurde.

Um die Zusammenhänge von allen Einstellmöglichkeiten und Rahmenbedingungen genau zu verstehen und um eine sinnvolle Fehlerdiagnose zu ermöglichen, wenn mal eine Benachrichtigung nicht wie erwartet erfolgt oder ausbleibt, beschreiben wir im folgenden alle Einzelheiten zum Ablauf einer Benachrichtigung mit allen beteiligten Komponenten.

[TIP]
====
Die Benachrichtigungshistorie, die wir oben für einen Service gezeigt haben, können Sie sich auch für einen Host anzeigen lassen: auf der Seite der Host-Details im Menü [.guihint]#Host# für den Host selbst (Menüeintrag [.guihint]#Notifications of host#) und auch für den Host mit all seinen Services ([.guihint]#Notifications of host & services#).
====


=== Die Komponenten

Im Benachrichtigungssystem von {CMK} sind folgende Komponenten beteiligt:

ifdef::onprem[]
[cols="30,~,25",options="header"]
|===
|Komponente |Aufgabe |Log-Datei
|Nagios |Monitoring-Kern von {CRE}, der Monitoring-Ereignisse erkennt und Rohbenachrichtigungen erzeugt. |`~/var/log/nagios.log +
~/var/nagios/debug.log`
|xref:cmc#[{CMK} Micro Core (CMC)] |Monitoring-Kern der kommerziellen Editionen, der die gleiche Aufgabe erfüllt wie Nagios in {RE}. |`~/var/log/cmc.log`
|Benachrichtigungsmodul |Auswertung der Benachrichtigungsregeln, um aus einer Rohbenachrichtigung eine Benutzerbenachrichtigung zu erzeugen. Das Modul ruft die Benachrichtigungsskripte auf. |`~/var/log/notify.log`
|Benachrichtigungs-Spooler (nur kommerzielle Editionen) |Asynchrone Zustellung von Benachrichtigungen und zentralisierte Benachrichtigungen in verteilten Umgebungen. |`~/var/log/mknotifyd.log`
|Benachrichtigungsskript |Für jede Benachrichtigungsmethode gibt es ein Skript, welches die eigentliche Zustellung durchführt (z.B. eine HTML-E-Mail generiert und versendet). |`~/var/log/notify.log`
|===
endif::[]

ifdef::saas[]
[cols="30,~",options="header"]
|===
|Komponente |Aufgabe
|xref:cmc#[{CMK} Micro Core (CMC)] |Monitoring-Kern, der Monitoring-Ereignisse erkennt und Rohbenachrichtigungen erzeugt.
|Benachrichtigungsmodul |Auswertung der Benachrichtigungsregeln, um aus einer Rohbenachrichtigung eine Benutzerbenachrichtigung zu erzeugen.
Das Modul ruft die Benachrichtigungsskripte auf.
|Benachrichtigungsskript |Für jede Benachrichtigungsmethode gibt es ein Skript, welches die eigentliche Zustellung durchführt (z.B. eine HTML-E-Mail generiert und versendet).
|===
endif::[]


=== Der Monitoring-Kern

==== Rohbenachrichtigungen

Wie oben beschrieben, beginnt jede Benachrichtigung mit einem Monitoring-Ereignis im Monitoring-Kern.
Wenn alle Bedingungen erfüllt sind und es grünes Licht für eine Benachrichtigung gibt, erzeugt der Kern eine _Rohbenachrichtigung_ an den internen Hilfskontakt [.guihint]#check-mk-notify.#
Die Rohbenachrichtigung enthält noch keine Angabe zu den eigentlichen Kontakten oder der Benachrichtigungsmethode.

In der Benachrichtigungshistorie des Services sieht eine Rohbenachrichtigung so aus:

image::notifications_raw.png[alt="Eine Rohbenachrichtigung in der Benachrichtigungshistorie."]

* Das Symbol ist ein icon:icon_alert_cmk_notify[] hellgrauer Lautsprecher.
* Als Kontakt wird `check-mk-notify` angegeben.
* Als Benachrichtigungskommando wird `check-mk-notify` angegeben.

Die Rohbenachrichtigung geht dann an das Benachrichtigungsmodul von {CMK}, welches die Auswertung der Benachrichtigungsregeln übernimmt.
ifdef::onprem[]
Dieses Modul wird von Nagios als externes Programm aufgerufen (`cmk --notify`).
endif::[]
Der CMC hält das Modul als permanenten Hilfsprozess in Bereitschaft (_notification helper_) und vermeidet so das Erzeugen von Prozessen, um Rechenzeit zu sparen.


ifdef::onprem[]
==== Fehlerdiagnose im Monitoring-Kern Nagios

{cre-only}
Der in {CRE} verwendete Nagios-Kern protokolliert alle Monitoring-Ereignisse nach `~/var/log/nagios.log`.
Diese Datei ist gleichzeitig der Ort, wo die Benachrichtigungshistorie gespeichert wird, welche Sie auch in der GUI abfragen, wenn Sie z.B. die Benachrichtigungen eines Hosts oder Services sehen möchten.

Interessanter sind aber die Meldungen in der Datei `~/var/nagios/debug.log`, welche Sie bekommen, wenn Sie in `etc/nagios/nagios.d/logging.cfg` die Variable `debug_level` auf `32` setzen.

Nach einem Core-Neustart{nbsp}...

[{shell}]
----
{c-omd} omd restart nagios
----

&#8230; finden Sie nützliche Informationen über Gründe, warum Benachrichtigungen erzeugt oder unterdrückt wurden:

.~/var/nagios/debug.log
[{file}]
----
[1592405483.152931] [032.0] [pid=18122] ** Service Notification Attempt ** Host: 'localhost', Service: 'backup4', Type: 0, Options: 0, Current State: 2, Last Notification: Wed Jun 17 16:24:06 2020
[1592405483.152941] [032.0] [pid=18122] Notification viability test passed.
[1592405485.285985] [032.0] [pid=18122] 1 contacts were notified.  Next possible notification time: Wed Jun 17 16:51:23 2020
[1592405485.286013] [032.0] [pid=18122] 1 contacts were notified.
----


==== Fehlerdiagnose im Monitoring-Kern CMC

{cee-only}
In den kommerziellen Editionen finden Sie in der Log-Datei `~/var/log/cmc.log` ein Protokoll des Monitoring-Kerns.
In der Standardeinstellung enthält dies keine Angaben zu Benachrichtigungen.
Sie können aber ein sehr detailliertes Logging einschalten, mit [.guihint]#Global settings > Monitoring Core > Logging of the notification mechanics.#
Der Kern gibt dann darüber Auskunft, warum er ein Monitoring-Ereignis für die Benachrichtigung an das Benachrichtigungsmodul weitergibt oder warum (noch) nicht:

[{shell}]
----
{c-omd} tail -f var/log/cmc.log
2021-08-26 16:12:37 [5] [core 27532] Executing external command: PROCESS_SERVICE_CHECK_RESULT;mysrv;CPU load;1;test
2021-08-26 16:12:43 [5] [core 27532] Executing external command: LOG;SERVICE NOTIFICATION: hh;mysrv;CPU load;WARNING;mail;test
2021-08-26 16:12:52 [5] [core 27532] Executing external command: LOG;SERVICE NOTIFICATION RESULT: hh;mysrv;CPU load;OK;mail;success 250 - b'2.0.0 Ok: queued as 482477F567B';success 250 - b'2.0.0 Ok: queued as 482477F567B'
----

*Hinweis:* Das eingeschaltete Logging zu Benachrichtigungen kann sehr viele Meldungen erzeugen.
Es ist aber nützlich, wenn man später die Frage beantworten will, warum in einer bestimmten Situation _keine_ Benachrichtigung erzeugt wurde.
endif::[]


[#rule_analysis]
=== Regelauswertung durch das Benachrichtigungsmodul

Nachdem der Kern eine Rohbenachrichtigung erzeugt hat, durchläuft diese die Kette der Benachrichtigungsregeln.
Resultat ist die Benachrichtigungstabelle.
Neben den Daten aus der Rohbenachrichtigung enthält jede Benutzerbenachrichtigung folgende zusätzliche Informationen:

* Der Kontakt, der benachrichtigt werden soll
* Die Methode für die Benachrichtigung
* Die Parameter für diese Methode

Bei einer synchronen Zustellung wird jetzt pro Eintrag in der Tabelle das passende xref:scripts[Benachrichtigungsskript] aufgerufen.
ifdef::onprem[]
Bei einer xref:async[asynchronen Zustellung] wird die Benachrichtigung per Datei an den Benachrichtigungs-Spooler übergeben.
endif::[]


==== Analyse der Regelkette

Wenn Sie komplexere Regelwerke erstellen, stehen Sie sicher gelegentlich vor der Frage, welche Regeln denn nun für eine bestimmte Benachrichtigung greifen.
Dazu bietet {CMK} unter [.guihint]#Setup > Setup > Analyze recent notifications# eine eingebaute Analysefunktion.

Im Analysemodus werden Ihnen standardmäßig die letzten zehn Rohbenachrichtigungen angezeigt, die das System erzeugt hat und welche die Regeln durchlaufen haben:

image::notifications_analysis.png[alt="Liste der der letzten 10 Rohbenachrichtigungen im Analysemodus."]

Sollten Sie für Ihre Analyse eine größere Menge an Rohbenachrichtigungen benötigen, können Sie die Anzahl über [.guihint]#Global settings > Notifications > Store notifications for rule analysis# erhöhen:

image::notifications_storenotifications.png[alt="Globale Einstellung für die Anzahl angezeigter Rohbenachrichtigungen."]

Für jede dieser Rohbenachrichtigungen stehen Ihnen drei Aktionen zur Verfügung:

[cols="10,~"]
|===
|icon:icon_analyze[alt="Symbol zum Test der Regelkette."] |Test der Regelkette, in dem für jede Regel geprüft wird, ob das Monitoring-Ereignis alle Bedingungen der Regel erfüllen würde. Im Anschluss an die Regeln wird dann die daraus resultierende Benachrichtigungstabelle angezeigt.
|icon:icon_toggle_context[alt="Symbol zur Anzeige des Benachrichtigungskontexts."] |Anzeige des kompletten Benachrichtigungskontexts.
|icon:icon_reload_cmk[alt="Symbol für die Wiederholung der Rohbenachrichtigung."] |Wiederholung der Rohbenachrichtigung, als wäre das Monitoring-Ereignis jetzt aufgetreten. Ansonsten ist die Anzeige gleich wie bei der Analyse. Damit können Sie nicht nur die Bedingungen der Regel überprüfen, sondern auch testen, wie eine Benachrichtigung dann aussieht.
|===


==== Fehlerdiagnose

Haben Sie den Test der Regelkette (icon:icon_analyze[alt="Symbol zum Test der Regelkette".]) durchgeführt, so sehen Sie, welche Regeln auf ein Monitoring-Ereignis icon:icon_test_green[alt="Symbol in grün".] angewendet oder eben auch icon:icon_test_grey[alt="Symbol in grau".] nicht angewendet wurden:

image::notifications_test_rules.png[alt="Liste der angewendeten und nicht angewendeten Regeln."]

Wurde eine Regel nicht angewendet, bewegen Sie die Maus über den grauen Kreis, um den Hinweistext (Mouse-Over-Text) zu sehen:

image::notifications_mouseover.png[alt="Hinweistext bei einer nicht angewendeten Regel."]

Dieser Mouse-Over-Text verwendet jedoch für die Ursachen einer nicht angewendeten Regel Abkürzungen.
Diese beziehen sich auf die xref:notification_rules#rule_conditions[Bedingungen] [.guihint]#Host events# bzw. [.guihint]#Service events# der Regel.

[cols="10,33,~",options="header"]
|===
3+|Ereignistypen für Hosts
|*Kürzel* |*Bedeutung* |*Beschreibung*
|`rd` |UP ➤ DOWN |Setzt den Host-Zustand von {UP} auf {DOWN}
|`ru` |UP ➤ UNREACHABLE |Setzt den Host-Zustand von {UP} auf {UNREACH}
|`dr` |DOWN ➤ UP |Setzt den Host-Zustand von {DOWN} auf {UP}
|`du` |DOWN ➤ UNREACHABLE |Setzt den Host-Zustand von {DOWN} auf {UNREACH}
|`ud` |UNREACHABLE ➤ DOWN |Setzt den Host-Zustand von {UNREACH} auf {DOWN}
|`ur` |UNREACHABLE ➤ UP |Setzt den Host-Zustand von {UNREACH} auf {UP}
|`?r` |any ➤ UP |Setzt jeden beliebigen Host-Zustand auf {UP}
|`?d` |any ➤ DOWN |Setzt jeden beliebigen Host-Zustand auf {DOWN}
|`?u` |any ➤ UNREACHABLE |Setzt jeden beliebigen Host-Zustand auf {UNREACH}
|`f` |Start or end of flapping state |Anfang oder Ende eines unstetigen Zustands
|`s` |Start or end of a scheduled downtime |Anfang oder Ende einer Wartungszeit
|`x` |Acknowledgment of problem |Quittierung eines Problems
|`as` |Alert handler execution, successful |Erfolgreiche Ausführung eines Alert Handlers
|`af` |Alert handler execution, failed |Gescheiterte Ausführung eines Alert Handlers
|===

[cols="10,33,~",options="header"]
|===
3+|Ereignistypen für Services
|*Kürzel* |*Bedeutung* |*Beschreibung*
|`rw` |OK ➤ WARN |Setzt den Service-Zustand von {OK} auf {WARN}
|`rr` |OK ➤ OK |Setzt den Service-Zustand von {OK} auf {OK}
|`rc` |OK ➤ CRIT |Setzt den Service-Zustand von {OK} auf {CRIT}
|`ru` |OK ➤ UNKNOWN |Setzt den Service-Zustand von {OK} auf {UNKNOWN}
|`wr` |WARN ➤ OK |Setzt den Service-Zustand von {WARN} auf {OK}
|`wc` |WARN ➤ CRIT |Setzt den Service-Zustand von {WARN} auf {CRIT}
|`wu` |WARN ➤ UNKNOWN |Setzt den Service-Zustand von {WARN} auf {UNKNOWN}
|`cr` |CRIT ➤ OK |Setzt den Service-Zustand von {CRIT} auf {OK}
|`cw` |CRIT ➤ WARN |Setzt den Service-Zustand von {CRIT} auf {WARN}
|`cu` |CRIT ➤ UNKNOWN |Setzt den Service-Zustand von {CRIT} auf {UNKNOWN}
|`ur` |UNKNOWN ➤ OK |Setzt den Service-Zustand von {UNKNOWN} auf {OK}
|`uw` |UNKNOWN ➤ WARN |Setzt den Service-Zustand von {UNKNOWN} auf {WARN}
|`uc` |UNKNOWN ➤ CRIT |Setzt den Service-Zustand von {UNKNOWN} auf {CRIT}
|`?r` |any ➤ OK |Setzt jeden beliebigen Service-Zustand auf {OK}
|`?w` |any ➤ WARN |Setzt jeden beliebigen Service-Zustand auf {WARN}
|`?c` |any ➤ CRIT |Setzt jeden beliebigen Service-Zustand auf {CRIT}
|`?u` |any ➤ UNKNOWN |Setzt jeden beliebigen Service-Zustand auf {UNKNOWN}
|===

Basierend auf diesen Hinweisen können Sie Ihre Regeln prüfen und überarbeiten.

ifdef::onprem[]
Eine weitere wichtige Diagnosemöglichkeit ist die Log-Datei `~/var/log/notify.log`.
Während Tests mit den Benachrichtigungen bietet sich dazu der beliebte Befehl `tail -f` an:

[{shell}]
----
{c-omd} tail -f var/log/notify.log
2025-04-09 08:02:49,302 [15] [cmk.base.notify]  -> does not match: Event type 'rd' not handled by this rule. Allowed are: du, ?r
2025-04-09 08:02:49,303 [20] [cmk.base.notify] User cmkadmin's rule 'my test notification'...
2025-04-09 08:02:49,303 [20] [cmk.base.notify]  -> matches!
2025-04-09 08:02:49,303 [20] [cmk.base.notify]    - adding notification of cmkadmin via mail
2025-04-09 08:02:49,303 [20] [cmk.base.notify] User peter's rule 'test notification of peter'...
2025-04-09 08:02:49,303 [20] [cmk.base.notify]  -> matches!
2025-04-09 08:02:49,303 [20] [cmk.base.notify]    - modifying notification of peter via mail
2025-04-09 08:02:49,303 [20] [cmk.base.notify] Executing 2 notifications:
2025-04-09 08:02:49,303 [20] [cmk.base.notify]   * would notify peter via mail, parameters: graphs_per_notification, notifications_with_graphs, matching_rule_nr, matching_rule_text, bulk: no
2025-04-09 08:02:49,303 [20] [cmk.base.notify]   * would notify cmkadmin via mail, parameters: graphs_per_notification, notifications_with_graphs, matching_rule_nr, matching_rule_text, bulk: no

----

Mit [.guihint]#Global settings > Notifications > Notification log level# können Sie die Ausführlichkeit der Meldungen in drei Stufen steuern.
Wenn Sie [.guihint]#Full dump of all variables and command# auswählen, so finden Sie in der Log-Datei eine komplette Auflistung aller Variablen, die dem xref:scripts[Benachrichtigungsskript] bereitgestellt werden:

image::notifications_log_level.png[alt="Globale Einstellung zur Festlegung der Protokollierungsebene."]

Dies sieht dann z.B. so aus (Auszug):

.~/var/log/notify.log
[{file}]
----
2025-04-09 08:47:39,186 [10] [cmk.base.notify] Raw context:
                    CONTACTS=hh
                    HOSTACKAUTHOR=
                    HOSTACKCOMMENT=
                    HOSTADDRESS=127.0.0.1
                    HOSTALIAS=localhost
                    HOSTATTEMPT=1
                    HOSTCHECKCOMMAND=check-mk-host-smart
----
endif::[]


ifdef::onprem[]
[#async]
=== Asynchrone Zustellung durch Benachrichtigungs-Spooler

{cee-only}
Eine mächtige Zusatzfunktion der kommerziellen Editionen ist der _Benachrichtigungs-Spooler_.
Dieser ermöglicht eine asynchrone Zustellung von Benachrichtigungen.
Was bedeutet asynchron in diesem Zusammenhang?

* Synchrone Zustellung:
Das Benachrichtigungsmodul wartet, bis das Benachrichtigungsskript fertig ausgeführt wurde.
Sollte dies eine längere Ausführungszeit haben, stauen sich weitere Benachrichtigungen auf.
Wird das Monitoring angehalten, gehen diese Benachrichtigungen verloren.
Außerdem kann sich bei vielen Benachrichtigungen in kurzer Zeit ein Rückstau bis zum Kern bilden, so dass das Monitoring dadurch ins Stocken gerät.

* Asynchrone Zustellung:
Jede Benachrichtigung wird in einer Spool-Datei unter `~/var/check_mk/notify/spool` abgelegt.
Es kann sich kein Stau bilden.
Bei einem Stopp des Monitorings bleiben die Spool-Dateien erhalten und Benachrichtigungen werden später korrekt zugestellt.
Das Abarbeiten der Spool-Dateien übernimmt der Benachrichtigungs-Spooler.

Eine synchrone Zustellung ist dann vertretbar, wenn das Benachrichtigungsskript schnell läuft und vor allem nicht in irgendeinen Timeout geraten kann.
Bei Benachrichtigungsmethoden, die auf vorhandene Spooler zurückgreifen, ist das gegeben.
Insbesondere bei E-Mail und SMS kommen Spool-Dienste vom System zum Einsatz.
Das Benachrichtigungsskript übergibt eine Datei an den System-Spooler, wobei keine Wartezustände auftreten können.

Bei Verwendung der xref:syncsmtp[nachvollziehbaren Zustellung per SMTP] oder anderer Skripte, welche Netzwerkverbindungen aufbauen, sollten Sie *auf jeden Fall* die asynchrone Zustellung einstellen.
Dazu gehören auch Skripte, welche per HTTP Textnachrichten (SMS) über das Internet versenden.
Die Timeouts bei der Verbindung zu einem Netzwerkdienst können bis zu mehrere Minuten lang sein und den oben beschriebenen Stau auslösen.

Die gute Nachricht: Die asynchrone Zustellung ist in {CMK} standardmäßig aktiviert.
Zum einen wird der Benachrichtigungs-Spooler  (`mknotifyd`) beim Start der Instanz mitgestartet, was Sie mit dem folgenden Kommando überprüfen können:
// Merker: Kommando für CMK < 1.6 zum Start von mknotifyd: omd -f config set MKNOTIFYD on

[{shell}]
----
{c-omd} omd status mknotifyd
mknotifyd:      [green]#running#
-----------------------
Overall state:  [green]#running#
----

Zum anderen ist in den globalen Einstellungen ([.guihint]#Global settings > Notifications > Notification Spooling#) die asynchrone Zustellung ([.guihint]#Asynchronous local delivery by notification spooler#) ausgewählt:

image::notifications_spooling.png[alt="Globale Einstellung zur Zustellungsmethode des Benachrichtigungs-Spoolers."]


==== Fehlerdiagnose

Der Benachrichtigungs-Spooler pflegt eine eigene Log-Datei: `~/var/log/mknotifyd.log`.
Diese verfügt über drei Log-Levels, die Sie unter [.guihint]#Global settings > Notifications > Notification Spooler Configuration# mit dem Parameter [.guihint]#Verbosity of logging# auswählen können.
Der Default steht auf [.guihint]#Normal logging (only startup, shutdown and errors#.
Bei der mittleren Stufe, [.guihint]#Verbose logging (also spooled notifications),# können Sie das Bearbeiten der Spool-Dateien sehen:

.~/var/log/mknotifyd.log
[{file}]
----
2025-04-09 08:47:37,928 [15] [cmk.mknotifyd] processing spoolfile: /omd/sites/mysite/var/check_mk/notify/spool/dad64e2e-b3ac-4493-9490-8be969a96d8d
2025-04-09 08:47:37,928 [20] [cmk.mknotifyd] running cmk --notify --log-to-stdout spoolfile /omd/sites/mysite/var/check_mk/notify/spool/dad64e2e-b3ac-4493-9490-8be969a96d8d
2025-04-09 08:47:39,848 [20] [cmk.mknotifyd] got exit code 0
2025-04-09 08:47:39,850 [20] [cmk.mknotifyd] processing spoolfile dad64e2e-b3ac-4493-9490-8be969a96d8d successful: success 250 - b'2.4.0 Ok: queued as 1D4FF7F58F9'
2025-04-09 08:47:39,850 [20] [cmk.mknotifyd] sending command LOG;SERVICE NOTIFICATION RESULT: hh;mysrv;CPU load;OK;mail;success 250 - b'2.4.0 Ok: queued as 1D4FF7F58F9';success 250 - b'2.0.0 Ok: queued as 1D4FF7F58F9'
----
endif::[]


ifdef::onprem[]
[#syncsmtp]
== Nachvollziehbare Zustellung per SMTP

=== E-Mail ist nicht zuverlässig

{cee-only}
Das Monitoring ist nur nützlich, wenn man sich auch darauf verlassen kann.
Dazu gehört, dass Benachrichtigungen _zuverlässig_ und _zeitnah_ ankommen.
Nun ist die Zustellung von E-Mails hier leider nicht ganz ideal.
Denn der Versand geschieht üblicherweise durch Übergabe der E-Mail an den lokalen SMTP-Server.
Dieser versucht dann die E-Mail selbständig und asynchron zuzustellen.

Bei einem vorübergehenden Fehler (z.B. falls der empfangende SMTP-Server nicht erreichbar ist) wird die E-Mail in eine Warteschlange versetzt und später ein erneuter Zustellversuch gestartet.
Dieses „später“ ist dann in der Regel frühestens in 15-30 Minuten.
Aber dann kann die Benachrichtigung eventuell schon viel zu spät sein!

Ist die E-Mail gar nicht zustellbar, so erzeugt der SMTP-Server eine hübsche Fehlermeldung in seiner Log-Datei und versucht, an den „Absender“ eine E-Mail über die gescheiterte Zustellung zu generieren.
Aber das Monitoring-System ist kein richtiger Absender und kann auch keine E-Mails empfangen.
In der Folge gehen solche Fehler dann einfach unter und Benachrichtigungen bleiben aus.



=== SMTP auf direktem Weg ermöglicht Fehlerauswertung

Die kommerziellen Editionen bieten die Möglichkeit einer _nachvollziehbaren_ Zustellung per SMTP.
Dabei wird bewusst auf eine Hilfe des lokalen Mailservers verzichtet.
Anstelle dessen sendet {CMK} selbst die E-Mail direkt via SMTP zu Ihrem Smarthost und wertet die SMTP-Antwort auch selbst aus.

Dabei werden nicht nur SMTP-Fehler intelligent behandelt, es wird auch eine korrekte Zustellung genau protokolliert.
Es ist ein bisschen wie ein Einschreiben: {CMK} bekommt quasi vom SMTP-Smarthost (empfangender Server) eine Quittung, dass die E-Mail übernommen wurde -- inklusive einer Mail-ID.

Die praktische Einrichtung einer SMTP-basierten Benachrichtigung finden Sie in den xref:notification_rules#SMTP[globalen Benachrichtigungsregeln] bzw. den xref:personal_notifications#SMTP[persönlichen Benachrichtigungsregeln] beschrieben.



=== SMS und andere Benachrichtigungsmethoden

Eine synchrone Zustellung inklusive Fehlermeldung und Nachvollziehbarkeit ist aktuell nur für HTML-E-Mails implementiert.
Wie Sie in einem eigenen Benachrichtigungsskript einen Fehlerstatus zurückgeben können, erfahren Sie im Kapitel über xref:scripts[das Schreiben von eigenen Skripten].
endif::[]


ifdef::onprem[]
[#distributed]
== Benachrichtigungen in verteilten Systemen

In verteilten Umgebungen -- also solchen mit mehr als einer {CMK}-Instanz -- stellt sich die Frage, was mit Benachrichtigungen geschehen soll, die auf Remote-Instanzen erzeugt werden.
Hier gibt es grundsätzlich zwei Möglichkeiten:

. Lokale Zustellung
. Zentrale Zustellung auf der Zentralinstanz (nur kommerzielle Editionen)

Einzelheiten dazu finden Sie im Artikel über das xref:distributed_monitoring#notifications[verteilte Monitoring].
endif::[]


[#scripts]
== Benachrichtigungsskripte

ifdef::onprem[]
=== Das Prinzip

Benachrichtigungen können auf sehr vielfältige und individuelle Weise geschehen.
Typische Fälle sind:

* Übergabe von Benachrichtigungen an ein Ticket- oder externes Benachrichtigungssystem
* Versand von SMS über verschiedene Internetdienste
* Automatisierte Anrufe
* Weiterleitung an ein übergeordnetes Monitoring-System

Aus diesem Grund bietet {CMK} eine sehr einfache Schnittstelle, mit der Sie selbst eigene Benachrichtigungsskripte schreiben können.
Sie können diese in jeder von Linux unterstützten Programmiersprache schreiben -- auch wenn Shell, Perl und Python zusammen hier sicher 95{nbsp}% „Marktanteil“ haben.

Die von {CMK} xref:includedscripts[mitgelieferten Skripte] liegen unter `~/share/check_mk/notifications`.
Dieses Verzeichnis ist Teil der Software und nicht für Änderungen vorgesehen.
Legen Sie eigene Skripte stattdessen in `~/local/share/check_mk/notifications` ab.
Achten Sie darauf, dass sie ausführbar sind (`chmod +x`).
Sie werden dann automatisch gefunden und bei den Benachrichtigungsregeln als Methode zur Auswahl angeboten.

Möchten Sie ein mitgeliefertes Skript anpassen, so kopieren Sie es einfach von `~/share/check_mk/notifications` nach `~/local/share/check_mk/notifications` und machen dort Ihre Änderungen.
Wenn Sie dabei den Dateinamen beibehalten, ersetzt Ihr Skript automatisch die Originalversion und Sie müssen keine bestehenden Benachrichtigungsregeln anpassen.

Einige weitere Beispielskripte werden unter `~/share/doc/check_mk/treasures/notifications` mitgeliefert.
Sie können diese als Vorlage nehmen und anpassen.
Die Konfiguration wird meist direkt im Skript vorgenommen -- Hinweise dazu finden Sie dort in den Kommentaren.

Im Falle einer Benachrichtigung wird Ihr Skript mit den Rechten des Instanzbenutzers aufgerufen.
In *Umgebungsvariablen*, die mit `NOTIFY_` beginnen, bekommt es alle Informationen über den betreffenden Host/Service, das Monitoring-Ereignis, den zu benachrichtigenden Kontakt und die Parameter, die in der Benachrichtigungsregel angegeben wurden.

Texte, die das Skript in die *Standardausgabe* schreibt (mit `print`, `echo`, etc.), erscheinen in der Log-Datei des Benachrichtigungsmoduls `~/var/log/notify.log`.


=== Nachvollziehbare Benachrichtigungen

Benachrichtigungsskripte haben die Möglichkeit, über den Exit Code mitzuteilen, ob ein wiederholbarer Fehler aufgetreten ist oder ein endgültiger:

[cols="25,~",options="header"]
|===
|Exit Code |Bedeutung
|`0` |Das Skript wurde erfolgreich ausgeführt.
|`1` |Ein temporärer Fehler ist aufgetreten. Die Ausführung soll nach kurzer Zeit erneut probiert werden, bis die konfigurierte maximale Anzahl von Versuchen erreicht ist. Beispiel: HTTP-Verbindung zu SMS-Dienst konnte nicht aufgebaut werden.
|`2` und höher |Ein endgültiger Fehler ist aufgetreten. Die Benachrichtigungen werden nicht wiederholt. Auf der GUI wird ein Benachrichtigungsfehler angezeigt. Der Fehler wird in der Historie des Hosts/Services angezeigt. Beispiel: der SMS-Dienst meldet den Fehler „Ungültige Authentifizierung“.
|===

Zudem wird in allen Fällen die Standardausgabe des Benachrichtigungsskripts zusammen mit dem Status in die Benachrichtigungshistorie des Hosts/Services eingetragen und ist somit über die GUI sichtbar.

*Wichtig:* Für xref:notification_rules#bulk[Sammelbenachrichtigungen] steht die nachvollziehbare Benachrichtigung nicht zur Verfügung!

{cee-only}
Die Behandlung von Benachrichtigungsfehlern aus Sicht des Benutzers wird im Kapitel über die xref:syncsmtp[nachvollziehbare Zustellung per SMTP] erklärt.


[#example]
=== Ein einfaches Beispielskript

Als Beispiel können Sie ein Skript erstellen, das alle Informationen zu der Benachrichtigung in eine Datei schreibt.
Als Sprache kommt die Bash Linux-Shell zum Einsatz:

.~/local/share/check_mk/notifications/foobar
[{file}]
----
#!/bin/bash
# Foobar Teleprompter

env | grep NOTIFY_ | sort > $OMD_ROOT/tmp/foobar.out
echo "Successfully written $OMD_ROOT/tmp/foobar.out"
exit 0
----

Danach machen Sie das Skript ausführbar:

[{shell}]
----
{c-omd} chmod +x local/share/check_mk/notifications/foobar
----

Hier einige Erklärungen zum Skript:

* In der ersten Zeile stehen `#!` und der Pfad zum Interpreter der Skriptsprache (hier `/bin/bash`).
* In der zweiten Zeile steht nach dem Kommentarzeichen `#` ein *Titel* für das Skript. Dieser wird bei der Auswahl der Benachrichtigungsmethode in der Regel angezeigt.
* Der Befehl `env` gibt alle Umgebungsvariablen aus, die das Skript bekommen hat.
* Mit `grep NOTIFY_` werden die Variablen von {CMK} herausgefiltert{nbsp}...
* &#8230; und mit `sort` alphabetisch sortiert.
* `&gt; $OMD_ROOT/tmp/foobar.out` schreibt das Ergebnis in die Datei `~/tmp/foobar.out` im Instanzverzeichnis.
* Das `exit 0` wäre an dieser Stelle eigentlich überflüssig, da die Shell immer den Exit Code des letzten Befehls übernimmt. Dieser ist hier `echo` und immer erfolgreich. Aber explizit ist immer besser.


[#example_test]
=== Beispielskript testen

Damit das Skript verwendet wird, müssen Sie es in einer Benachrichtigungsregel als Methode einstellen.
Selbst geschriebene Skripte haben keine Parameterdeklaration.
Daher fehlen die ganzen Checkboxen, wie sie z.B. bei der Methode [.guihint]#HTML Email# angeboten werden.
Anstelle dessen können Sie eine Liste von Texten als Parameter angeben, die dem Skript als `NOTIFY_PARAMETER_1`, `NOTIFY_PARAMETER_2` usw. bereitgestellt werden.
Für den Test übergeben Sie die Parameter `Fröhn`, `Klabuster` und `Feinbein`:

image::notifications_method_foobar.png[alt="Regel mit Auswahl des Beispielskripts als Benachrichtigungsmethode."]

Nun setzen Sie zum Test den Service `CPU load` auf dem Host `myserver` auf {CRIT} -- mit dem xref:commands#[Kommando] [.guihint]#Fake check results.#
In der Log-Datei des Benachrichtigungsmoduls `~/var/log/notify.log` sehen Sie die Ausführung des Skripts samt Parametern und der erzeugten Spool-Datei:

.~/var/log/notify.log
[{file}]
----
2021-08-25 13:01:23,887 [20] [cmk.base.notify] Executing 1 notifications:
2021-08-25 13:01:23,887 [20] [cmk.base.notify]   * notifying hh via foobar, parameters: Fröhn, Klabuster, Feinbein, bulk: no
2021-08-25 13:01:23,887 [20] [cmk.base.notify] Creating spoolfile: /omd/sites/mysite/var/check_mk/notify/spool/e1b5398c-6920-445a-888e-f17e7633de60
----

Die Datei `~/tmp/foobar.out` enthält nun eine alphabetische Liste aller {CMK}-Umgebungsvariablen, die Informationen über die Benachrichtigung beinhalten.
Dort können Sie sich orientieren, was für Werte für Ihr Skript zur Verfügung stehen. Hier die ersten zehn Zeilen:

[{shell}]
----
{c-omd} head tmp/foobar.out
NOTIFY_ALERTHANDLERNAME=debug
NOTIFY_ALERTHANDLEROUTPUT=Arguments:
NOTIFY_ALERTHANDLERSHORTSTATE=OK
NOTIFY_ALERTHANDLERSTATE=OK
NOTIFY_CONTACTALIAS=Harry Hirsch
pass:[NOTIFY_CONTACTEMAIL=harryhirsch@example.com]
NOTIFY_CONTACTNAME=hh
NOTIFY_CONTACTPAGER=
NOTIFY_CONTACTS=hh
NOTIFY_DATE=2021-08-25
----

Auch die Parameter lassen sich hier wiederfinden:

[{shell}]
----
{c-omd} grep PARAMETER tmp/foobar.out
NOTIFY_PARAMETERS=Fröhn Klabuster Feinbein
NOTIFY_PARAMETER_1=Fröhn
NOTIFY_PARAMETER_2=Klabuster
NOTIFY_PARAMETER_3=Feinbein
----


[#environment_variables]
=== Umgebungsvariablen

Im obigen Beispiel haben Sie einige Umgebungsvariablen gesehen, die dem Skript übergeben wurden.
Welche Variablen genau bereitstehen, hängt ab von der Art der Benachrichtigung, der {CMK}-Version und -Edition und dem verwendeten Monitoring-Kern (xref:cmc#[CMC] or Nagios).
Neben dem Trick mit dem Kommando `env` gibt es noch zwei weitere Wege zu einer vollständigen Liste aller Variablen:

* Das Hochschalten des Log-Levels für `~/var/log/notify.log` über [.guihint]#Global settings > Notifications > Notification log level#.
* Bei Benachrichtigungen per [.guihint]#HTML Email# gibt es eine Checkbox [.guihint]#Information to be displayed in the email body# und dort die Option [.guihint]#Complete variable list (for testing)#.

Folgendes sind die wichtigsten Variablen:

[cols="40,~"},options="header"]
|===
|Umgebungsvariable |Beschreibung
|`OMD_ROOT` |Home-Verzeichnis der Instanz, z.B. `/omd/sites/mysite`
|`OMD_SITE` |Name der Instanz, z.B. `mysite`
|`NOTIFY_WHAT` |Bei Host-Benachrichtigungen das Wort `HOST`, sonst `SERVICE`. Damit können Sie Ihr Skript so intelligent machen, dass es in beiden Fällen sinnvolle Informationen meldet.
|`NOTIFY_CONTACTNAME` |Benutzername (Login) des Kontakts
|`NOTIFY_CONTACTEMAIL` |E-Mail-Adresse des Kontakts
|`NOTIFY_CONTACTPAGER` |Eintrag im Feld [.guihint]#Pager# des Benutzerprofils des Kontakts. Da das Feld meist nicht für einen bestimmten Zweck belegt ist, können Sie es einfach nutzen, um eine für die Benachrichtigung nötige Information pro Benutzer zu speichern.
|`NOTIFY_DATE` |Datum der Benachrichtigung im ISO-8601-Format, z.B. `2021-08-25`
|`NOTIFY_LONGDATETIME` |Datum und Uhrzeit in der nicht-lokalisierten Standarddarstellung des Linux-Systems, z.B. `Wed Aug 25 15:18:58 CEST 2021`
|`NOTIFY_SHORTDATETIME` |Datum und Uhrzeit im ISO-Format, z.B. `2021-08-25 15:18:58`
|`NOTIFY_HOSTNAME` |Name des betroffenen Hosts
|`NOTIFY_HOSTOUTPUT` |Ausgabe des Check-Plugins des Host-Checks, z.B. `Packet received via smart PING`. Diese Ausgabe ist nur bei Host-Benachrichtigungen interessant, aber auch bei Service-Benachrichtigungen vorhanden.
|`NOTIFY_HOSTSTATE` |Eines der Worte `UP`, `DOWN` oder `UNREACH`
|`NOTIFY_NOTIFICATIONTYPE` |Typ der Benachrichtigung, wie in der xref:intro[Einleitung dieses Artikels] beschrieben. Er wird durch eines der folgenden Worte ausgedrückt: +
`PROBLEM`: Normales Host-/Service-Problem +
`RECOVERY`: Host/Service kehrt zurück zum Zustand {UP} / {OK} +
`ACKNOWLEDGEMENT (...)`: xref:basics_ackn#[Quittierung] eines Problems +
`FLAPPINGSTART`: Host/Service beginnt unstetig zu sein +
`FLAPPINGSTOP`: Ende der Unstetigkeit +
`DOWNTIMESTART`: Beginn einer xref:basics_downtimes#[Wartungszeit] +
`DOWNTIMEEND`: Normales Ende einer Wartungszeit +
`DOWNTIMECANCELLED`: Vorzeitiger Abbruch einer Wartungszeit +
`CUSTOM`: Mit xref:commands#[Kommando] manuell ausgelöste Benachrichtigung +
`ALERTHANDLER (...)`: Alert Handler-Ausführung (nur kommerzielle Editionen) +
Bei den Typen mit `(...)` stehen in der Klammer weitere Informationen über die Art der Benachrichtigung.
|`NOTIFY_PARAMETERS` |Alle Parameter des Skripts durch Leerzeichen getrennt
|`NOTIFY_PARAMETER_1` |Erster Parameter des Skripts
|`NOTIFY_PARAMETER_2` |Zweiter Parameter des Skripts, usw.
|`NOTIFY_SERVICEDESC` |Name des betroffenen Services. Bei Host-Benachrichtigungen ist diese Variable nicht vorhanden.
|`NOTIFY_SERVICEOUTPUT` |Ausgabe des Check-Plugins des Service-Checks (nicht bei Host-Benachrichtigungen)
|`NOTIFY_SERVICESTATE` |Eines der Worte `OK`, `WARN`, `CRIT` oder `UNKNOWN`
|===


=== Sammelbenachrichtigungen

Wenn Ihr Skript xref:notification_rules#bulk[Sammelbenachrichtigungen] unterstützen soll, müssen Sie es speziell dafür präparieren, da hier dem Skript _mehrere Benachrichtigungen auf einmal_ übergeben werden.
Aus diesem Grund funktioniert dann auch die Übergabe per Umgebungsvariablen nicht mehr sinnvoll.

Deklarieren Sie Ihr Skript in der _dritten Zeile_ im Kopf wie folgt, dann sendet das Benachrichtigungsmodul die Benachrichtigungen auf der _Standardeingabe:_

.~/local/share/check_mk/notifications/mybulk
[{file}]
----
#!/bin/bash
# My Bulk Notification
# Bulk: yes
----

Auf der Standardeingabe werden dem Skript Blöcke von Variablen gesendet.
Jede Zeile hat die Form `NAME=VALUE`.
Blöcke werden getrennt durch Leerzeilen.
Das ASCII-Zeichen mit dem Code 1 (`\a`) wird verwendet, um innerhalb der Texte Zeilenumbrüche (_newlines_) darzustellen.

Der erste Block enthält eine Liste von allgemeinen Variablen (z.B. Aufrufparameter).
Jeder weitere Block fasst die Variablen zu einer Benachrichtigung zusammen.

Am besten, Sie probieren das Ganze erst einmal mit einem einfachen Test aus, der die kompletten Daten in eine Datei schreibt und sehen sich an, wie die Daten gesendet werden.
Dazu können Sie z.B. das folgende Benachrichtigungsskript nutzen:

.~/local/share/check_mk/notifications/mybulk
[{file}]
----
#!/bin/bash
# My Bulk Notification
# Bulk: yes

cat > $OMD_ROOT/tmp/mybulktest.out
----

Testen Sie das Skript wie xref:example_test[oben beschrieben] und aktivieren Sie zusätzlich in der Benachrichtigungsregel die Sammelbenachrichtigung ([.guihint]#Notification Bulking#).


[#includedscripts]
=== Mitgelieferte Benachrichtigungsskripte
endif::[]

Im Auslieferungszustand stellt {CMK} bereits eine ganze Reihe Skripte bereit zur Anbindung an beliebte und weit verbreitete Instant-Messaging-Dienste, Incident-Management-Plattformen und Ticketsysteme.
Wie Sie diese Skripte nutzen können, erfahren Sie in den folgenden Artikeln:

* xref:notifications_webex#[Cisco Webex Teams]
* xref:notifications_ilert#[ilert]
* xref:notifications_jira#[Jira]
* xref:notifications_mattermost#[Mattermost]
* xref:notifications_teams#[Microsoft Teams]
* xref:notifications_pagerduty#[PagerDuty]
* xref:notifications_pushover#[Pushover]
* xref:notifications_opsgenie#[Opsgenie]
* xref:notifications_servicenow#[ServiceNow]
* xref:notifications_signl4#[SIGNL4]
* xref:notifications_slack#[Slack]
* xref:notifications_splunkoncall#[Splunk On-Call]


ifdef::onprem[]
[#files]
== Dateien und Verzeichnisse

=== Pfade von {CMK}

[cols="50,~",options="header"]
|===
|Pfad |Bedeutung
|`~/var/log/cmc.log` |Log-Datei des xref:cmc#[CMC]. Falls das Debugging für Notifications eingeschaltet ist, finden Sie hier genaue Angaben, warum Benachrichtigungen (nicht) erzeugt wurden.
|`~/var/log/notify.log` |Log-Datei des Benachrichtigungsmoduls
|`~/var/log/mknotifyd.log` |Log-Datei des Benachrichtigungs-Spoolers
|`~/var/log/mknotifyd.state` |Aktueller Zustand des Benachrichtigungs-Spoolers. Das ist hauptsächlich bei  xref:distributed_monitoring#notifications[Benachrichtigungen in verteilten Umgebungen] relevant.
|`~/var/nagios/debug.log` |Debug-Log-Datei von Nagios. Schalten Sie Debug-Meldungen in `etc/nagios/nagios.d/logging.cfg` in der Variablen `debug_level` ein.
|`~/var/check_mk/notify/spool/` |Ablage der Spool-Dateien, die der Benachrichtigungs-Spooler bearbeiten soll.
|`~/var/check_mk/notify/deferred/` |Bei temporären Fehlern verschiebt der Benachrichtigungs-Spooler die Dateien hierher und probiert es erst nach ein paar Minuten nochmal.
|`~/var/check_mk/notify/corrupted/` |Defekte Spool-Dateien werden hierher verschoben.
|`~/share/check_mk/notifications` |Von {CMK} mitgelieferte Benachrichtigungsskripte. Ändern Sie hier nichts.
|`~/local/share/check_mk/notifications` |Ablageort für eigene Benachrichtigungsskripte. Möchten Sie ein mitgeliefertes Skript anpassen, so kopieren Sie es von `~/share/check_mk/notifications` hierher und behalten dessen Dateinamen bei.
|`~/share/doc/check_mk/treasures/notifications` |Weitere Benachrichtigungsskripte, die Sie geringfügig anpassen und verwenden können.
|===


[#maillog]
=== Log-Dateien des SMTP-Servers

Die Log-Dateien des SMTP-Servers sind Systemdateien und werden hier folglich
mit absoluten Pfaden angegeben. Wo die Log-Datei genau liegt, hängt von Ihrer
Linux-Distribution ab.

[cols="50,~",options="header"]
|===
|Pfad |Bedeutung
|`/var/log/mail.log` |Log-Datei des SMTP-Servers unter Debian und Ubuntu
|`/var/log/mail` |Log-Datei des SMTP-Servers unter SUSE Linux Enterprise Server (SLES)
|`/var/log/maillog` |Log-Datei des SMTP-Servers unter Red Hat Enterprise Linux (RHEL)
|===
endif::[]
