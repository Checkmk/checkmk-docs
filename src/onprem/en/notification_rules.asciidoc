// -*- coding: utf-8 -*-
// IGNORE 
// NONASCII 
include::global_attr.adoc[]
= Setting up notifications by rules
:revdate: draft
:title: Setting up notifications by rules
:description: Simple notifications can be sent by email, more complex notifications are controlled via rules. Learn here how to implement your requirements in {CMK}.

{related-start}
xref:notifications#[Notification basics]
xref:personal_notifications#[Personal notification rules]
xref:basics_ackn#[Acknowledging problems]
xref:commands#[Commands]
xref:wato_user#[Users, roles and permissions]
{related-end}


// delete from here
[TIP]
====
This article is incomplete as it is currently being revised for publication.
Please be patient. Thank you! +
By the way, the https://docs.checkmk.com/master/de/notification_rules.html[German version] of this article has already been updated -- if that is an alternative for you.
====
// delete to here


[#intro]
== Introduction

// This block is new
// start translation
////
Nachdem sich der Artikel xref:notifications#[Grundlagen zu Benachrichtigungen] mit grundsätzlichen Dingen rund um Benachrichtigungen befasst hat,
beschäftigt sich dieser Artikel nun mit Benachrichtigungen per E-Mail sowie der Erstellung von Benachrichtigungen über Regeln.
////
// end translation

[#overview]
== The central notifications view

// This block is new
// start translation
////
Über [.guihint]#Setup > General > Global settings# gelangen Sie zur Übersichtsseite der Benachrichtigungen.
Hier sind alle entscheidenden Informationen rund um dieses Thema gebündelt:

image::notifications_overview.png[alt="Die Übersichtsseite der Benachrichtigungen."]

Ein funktionierendes Benachrichtigungssystem basiert auf dem Ineinandergreifen etlicher Komponenten, die alle eingestellt sein wollen.
Diese Übersichtsseite erspart Ihnen die Suche nach den einzelnen Regeln, Parametern etc. in den verschiedenen Bereichen von {CMK}.
Sie können von hier aus alle Aspekte rund um das Thema Benachrichtigung erreichen.


=== Status der Benachrichtigungen

Im linken Bereich sehen Sie erst einmal eine Übersicht über den aktuellen Status der Benachrichtigungen:

image::notifications_failed.png[alt="Übersicht über den aktuellen Status der Benachrichtigungen.", width=60%]

Angezeigt werden:
[cols="20,~"]
|===
|[.guihint]#Failed notifications# |Anzahl der fehlgeschlagenen Benachrichtigungen.
Wenn fehlgeschlagene Benachrichtigungen existieren, so wird darunter ein Link zur entsprechenden Übersicht angezeigt.
|[.guihint]#Total sent notifications# |Anzahl der gesendeten Benachrichtigungen.
Wenn fehlgeschlagene Benachrichtigungen existieren, so wird darunter ein Link zu den [.guihint]#Notifications of host & services#, gefiltert für die letzten 7 Tage, angezeigt.
Darüber können Sie einen genaueren Blick darauf werfen, welche Benachrichtigungen gesendet wurden.
|[.guihint]#Core status of notifications# |Zeigt an, auf wie vielen {CMK}-xref:glossar.html#site[Instanzen] Benachrichtigungen aktiviert sind.
Wenn sie auf einer Instanz z. B. über das Snapin xref:user_interface#master_control[Master control] deaktiviert sind, wird der Instanz-Name angezeigt.
Damit können Sie prüfen, ob dies beabsichtigt war.
|===


=== Benachrichtigungsregeln

Rechts neben den Statusanzeigen finden Sie Links zu allen in {CMK} existierenden Regeln rund um die Benachrichtigungen:

image::notifications_overview_rules.png[alt="Auflistung der Benachrichtigungsregeln."]

Von hier aus gelangen Sie sowohl zu den Regeln zur Optimierung Ihrer Benachrichtigungen als auch zu allen weiteren Regeln rund um das Thema Benachrichtigung.

[TIP]
====
Die hier angezeigten Regeln kommen Ihnen möglicherweise bereits von anderen Stellen in {CMK} bekannt vor. 
Hier wurden keine neuen Regeln kreiert, sondern lediglich die vorhandenen übersichtlich zusammengefasst.
====
////
// end translation


ifdef::onprem[]
=== Global and predefined notification rule

The last part of the overview page consists of the existing global rule.

If you have a freshly-installed {CMK}, precisely one rule will have been predefined:

image::notifications_default_rule.png[alt="List with the predefined notification rule."]
endif::[]

ifdef::saas[]
=== Global and predefined notification rules

The last part of the overview page consists of the existing global rules.

If you have a freshly-installed {CMK}, precisely two rules will have been predefined:

image::notifications_default_rules_saas.png[alt="List with the predefined notification rules.",width=97%]
endif::[]

Such a rule is structured as follows:

[cols="30,~"]
|===
ifdef::onprem[]
|Condition |All status changes of hosts to {DOWN} and {UP}, and of services to {CRIT}, {WARN} and {OK}.
endif::[]
ifdef::saas[]
|Condition |All status changes of hosts to {DOWN}, {UP} and {UNREACH}, and of services to {CRIT} and {UNKNOWN}, among others.
endif::[]
|Method |Sends an email in HTML format (with embedded metric graphs).
|Contact |All contacts of the affected host/service.
|===

As usual, you can edit the rule icon:icon_edit[alt="Icon for editing."], clone it icon:icon_clone[alt="Icon for cloning."], delete it icon:icon_delete[alt="Icon for deleting."], or create a new rule.
Once you have more than a single rule, you can change their processing order by dragging and dropping them with the icon:icon_drag[alt="Icon for moving an entry in the list."] icon.

[TIP]
====
Changes to notification rules do *not* require activation of the changes,
rather they take effect immediately.
====


[#simple_mail]
== Simple notifications by email

// This block is new
// start translation
////
Aber bevor Sie sich mit komplexeren Benachrichtigungen beschäftigen, fangen Sie erst einmal mit einer ganz einfachen Form der Benachrichtigung an: einer simplen E-Mail.
////
// end translation

An email notification sent by {CMK} in HTML format looks something like this:

[{image-border}]
image::html_notification.png[alt="A notification by email."]

As can be seen in the example, the email also contains the current xref:glossar#metric[metrics] for the affected service.

Before you receive such an email from {CMK}, a few preparations are necessary, as are described below.


=== Prerequisites

In the default {CMK} configuration, a user will receive notifications per email when the following prerequisites have been satisfied:

ifdef::onprem[]
* The {CMK} server has a functioning xref:smtp[setup for sending emails].
* An email address is configured for the xref:wato_user#user_config[user].
endif::[]
* The user is a member of a xref:wato_user#contact_groups[contact group], and is therefore a xref:glossar#contact[contact].
* A monitoring event occurs on a host or service assigned to this contact group, which triggers a notification.


ifdef::onprem[]
[#smtp]
=== Setting up mail dispatching in Linux

For the successful sending of emails, your {CMK} server must have a functioning SMTP-server configuration.
Depending on your Linux distribution, this could utilize, for example, Postfix, Qmail, Exim, or Nullmailer.
The configuration will be implemented with your Linux distribution’s resources.

The configuration is generally confined to registering a ‘smarthost’ (also known as an SMTP relay server) to which all emails will be directed.
This will then be your firm’s internal SMTP mail server.
As a rule smarthosts don’t require authentication in a LAN -- which makes matters simple.
In some distributions the smarthost will be queried during the installation.
With the {CMK} appliance one can configure the smarthost conveniently via the xref:appliance_usage#cma_webconf_system_settings[web interface].

You can test the sending of emails easily with the `mail` command on the command line.
Because there are numerous different implementations for this command under Linux, for standardization {CMK} provides the version from the link:https://heirloom.sourceforge.net/mailx.html[Heirloom mailx^] project directly in the site user’s search path (as `~/bin/mail`).
The corresponding configuration file is `~/etc/mail.rc`.
The best way to test this is as a site user, since the notification scripts will later run with the same permissions.

The email’s content is read from the standard input, the subject specified with `-s`, and the recipient’s address simply appended as an argument to the end of the command line:

[{shell-raw}]
----
{c-omd} echo "content" | mail -s test-subject harry.hirsch@example.com
----

The email should be delivered without delay.
If this doesn’t work, information can be found in the SMTP server’s log file in the `/var/log` directory (see xref:notifications#maillog[Files and directories]).
endif::[]


ifdef::onprem[]
=== Email address and contact groups

A user’s email address and contact groups are defined in the xref:wato_user#user_config[user administration]:

image::notifications_add_user.png[alt="Dialog for entering email address and selecting contact groups."]
endif::[]

ifdef::saas[]
=== Contact groups

A user’s contact groups are defined in the xref:wato_user#user_config[user administration]:

image::notifications_edit_user_saas.png[alt="Dialog for selecting contact groups."]
endif::[]

In a freshly-generated {CMK} site, initially there is only the [.guihint]#Everything# contact group.
Members of this group are automatically responsible for *all* hosts and services, and will be notified of every relevant monitoring event by email.


[#ticketsystem]
ifdef::onprem[]
=== Special cases: Ticket system, messenger and event engine

Instead of email or SMS, you can also send notifications to a ticket system (such as Jira or ServiceNow), a messenger (Slack, Mattermost) or an event engine (Event Console).
endif::[]

ifdef::saas[]
=== Special cases: Ticket system and messenger

Instead of email or SMS, you can also send notifications to a ticket system (such as Jira or ServiceNow) or a messenger (Slack, Mattermost).
endif::[]
There is a separate xref:notification_method[notification method] for each of these special cases, which can be selected in the notification rule.
However, you must note the following two points when creating the rule:

include::include_ticketsystem.asciidoc[]


[#finetuning]
=== Fine-tuning HTML email

When sending HTML emails, you may wish to add additional information or flexibly define a reply address ([.guihint]#Reply to#) to a specific contact for any queries.
For this, there is the [.guihint]#Setup > Notifications > Parameters for notification methods > HTML Email# rule, and in notification rules the HTML email xref:notification_method[notification method].
With these rules you can add a number of parameters such as response address, additional fields with details or free text formatted as HTML.

Note that in the [.guihint]#Custom HTML section (e.g. title, description…)#  field, for security reasons only a small set of HTML tags is allowed.
These are:

[cols="10,25,~",options="header"]
|===
|Tag |Function |Tips
|`a` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a[Anchor/Link^] |Permitted when combined with the `href` (mandatory) and `target` (optional) attributes. Links must either contain relative paths (i.e. start with `./` or `../`) or use one of the URL schemes `http`, `https` or `mailto`. We do not recommend using relative paths because of the very different handling by email clients.
|`h1` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1[Heading 1^] |
|`h2` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2[Heading 2^] |
|`b` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b[Bring Attention (usually bold)^] |
|`tt` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tt[Teletype (monospaced font)^] |Deprecated. Do not use this tag!
|`i` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i[Idiomatic (usually italic)^] |
|`u` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u[Unarticulated Annotation (usually underlined)^] |
|`br` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br[Break (Line Break)^] |
|`nobr` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nobr[Non-Breaking Text^] |Deprecated. Do not use this tag!
|`pre` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre[Preformatted^] |Spaces and indentations are preserved.
|`sup` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup[Superscript^] |
|`p`  |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p[Paragraph^] |
|`hr` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr[Thematic Break (Horizontal Rule)^] |
|`li` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li[List Item^] |Use only within the following lists `ul` and `ol`.
|`ul` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul[Unordered List^] |
|`ol` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol[Ordered List^] |
|===

As usual with all rules in {CMK}, a very finely granulated application is possible, so that you can individualize a detailed set of notifications to hosts and services as required.


[#rules]
== Controlling notifications with rules

// This block is new
// start translation
////
Neben den einfachen E-Mail-Benachrichtigungen können Sie mit {CMK} aber auch komplexere Benachrichtigungssysteme aufbauen.

=== Vereinfachte Regelerstellung

Um Ihnen die Regelerstellung für Benachrichtigungen zu vereinfachen, sieht {CMK} hier anders aus als Sie es aus anderen Bereichen gewöhnt sind.
Mit [.guihint]#Setup > Events > Notifications > Add notification rule# gelangen Sie zum Einstieg in die Erstellung von Benachrichtigungen:

image::notifications_modes.png[alt="Ansicht der beiden Modi in 'Add notification rule'."]

Hier müssen Sie sich nun entscheiden.

Wählen Sie den [.guihint]#Guided mode,# so werden Sie abschnittsweise durch die Erstellung einer Benachrichtigungsregel geführt.
Jeder Abschnitt behandelt gezielt einen Aspekt der Benachrichtigung.
Füllen Sie den jeweiligen Abschnitt mit den für Ihre Umgebung relevanten Daten.
Beschreibungen zu den einzelnen Themen finden Sie im weiteren Verlauf dieses Artikels.
Haben Sie einen Abschnitt bearbeitet, so klicken Sie auf [.guihint]#Next step...#
Ihre Angaben werden dann -- soweit sie technisch zwingend erforderlich sind -- verifiziert.
Fehlen beispielsweise technisch relevante Daten wie die zu nutzende E-Mailadresse, so erhalten Sie eine Fehlermeldung.
Nach korrekter Eingabe der wesentlichen Basisdaten gelangen Sie zum nächsten Abschnitt bis Sie am Ende eine komplette Benachrichtigungsregel vorbereitet haben.
Schließen Sie die Erstellung dann entweder mit [.guihint]#Apply & test notification rule# oder [.guihint]#Apply & create another rule# ab. 

Alternativ können Sie den [.guihint]#Overview mode# nutzen.
Dieser ist vor allem für die gezielte Bearbeitung einzelner Parameter in einer bestehenden Benachrichtigungsregel sinnvoll.
Oder auch dann, wenn Sie sich schon sehr gut mit der Regelerstellung auskennen und nicht mehr geführt werden wollen.
Im [.guihint]#Overview mode# sehen Sie alle Bearbeitungsabschnitte gleichzeitig und können direkt alle Felder und Optionen bearbeiten.
Die technische Verifizierung erfolgt dann einmalig und über alle Abschnitte hinweg sobald Sie auf 
[.guihint]#Apply & test notification rule# oder [.guihint]#Apply & create another rule# klicken.
////
// end translation


[#notification_rule]
=== Structure of the notification rules

In the following, we present the general structure of the notification rules with the definitions of conditions, event types, filters, notification methods, contacts and general properties.


[#rule_conditions]
==== Conditions

Conditions determine when a rule will be used.
They are the basis for every rule. 
For comprehension it is important to remember that the source is always a monitoring event on a concrete host or service.

The conditions address

* the object's static attributes – e.g., whether the service name contains the `/tmp` text  or whether a host is in a specific xref:glossar#host_group[host group],
* with the current state or the change of the state, e.g. whether the service has just changed from {OK} to {CRIT},
* or with completely different things, e.g., whether the 'working time' xref:glossar#time_period[time period] is currently active.

There are two important points to consider when setting the conditions:

. If no conditions have been defined the rule will take effect for *every* monitoring event.
. As soon as you select even a single condition, the rule takes effect only if *all* conditions are met.
All selected conditions are linked with AND.
There is only one exception to this important rule, which we will discuss later and not consider now.

This means that you should pay very close attention to whether the conditions you have chosen can be met at the same time so that a notification is triggered for the desired case. 


// This block is new
// start translation
////
==== Ereignisarten definieren

Im folgenden Beispiel für den Aufbau einer Benachrichtigungsregel sollen zwei Zustandsänderungen Benachrichtigungen auslösen:

* Hosts, die auf den Zustand {DOWN} wechseln und 
* Services, die auf den Zustand {CRIT} wechseln.

Dies wird in Schritt 1 festgelegt:

image::notification_rules_step1.png[alt="Regel mit erweiterten Bedingungen für die Erstellung einer Benachrichtigung."]
////
// end translation


[discrete]
==== The exception to the AND operation (part 1)

The following generally applies in {CMK}:
Only if a monitoring event satisfies all configured conditions, the notification rule will apply. 
There is one important exception to this general rule: for the [.guihint]#Host events# and [.guihint]#Service events# conditions.

Should you select *only* [.guihint]#Host events#, the rule will match no single service event. 
Similarly, this applies to the selection of [.guihint]#Service events# and host events. 
Should you activate *both* conditions however, the rule will match if an event is defined in *any* of the two two conditions.
In this exceptional case these conditions will thus not be linked with a logical AND, but rather with an OR.
In this way you can simply administer host and service notifications with a single rule.


// This block is new
// start translation
////
==== Host- und Service-Filter setzen

Angenommen, die obige Regel würde nun so eingeschränkt werden, dass nur eine Benachrichtigung erfolgen würde, wenn ein Monitoring-Ereignis für einen Service, der mit dem Namen `NTP` beginnt, auf einem Host im Ordner [.guihint]#Main# einträte:

image::notification_rules_step2.png[alt="Regel mit den Bedingungen für die Erstellung einer Benachrichtigung."]

Das Ergebnis dieser Benachrichtigungsregel mit den drei Einzelbedingungen (Statusänderungen, Service-Name, Ordner) wäre, dass *nur* Benachrichtigungen erfolgen würden, wenn ein Service auf {CRIT} ginge -- und die Zustandsänderungen des Hosts würden ignoriert, weil kein Monitoring-Ereignis die Zustandsänderung eines Hosts *und* den Service-Namen mit `NTP` enthalten würde.
////
// end translation


[discrete]
==== The exception to the AND operation (part 2)

A further tip regarding the [.guihint]#Contact group filters# option in the image above:
The condition checked here is whether the host/service in question has a certain contact assignment.
This can be used to implement functions such as "Host notifications in the contact group Linux should never be sent by SMS".
This has nothing to do with the contact selection described above.


[#notification_method]
==== Notification method

The notification method in step 3 specifies the technique to be used for sending the notification., e.g. with HTML email.

image::notification_rules_step3.png[alt="Regel mit den Optionen zur Benachrichtigungsmethode."]

Each method is realized using a script.
ifdef::onprem[]
{CMK} includes a number of xref:notifications#includedscripts[scripts].
You can also quite easily write your xref:notifications#scripts[custom scripts] in any desired programming language in order to implement special notifications -- for example, to redirect a notification to your own ticket system.
endif::[]
ifdef::saas[]
{CMK} includes a number of xref:notifications#scripts[scripts].
endif::[]

// This block replaces the following text
// start translation
////
Eine Methode kann Parameter anbieten.
Zum Beispiel erlauben es die Methoden für ASCII- und HTML-E-Mails, die Absenderadresse (`From:`) explizit zu setzen.
Die passende Seite zur Einstellung der Parameter erscheint nach der Auswahl der Methode, sobald Sie auf [.guihint]#Create# klicken.

Bevor Sie hier aber Einstellungen in der einzelnen Benachrichtigungsregel machen, sollten Sie wissen, dass Sie Parameter für die Benachrichtigungsmethoden auch allgemeingültig an zwei anderen Stellen in {CMK} setzen können:

* In den xref:parameters[Parametern für Benachrichtigungsmethoden], die weiter unten in diesem Artikel beschrieben werden.
In der Benachrichtigungsregel wählen Sie dann unter [.guihint]#Select parameters# die gewünschte Parameterdefinition aus, *bevor* Sie auf [.guihint]#Create# klicken.

* In den xref:wato_rules#[Regeln] für Hosts und Services:
Unter [.guihint]#Setup > Services > Service monitoring rules# finden Sie im Abschnitt [.guihint]#Notifications# für jede Benachrichtigungsmethode einen Regelsatz, mit dem Sie die gleichen Einstellungen festlegen können -- und das wie gewohnt abhängig von Host oder Service.

Ändern Sie die Parameterdefinitionen in der Benachrichtigungsregel nur dann, wenn sie für Einzelfälle von diesen Einstellungen abweichen wollen.
So können Sie z. B. global einen bestimmten Betreff für Ihre E-Mail festlegen, aber in einer einzelnen Benachrichtigungsregel einen alternativen Betreff definieren.

Anstelle von [.guihint]#Send notification# können Sie auch [.guihint]#Suppress all previous# auswählen.
Dann werden Benachrichtigungen in Form dieser Methode aus früheren Regeln wieder verworfen.
Näheres dazu finden Sie beim Thema xref:cancel[Löschen von Benachrichtigungen.]
////
// end translation
// delete from here
A method can include parameters -- such as allowing the method that sends ASCII and HTML emails to explicitly set the sender’s address (`From:`) for example.

Before making settings directly in the notification rule, one should know that parameters for the notification methods can also be specified via xref:wato_rules#[rules] for hosts and services:
Under [.guihint]#Setup > Services > Service monitoring rules#, in the [.guihint]#Notifications# section, you will find a rule set for each notification method, which you can use to define the same settings -- and as usual, can be dependent on the host or service.

Parameter definitions in notification rules enable these settings to be varied in individual cases.
So you can, for example, define a global subject for your email, but also define an alternative subject with an individual notification rule.

Instead of parameters you can also select [.guihint]#Cancel previous notifications# –
with which all of this method’s notifications from prior rules will be deleted.
For more on this, see the topic xref:cancel[deleting notifications].
// delete to here

[TIP]
====
For many notification methods for forwarding to other systems, you will find more detailed information in separate articles.
The list of articles can be found in the chapter on
ifdef::onprem[]
xref:notifications#includedscripts[notification scripts].
endif::[]
ifdef::saas[]
xref:notifications#scripts[notification scripts].
endif::[]
====


==== Selecting contacts

The most common procedure is for notifications to be sent to all users who have been registered as a xref:wato_user#add_host_to_contact_group[contact] for the respective host/service.
This is the ‘normal’ and logical procedure, since it is also via the contacts that it is defined which objects each user receives in their GUI display -- in effect those objects for which the user is responsible.

You can specify several options when selecting contacts with [.guihint]#Add recipient# and thus extend the notification to more contacts. 
{CMK} will automatically delete duplicate contacts.
In order for the rule to make sense at least one selection must be made.

image::notification_rules_step4.png[alt="Rule with contact selection options."]

The two [.guihint]#Restrict previous options to# options function somewhat differently.
Here the contacts selected with the other options will again be _restricted_.
With these you can also create an AND-operator between contact groups, for example, to enable notifications to be sent to all contacts who are members of both the `Linux` and `Data center` groups.

By entering [.guihint]#Explicit email addresses# you can notify persons who are not in fact nominated as users in {CMK}.
This of course only makes sense when used in the notification method that actually sends emails.

If, in the chosen method, you have selected [.guihint]#Suppress all previous#, the notifications will only be deleted for the contact selected here.

[TIP]
====
When using
ifdef::onprem[]
a ticket system, a messenger or an event engine
endif::[]
ifdef::saas[]
a ticket system or a messenger
endif::[]
as notification method, you should also observe the notes on these xref:ticketsystem[special cases].
====


// This block is new
// start translation
////
==== Versandkonditionen

Die Versandkonditionen können Sie für einfache Regeln erst einmal überspringen.
Diese sind primär interessant, wenn Sie xref:escalation[Eskalationen] aufbauen wollen.
////
// end translation


==== General properties

As with all rules in {CMK}, here you can include a description and a commentary for the rule, or even temporarily deactivate the rule.

image::notifications_rule_part1.png[alt="Rule with the option to enable disabling of notifications by users."]

With the [.guihint]#Allow users to deactivate this notification# option you can allow users to 'unsubscribe' from notifications generated by this rule.
We show how to do this with the xref:personal_notifications#[personal notifications].


// This block is new
// start translation
////
[#parameters]
=== Parameter für Benachrichtigungsmethoden festlegen

Für jede Benachrichtigungsmethode können Sie separate Parameter festlegen.
Diese Parameter werden in {CMK} getrennt von den eigentlichen Benachrichtigungsregeln definiert und verwaltet.
Dadurch können Sie die Parameter für mehrere Regeln gleichzeitig verwenden.
Auftretende Änderungen brauchen Sie nur zentral an einer Stelle vornehmen.
Und Sie erhalten ein einheitliches Erscheinungsbild für alle Benachrichtigungen des gleichen Typs, unabhängig von den auslösenden Regeln.

Öffnen Sie über [.guihint]#Setup > Events > Notifications# und den Knopf [.guihint]#Parameters for notifications methods# die Übersicht aller einstellbaren Parameter:

image::notifications_parameters.png[alt="Übersicht aller Benachrichtigungsmethoden für die Parameter vergeben werden können."]

Von hier aus können Sie die allgemeinen Parameter für jede Methode erstellen, bearbeiten und -- wenn sie in keiner Regel genutzt werden -- auch wieder löschen.
////
// end translation


[#notification_testing]
=== Testing notification rules

For testing notification rules, {CMK} offers a smart tool with [.guihint]#Test notifications#.
You can use it to simulate a notification for a host or service and recognize which of your notification rules are effective.
In addition to the simulation, you can also have the notification sent.

The quickest way to access the notification test is via [.guihint]#Setup > Events > Test notifications#.
In addition, there are other options for calling from some views in Monitoring (service list and service details) and in the Setup (host properties), in each case in the menu [.guihint]#Host > Test notifications#.

image::notifications_test.png[alt="Dialog for defining the properties of the simulated notification."]

First, click on one of the two buttons to decide whether the notification is for a [.guihint]#Host# or a [.guihint]#Service#.
Then select which host or service it should be.
As the event you can select a state change or the start of a xref:glossar#scheduled_downtime[scheduled downtime].
You can add a description of the event to [.guihint]#Plugin output#.
Use the [.guihint]#Send out notification for specific method# checkbox to specify whether the notification is only simulated or actually sent.

Finally, under [.guihint]#Advanced condition simulation# there are two further options with which you can define the time and number of notifications.
This allows you to test notification rules that only apply during a certain period (e.g. outside of business hours) or that start an xref:repeat_escalate[escalation] after a specified number of repeated notifications.

Click on [.guihint]#Test notifications# to start the test -- and also the dispatch, if you have selected this option.
The results are displayed below the [.guihint]#Test notifications# box:

image::notification_rules_test_results1.png[alt="Die Zusammenfassung der Simulationsresultate."]

First comes the summary.
Under [.guihint]#Test results# you can see how many notification rules apply and how many notifications result from them.
If you have selected _Send out notification_, the corresponding message `notifications have been sent out` is displayed here.
This must then immediately lead to an email for this problem.

The line below summarizes the notifications generated from your entries.
By clicking on the icon:icon_toggle_context[alt="Icon for showing or hiding the notification context."] icon, you can show the notification context.
This allows you to see the environment variables and their values that are valid in the context of this notification. 

The following two sections then show more details:

image::notifications_test_results2.png[alt="The details of the simulation results."]

Under [.guihint]#Predicted notifications# you can see to whom and how notifications would be sent.
You will also receive this information about the simulation if you have _not_ selected to send the notification.

Under [.guihint]#Global notification rules# the notification rules are listed that you have created here.
At this point, only the first column of the table is important, which uses icons to indicate which of the rules apply icon:icon_checkmark[alt="Icon for displaying a positive status."] and which do not icon:icon_hyphen[alt="Icon for displaying a negative status."].

[TIP]
====
As usual, you can continue to trigger notifications directly via the GUI as an alternative to testing notifications via simulation, e.g. with the [.guihint]#Send custom notification# and [.guihint]#Fake check results# xref:commands#[commands].
====


[#repeat_escalate]
=== Periodically-repeated notifications and escalation

For some systems, it can make sense not to leave it to a single notification when a problem persists over a longer time frame, for example, for hosts whose xref:glossar#host_tag[host tag] [.guihint]#Criticality# is set to [.guihint]#Business critical#.


==== Set up periodically-repeated notifications

{CMK} can be set up so that successive notifications are issued at fixed intervals, until either the problem has been icon:icon_ack[alt="Icon of an acknowledgment."] xref:basics_ackn#[acknowledged] or solved.

The setting for this can be found in the [.guihint]#Periodic notifications during host problems#, or respectively, the [.guihint]#Periodic notifications during service problems# rule set:

image::notifications_periodic.png[alt="Rule for periodically-repeated notifications."]

Once this option is active, for a persistent problem, {CMK} will trigger regular notifications at the configured intervals.
These notifications will receive an incrementing number beginning with 1 (for the initial notification).

Periodic notifications are not only useful for reminding about a problem (and _annoying_ the operator), they also provide a basis for _escalations_ 
-- meaning that after a defined time a notification can be escalated to other recipients.


==== Set up escalations and understand them

To set up an escalation, create an additional notification rule which uses the [.guihint]#Restrict to notification number# condition.

image::notification_rules_step5.png[alt="Regel zur Einstellung der Häufigkeit von Benachrichtigungen."]

If you enter 3 to 99999 as the range for the sequential number, this rule takes effect from the third notification.
The escalation can then be performed either by selecting another method, (e.g., SMS), or it can notify other persons (contact selection).

With the [.guihint]#Throttling of 'Periodic notifications'# option, after a given time the rate of notification repetition can be reduced so that, for example, in the beginning an email can be sent every hour, and later this can be reduced to one email per day.

With multiple notification rules, you can build an escalation model.
But how will this escalation then function in practice?
Who is notified and when?
Here is an example, implemented with one rule for periodically repeated notifications as well as three notification rules:
For example:

* In the event of a problem being detected in a service, a notification in the form of an email will be triggered every 60 minutes until the problem is either resolved or acknowledged.
* Notifications one to five go to the two people responsible for the service.
* Notifications six to ten are also sent to the relevant team leader.
* From notification eleven on, a daily mail goes to the company management instead.

At 9 o'clock in the morning, a problem occurs at the facility.
The two responsible employees are notified of the problem but do not respond (for whatever reason).
So at 10, 11, 12 and at 1 p.m. they each receive new emails.
From the sixth notification at 2 p.m., the team leader now also receives an email -- nevertheless, the problem still does not change.
At 3, 4, 5 and 6 p.m., further emails are sent to the team members and the team leader.

At 7 p.m., the third escalation level takes effect:
From now on, no more emails are sent to the team members or the team leader.
Instead, the company management now receives an email every day at 7 p.m. until the problem is resolved.

As soon as the problem has been fixed and the service in {CMK} goes back to {OK}, an 'all clear' is automatically sent to the last notified group of people:
So in the example above, if the problem is fixed before 2 p.m., to the two team members; if the problem is fixed between 2 and 7 p.m., to the team members and the team leader; and after 7 p.m., only to the company management.


[#cancel]
=== Deleting notifications by rules

As already mentioned in the selection of the notification method, you will also find the selection option [.guihint]#Suppress all previous#.
In order to be able to understand the functioning of such a rule, it is best to visualize the notification table.
Assuming the processing of the rules for a concrete monitoring event is partly complete, and that due to a number of rules the following three notifications have been triggered:

[cols=2,options="header"]
|===
|Who (contact) |How (method)
|Harry Hirsch |Email
|Bruno Weizenkeim |Email
|Bruno Weizenkeim |SMS
|===

Now comes a next rule with the [.guihint]#SMS# method and the [.guihint]#Cancel previous notifications# selection.
The contact selection chooses the 'Windows' group, in which Bruno Weizenkeim is a member.
As a result of this rule, the entry 'Bruno Weizenkeim / SMS' is removed from the table, which then looks like this:

[cols=2,options="header"]
|===
|Who (contact) |How (method)
|Harry Hirsch |Email
|Bruno Weizenkeim |Email
|===

Should a subsequent rule again define an SMS notification for Bruno, then this rule will have priority and the SMS will be added anew to the table.

To summarize:

* Rules can suppress (delete) specific notifications.
* Deletion rules must come after the rules that create the notifications.
* A deletion rule does not actually ‘delete’ a preceding rule, rather it suppresses the notifications that are generated by (possibly multiple) preceding rules.
* Subsequent rules can reinstate the previously suppressed notifications.


[#sync_html]
=== Synchronous delivery for HTML emails

You can select and configure the traceable delivery via SMTP for the notification method HTML email by entering the smarthost (with name and port number) and the access data and encryption method:

image::notification_rules_enable_sync_smtp.png[alt="Notification method with synchronous email delivery options."]

In the history of the service concerned, you can then track the delivery exactly.
Here is an example in which a service -- for testing purposes -- was manually set to {CRIT}.
The screenshot below shows the notifications for this service, which you can display on the service details page with [.guihint]#Service > Service Notifications#:

image::notifications_smtp_success.png[alt="List of accumulated notifications for a successful email delivery."]

Here you will see the four individual steps in the chronological sequence from bottom to top, as we have already presented them in the chapter on xref:notifications#history[notification history] in the in article on the notification basics.
The important difference is that now you can see in the icon:icon_alert_notify_result[] topmost entry that the email was successfully delivered to the smarthost and its response is `success`.

You can also follow the individual steps in the `~/var/log/notify.log` file.
The following lines belong to the last step and contain the response of the SMTP server:

.~/var/log/notify.log
[{file}]
----
2021-08-26 10:02:22,016 [20] [cmk.base.notify] Got spool file d3b417a5 (mysrv;CPU load) for local delivery via mail
2021-08-26 10:02:22,017 [20] [cmk.base.notify]      executing /omd/sites/mysite/share/check_mk/notifications/mail
2021-08-26 10:02:29,538 [20] [cmk.base.notify]      Output: success 250 - b'2.0.0 Ok: queued as 1BE667EE7D6'
----

The Message-ID `1BE667EE7D6`  will appear in the smarthost’s log file.
There -- if you are concerned -- you can investigate where the email has gotten to.
In any case you can prove that, and when, the email was correctly sent from {CMK}.

Let us repeat the test from above, but this time with a falsely-configured password for the SMTP transfer to the smarthost.
Here you can see in plain text the SMTP error message `Error: authentication failed` from the smarthost:

image::notifications_smtp_failed.png[alt="List of accumulated notifications for a failed email delivery."]

What can be done about failed notifications?
Again, notifying by email is apparently not a good solution.
Instead {CMK} shows a clear warning with red background color in the xref:user_interface#overview[Overview] snap-in:

image::notifications_overview_failed.png[alt="Display of failed notifications in the 'Overview' snap-in.",width=50%]

Here you can:

* Click on the text [.guihint]#... failed notifications# for a list of the failed deliveries.
* Click on the icon:icon_delete[alt="Icon for deleting."] icon to confirm these messages and remove the notice by clicking on icon:icon_confirm[alt="Icon for confirmation."] [.guihint]#Confirm# in the overview that opens.

*Important:* Note that direct delivery per SMTP in error situations can lead to a notification script running for a very long time and lead to a timeout.
For this reason you are strongly advised to use the notification spooler and to select an xref:notifications#async[asynchronous delivery] of notifications.

The conduct with repeatable errors (such as an SMTP timeout) can be defined with [.guihint]#Global settings > Notifications > Notification spooler configuration# per notification method:

image::notifications_plugin_timing_settings.png[alt="Global timer setting for a notification method."]

Alongside an optional timeout (the default is 1 minute) and a maximum number of retries, it can also be defined whether the script is permitted to run multiply in parallel and thus send multiple notifications ([.guihint]#Maximum concurrent executions#).
If the notification script is very slow a parallel execution can make sense -- however the script must be so-programmed that multiple executions run cleanly (and, for example, that the script doesn’t reserve certain data for itself).

A multiple, parallel delivery over SMTP is unproblematic since the target server can manage multiple parallel connections.
This is certainly not the case when delivering directly from SMS via a modem without an additional spooler, and here one should stick with the setting 1.

*Important:* Traceable delivery via SMTP is not available for xref:bulk[bulk notifications]!


[#bulk]
== Bulk notifications

=== Overview

Everyone who works with monitoring has experienced an isolated problem setting off a veritable flood of (successive) notifications.
The principle of the xref:notifications#parents[parent hosts] is a way of reducing these under specific circumstances, but unfortunately it doesn’t help in all cases.

You can take an example from the {CMK} project itself:
Once each day we build {CMK} installation packages for every supported Linux distribution.
Our own {CMK} monitoring is set up so that we have a service that is then only {OK} if the right number of packages have been correctly constructed.
It can occasionally happen that a general error in the software hampers the packaging, causing 43 services to go into a {CRIT} state simultaneously.

We have configured the notifications in such a way that in such a case only a single email listing all 43 notifications in sequence will be sent.
This is naturally clearer than 43 single emails, and it also reduces the risk that ‘in the heat of the battle’ one misses a 44th email belonging to quite another problem.

The mode of operation of this _bulk notification_ is very simple.
When a notification occurs, at first it will be held back for a short time.
Subsequent notifications that occur during this time will be immediately added into the same email.
This collecting can be defined _for each rule_.
So, for example, during the day you can operate with individual emails, but overnight with a bulk notification.
If a bulk notification is activated you will generally be offered the following options:

image::notification_rules_bulk.png[alt="Notification method with bulk notification options."]

The waiting time can be configured as desired.
In many cases one minute suffices as by then at the latest all related problems should have appeared.
You can of course set a longer time,
but that will result in a fundamental delay to the notifications.

Since it naturally makes no sense to throw everything into a single pot, you can specify which groups of problems should be notified collectively.
The [.guihint]#Host# option is very commonly used -- this ensures that only notifications from the same host are bundled.

Here are a few additional facts about bulk notifications:

* If the bundling is activated in a rule, the activation can be deactivated by a subsequent rule – and vice versa.

* The bulk notification always takes place per contact.
Each contact has their own 'private collection pot' in effect.

* You can limit the size of the pot ([.guihint]#Max. notifications per bulk#).
Once the maximum is reached the bulk notification will immediately be sent.


=== Bulk notifications and time periods

What happens when a notification is within the notification period, but the bulk notification that contains this notification -- and which comes somewhat later -- is outside the notification period?
The reverse situation is also possible...

Here a very simple principle applies:
all configurations that restrict notifications to time periods are valid only *for the actual notification*.
The subsequent bulk notification will always be delivered *independently* of all time periods.


ifdef::onprem[]
[#fallback]
== What happens if no rule is applicable?

One who configures can also make errors.
One possible error in the notification configuration could be that a critical monitoring problem is discovered, but not a single notification rule takes effect.

To protect you from such a case, {CMK} offers the setting [.guihint]#Fallback email address for notifications#.
This can be found under [.guihint]#Setup > General > Global settings# in the [.guihint]#Notifications# section.
Enter an email address here.
This email address will then receive notifications for which no notification rule applies.

[TIP]
====
Alternatively, you can also make a user the recipient in his xref:wato_user#user_config_notifications[personal settings]. 
The email address stored with the user is used as the fallback address.
====

The fallback address will however only be used if *no rule* applies, not when no notification has been triggered!
As we showed in in the section on xref:cancel[deletion of notifications], the explicit suppression of notifications is desired -- it is not a configuration error.

The entry of a fallback address will be ‘recommended’ on the [.guihint]#Notifications# page with an onscreen warning:

image::notifications_warning_fallback_email.png[alt="Warning that no fallback email address is stored."]

If - for whatever reason - you only want to get rid of the warning, but at the same time do *not* want to receive emails at the fallback address, first enter a fallback address anyhow and then create a new rule as the _first rule_, which deletes all previous notifications.
This rule is ineffective on the notification configuration, as no notifications have been created here yet.
But with this you can ensure that at least one rule will always apply, thus allowing this warning to be eliminated.

We explicitly advise against this approach, as you may overlook gaps in your rule chain.

// This block is new
// start translation
////
[TIP]
====
Wenn Sie Benachrichtigungen nur für sich persönlich abschalten wollen, können Sie dies über die xref:personal_notifications#[persönlichen Benachrichtigungen] machen.
====
////
// end translation
endif::[]