// -*- coding: utf-8 -*-
// IGNORE 
// NONASCII 
include::global_attr.adoc[]
= Setting up notifications by rules
:revdate: 2025-05-13
:title: Setting up notifications by rules
:description: Simple notifications can be sent by email, more complex notifications are controlled via rules. Learn here how to implement your requirements in {CMK}.

{related-start}
xref:notifications#[Notification basics]
xref:personal_notifications#[Personal notification rules]
xref:basics_ackn#[Acknowledging problems]
xref:commands#[Commands]
xref:wato_user#[Users, roles and permissions]
{related-end}


[#intro]
== Introduction

Following the xref:notifications#[Notification basics] article describing the fundamentals of notifications,
this article now deals with notifications by email and the creation of notifications via rules.


[#overview]
== The central view on notifications 

Via [.guihint]#Setup > Events > Notification# you can access the notifications overview page.
All important information on this topic is bundled here:

image::notifications_overview.png[alt=“The notifications overview page.”]

A functioning notification system is based on the interaction of a number of components that all need to be configured.
This overview page saves you having to search for the individual rules, parameters etc. in the various areas of {CMK}.
You can access all aspects relating to the topic of notifications from here.


=== Status of the notifications

An overview of the current status of the notifications appears on the left-hand side of the page:

image::notifications_failed.png[alt="Overview of the current status of notifications.", width=60%]

Displayed are:
[cols="20,~"]
|===
|[.guihint]#Failed notifications# |Number of failed notifications.
If failed notifications exist, a link to the corresponding overview is displayed below.
|[.guihint]#Total sent notifications# |Number of notifications sent.
If failed notifications exist, a link to the [.guihint]#Notifications of host & services#, filtered for the last 7 days, is displayed below.
You can use this to take a closer look at which notifications have been sent.
|[.guihint]#Core status of notifications# |Displays on how many {CMK} xref:glossar#site[sites] notifications are activated.
If they are deactivated on a site, e.g. via the xref:user_interface#master_control[Master control] snap-in, the site name is displayed.
This allows you to check whether this was intended.
|===


=== Notification rules

To the right of the status displays you will find links to all of the existing notification rules in {CMK}:

image::notifications_overview_rules.png[alt="Listing of notification rules."]

From here, you can access the rules for optimizing your notifications as well as all other rules relating to notifications.

[TIP]
====
The rules displayed here may already be familiar to you from other places in {CMK}. 
No new rules have been created here, only the existing ones have been clearly summarized.
====


ifdef::onprem[]
=== Global and predefined notification rule

The last part of the overview page consists of the existing global rule.

If you have a freshly-installed {CMK}, precisely one rule will have been predefined:

image::notifications_default_rule.png[alt="List with the predefined notification rule."]
endif::[]

ifdef::saas[]
=== Global and predefined notification rules

The last part of the overview page consists of the existing global rules.

If you have a freshly-installed {CMK}, precisely two rules will have been predefined:

image::notifications_default_rules_saas.png[alt="List with the predefined notification rules.",width=97%]
endif::[]

Such a rule is structured as follows:

[cols="30,~"]
|===
ifdef::onprem[]
|Condition |All status changes of hosts to {DOWN} and {UP}, and of services to {CRIT}, {WARN} and {OK}.
endif::[]
ifdef::saas[]
|Condition |All status changes of hosts to {DOWN}, {UP} and {UNREACH}, and of services to {CRIT} and {UNKNOWN}, among others.
endif::[]
|Method |Sends an email in HTML format (with embedded metric graphs).
|Contact |All contacts of the affected host/service.
|===

As usual, you can edit the rule icon:icon_edit[alt="Icon for editing."], clone it icon:icon_clone[alt="Icon for cloning."], delete it icon:icon_delete[alt="Icon for deleting."], or create a new rule.
Once you have more than a single rule, you can change their processing order by dragging and dropping them with the icon:icon_drag[alt="Icon for moving an entry in the list."] icon.

[TIP]
====
Changes to notification rules do *not* require activation of the changes,
rather they take effect immediately.
====


[#simple_mail]
== Simple notifications by email

But before you get into more complex notifications, start with a very simple form of notification -- a simple email.

An email notification sent by {CMK} in HTML format looks something like this:

[{image-border}]
image::html_notification.png[alt="A notification by email."]

As can be seen in the example, the email also contains the current xref:glossar#metric[metrics] for the affected service.

Before you receive such an email from {CMK}, a few preparations are necessary, as are described below.


=== Prerequisites

In the default {CMK} configuration, a user will receive notifications per email when the following prerequisites have been satisfied:

ifdef::onprem[]
* The {CMK} server has a functioning xref:smtp[setup for sending emails].
* An email address is configured for the xref:wato_user#user_config[user].
endif::[]
* The user is a member of a xref:wato_user#contact_groups[contact group], and is therefore a xref:glossar#contact[contact].
* A monitoring event occurs on a host or service assigned to this contact group, which triggers a notification.


ifdef::onprem[]
[#smtp]
=== Setting up mail dispatching in Linux

For the successful sending of emails, your {CMK} server must have a functioning SMTP-server configuration.
Depending on your Linux distribution, this could utilize, for example, Postfix, Qmail, Exim, or Nullmailer.
The configuration will be implemented with your Linux distribution’s resources.

The configuration is generally confined to registering a ‘smarthost’ (also known as an SMTP relay server) to which all emails will be directed.
This will then be your firm’s internal SMTP mail server.
As a rule smarthosts don’t require authentication in a LAN -- which makes matters simple.
In some distributions the smarthost will be queried during the installation.
With the {CMK} appliance one can configure the smarthost conveniently via the xref:appliance_usage#cma_webconf_system_settings[web interface].

You can test the sending of emails easily with the `mail` command on the command line.
Because there are numerous different implementations for this command under Linux, for standardization {CMK} provides the version from the link:https://heirloom.sourceforge.net/mailx.html[Heirloom mailx^] project directly in the site user’s search path (as `~/bin/mail`).
The corresponding configuration file is `~/etc/mail.rc`.
The best way to test this is as a site user, since the notification scripts will later run with the same permissions.

The email’s content is read from the standard input, the subject specified with `-s`, and the recipient’s address simply appended as an argument to the end of the command line:

[{shell-raw}]
----
{c-omd} echo "content" | mail -s test-subject harry.hirsch@example.com
----

The email should be delivered without delay.
If this doesn’t work, information can be found in the SMTP server’s log file in the `/var/log` directory (see xref:notifications#maillog[Files and directories]).
endif::[]


ifdef::onprem[]
=== Email address and contact groups

A user’s email address and contact groups are defined in the xref:wato_user#user_config[user administration]:

image::notifications_add_user.png[alt="Dialog for entering email address and selecting contact groups."]
endif::[]

ifdef::saas[]
=== Contact groups

A user’s contact groups are defined in the xref:wato_user#user_config[user administration]:

image::notifications_edit_user_saas.png[alt="Dialog for selecting contact groups."]
endif::[]

In a freshly-generated {CMK} site, initially there is only the [.guihint]#Everything# contact group.
Members of this group are automatically responsible for *all* hosts and services, and will be notified of every relevant monitoring event by email.


[#ticketsystem]
ifdef::onprem[]
=== Special cases: Ticket system, messenger and event engine

Instead of email or SMS, you can also send notifications to a ticket system (such as Jira or ServiceNow), a messenger (Slack, Mattermost) or an event engine (Event Console).
endif::[]

ifdef::saas[]
=== Special cases: Ticket system and messenger

Instead of email or SMS, you can also send notifications to a ticket system (such as Jira or ServiceNow) or a messenger (Slack, Mattermost).
endif::[]
There is a separate xref:notification_method[notification method] for each of these special cases, which can be selected in the notification rule.
However, you must note the following two points when creating the rule:

include::include_ticketsystem.asciidoc[]


[#finetuning]
=== Fine-tuning HTML email

When sending HTML emails, you may wish to add additional information or flexibly define a reply address ([.guihint]#Reply to#) to a specific contact for any queries.
For this, there is the [.guihint]#Setup > Notifications > Parameters for notification methods > HTML Email# rule, and in notification rules the HTML email xref:notification_method[notification method].
With these rules you can add a number of parameters such as response address, additional fields with details or free text formatted as HTML.

Note that in the [.guihint]#Custom HTML section (e.g. title, description…)#  field, for security reasons only a small set of HTML tags is allowed.
These are:

[cols="10,25,~",options="header"]
|===
|Tag |Function |Tips
|`a` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a[Anchor/Link^] |Permitted when combined with the `href` (mandatory) and `target` (optional) attributes. Links must either contain relative paths (i.e. start with `./` or `../`) or use one of the URL schemes `http`, `https` or `mailto`. We do not recommend using relative paths because of the very different handling by email clients.
|`h1` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1[Heading 1^] |
|`h2` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2[Heading 2^] |
|`b` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b[Bring Attention (usually bold)^] |
|`tt` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tt[Teletype (monospaced font)^] |Deprecated. Do not use this tag!
|`i` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i[Idiomatic (usually italic)^] |
|`u` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u[Unarticulated Annotation (usually underlined)^] |
|`br` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br[Break (Line Break)^] |
|`nobr` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nobr[Non-Breaking Text^] |Deprecated. Do not use this tag!
|`pre` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre[Preformatted^] |Spaces and indentations are preserved.
|`sup` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup[Superscript^] |
|`p`  |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p[Paragraph^] |
|`hr` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr[Thematic Break (Horizontal Rule)^] |
|`li` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li[List Item^] |Use only within the following lists `ul` and `ol`.
|`ul` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul[Unordered List^] |
|`ol` |link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol[Ordered List^] |
|===

As usual with all rules in {CMK}, a very finely granulated application is possible, so that you can individualize a detailed set of notifications to hosts and services as required.


[#rules]
== Controlling notifications with rules

In addition to simple email notifications, you can also set up more complex notification systems with {CMK}.


=== Simplified rule creation

To make it easier to create rules for notifications, {CMK} looks different here compared to what you are used to in other areas.
With [.guihint]#Setup > Events > Notifications > Add notification rule# you can get started with the creation of notifications:

image::notifications_modes.png[alt=“View of the two modes in ‘Add notification rule’.”]

You will now need to make a decision.

If you select [.guihint]#Guided mode,# you will be guided, section by section, through the creation of a notification rule.
Each section deals specifically with one aspect of the notification.
Fill in the respective section with the data relevant to your environment.
Descriptions of the individual topics can be found later in this article.
Once you have edited a section, click on [.guihint]#Next step...#.
Your details will then be verified, provided they are technically mandatory.
If, for example, technically relevant data such as the email address to be used is missing, you will receive an error message.
Once you have entered the essential basic data correctly, you will be taken to the next section and then finally to the end where you will have prepared a complete notification rule.
Then complete the creation with either [.guihint]#Apply & test notification rule# or [.guihint]#Apply & create another rule#. 

Alternatively, you can use the [.guihint]#Overview mode#.
This is particularly useful for the targeted editing of individual parameters in an existing notification rule -- likewise if you are already very familiar with rule creation and no longer want to be guided.
In [.guihint]#Overview mode# you see all editing sections at the same time and can edit all fields and options directly.
The technical verification is then carried out once and across all sections as soon as you click on 
[.guihint]#Apply & test notification rule# or [.guihint]#Apply & create another rule#.


[#notification_rule]
=== Structure of the notification rules

In the following, we present the general structure of the notification rules with the definitions of conditions, event types, filters, notification methods, contacts and general properties.


[#rule_conditions]
==== Conditions

Conditions determine when a rule will be used.
They are the basis for every rule. 
For comprehension it is important to remember that the source is always a monitoring event on a concrete host or service.

The conditions address

* the object's static attributes – e.g., whether the service name contains the `/tmp` text  or whether a host is in a specific xref:glossar#host_group[host group],
* with the current state or the change of the state, e.g. whether the service has just changed from {OK} to {CRIT},
* or with completely different things, e.g., whether the 'working time' xref:glossar#time_period[time period] is currently active.

There are two important points to consider when setting the conditions:

. If no conditions have been defined the rule will take effect for *every* monitoring event.
. As soon as you select even a single condition, the rule takes effect only if *all* conditions are met.
All selected conditions are linked with AND.
There is only one exception to this important rule, which we will discuss later and not consider now.

This means that you should pay very close attention to whether the conditions you have chosen can be met at the same time so that a notification is triggered for the desired case. 


==== Defining event types

In the following example of the structure of a notification rule, two status changes should trigger notifications:

* Hosts that change to the {DOWN} state and
* Services that change to the {CRIT} state.

This is defined in step 1:

image::notification_rules_step1.png[alt=“Rule with extended conditions for creating a notification.”]


[discrete]
==== The exception to the AND operation

The following generally applies in {CMK}:
Only if a monitoring event satisfies all configured conditions, the notification rule will apply. 
There is one important exception to this general rule: for the [.guihint]#Host events# and [.guihint]#Service events# conditions.

Should you select *only* [.guihint]#Host events#, the rule will match no single service event. 
Similarly, this applies to the selection of [.guihint]#Service events# and host events. 
Should you activate *both* conditions however, the rule will match if an event is defined in *any* of the two two conditions.
In this exceptional case these conditions will thus not be linked with a logical AND, but rather with an OR.
In this way you can simply administer host and service notifications with a single rule.


[#filter]
==== Setting host and service filters

In step 2, you use various filters to determine the hosts and services to which the notification rule should apply.

Assume you were to set the filter so that a notification would only be sent if a monitoring event for a service starting with the name `NTP` occurred on a host in the [.guihint]#Main# folder:

image::notification_rules_step2.png[alt=“Rule with the conditions for creating a notification.”]

The result of this notification rule with the three individual conditions (status changes, service name, folder) would be that the notifications would *only* be sent if a service went to {CRIT} -- and the status changes of the host would be ignored because no monitoring event would contain the status change of a host *and* the service name with `NTP`.

A further tip regarding the [.guihint]#Contact group filters# option in the image above:
The condition checked here is whether the host/service in question has a certain contact assignment.
This can be used to implement functions such as "Host notifications in the contact group Linux should never be sent by SMS".
This has nothing to do with the contact selection described above.


[#notification_method]
==== Notification method

The notification method in step 3 specifies the technique to be used for sending the notification., e.g. with HTML email.

image::notification_rules_step3.png[alt="Regel mit den Optionen zur Benachrichtigungsmethode."]

Each method is realized using a script.
ifdef::onprem[]
{CMK} includes a number of predefined xref:notifications#includedscripts[scripts].
You can also quite easily write your own xref:notifications#scripts[custom scripts] in any desired programming language in order to implement special notifications -- for example, to redirect a notification to your own ticket system.
endif::[]
ifdef::saas[]
{CMK} includes a number of predefined xref:notifications#scripts[scripts].
endif::[]

Some notification methods can include parameters.
For example, the methods for ASCII and HTML emails allow you to explicitly specify the sender address (`From:`).
The appropriate page for setting the parameters appears after selecting the method as soon as you click on [.guihint]#Create#.

However, before you make settings in the individual notification rule here, you should know that you can also set parameters for the notification methods generally in two other places in {CMK}:

* In the xref:parameters[Parameters for notification methods], which are described later in this article.
In the notification rule, select the desired parameter definition under [.guihint]#Select parameters# *before* you click on [.guihint]#Create# to change the selected parameter definition for this notification rule.

* In the xref:wato_rules#[rules] for hosts and services:
Under [.guihint]#Setup > Services > Service monitoring rules#, you will find a rule set for each notification method in the [.guihint]#Notifications# section, which you can use to define the same settings -- and as usual, depending on the host or service.

Only change the parameter definitions in the notification rule if you want to deviate from these settings for individual cases.
For example, you can define a specific subject for your email globally, but define an alternative subject in an individual notification rule.

Instead of [.guihint]#Send notification#, you can also select [.guihint]#Suppress all previous#.
Notifications from previous rules that used this method will then be discarded.
You can find more information on this in the section xref:cancel[Deleting notifications by rules].

[TIP]
====
For many notification methods for forwarding to other systems, you will find more detailed information in separate articles.
The list of articles can be found in the chapter on
ifdef::onprem[]
xref:notifications#includedscripts[notification scripts].
endif::[]
ifdef::saas[]
xref:notifications#scripts[notification scripts].
endif::[]
====


==== Selecting contacts

The most common procedure is for notifications to be sent to all users who have been registered as a xref:wato_user#add_host_to_contact_group[contact] for the respective host/service.
This is the ‘normal’ and logical procedure, since it is also via the contacts that it is defined which objects each user receives in their GUI display -- in effect those objects for which the user is responsible.

You can specify several options when selecting contacts with [.guihint]#Add recipient# and thus extend the notification to more contacts. 
{CMK} will automatically delete duplicate contacts.
In order for the rule to make sense at least one selection must be made.

image::notification_rules_step4.png[alt="Rule with contact selection options."]

The two [.guihint]#Restrict previous options to# options function somewhat differently.
Here the contacts selected with the other options will again be _restricted_.
With these you can also create an AND-operator between contact groups, for example, to enable notifications to be sent to all contacts who are members of both the `Linux` and `Data center` groups.

By entering [.guihint]#Explicit email addresses# you can notify persons who are not in fact nominated as users in {CMK}.
This of course only makes sense when used in the notification method that actually sends emails.

If, in the chosen method, you have selected [.guihint]#Suppress all previous#, the notifications will only be deleted for the contact selected here.

[TIP]
====
When using
ifdef::onprem[]
a ticket system, a messenger or an event engine
endif::[]
ifdef::saas[]
a ticket system or a messenger
endif::[]
as notification method, you should also observe the notes on these xref:ticketsystem[special cases].
====


==== Conditions for sending notifications

You can skip the [.guihint]#Sending conditions# step for simple rules for the time being.
These are primarily of interest if you want to set up xref:escalation[escalations].


==== General properties

As with all rules in {CMK}, here you can include a description and a commentary for the rule, or even temporarily deactivate the rule.

image::notifications_rule_part1.png[alt="Rule with the option to enable disabling of notifications by users."]

With the [.guihint]#Allow users to deactivate this notification# option you can allow users to 'unsubscribe' from notifications generated by this rule.
We show how to do this with the xref:personal_notifications#[personal notifications].


[#parameters]
=== Set parameters for notification methods

You can define separate parameters for each notification method.
These parameters are defined and managed separately from the actual notification rules in {CMK}.
This allows you to use the parameters for multiple rules at the same time.
You only need to make any changes centrally in one place, and you will get a uniform appearance for all notifications of the same type, regardless of the triggering rules.

Open the overview of all customizable parameters via [.guihint]#Setup > Events > Notifications# and the button [.guihint]#Parameters for notifications methods#:

image::notifications_parameters.png[alt=“Overview of all notification methods for which parameters can be assigned.”]

From here, you can create, edit and -- if they are not used in any rule -- delete the general parameters for each method.


[#notification_testing]
=== Testing notification rules

For testing notification rules, {CMK} offers a smart tool with [.guihint]#Test notifications#.
You can use it to simulate a notification for a host or service and recognize which of your notification rules are effective.
In addition to the simulation, you can also have the notification sent.

The quickest way to access the notification test is via [.guihint]#Setup > Events > Test notifications#.
In addition, there are other options for calling from some views in Monitoring (service list and service details) and in the Setup (host properties), in each case in the menu [.guihint]#Host > Test notifications#.

image::notifications_test.png[alt="Dialog for defining the properties of the simulated notification."]

First, click on one of the two buttons to decide whether the notification is for a [.guihint]#Host# or a [.guihint]#Service#.
Then select which host or service it should be.
As the event you can select a state change or the start of a xref:glossar#scheduled_downtime[scheduled downtime].
You can add a description of the event to [.guihint]#Plugin output#.
Use the [.guihint]#Send out notification for specific method# checkbox to specify whether the notification is only simulated or actually sent.

Finally, under [.guihint]#Advanced condition simulation# there are two further options with which you can define the time and number of notifications.
This allows you to test notification rules that only apply during a certain period (e.g. outside of business hours) or that start an xref:repeat_escalate[escalation] after a specified number of repeated notifications.

Click on [.guihint]#Test notifications# to start the test -- and also the dispatch, if you have selected this option.
The results are displayed below the [.guihint]#Test notifications# box:

image::notification_rules_test_results1.png[alt="Die Zusammenfassung der Simulationsresultate."]

First comes the summary.
Under [.guihint]#Test results# you can see how many notification rules apply and how many notifications result from them.
If you have selected _Send out notification_, the corresponding message `notifications have been sent out` is displayed here.
This must then immediately lead to an email for this problem.

The line below summarizes the notifications generated from your entries.
By clicking on the icon:icon_toggle_context[alt="Icon for showing or hiding the notification context."] icon, you can show the notification context.
This allows you to see the environment variables and their values that are valid in the context of this notification. 

The following two sections then show more details:

image::notifications_test_results2.png[alt="The details of the simulation results."]

Under [.guihint]#Predicted notifications# you can see to whom and how notifications would be sent.
You will also receive this information about the simulation if you have _not_ selected to send the notification.

Under [.guihint]#Global notification rules# the notification rules are listed that you have created here.
At this point, only the first column of the table is important, which uses icons to indicate which of the rules apply icon:icon_checkmark[alt="Icon for displaying a positive status."] and which do not icon:icon_hyphen[alt="Icon for displaying a negative status."].

[TIP]
====
As usual, you can continue to trigger notifications directly via the GUI as an alternative to testing notifications via simulation, e.g. with the [.guihint]#Send custom notification# and [.guihint]#Fake check results# xref:commands#[commands].
====


[#repeat_escalate]
=== Periodically-repeated notifications and escalation

For some systems, it can make sense not to leave it to a single notification when a problem persists over a longer time frame, for example, for hosts whose xref:glossar#host_tag[host tag] [.guihint]#Criticality# is set to [.guihint]#Business critical#.


==== Set up periodically-repeated notifications

{CMK} can be set up so that successive notifications are issued at fixed intervals, until either the problem has been icon:icon_ack[alt="Icon of an acknowledgment."] xref:basics_ackn#[acknowledged] or solved.

The setting for this can be found in the [.guihint]#Periodic notifications during host problems#, or respectively, the [.guihint]#Periodic notifications during service problems# rule set:

image::notifications_periodic.png[alt="Rule for periodically-repeated notifications."]

Once this option is active, for a persistent problem, {CMK} will trigger regular notifications at the configured intervals.
These notifications will receive an incrementing number beginning with 1 (for the initial notification).

Periodic notifications are not only useful for reminding about a problem (and _annoying_ the operator), they also provide a basis for _escalations_ 
-- meaning that after a defined time a notification can be escalated to other recipients.

[#escalation]
==== Set up escalations and understand them

To set up an escalation, create an additional notification rule which uses the [.guihint]#Restrict to notification number# condition.

image::notification_rules_step5.png[alt="Regel zur Einstellung der Häufigkeit von Benachrichtigungen."]

If you enter 3 to 99999 as the range for the sequential number, this rule takes effect from the third notification.
The escalation can then be performed either by selecting another method, (e.g., SMS), or it can notify other persons (contact selection).

With the [.guihint]#Throttling of 'Periodic notifications'# option, after a given time the rate of notification repetition can be reduced so that, for example, in the beginning an email can be sent every hour, and later this can be reduced to one email per day.

With multiple notification rules, you can build an escalation model.
But how will this escalation then function in practice?
Who is notified and when?
Here is an example, implemented with one rule for periodically repeated notifications as well as three notification rules:
For example:

* In the event of a problem being detected in a service, a notification in the form of an email will be triggered every 60 minutes until the problem is either resolved or acknowledged.
* Notifications one to five go to the two people responsible for the service.
* Notifications six to ten are also sent to the relevant team leader.
* From notification eleven on, a daily mail goes to the company management instead.

At 9 o'clock in the morning, a problem occurs at the facility.
The two responsible employees are notified of the problem but do not respond (for whatever reason).
So at 10, 11, 12 and at 1 p.m. they each receive new emails.
From the sixth notification at 2 p.m., the team leader now also receives an email -- nevertheless, the problem still does not change.
At 3, 4, 5 and 6 p.m., further emails are sent to the team members and the team leader.

At 7 p.m., the third escalation level takes effect:
From now on, no more emails are sent to the team members or the team leader.
Instead, the company management now receives an email every day at 7 p.m. until the problem is resolved.

As soon as the problem has been fixed and the service in {CMK} goes back to {OK}, an 'all clear' is automatically sent to the last notified group of people:
So in the example above, if the problem is fixed before 2 p.m., to the two team members; if the problem is fixed between 2 and 7 p.m., to the team members and the team leader; and after 7 p.m., only to the company management.


[#cancel]
=== Deleting notifications by rules

As already mentioned in the selection of the notification method, you will also find the selection option [.guihint]#Suppress all previous#.
In order to be able to understand the functioning of such a rule, it is best to visualize the notification table.
Assuming the processing of the rules for a concrete monitoring event is partly complete, and that due to a number of rules the following three notifications have been triggered:

[cols=2,options="header"]
|===
|Who (contact) |How (method)
|Harry Hirsch |Email
|Bruno Weizenkeim |Email
|Bruno Weizenkeim |SMS
|===

Now comes a next rule with the [.guihint]#SMS# method and the [.guihint]#Cancel previous notifications# selection.
The contact selection chooses the 'Windows' group, in which Bruno Weizenkeim is a member.
As a result of this rule, the entry 'Bruno Weizenkeim / SMS' is removed from the table, which then looks like this:

[cols=2,options="header"]
|===
|Who (contact) |How (method)
|Harry Hirsch |Email
|Bruno Weizenkeim |Email
|===

Should a subsequent rule again define an SMS notification for Bruno, then this rule will have priority and the SMS will be added anew to the table.

To summarize:

* Rules can suppress (delete) specific notifications.
* Deletion rules must come after the rules that create the notifications.
* A deletion rule does not actually ‘delete’ a preceding rule, rather it suppresses the notifications that are generated by (possibly multiple) preceding rules.
* Subsequent rules can reinstate the previously suppressed notifications.


[#sync_html]
=== Synchronous delivery for HTML emails

You can select and configure the traceable delivery via SMTP for the notification method HTML email by entering the smarthost (with name and port number) and the access data and encryption method:

image::notification_rules_enable_sync_smtp.png[alt="Notification method with synchronous email delivery options."]

In the history of the service concerned, you can then track the delivery exactly.
Here is an example in which a service -- for testing purposes -- was manually set to {CRIT}.
The screenshot below shows the notifications for this service, which you can display on the service details page with [.guihint]#Service > Service Notifications#:

image::notifications_smtp_success.png[alt="List of accumulated notifications for a successful email delivery."]

Here you will see the four individual steps in the chronological sequence from bottom to top, as we have already presented them in the chapter on xref:notifications#history[notification history] in the in article on the notification basics.
The important difference is that now you can see in the icon:icon_alert_notify_result[] topmost entry that the email was successfully delivered to the smarthost and its response is `success`.

You can also follow the individual steps in the `~/var/log/notify.log` file.
The following lines belong to the last step and contain the response of the SMTP server:

.~/var/log/notify.log
[{file}]
----
2021-08-26 10:02:22,016 [20] [cmk.base.notify] Got spool file d3b417a5 (mysrv;CPU load) for local delivery via mail
2021-08-26 10:02:22,017 [20] [cmk.base.notify]      executing /omd/sites/mysite/share/check_mk/notifications/mail
2021-08-26 10:02:29,538 [20] [cmk.base.notify]      Output: success 250 - b'2.0.0 Ok: queued as 1BE667EE7D6'
----

The Message-ID `1BE667EE7D6`  will appear in the smarthost’s log file.
There -- if you are concerned -- you can investigate where the email has gotten to.
In any case you can prove that, and when, the email was correctly sent from {CMK}.

Let us repeat the test from above, but this time with a falsely-configured password for the SMTP transfer to the smarthost.
Here you can see in plain text the SMTP error message `Error: authentication failed` from the smarthost:

image::notifications_smtp_failed.png[alt="List of accumulated notifications for a failed email delivery."]

What can be done about failed notifications?
Again, notifying by email is apparently not a good solution.
Instead {CMK} shows a clear warning with red background color in the xref:user_interface#overview[Overview] snap-in:

image::notifications_overview_failed.png[alt="Display of failed notifications in the 'Overview' snap-in.",width=50%]

Here you can:

* Click on the text [.guihint]#... failed notifications# for a list of the failed deliveries.
* Click on the icon:icon_delete[alt="Icon for deleting."] icon to confirm these messages and remove the notice by clicking on icon:icon_confirm[alt="Icon for confirmation."] [.guihint]#Confirm# in the overview that opens.

*Important:* Note that direct delivery per SMTP in error situations can lead to a notification script running for a very long time and lead to a timeout.
For this reason you are strongly advised to use the notification spooler and to select an xref:notifications#async[asynchronous delivery] of notifications.

The conduct with repeatable errors (such as an SMTP timeout) can be defined with [.guihint]#Global settings > Notifications > Notification spooler configuration# per notification method:

image::notifications_plugin_timing_settings.png[alt="Global timer setting for a notification method."]

Alongside an optional timeout (the default is 1 minute) and a maximum number of retries, it can also be defined whether the script is permitted to run multiply in parallel and thus send multiple notifications ([.guihint]#Maximum concurrent executions#).
If the notification script is very slow a parallel execution can make sense -- however the script must be so-programmed that multiple executions run cleanly (and, for example, that the script doesn’t reserve certain data for itself).

A multiple, parallel delivery over SMTP is unproblematic since the target server can manage multiple parallel connections.
This is certainly not the case when delivering directly from SMS via a modem without an additional spooler, and here one should stick with the setting 1.

*Important:* Traceable delivery via SMTP is not available for xref:bulk[bulk notifications]!


[#bulk]
== Bulk notifications

=== Overview

Everyone who works with monitoring has experienced an isolated problem setting off a veritable flood of (successive) notifications.
The principle of the xref:notifications#parents[parent hosts] is a way of reducing these under specific circumstances, but unfortunately it doesn’t help in all cases.

You can take an example from the {CMK} project itself:
Once each day we build {CMK} installation packages for every supported Linux distribution.
Our own {CMK} monitoring is set up so that we have a service that is then only {OK} if the right number of packages have been correctly constructed.
It can occasionally happen that a general error in the software hampers the packaging, causing 43 services to go into a {CRIT} state simultaneously.

We have configured the notifications in such a way that in such a case only a single email listing all 43 notifications in sequence will be sent.
This is naturally clearer than 43 single emails, and it also reduces the risk that ‘in the heat of the battle’ one misses a 44th email belonging to quite another problem.

The mode of operation of this _bulk notification_ is very simple.
When a notification occurs, at first it will be held back for a short time.
Subsequent notifications that occur during this time will be immediately added into the same email.
This collecting can be defined _for each rule_.
So, for example, during the day you can operate with individual emails, but overnight with a bulk notification.
If a bulk notification is activated you will generally be offered the following options:

image::notification_rules_bulk.png[alt="Notification method with bulk notification options."]

The waiting time can be configured as desired.
In many cases one minute suffices as by then at the latest all related problems should have appeared.
You can of course set a longer time,
but that will result in a fundamental delay to the notifications.

Since it naturally makes no sense to throw everything into a single pot, you can specify which groups of problems should be notified collectively.
The [.guihint]#Host# option is very commonly used -- this ensures that only notifications from the same host are bundled.

Here are a few additional facts about bulk notifications:

* If the bundling is activated in a rule, the activation can be deactivated by a subsequent rule – and vice versa.

* The bulk notification always takes place per contact.
Each contact has their own 'private collection pot' in effect.

* You can limit the size of the pot ([.guihint]#Max. notifications per bulk#).
Once the maximum is reached the bulk notification will immediately be sent.


=== Bulk notifications and time periods

What happens when a notification is within the notification period, but the bulk notification that contains this notification -- and which comes somewhat later -- is outside the notification period?
The reverse situation is also possible...

Here a very simple principle applies:
all configurations that restrict notifications to time periods are valid only *for the actual notification*.
The subsequent bulk notification will always be delivered *independently* of all time periods.


ifdef::onprem[]
[#fallback]
== What happens if no rule is applicable?

One who configures can also make errors.
One possible error in the notification configuration could be that a critical monitoring problem is discovered, but not a single notification rule takes effect.

To protect you from such a case, {CMK} offers the setting [.guihint]#Fallback email address for notifications#.
This can be found under [.guihint]#Setup > General > Global settings# in the [.guihint]#Notifications# section.
Enter an email address here.
This email address will then receive notifications for which no notification rule applies.

[TIP]
====
Alternatively, you can also make a user the recipient in his xref:wato_user#user_config_notifications[personal settings]. 
The email address stored with the user is used as the fallback address.
====

The fallback address will however only be used if *no rule* applies, not when no notification has been triggered!
As we showed in in the section on xref:cancel[deletion of notifications], the explicit suppression of notifications is desired -- it is not a configuration error.

The entry of a fallback address will be ‘recommended’ on the [.guihint]#Notifications# page with an onscreen warning:

image::notifications_warning_fallback_email.png[alt="Warning that no fallback email address is stored."]

If -- for whatever reason -- you only want to get rid of the warning, but at the same time do *not* want to receive emails at the fallback address, first enter a fallback address anyhow and then create a new rule as the _first rule_, which deletes all previous notifications.
This rule is ineffective on the notification configuration, as no notifications have been created here yet.
But with this you can ensure that at least one rule will always apply, thus allowing this warning to be eliminated.

We explicitly advise against this approach, as you may overlook gaps in your rule chain.

[TIP]
====
If you only want to switch off notifications for yourself personally, you can do this via xref:personal_notifications#[personal notification rules].
====
endif::[]
