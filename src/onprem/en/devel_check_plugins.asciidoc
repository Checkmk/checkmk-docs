// -*- coding: utf-8 -*-
include::global_attr.adoc[]
= Writing your own check plug-ins
:revdate: 2021-05-27
:title: Writing your own check plug-ins
:description: Here you will learn how to develop {CMK} plug-ins — with everything that goes with it, especially with the new Check API developed in version 2.0.0.

{related-start}
xref:localchecks#[Local checks]
xref:agent_linux#[Monitoring Linux]
xref:agent_windows#[Monitoring Windows]
xref:cmk_commandline#[{CMK} on the command line]
xref:mkps#[{CMK} extension packages (MKPs)]
xref:simulation_mode#[Simulation mode]
xref:snmp#[Monitoring via SNMP]
xref:wato_monitoringagents#[Monitoring agents]
xref:wato_services#[Understanding and configuring services]
{related-end}

////
Hintes for translation:
The old article is still online. Delete everything from line 1 to 2520.
Afterwards follows the new German article (including new header) commented out as usual.
////


== Introduction

{CMK} includes nearly 2000 ready-made check plug-ins for all imaginable hardware and software.
These are maintained by the {CMK} team, and new plug-ins are added every week.
On the link:https://exchange.checkmk.com[{CMK} Exchange^] there are also more plug-ins contributed by our users.

And yet there are always situations where a device, an application,
or just a specific metric that is important to you is not covered by any of
these plug-ins -- maybe because it is something that was developed within your
own company and is therefore not available to anyone else.


[#real_plug-in]
=== Does it always have to be a real plug-in?

What options do you have for implementing an effective monitoring here?
Well, you could of course contact our link:https://checkmk.com/product/pricing#/[support team^] and request that they develop a suitable plug-in for you -- but naturally it is quicker if you can do it yourself.

You have four options:

[cols=4]
|===
|Method |How to do it |Advantages |Disadvantages 

|xref:localchecks#[Local check] |Extend a {CMK} Agent with a simple script |Is very simple, is possible in all programming languages offered by the monitored host’s operating system, and even supports service discovery |Threshold configuration only for the agent itself, SNMP not possible or very cumbersome
|Nagios-compatible check plug-in |Run the plug-in via _MRPE_ from the xref:agent_windows#mrpe[Windows] or xref:agent_linux#mrpe[Linux] agent |Access to all existing Nagios plug-ins, also free choice of the programming language |Threshold configuration only for the agent itself, SNMP not possible or very cumbersome, no service discovery possible
|Evaluating log messages |Monitor _messages_ with the xref:ec#[Event Console] |No development necessary, but only need to set up rules in the Event Console |Only works if suitable log messages are available, no verified current status, no recording of metrics, no configurable thresholds
|Genuine {CMK} plug-in |Will be explained in this article |Integrates 100{nbsp}% with {CMK}, automatic service detection, central configuration of thresholds via graphical interface, very high performance, supports xref:snmp#[SNMP], automatic host and service labels are possible, supports xref:inventory#[HW/SW inventory], supported by standard libraries from {CMK} |Requires more training and knowledge of the Python programming language
|===

This article will show you how to develop real {CMK} check plug-ins -- along
with everything associated with them.
Here we show you how to use the *newly-developed API* for programming
plug-ins in version {v20} of {CMK}.


=== What has changed compared to the old API?

Do you already have experience with developing check plug-ins for {CMK} Version
{v16} or earlier? If so, here is a concise overview of all of the
changes introduced in the new Check API available from Version {v20}:

* Plug-ins are now Python 3 modules, and the file names must have the `.py` extension.
* The custom plug-ins are now located in the `local/lib/check_mk/base/plugins/agent_based` directory.
* At the beginning of the file you will now need at least one special `import` statement.
* The sections and the actual checks are now stored separately. For this purpose there are the new `register.agent_section` and `register.check_plugin` functions.
* Several function and argument names have been renamed. Among other things, _Discovery_ is now always used consistently (previously _Inventory_).
* The Discovery function (formerly Inventory function) and also the Check function must now _always_ work as generators (so use `yield`).
* The names for the declared functions' arguments are now fixed.
* Instead of the SNMP scan function, write a _declaration_ of which OIDs are expected with which values.
* The functions for representing numbers have been restructured (e.g. `get_bytes_human_readable` becomes `render.bytes`).
* There is now a separate method for checks to exclude others (`supersedes`). This is no longer done in the SNMP scan function.
* The auxiliary functions for working with counters, rates and averages have changed.
* Instead of magic return values such as `2` for {CRIT}, there are now constants (e.g. `State.CRIT`).
* Many possible programming errors in your plug-in are now recognized by {CMK} at a very early stage and can be immediately highlighted for you.


=== Will the old API still be supported?

Yes -- the API for the development of check plug-ins valid up to version
{v16} of {CMK} will be supported with some minor restrictions for a few
more years, because a significant number of plug-ins have been developed
with it. During this time, {CMK} will offer both APIs in parallel.
Details can be found in the
link:https://checkmk.com/werk/10601[#10601^] work.

Nevertheless, we do recommend the new API for the development of new plug-ins,
as it is more consistent and logical, better documented and is the most
future-proof solution in the long term.


=== The different types of agents

Check plug-ins evaluate the data from the {CMK} agents. And that is why, before
we leap into action here, we should first look at an overview of the types of
agents that {CMK} actually recognizes:

[cols="20,~"]
|===

|{CMK} Agent |The ‘normal’ plug-ins evaluate data that the {CMK} agent sends for Linux, Windows or other operating systems. This agent monitors operating system parameters and applications, and sometimes also server hardware. Each new check plug-in requires an extension of the agent to provide the necessary data. Therefore you first develop an agent plug-in, and then one or more check plug-ins that evaluate this data.
|Special Agent / API-Integration |You need a special agent if you do not receive the data that is relevant for monitoring from either the normal {CMK} agent or xref:snmp#[SNMP]. The most common application for Special Agent is querying HTTP-based APIs. Examples are, e.g. Monitoring xref:monitoring_aws#[AWS], xref:monitoring_azure#[Azure], or xref:monitoring_vmware#[VMware]. In this case you write a script that runs directly on the {CMK} server, connects to the API, and outputs data in the same format as an agent plug-in would. For this you write suitable check plug-ins in the same way as with the ‘agent-based’ monitoring.
|SNMP |When monitoring via xref:snmp#[SNMP] you do not need an extension of an agent, but simply evaluate the data retrieved from your device via SNMP, which provides this by default. {CMK} supports you and takes over all of the details and special features of the SNMP protocol. There is in fact an agent here as well -- namely the SNMP agent which is pre-installed on the system being monitored.
|Active Check |This check type forms a special role. Here you first write a classic Nagios-compatible plug-in which is intended for execution _on the {CMK} server_, and which from there uses a network protocol to directly query a service on the target device. The most prominent example is the `check_http` plug-in which allows you to monitor web servers and web pages. You can then integrate this plug-in into {CMK} so that it can be set up as usual via rules.
|===


=== Prerequisites

If you feel like programming check plug-ins, you need to satisfy the following prerequisites:

* Knowledge of the Python programming language
* Experience with {CMK}, especially with regard to agents and checks
* Experience with Linux on the command line

As preparation, the following articles are recommended:

- xref:wato_services#[Understanding and configuring services]
- xref:wato_monitoringagents#[Monitoring agents]
- xref:agent_windows#[Monitoring Windows]
- xref:agent_linux#[Monitoring Linux]
- xref:snmp#[Monitoring via SNMP]
- xref:cmk_commandline#[{CMK} on the command line]
- xref:mkps#[{CMK} extension packages (MKPs)]
- xref:simulation_mode#[Simulation mode]


[#agentbased]
== A first simple check plug-in

After this long introduction, it's time we programmed our first simple check
plug-in. As an example, let's take a simple monitoring for Linux.
Since {CMK} itself runs on Linux, it is very likely that you also have access
to a Linux system.

The check plug-in will create a new service that detects whether someone has
inserted a USB stick on a Linux server. In this case, this service should then
become critical. You might even find something like this useful, but it is really
only a simplified example and possibly also not programmed in a completely
watertight way -- but for now that's not what this exercise is really about.

The whole procedure involves two steps:

. We find out which Linux command can be used to determine whether a USB stick has been plugged in, and then extend the Linux agent with a small script that calls this command.
. We then write a check plug-in in the {CMK} site that evaluates this data.

Here we go...


=== Finding the right command

At the beginning of any check programming activity is the necessary research!
This means that we have to find out how we can get the information we need for
monitoring. With Linux, this will often involve command line commands.
In Windows, PowerShell, VBScript or WMI can help, and with xref:snmp#[SNMP] we have
to find the right OIDs (there is an xref:devel_check_plugins#snmp[own chapter] for this).

Unfortunately, there is no general procedure for determining the correct command,
so we do not want to spend too much time on the subject here, we will however briefly explain
how it works for a USB stick.

First we log in to the host we want to monitor. Under Linux, the agent runs
as the `root` user by default -- which is why we perform all our tests as `root`. For our task with the USB stick, there are convenient
symbolic links in the directory `/dev/disk/by-id`. These point to all the
Linux block devices. And a plugged-in USB stick is one such device. In addition,
you can tell by the ID of the prefix `usb-` when a block device is a USB
device.

The following command lists all entries in this directory:

[{shell}]
----
{c-root} ls -l /dev/disk/by-id/
total 0
lrwxrwxrwx 1 root root  9 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191 -> ../../sda
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5 -> ../../sda5
lrwxrwxrwx 1 root root  9 May 14 11:21 wwn-0x5002538655584d30 -> ../../sda
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part5 -> ../../sda5
----

So -- and now the whole thing with the plugged in USB stick:

[{shell}]
----
{c-root} ls -l /dev/disk/by-id/
total 0
lrwxrwxrwx 1 root root  9 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191 -> ../../sda
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5 -> ../../sda5
lrwxrwxrwx 1 root root  9 Mai 14 12:15 usb-SCSI_DISK-0:0 -> ../../sdc
lrwxrwxrwx 1 root root 10 Mai 14 12:15 usb-SCSI_DISK-0:0-part1 -> ../../sdc1
lrwxrwxrwx 1 root root 10 Mai 14 12:15 usb-SCSI_DISK-0:0-part2 -> ../../sdc2
lrwxrwxrwx 1 root root  9 Mai 14 11:21 wwn-0x5002538655584d30 -> ../../sda
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part5 -> ../../sda5
----


=== Purging the data

Actually, we would be finished with that and could transport this whole output
via the {CMK} agent to the {CMK} server and have it analyzed there as well,
because in {CMK} the following recommendation always applies: always let the
server do the complex work, so keep the agent plug-in as simple as possible.

But there is still too much hot air in here. Transferring unnecessary data is always undesirable. Avoiding unnecessary transfers saves network traffic, memory, computing time and also makes everything clearer. That is simply a better way of doing things!

First, we can omit the `-l`.
This already makes the output of `ls` much leaner:

[{shell}]
----
{c-root} ls /dev/disk/by-id/
ata-APPLE_SSD_SM0512F_S1K5NYBF810191        ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5  wwn-0x5002538655584d30-part3
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1  wwn-0x5002538655584d30-part4                ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2
wwn-0x5002538655584d30                      wwn-0x5002538655584d30-part5                ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3
wwn-0x5002538655584d30-part1                ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4  wwn-0x5002538655584d30-part2
----

Now again, the multi-column structure is disturbing, but this is only because
the `ls` command recognizes that it is running in an interactive terminal.
Later, as part of the agent, it will output the data in a single column.
But we can also easily force this here with the `-1` option (for output in *one* column):

[{shell}]
----
{c-root} ls -1 /dev/disk/by-id/
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5
wwn-0x5002538655584d30
wwn-0x5002538655584d30-part1
wwn-0x5002538655584d30-part2
wwn-0x5002538655584d30-part3
wwn-0x5002538655584d30-part4
wwn-0x5002538655584d30-part5
----

If you look closely, you will see not only the block devices themselves,
but also any partitions that exist there. These are the entries that end in
`-part1`, `-part2`, etc. We do not need these for our check and
can get rid of them quite easily with a `grep`. There we take the `-v` option for negative logic:

[{shell}]
----
{c-root} ls /dev/disk/by-id/ | grep -v -- -part
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
usb-SCSI_DISK-0:0
wwn-0x5002538655584d30
----

Here you can now see much more clearly that in our
example there are in fact exactly three devices when the USB stick is plugged in.

Perfect! We now have a clear list of all block devices which has been
compiled with a simple command. That's all we need.

We have again omitted the `-1` in the last command, because `ls` now writes into a pipe and outputs a single column by itself. And `grep` needs the
`--` because otherwise it would interpret the word `-part` as the
four options `-p`, `-a`, `-r` and `-t`.

And by the way: Why don't we simply 'grep' for `usb` in addition so that only USB devices are output? Well, of course we could do that. 
But for one thing, our example then becomes increasingly boring, and besides, it is somehow more
reassuring to get _some_ content in the section in a normal situation and not
simply nothing. In this way one can see immediately on the {CMK} server that the
agent plug-in is working correctly.


[#includecommand]
=== Including the command in the agent

In order for us to be able to retrieve this data from the {CMK} server,
we need to make the new command part of the {CMK} agent on the system being
monitored. We could of course simply edit the `/usr/bin/check_mk_agent` file
there and include that. However, this would have the disadvantage that our
command would disappear again when we update the agent's software because the
file will be replaced at that point.

It is therefore better if we make an *agent plug-in*. This is even simpler.
All we need is an executable file with our command in the
`/usr/lib/check_mk_agent/plugins` directory.

And one more point is important: we can't just output our data like this.
What we still need is a *section header*. This is a specially-formatted
line that contains our new check's name. By means of these section headers,
{CMK} can later recognize where this plug-in's data begins and the previous
plug-in's data ends.

So now we need a meaningful name for our new check.
This name is limited to lower case letters (only _a-z_, no accents, no umlauts), underscores and numbers and must be unique.
Avoid name collisions with existing check plug-ins.
If you are curious about which names already exist, in a {CMK} site you can list them on the command line with `cmk -L`:

[{shell}]
----
{c-omd} cmk -L | head -n 20
3par_capacity                agent      HPE 3PAR: Capacity
3par_cpgs                    agent      HPE 3PAR: CPGs
3par_cpgs_usage              agent      HPE 3PAR: CPGs Usage
3par_hosts                   agent      HPE 3PAR: Hosts
3par_ports                   agent      HPE 3PAR: Ports
3par_remotecopy              agent      HPE 3PAR: Remote Copy
3par_system                  agent      HPE 3PAR: System
3par_volumes                 agent      HPE 3PAR: Volumes
3ware_disks                  agent      3ware ATA RAID Controller: State of Disks
3ware_info                   agent      3ware ATA RAID Controller: General Information
3ware_units                  agent      3ware ATA RAID Controller: State of Units
acme_agent_sessions          snmp       ACME Devices: Agent Sessions
acme_certificates            snmp       ACME Devices: Certificates
acme_fan                     snmp       ACME Devices: Fans
acme_powersupply             snmp       ACME Devices: Power Supplies
acme_realm                   snmp       ACME Devices: Realm
acme_sbc                     agent      ACME SBC: Health
acme_sbc_settings            agent      ACME SBC: Health Settings
acme_sbc_snmp                snmp       ACME SBC: Health (via SNMP)
acme_temp                    snmp       ACME Devices: Temperature
----

The second column shows how the respective check plug-in obtains its data.

For our example, let's choose the name `linux_usbstick`.
In this example the section header must look like this:

[{file}]
----
<<<linux_usbstick>>>
----

We can simply output this with `echo`. If we then don't forget the
'Shebang' (this is not a venomous sting from the desert planet but an
abbreviation for _sharp_ and _bang_ -- the latter being an abbreviation
for the exclamation mark!), by which Linux recognizes that it should execute the
script with the shell, in which case our plug-in will look like this:

./usr/lib/check_mk_agent/plugins/linux_usbstick
[{file}]
----
#!/bin/sh
echo '<<<linux_usbstick>>>'
ls /dev/disk/by-id/ | grep -v -- -part
----

We have now simply used the file name `linux_usbstick`, even though it
doesn't really matter.
But one thing is still very important: Make the file executable!

[{shell}]
----
{c-root} chmod +x /usr/lib/check_mk_agent/plugins/linux_usbstick
----

Of course, you can easily try out the plug-in by manually by entering the
complete path as a command:

[{shell-raw}]
----
{c-root} /usr/lib/check_mk_agent/plugins/linux_usbstick
<<<linux_usbstick>>>
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
wwn-0x5002538655584d30
----


=== Testing the agent

As always, the next most important tasks are testing and troubleshooting.
It is best to proceed in three steps:

. Try out the plug-in on its own. We have just done that.
. From the agent test the whole process locally.
. Retrieve the agent via the {CMK} server.

Testing the agent locally is very simple -- as `root` user call
the command `check_mk_agent`.
The new section should appear somewhere in the output from this:

[{shell}]
----
{c-root} check_mk_agent
----

Here is an excerpt from that output which contains the new section:

[{shell-raw}]
----
<<<lnx_thermal:sep(124)>>>
thermal_zone0|-|BAT0|35600
thermal_zone1|-|x86_pkg_temp|81000|0|passive|0|passive
<<<local>>>
<<<linux_usbstick>>>
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
wwn-0x5002538655584d30
<<<lnx_packages:sep(124):persist(1589463274)>>>
accountsservice|0.6.45-1ubuntu1|amd64|deb|-||install ok installed
acl|2.2.52-3build1|amd64|deb|-||install ok installed
acpi|1.7-1.1|amd64|deb|-||install ok installed
----

By appending `less` you can scroll through the output (press the space
bar to scroll, `/` to search and `Q` to exit):

[{shell}]
----
{c-root} check_mk_agent | less
----

The third test is then performed directly from the {CMK} site. Include the
host in the monitoring (e.g. as `myserver01`) and then retrieve the agent
data with `cmk -d`. You should get the same output here:

[{shell}]
----
{c-omd} cmk -d myserver01 | less
----

By the way: `grep` has the `-A` option to output a few more lines
after each hit.  This allows you to conveniently search and output the section:

[{shell-raw}]
----
{c-omd} cmk -d myserver01 | grep -A5 '^<<<linux_usbstick'
<<<linux_usbstick>>>
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
wwn-0x5002538655584d30
<<<lnx_packages:sep(124):persist(1589463559)>>>
accountsservice|0.6.45-1ubuntu1|amd64|deb|-||install ok installed
----

If this works, your agent is now ready! And what have we done to achieve this?
We simply created a three-line script with the path
`/usr/lib/check_mk_agent/plugins/linux_usbstick` and made it executable!

Everything that follows now only takes place on the {CMK} server:
There we will write the actual check plug-in.


=== Declaring the section

Preparing the agent is the most complicated part, but it is only half the battle.
Now we have to teach {CMK} how to handle the information and the new agent
section, which services it should generate, when they should go to {OK} or
{CRIT}, etc. We do all this by programming a check plug-in in Python.

For your own check plug-ins you will find a directory prepared in the
`local` hierarchy of the xref:cmk_commandline#sitedir[site directory].
This is `local/lib/check_mk/base/plugins/agent_based/`.
Here in the path, `base` means the part of {CMK} that is responsible for
actually monitoring and alerting. The `agent_based` is for all plug-ins
that relate to the {CMK} agent (so not alerting plug-ins, for example).
The easiest way to work with this is to switch to it:

[{shell}]
----
{c-omd} cd local/lib/check_mk/base/plugins/agent_based
----

This directory belongs to the site user and is therefore editable by you.
You can edit your plug-in with any text editor installed on the Linux system.

So let's create our plug-in here. The convention is that the file name reflects
the agent section's name. _Mandatory_ is that the file ends with
`.py`, since from {CMK} version {v20} onwards the plug-ins
will always be real Python modules.

First, we need to import the functions needed for the plug-ins from other
Python modules. The simplest method for this is with a `pass:[*]`. As you might
guess, there is also a version number of the API for plug-in programming here.
This will be version 1 until further notice,
and is abbreviated here to `v1`:

.local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
[{python}]
----
from .agent_based_api.v1 import *
----

This versioning allows us to eventually provide future new versions of the API
_parallel_ to the previous ones, so that existing check plug-ins continue
to work without problems.

In the simplest case, you skip explicitly declaring the section.
If you want to implement a parse function (which professional developers would always advise you to do), see the xref:devel_check_plugins#parsefunction[section on parse functions] for more information.


=== Registering the check

In order for {CMK} to know that the new check exists, it must be registered.
This is done by calling the function `register.check_plugin`.
In doing so, you must always specify at least four things:

. `name`: The name of the check plug-in. If you don't want to get into trouble, take the same name here as for your new agent section. This way the check will automatically know which section to evaluate.
. `service_name`: The name of the service as it should then appear in the monitoring.
. `discovery_function`: The function that discovers services of this type (more on this in a moment).
. `check_function`: The function to perform the actual check (more on this in a moment).

So for our check the registration will look like this:

[{python}]
----
register.check_plugin(
    name="linux_usbstick",
    service_name="USB stick",
    discovery_function=discover_linux_usbstick,
    check_function=check_linux_usbstick,
)
----

It's best not to try this out just yet, because of course we still have to write
the `discover_linux_usbstick` and `check_linux_usbstick` functions
beforehand, and these functions must appear in the source code _before_
the above declaration.


=== Writing the discovery function

A special feature of {CMK} is the automatic discovery of services to be monitored.
In order for this to work, each check plug-in must define a function that detects
_whether_ a service of this type or _which_ services of this type are
to be created for the host in question on the basis of the agent's output.

The discovery function is always called when the service discovery is carried
out for a host. This function then decides whether or which services are to be
created. In the standard procedure, it receives exactly one argument with the
name `section`. This contains the data of the agent section in a parsed
format (more on this later).

We implement the following simple logic: _If_ the agent section
`linux_usbstick` exists, then we also create a matching service.
This service will then automatically appear on all hosts where our agent plug-in
has been rolled out. We recognize the presence of the section simply by the fact
that our discovery has actually been invoked!

The discovery function must return an object of the type `Service` for
each service to be created using `yield` (not with `return`).
For checks that can only occur once per host, no further information is needed:

[{python}]
----
def discover_linux_usbstick(section):
    yield Service()
----


=== Writing the check function

So now we can come to the actual check function, which finally decides on the
basis of current agent outputs which state a service should assume. Since our
check has no parameters and there is only ever one per host, our function is
also called with the single argument `section`.

Since we really need the content this time, we have to deal with the format of
this argument. Unless you have explicitly defined a
xref:devel_check_plugins#parsefunction[parse function]
{CMK} will parse each line
of the section into a _list of words_ using spaces. The whole thing then in
turn becomes a list of these word lists. So the end result is that we will
always have a list of lists.

In the simple case in which our agent plug-in only finds two devices,
it will then look like this (here there is only one word per line):

[{python}]
----
[['ata-APPLE_SSD_SM0512F_S1K5NYBF810191'], ['wwn-0x5002538655584d30']]
----

The check function now goes through line by line and looks for a line whose
first (and only) word begins with `usb-SCSI_DISK`.
If this is found, the state will become {CRIT}. Here is the implementation:

[{python}]
----
def check_linux_usbstick(section):
    for line in section:
        if line[0].startswith("usb-SCSI_DISK"):
            yield Result(state=State.CRIT, summary="Found USB stick")
            return
    yield Result(state=State.OK, summary="No USB stick found")
----

And here is the explanation:

. With `for line in section` we loop through all of the lines in the agent's output.
. We then check whether the first word in the line -- the respective device -- begins with `usb-SCSI_DISK`.
. If yes, we generate a check result with the status {CRIT} and the text `Found USB stick`. And we then end the function with a `return`.
. If the loop is run without finding anything, it will generate the status {OK} and the text `No USB stick found`.


=== The complete plug-in at a glance

And here is the complete plug-in one more time:

.local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
[{python}]
----
from .agent_based_api.v1 import *

def discover_linux_usbstick(section):
    yield Service()

def check_linux_usbstick(section):
    for line in section:
        if line[0].startswith("usb-SCSI_DISK"):
            yield Result(state=State.CRIT, summary="Found USB stick")
            return
    yield Result(state=State.OK, summary="No USB stick found")

register.check_plugin(
    name = "linux_usbstick",
    service_name = "USB stick",
    discovery_function = discover_linux_usbstick,
    check_function = check_linux_usbstick,
)
----

And this is the plug-in for the Linux agent:

./usr/lib/check_mk_agent/plugins/linux_usbstick
[{file}]
----
#!/bin/sh
echo '<<<linux_usbstick>>>'
ls /dev/disk/by-id/ | grep -v -- -part
----


== Checks with more than one service (items) per host


=== Basic principles

In our example, we have built a very simple check that creates a service on a
host -- or not. A very common situation is, of course, that there can be several
services with one check on one host.

The most common example of this is the file systems for a host.
The plug-in named `df` creates one service per file system on the host.
To distinguish these services, the mount point of the file system
(e.g. `/var`), or the drive letter (e.g. `C:`) is built into the
service name.  This then results in the service name being,
e.g. `filesystem /var`, or `filesystem C:`.
The word `/var` or `C:` is referred to here as the _item_.
So we also speak of a check _with items_.

If you want to build a check with multiple items,
you need to implement the following things:

* The discovery function must generate a service for each of the items that are to be meaningfully monitored on the host.
* In the service name you must include this item using the `%s` wildcard (i.e. `"Filesystem %s"`).
* The check function is invoked once separately for each item and receives this as an argument. It must then fish out the relevant data for this item from the agent data.


=== A simple example

To be able to test the whole thing practically, we will simply build another
agent section that only outputs game data. A small shell script is sufficient
for this. The section should be called `foobar` in this example:

./usr/lib/check_mk_agent/plugins/foobar
[{file}]
----
#!/bin/sh
echo "<<<foobar>>>"
echo "West 100 100"
echo "East 197 200"
echo "North 0 50"
----

From _foobar_, there are three sectors to be found here: `West`,
`East` and `North` (whatever that means).
In each sector there are a number of _seats_, some of which are occupied
(e.g. in `West` 100 of 100 seats are occupied).

Now we will create a matching check plug-in for this.
The registration is as usual, but with the important difference that the service
name now contains exactly one `%s`.
At this position the item's name will be inserted later by {CMK}:

[{python}]
----
register.check_plugin(
    name = "foobar",
    service_name = "Foobar Sector %s",
    discovery_function = discover_foobar,
    check_function = check_foobar,
)
----

The discovery function now has the task of determining the items to be monitored.
As usual, it receives the `section` argument. And again, this is a list
of lines, which in turn are lists of words.

In our example the list looks like this:

[{python}]
----
[['West', '100', '100'], ['East', '197', '200'], ['North', '0', '50']]
----

You can loop through such a list with Python and give meaningful names to these
three words grouped in each line:

[{python}]
----
for sector, _used, _slots in section:
    ...
----

In each line, the first word -- here the sector -- is our item.
Whenever we find an item, we return that with `yield`, creating an object
of type `Service` that gets the sector name as its item. The underscore
indicates that for now we don't care about the other two columns in the output,
since in a discovery it ultimately doesn't matter how many slots are occupied.

Overall it looks like this:

[{python}]
----
def discover_foobar(section):
    for sector, _used, _slots in section:
        yield Service(item=sector)
----

Of course, it would be easy to omit some lines here on the basis of arbitrary
criteria. Maybe there are sectors which have a size of 0 and which you would
never want to monitor? Simply omit such rows so that no item will be generated
for them.

Then later, when the host is being monitored, the check function is called
separately for each service -- and thus for each item. Therefore, in addition to
the section, it also receives the `item` argument with the item it is
looking for. Now we go through all of the lines one after the other.
When doing so, we will find the line that corresponds to the desired item:

[{python}]
----
def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            ...
----

Now all that is missing is the actual logic which determines when the item
should in fact be {OK}, {WARN} or {CRIT}. We do that here like this:

* When all slots have been used, the thing is to become {CRIT}.
* If there are fewer than 10 slots free, then it will become {WARN}.
* Otherwise {OK}

The occupied and total slots always appear as the second and third words in each
line. However, here we are dealing with strings, not numbers -- but we need
numbers to be able to compare and calculate. We therefore convert the strings
into numbers using `int()`.

We then return the check result by supplying an object of type `result`
via `yield`. This takes the parameters `state` and `summary`:

[{python}]
----
def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            used = int(used)   # convert string to int
            slots = int(slots)   # convert string to int
            if used == slots:
                s = State.CRIT
            elif slots - used <= 10:
                s = State.WARN
            else:
                s = State.OK
            yield Result(
                state = s,
                summary = f"Used {used} out of {slots} slots")
            return
----

In this context, please note the following:

. The command `return` ensures that the check function is terminated immediately after processing the found item. There is nothing more to be done, after all.
. If the loop is processed without finding the item being searched for, {CMK} _automatically_ generates the result `UNKNOWN - Item not found in monitoring data`. This is intentional and a good thing. Do not handle this case yourself. If you don't find an item you are looking for, just let Python run its course through the function and let {CMK} do its work.
. With the argument `summary` you define the text that the service produces from the status output. This is purely informal and will not be evaluated further by {CMK}.

By the way, for the common situation where you want to check a simple metric for thresholds, there is a helper function called `check_levels`.
This helper function is explained in the Check API documentation, which you can access in {CMK} via [.guihint]#Help > Check plugin API reference > Agent based API ("Check API")#.

Now let's first try out the discovery. For the sake of clarity we will restrict
this action to our plug-in by using the `--detect-plugins=foobar` option:

[{shell}]
----
{c-omd} cmk --detect-plugins=foobar -vI myhost123
  [green]#3# foobar
SUCCESS - Found 3 services, 1 host labels
----

And now right away we can test the checking process
(here also limited to `foobar`):

[{shell}]
----
{c-omd} cmk --detect-plugins=foobar -v myhost123
Foobar Sector East   [yellow]#WARN - used 197 out of 200 slots#
Foobar Sector North  [green]#OK - used 0 out of 50 slots#
Foobar Sector West   [red]#CRIT - used 100 out of 100 slots#
----


=== The example -- a recap

And here again our example in full. To avoid errors due to undefined function
names, the functions must always be defined before registering.

.local/lib/check_mk/base/plugins/agent_based/foobar.py
[{python}]
----
from .agent_based_api.v1 import *
import pprint


def discover_foobar(section):
    for sector, used, slots in section:
        yield Service(item=sector)


def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            used = int(used)    # convert string to int
            slots = int(slots)  # convert string to int
            if used == slots:
                s = State.CRIT
            elif slots - used <= 10:
                s = State.WARN
            else:
                s = State.OK
            yield Result(
                state = s,
                summary = f"used {used} out of {slots} slots")
            return


register.check_plugin(
    name = "foobar",
    service_name = "Foobar Sector %s",
    discovery_function = discover_foobar,
    check_function = check_foobar,
)
----


== Performance values


=== Determining values in the check function

Not always, but very often checks work with numbers.
With its xref:graphing#[graphing system] {CMK} has a component to store, evaluate and
display such numbers. This works completely independently from the generation of
any resulting {OK}, {WARN} or {CRIT} states.

Such measured values -- or metrics -- are determined by the check function and
simply returned as an additional result. For this purpose the `Metric`
object is used, which requires at least the two arguments `name` and
`value`. Here is an example:

[{python}]
----
    yield Metric("fooslots", used)
----


[#thresholdinformation]
=== Threshold information

Furthermore there are two optional arguments. With the argument `levels`
you can provide information about thresholds for {WARN} and {CRIT},
in the form of a pair of two numbers. This is then usually plotted on the graph
as a yellow and a red line. The first number (yellow line) represents the warning
threshold, the second (red line) the critical one. The convention is that the
check already goes to {WARN} when the warning threshold is reached (analogous
for {CRIT}).

The coding could then look like this (here with hard coded thresholds):

[{python}]
----
    yield Metric("fooslots", used, levels=(190,200))
----

Notes:

* If only one of the two thresholds will be defined, simply enter `None` for the other threshold, e.g. `levels=(None, 200)`.
* Floating point numbers are also allowed, but not strings.
* Attention: the check function itself is responsible for the _check_ of the thresholds .  The specification of `levels` serves only as marginal information for the graphing system!


=== The values range

Analogous to the threshold values, you can also provide the graphing system with
information about a range of possible values. This denotes the smallest and
largest possible value. This is done in the `boundaries` argument, where
`None` can also be optionally used here for one of the two boundaries.

Example:

[{python}]
----
    yield Metric(name="fooslots", value=used, boundaries=(0, 200))
----

And now once again our check function from the above example, but this time with
the return of metric information including threshold values and a value range
(this time of course not with fixed but with calculated values):

[{python}]
----
def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            used = int(used)    # convert string to int
            slots = int(slots)  # convert string to int

            yield Metric(
                "fooslots",
                used,
                levels=(slots-10, slots),
                boundaries=(0, slots))

            if used == slots:
                s = State.CRIT
            elif slots - used <= 10:
                s = State.WARN
            else:
                s = State.OK
            yield Result(
                state = s,
                summary = f"used {used} out of {slots} slots")
            return
----


== Checks with multiple partial results

In order to prevent the number of services on a host from growing out of all
control, several partial results are often combined in a single service.
For example, the [.guihint]#Memory used# service under Linux checks not only RAM and swap
usage, but also shared memory, page tables and various other information.

The API provided by {CMK} offers a very convenient interface for this. In this
way, a check function may simply generate a result with `yield` any
number of times. The overall status for the service is then based on the 'worst'
partial result according to the scheme {OK} → {WARN} → {UNKNOWN} → {CRIT}.

Here is an abbreviated, fictitious example:

[{python}]
----
def check_foobar(section):
    yield Result(state=State.OK, summary="Knulf rate optimal")
    # ...
    yield Result(state=State.WARN, summary="Gnarz required")
    # ...
    yield Result(state=State.OK, summary="Last Szork was good")
----

The summary of the service in the GUI then looks like this:
"Knulf rate optimal, Gnarz required {WARN}, Last Szork was good".
And the overall status will be {WARN}.

You can return multiple metrics in the same way.
Simply call `yield Metric(...)` once for each metric.


== Summary and Details

In the {CMK} monitoring, each service also has a line of text in addition
to its status {OK}, {WARN}, and so on. Up until version {v16} this was
called [.guihint]#Output of check plugin#. As of version {v20} this is now called
[.guihint]#Summary# -- so it has the task of providing a concise summary of the status.
The idea is that this text does not exceed a length of 60 characters,
so that it is always easy to read and ensures a clear table display without
annoying line breaks.

Next to this there is the [.guihint]#Details# field, which used to be called
[.guihint]#Long output of check plugin (multiline)#. Here all of the details of the state
are displayed, the idea being that all of the summary information is included
here as well.

When calling `yield Result(...)` you can determine which information is
so important that it should be displayed in the summary and for which information
it is sufficient that it appears in the details. The default rule is that partial
results that lead to a {WARN}/{CRIT} will _always_ be visible in the summary.

In our examples so far we have always used the following call:

[{python}]
----
    yield Result(state=State.OK, summary="some important text")
----

This will cause `some important text` to always appear in the
[.guihint]#Summary# -- and additionally in the [.guihint]#Details# -- so you should only use
this for important information. If a partial result is of secondary importance,
replace `summary` with `notice` and the text will appear -- if the service is {OK} _only_ in the details.

[{python}]
----
    yield Result(state=State.OK, notice="some additional text")
----

If the state is {WARN} or {CRIT}, the text will then automatically appear as an
addition in the summary:

[{python}]
----
    yield Result(state=State.CRIT, notice="some additional text")
----

Thus, in the summary it will be immediately clear why the service is not {OK}.

Last but not least, you have -- for both `summary` and `notice` --
the possibility to specify an _alternative_ text for the details,
which may contain more information about the partial result:

[{python}]
----
    yield Result(state=State.OK,
                 summary="55% used space",
                 details="55.2% of 160 GB used (82 GB)")
----

To summarize, this means:

* The full text of the summary (for services that are {OK}) should not exceed 60 characters.
* Always use either `summary` or `notice` -- not both, and not neither.
* Add `details` as necessary if you want the details text to be an alternative one.


[#errors]
== Error handling


=== Exceptions and crash reports

The correct handling of errors (unfortunately) consumes a large chunk of the
programming work. The good news is that the {CMK} API already does most of the
work for you. Consequently, in most cases, it is important for you to simply
*not* deal with errors.

When Python gets into a situation that is in some way _unexpected_ ,
it responds with what is known as an _exception_. Here are a few examples:

* You convert a string into a number with `int(...)`, but the string does not actually include a number, e.g. `int("foo")`.
* You access the fifth element of `bar` with `bar[4]`, but this in fact has only four elements.
* You are calling a function that does not exist.

Here the important general rule applies: *Don't capture exceptions yourself!*
{CMK} will always do this for you in a consistent and efficient way -- in most
cases accompanied by a _crash report_. Such a report will look like this, for
example:

image::crash_report_1.png[]

By clicking on the icon:icon_crash[] icon, the user is navigated to a page
where they can

* view a display of the file in which the crash took place.
* get all information about the crash, for instance any error messages, call stack, agent output, the current values of local variables and much more.
* send the report to us ({comfull}) as feedback.

Submitting the report of course only makes sense for check plug-ins
which are official {CMK} components. But you can also ask your users to simply
send you the data. The users can then help you to find the error. It is often
the case that a check plug-in works for you, but other users may experience
sporadic errors.
Working together you can then usually identify these problems very easily.

But if you were to intercept the exception yourself, all of this information
would simply be unavailable. You would perhaps set the service to {UNKNOWN} and
issue an error message, but all of the background circumstances that led to an
error (e.g. the data from the agent) would simply be invisible.


=== Viewing exceptions on the command line

If you run your plug-in on the command line, no crash reports will be generated --
you will only see the summarized error message:

[{shell}]
----
{c-omd} cmk -II --detect-plugins=foobar myhost123
  WARNING: Exception in discovery function of check plugin 'foobar': invalid literal for int() with base 10: 'foo'
----

BUT: if you simply append the `--debug` option to this, you will then
receive the Python stack trace:

[{shell}]
----
{c-omd} cmk --debug -II --detect-plugins=foobar myhost123
Traceback (most recent call last):
  File "/omd/sites/myhost123/bin/cmk", line 82, in <module>
    exit_status = modes.call(mode_name, mode_args, opts, args)
  File "/omd/sites/myhost123/lib/python3/cmk/base/modes/__init__.py", line 68, in call
    return handler(*handler_args)
  File "/omd/sites/myhost123/lib/python3/cmk/base/modes/check_mk.py", line 1577, in mode_discover
    discovery.do_discovery(set(hostnames), options.get("checks"), options["discover"] == 1)
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 345, in do_discovery
    _do_discovery_for(
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 397, in _do_discovery_for
    discovered_services = _discover_services(
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 1265, in _discover_services
    service_table.update({
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 1265, in <dictcomp>
    service_table.update({
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 1337, in _execute_discovery
    yield from _enriched_discovered_services(hostname, check_plugin.name, plugins_services)
  File "/omd/sites/myhost123/lib/python3/cmk/base/discovery.py", line 1351, in _enriched_discovered_services
    for service in plugins_services:
  File "/omd/sites/myhost123/lib/python3/cmk/base/api/agent_based/register/check_plugins.py", line 69, in filtered_generator
    for element in generator(*args, **kwargs):
  File "/omd/sites/myhost123/local/lib/python3/cmk/base/plugins/agent_based/foobar.py", line 5, in discover_foobar
    int("foo")
ValueError: invalid literal for int() with base 10: 'foo'
----


=== Invalid outputs from an agent

The question is how to react when the output from the agent is not in the form
you would normally expect -- whether it is from the 'real' agent or when the data
comes via xref:snmp#[SNMP]. Let's assume that you always expect three words per line.
What should you do if only two words were to arrive?

Now -- if this is a _permitted and familiar_ agent behavior, then of course
you need to capture that and employ case discrimination.

If, however, this is not actually allowed ... then it is best to treat the line
as if it always contains three words, e.g. with:

[{python}]
----
def check_foobar(section):
    for foo, bar, baz in section:
        # ...
----

If there should ever be a line that does not consist of exactly three words,
a nice exception will be generated and you will receive the very helpful crash
report that was just mentioned.


=== Missing items

What if the agent outputs data correctly, but the item to be checked is missing?
So, like this, for example:

[{python}]
----
def check_foobar(item, section):
    for sector, used, slots in section:
        if item == sector:
            # ... Check state ...
            yield Result(...)
            return
----

If the item you are looking for is not there, the loop is run and Python just
falls out of the back at the end of the function without 'yielding' a
result. And that's exactly the correct procedure! Because {CMK} recognizes that
the item to be monitored is missing and with {UNKNOWN} generates the correct
status and a suitable standard text for it.


[#snmp]
== SNMP-based checks


=== The fundamentals

Developing checks that work with SNMP is very similar to agent-based checks,
except that you still need to specify which SNMP ranges (OIDs) the check requires.
If you don't as yet have any experience with SNMP, we strongly recommend reading
the article on xref:snmp#[Monitoring via SNMP] as preparation at this point.

The process of discovery and checking via SNMP is somewhat different from that
for a normal agent. Because unlike there -- where the agent sends all of the
relevant information on its own -- with SNMP we have to say exactly which data
ranges we require. A complete dump of all data would be theoretically possible
(via SNMP walk), but this process can take minutes for fast devices and
over an hour for complex switches. Thus, this is not viable for checking or even
for discovery. {CMK} therefore proceeds in a more targeted manner.


==== SNMP detection

Service detection is divided into two phases. First, the _SNMP detection_
is performed. This determines which plug-ins on the respective device are of
actual interest. To do this, a few SNMP OIDs are retrieved -- individually,
without a walk. The most important of these is the
`sysDescr` (OID: `1.3.6.1.2.1.1.0`). Under this OID, each SNMP
device holds a description of itself,
e.g. `Cisco NX-OS(tm) n5000, Software (n5000-uk9),...`.

Based on this text, you can already define for very many plug-ins whether they
can be useful for this application. If the text is still not specific enough,
further OIDs are fetched and checked. The result of the SNMP detection will then
be a list of candidates for check plug-ins.


==== Discovery

In the second step, the necessary monitoring data is fetched for each of these
candidates with SNMP walks. These are then combined into a table and provided to
the check's discovery function with the `section` argument, which then as
usual determines the items to be monitored.


==== Checking

When running checks, it is already known which plug-ins are to be executed for
the device and the SNMP detection is now omitted. Here the monitoring data
needed for the plug-ins are fetched immediately by SNMP walks and from it the
`section` argument for the check function is filled.


==== Summary

So what do you need to do differently with an SNMP check compared to an
agent-based one?

. You do not need a plug-in for the agent.
. You must define the single OIDs and search texts required for an SNMP detection.
. You have to define which SNMP areas must be fetched for monitoring.


=== A word about the MIBs

Before we continue, we want to say a word about the infamous SNMP MIBs, because
there are many prejudices about these. Right at the beginning, some good news:
{CMK} doesn't need them. Really! But they are an important aid in being able to
_develop_ an SNMP check.

So what is a MIB? Literally, the abbreviation means
_Management Information Base_ -- somewhat meaningless really.
To be concrete, a MIB is a quite easy to read text file which describes a
certain subtree in the SNMP world. Namely, it states which branch in the
tree -- that is, which _OID_ -- has which meaning. This includes a name for
the OID, a comment on what values it can take (e.g. for enumerated data types,
where things like 1=up, 2=down, etc. are defined) and sometimes a useful comment.

{CMK} provides a set of freely-available MIB files. These describe very general
areas in the global OID tree, but do not contain any vendor-specific areas.
Therefore they are of not much help for self-developed checks.

So try to find the MIB files relevant for your particular device somewhere on
the manufacturer's web pages or even on the device's management interface,
and install these in the {CMK} site in `local/share/check_mk/mibs`.
You can then have SNMP walks convert OID numbers to names and can thus more
quickly find where the data of interest for your monitoring is located.
Also, MIBs, if done carefully, contain interesting information in their
comments, as we noted above. You can easily read an MIB file with a text editor
or with `less`.


[#locating_oids]
=== Locating the correct OIDs

The crucial prerequisite for developing a plug-in is, of course, that you know
which OIDs contain the necessary information. The first step in doing this (if
the device doesn't refuse) is to perform a complete SNMP walk.
This will retrieve _all_ of the available data via SNMP.

{CMK} can accomplish this very easily for you. To do so, first include the
device (or one of the devices) for which you want to develop a plug-in into your
monitoring. Let's say this device is called `mydevice01`. Check in the
device's basic functions to make sure that it can be monitored.
As a minimum, the [.guihint]#SNMP Info# and [.guihint]#Uptime# services need to be found,
and probably at least one [.guihint]#Interface# as well.
This is how you make sure that SNMP access works cleanly.

Then switch to the command line in the {CMK} site. Here you can perform a
complete walk with the following command. We recommend using the `-v`
(verbose) option when doing this for the very first time:

[{shell}]
----
{c-omd} cmk -v --snmpwalk mydevice01
mydevice01:
Walk on ".1.3.6.1.2.1"...3898 variables.
Walk on ".1.3.6.1.4.1"...6025 variables.
Wrote fetched data to /omd/sites/heute/var/check_mk/snmpwalks/mydevice01.
----

As mentioned earlier, such a complete walk can take minutes or even
hours -- although the latter is rare. So don't become nervous if it takes a
while to complete this process. The walk will be saved in the file
`var/check_mk/snmpwalks/mydevice01`.
This will be a easily-readable text file that starts something like this:

.var/check_mk/snmpwalks/mydevice01
[{file}]
----
.1.3.6.1.2.1.1.1.0 JetStream 24-Port Gigabit L2 Managed Switch with 4 Combo SFP Slots
.1.3.6.1.2.1.1.2.0 .1.3.6.1.4.1.11863.1.1.3
.1.3.6.1.2.1.1.3.0 546522419
.1.3.6.1.2.1.1.4.0 hh@example.com
.1.3.6.1.2.1.1.5.0 sw-ks-01
.1.3.6.1.2.1.1.6.0 Core Switch Serverraum klein
.1.3.6.1.2.1.1.7.0 3
.1.3.6.1.2.1.2.1.0 27
----

In each line there is an OID and then its value. And right there in the first
line you find the most important one, namely the `sysDescr`.

Now the OIDs themselves are not very informative. If the correct MIBs are
installed, you can have them converted to names in a second step with
the `cmk --snmptranslate` command. It is best to redirect the result --
which would otherwise appear in the terminal -- to a file:

[{shell}]
----
OMD[heute]:~$ cmk --snmptranslate mydevice01  > translated
Processing 9923 lines.
finished.
----

The `translated` file reads like the original walk, but has a translated
value for the OID on each line after the `--&gt;`:

.translated
[{file}]
----
.1.3.6.1.2.1.1.1.0 JetStream 24-Port Gigabit L2 Managed Switch with 4 Combo SFP Slots --> SNMPv2-MIB::sysDescr.0
.1.3.6.1.2.1.1.2.0 .1.3.6.1.4.1.11863.1.1.3 --> SNMPv2-MIB::sysObjectID.0
.1.3.6.1.2.1.1.3.0 546522419 --> DISMAN-EVENT-MIB::sysUpTimeInstance
.1.3.6.1.2.1.1.4.0 hh@example.com --> SNMPv2-MIB::sysContact.0
.1.3.6.1.2.1.1.5.0 sw-ks-01 --> SNMPv2-MIB::sysName.0
.1.3.6.1.2.1.1.6.0 Core Switch Serverraum klein --> SNMPv2-MIB::sysLocation.0
.1.3.6.1.2.1.1.7.0 3 --> SNMPv2-MIB::sysServices.0
.1.3.6.1.2.1.2.1.0 27 --> IF-MIB::ifNumber.0
.1.3.6.1.2.1.2.2.1.1.1 1 --> IF-MIB::ifIndex.1
.1.3.6.1.2.1.2.2.1.1.2 2 --> IF-MIB::ifIndex.2
----

Example: the OID `.1.3.6.1.2.1.1.4.0` has the translated name
`SNMPv2-MIB::sysContact.0`. This is an important hint -- the rest is then
practice, experience and of course experimentation.


=== Registering the SNMP section

So, once you have determined the necessary OIDs, it's on to the actual
development of the plug-in. This is done in three steps:

. For an SNMP detection, specify which OIDs must contain which texts for your plug-in to run.
. Declare which OID branches need to be fetched for the monitoring.
. Write a check plug-in analogous to those for agent-based checks.

The first two steps are performed by registering an SNMP section.
You do this by calling `register.snmp_section()`. Here you specify at
least three arguments: the name of the section (`name`), the details for
the SNMP detect `detect`, and the OID branches needed for actually
monitoring (`fetch`). Here is an example of a hypothetical check plug-in
with the name `foo`:

.local/lib/check_mk/base/plugins/agent_based/foo.py
[{python}]
----
register.snmp_section(
    name = "foo",
    detect = startswith(".1.3.6.1.2.1.1.1.0", "foobar device"),
    fetch = SNMPTree(
        base = '.1.3.6.1.4.1.35424.1.2',
        oids = [
            '4.0',
            '5.0',
            '8.0',
        ],
    ),
)
----


==== The SNMP detection

With the keyword `detect` you specify under which conditions the discovery
function should be executed. In our example, this is the case if the value of the
OID `.1.3.6.1.2.1.1.0` (i.e. the `sysDescr`) starts with the text
`foobar device` (case-insensitive in principle). In addition to
`startswith`, there are a number of other possible attributes. There is
also a negated form of each of these, which begins with `not_`:

[cols="28,33,~"]
|===
|Attribute |Negation |Function 

|`equals(oid, needle)` |`not_equals(oid, needle)` |The value of the OID is equal to the text `needle`
|`contains(oid, needle)` |`not_contains(oid, needle)` |The value of the OID at some point contains the text `needle`
|`startswith(oid, needle)` |`not_startswith(oid, needle)` |The value of the OID starts with the text `needle`
|`endswith(oid, needle)` |`not_endswith(oid, needle)` |The value of the OID ends with the text `needle`
|`matches(oid, regex)` |`not_matches(oid, regex)` |The value of OID matches the xref:regexes#[regular expression] `regex`, anchored at the start and at the end -- so with an exact match. If you only need a substring, just add another `pass:[.*]`
|`exists(oid)` |`not_exists(oid)` |Met if the OID is available on the device. The value may be empty.
|===

As well as the above, there is also the possibility of linking multiple tests with
`all_of` or `any_of`. The option `all_of` requires multiple
successful attributes for a positive discovery of the plug-in. The following
example finds the plug-in on a device if `sysDescr` starts with the text
`foo` (or `FOO` or `Foo`) *and* the
OID `.1.3.6.1.2.1.2.0` contains the text `.4.1.11863.`:

[{python}]
----
detect = all_of(
    startswith(".1.3.6.1.2.1.1.1.0", "foo"),
    contains(".1.3.6.1.2.1.1.2.0", ".4.1.11863.")
)
----

The `any_of` option, on the other hand, is satisfied if any single one of
the criteria is met. Here is an example where different values are allowed for
the  `sysDescr` keyword:

[{python}]
----
detect = any_of(
    startswith(".1.3.6.1.2.1.1.1.0", "foo version 3 system"),
    startswith(".1.3.6.1.2.1.1.1.0", "foo version 4 system"),
    startswith(".1.3.6.1.2.1.1.1.0", "foo version 4.1 system"),
)
----

By the way -- are you familiar with xref:regexes#[regular expressions]? If so, with
these you would probably simplify this whole process and still get by with just
a single line:

[{python}]
----
detect = matches(".1.3.6.1.2.1.1.1.0", "FOO Version (3|4|4.1) .*"),
----

And one more important note: The OIDs you specify in the `detect`
declaration from a plug-in will, in case of doubt, be fetched from *every*
device that is monitored via SNMP. Therefore, be very sparing in your use of
vendor-specific OIDs. Try to make your discovery absolutely exclusive to the
`sysDescr` (`.1.3.6.1.2.1.1.1.0`) and the `sysObjectID`
(`.1.3.6.1.2.1.1.2.0`). If you still need another different OID, then
reduce the number of devices where it is requested to a minimum by excluding as
many devices as possible beforehand using the `sysDescr`, e.g. like this:

[{python}]
----
detect = all_of(
    startswith(".1.3.6.1.2.1.1.1.0", "foo"),   # first check sysDescr
    contains(".1.3.6.1.4.1.4455.1.3", "bar"),  # fetch vendor specific OID
)
----

The `all_of()` works in such a way that if the first condition fails,
the second is not even tried (and thus the OID in question is not fetched).
Here in the example, the OID `.1.3.6.1.4.1.4455.1.3` is fetched only for
those devices that have `foo` in their `sysDescr`.

What happens if you have made the declaration incorrectly or at least not quite
on target?

* If the detection erroneously detects devices that do not have the necessary OIDs, your discovery function will not generate any services -- so nothing 'bad' will happen. However, this will slow down the discovery on such devices, because now every time it will pointlessly try to retrieve the corresponding OIDs.
* If the detection does _not_ detect devices that are actually allowed, during the discovery no services will be found in the monitoring.


=== The OID ranges for monitoring

The most important part of the SNMP declaration is the specification of which
OIDs are to be fetched for the monitoring. In almost all cases, a plug-in only
needs selected branches from a single table to do this.
Let's consider the following example:

[{python}]
----
    fetch = SNMPTree(
        base = '.1.3.6.1.4.1.35424.1.2',
        oids = [
            '4.0',
            '5.0',
            '8.0',
        ],
    ),
----

The keyword `base` specifies an OID prefix here.
All necessary data is below. At `oids` you then specify a list of
sub-OIDs to be fetched from there. In the above example, a total of three SNMP
walks are then made, namely on starting from the OIDs
`.1.3.6.1.4.1.35424.1.2.4.0` and `.1.3.6.1.4.1.35424.1.2.5.0`
and `.1.3.6.1.4.1.35424.1.2.8.0`. It is important that these walks fetch
the same number of variables and that they also correspond to each other.
This means that, for example, the nth element from each of the walks corresponds
to the same monitored object.

Here is an example from the check plug-in `snmp_quantum_storage_info`:
[{python}]
----
    tree = SNMPTree(
       base=".1.3.6.1.4.1.2036.2.1.1",  # qSystemInfo
       oids=[
           "4",   # qVendorID
           "5",   # qProdId
           "6",   # qProdRev
           "12",  # qSerialNumber
       ],
    ),
)
----

Here, the vendor ID, the product ID, the product revision and the serial number
are retrieved from each storage device.

The discovery and check function is presented with this data as a table,
i.e. as a list of lists. The table is mirrored so that you have all of the data
for each item per entry in the outer list. Each entry has as many items as you
specified in `oids`.
This allows you to loop through the list in a very practical way, e.g.:

[{python}]
----
    for vendor_id, prod_id, prod_rev, serial_number in section:
        ...
----

Please note:

* All entries are _strings_, even if the OIDs in question are actually numbers.
* Missing OIDs are presented as empty strings.
* Remember the ability to output formatted data during development with `pprint`.


=== Other SNMP special features

We will describe here in the future:

* How to retrieve multiple independent SNMP areas.
* What OIDEnd() is all about
* Other special cases when dealing with SNMP


[#format_numbers]
== Formatting numbers


=== The basics

In the summary or details for a service, numbers are often output. To make it as
easy as possible for you to format them nicely and correctly, and also to
standardize the output from all check plug-ins, there are helper functions for
rendering different kinds of sizes. All of these are sub-functions of the
`render` module and are consequently called with `render.`.
For example, `render.bytes(2000)` results in the text `1.95 KiB`.

What all of these functions have in common is that they get their values in a
so-called _canonical_ or natural unit. Thus one must never think, and there
are no difficulties or errors with the conversion. For example, times are always
given in seconds, and the sizes of hard disks, files, etc. are always given in
bytes and not in kilobytes, kibibytes, blocks or any other confusion of units.

Please use these functions even if you don't like the display so much.
After all, this is then consistent for the user. And future versions of {CMK}
may be able to change the display or even make it configurable for the user.
Your check plug-in will then also benefit from this.

Following the detailed description of all of the display functions
(render functions), you will find a summary of these in the form of a clear table.


=== Times, time spans, frequencies

Absolute time specifications (timestamps) are formatted with
`render.date()` or `render.datetime()`. The specifications are
always in _seconds from January 1, 1970, 00:00:00 UTC_ -- the so-called
epoch time. This is also the format used by the Python function
`time.time()`. The advantage of this representation is that it can be
used to calculate very easily, for example, the duration of an operation if the
start and end times are known. The formula is then simply
`duration = end - start`. These calculations also work independently of
the time zone, daylight saving time changes or leap years.

`render.date()` outputs only the date, `render.datetime()` adds
the time. The output is done according to the current time zone for the {CMK} server that is running the check!

Examples:

[cols="50,~"]
|===
|Call |Output 

|`render.date(0)` |`Jan 01 1970`
|`render.datetime(0)` |`Jan 01 1970 01:00:00`
|`render.date(1600000000)` |`Sep 13 2020`
|`render.datetime(1600000000)` |`Sep 13 2020 14:26:40`
|===

Now please don't be surprised that `render.date(0)` outputs 01:00 as the
time instead of 00:00! This is because we are writing this manual in the time zone
for Germany, which is one hour ahead of UTC standard time (at least during
standard time, because, as you know, January 1 is not in (the European Summer)
daylight saving time)

For _time span_ there is still the function `render.timespan()`.
This produces a duration in seconds and outputs it in a human readable form.
For larger time spans, seconds or minutes are omitted.

[cols="50,~"]
|===
|Call |Output 

|`render.timespan(1)` |`1 second`
|`render.timespan(123)` |`2 minutes 3 seconds`
|`render.timespan(12345)` |`3 hours 25 minutes`
|`render.timespan(1234567)` |`14 days 6 hours`
|===


A _frequency_ is effectively the reciprocal of time.
The canonical unit is _Hz_, which is equivalent to once per second.
A field of application is, for example, for the clock rate of a CPU:

[cols="50,~"]
|===
|Call |Output 

|`render.frequency(111222333444)` |`111 GHz`
|===


=== Bytes

Whenever memory, files, hard disks, file systems and the like are concerned,
the canonical unit is the _byte_. Since computers usually organize such
things in powers of two, e.g. in units of 512, 1024 or 65536 bytes, from the
beginning it has been accepted that a _kilobyte_ is not 1000 but 1024 bytes.
This is in itself very practical, because in this way mostly round numbers
came out. The legendary Commodore C64 had a 64 kilobyte memory and not 65,536.

Unfortunately, at some point hard disk manufacturers came up with the idea of
specifying the sizes of their disks in 1000's of units. Since the difference
between 1000 and 1024 is 2.4{nbsp}% for each size, and these are multiplied,
a 1 GB disk (1024 times 1024 * 1024) suddenly becomes 1.07 GB. That sells better.

This annoying confusion persists to this day and continues to cause errors.
As a remedy, new prefixes based on the binary system were defined by the
International Electrotechnical Commission. Accordingly, nowadays a kilobyte is
officially 1000 bytes, and a _kibibyte_ is 1024 bytes (2 to the power of 10).
In addition one should say _Mebibyte_ and _Gibitbyte_ and
_Tebibyte_ (ever heard of these?). The abbreviations are (attention,
here at once always *i*, instead of *e*!) _KiB_, _MiB_,
_GiB_ and _TiB_.

{CMK} adapts itself to this standard and helps you with multiple adapted render
functions so that you can always produce correct outputs. So specifically for
hard disks and file systems there is the `render.disksize()` function,
which gives the output in powers of 1000.

[cols="50,~"]
|===
|Call |Output 

|`render.disksize(1000)` |`1.00 kB`
|`render.disksize(1024)` |`1.02 kB`
|`render.disksize(2000000)` |`2.00 MB`
|===

For the sizes of _files_ it is common to specify the exact size in
bytes _without rounding_. This has the advantage that you can see very
quickly if a file has changed even minimally or that two files are (probably)
the same. The `render.filesize()` function is responsible for this:

[cols="50,~"]
|===
|Call |Output 

|`render.filesize(1000)` |`1,000 B`
|`render.filesize(1024)` |`1,024 B`
|`render.filesize(2000000)` |`2,000,000 B`
|===

If you want to output a size that is not a disk or a file size, just use the
generic `render.bytes()`.
This will give you the output in the classic 1024's in the new official notation:

[cols="50,~"]
|===
|Call |Output 

|`render.bytes(1000)` |`1000 B`
|`render.bytes(1024)` |`1.00 KiB`
|`render.bytes(2000000)` |`1.91 MiB`
|===


=== Bandwidths and data rates

Networkers have their own terms and ways of expressing things. And as always,
in each domain {CMK} tries hard to adopt the way of communicating that is
customary there. That's why there are three different rendering functions for
data rates and speeds. All of these have in common that the rates are passed in
_bytes per second_, even when the output is in bits!

`render.nicspeed()` represents the maximum speed of a network card or
switch port. Since they are not measured values, there is no need to do any
rounding. Although no port can send single bits, the specifications are in bits
for historical reasons. Attention: you must however always pass bytes per second
here as well!

Examples:

[cols="50,~"]
|===
|Call |Output 

|`render.nicspeed(12500000)` |`100 MBit/s`
|`render.nicspeed(100000000)` |`800 MBit/s`
|===


`render.networkbandwidth()` is for an actual measured transmission speed
on the network. The input value is again bytes per second (or 'octets' as a
networker would say):

[cols="50,~"]
|===
|Call |Output 

|`render.networkbandwidth(123)` |`984 Bit/s`
|`render.networkbandwidth(123456)` |`988 kBit/s`
|`render.networkbandwidth(123456789)` |`988 MBit/s`
|===


Where the network is not involved and data rates are nevertheless output,
bytes are again common. The most prominent examples are the IO rates of hard
disks. For this there is the render function `render.iobandwidth()`,
which in {CMK} works with powers of 1000:

[cols="50,~"]
|===
|Call |Output 

|`render.iobandwidth(123)` |`123 B/s`
|`render.iobandwidth(123456)` |`123 kB/s`
|`render.iobandwidth(123456789)` |`123 MB/s`
|===


=== Percentages

The `render.percent()` function represents a percentage value --
rounded to two decimal places. It is an exception to the other functions in that the
actual natural value -- that is, the ratio -- is not passed here, but really the
percentage.
So if something is half full, for example, rather than 0.5. you must pass 50.

Because it can sometimes be interesting to know whether a value is almost zero or exactly zero, values that are greater than zero but less than 0.01 are marked by adding a "<" sign.

[cols="50,~"]
|===
|Call |Output 

|`render.percent(0.004)` |`<0.01{nbsp}%`
|`render.percent(18.5)` |`18.50{nbsp}%`
|`render.percent(123)` |`123.00{nbsp}%`
|===


=== Summary

Here to recap is an overview of all of the render functions:

[cols="10,10,40,~"]
|===
|Function |Entry |Description |Output example 

|`date` |Epoch |Date |`Dec 18 1970`
|`datetime` |Epoch |Date and time |`Dec 18 1970 10:40:00`
|`timespan` |Seconds |Duration / Age |`3d 5m`
|`frequency` |Hz |Frequency (e.g. Clock rate) |`110 MHz`
|`disksize` |Bytes |Hard disk size, Basis 1000 |`1,234 GB`
|`filesize` |Bytes |Size of files, exact |`1,334,560 B`
|`bytes` |Bytes |Size in bytes, base 1024 |`23,4 KiB`
|`nicspeed` |Octets/sec |Network card speed |`100 MBit/s`
|`networkbandwidth` |Octets/sec |Transmission speed |`23.50 GBit/s`
|`iobandwidth` |Bytes/sec |IO-Bandwidth |`124 MB/s`
|`percent` |Percent |Percentage value, meaningfully rounded |`99.997{nbsp}%`   
|===


[#parameters]
== Thresholds and check parameters


=== A rule set for the setup

In one of our previous examples, we generated the state {WARN} if there were only 10 or fewer slots left. The number `10` was coded directly into the check function -- hard-coded, as programmers would say. In {CMK}, however, users are more used to being able to configure such thresholds and parameters by _rule_. We will therefore take a look at how you can improve your check so that it can be configured via the setup interface.

To do this, we need to distinguish between two scenarios:

. There is already a suitable rule set. This can actually only be the case if your new check performs a check for which {CMK} already has check plug-ins of the same type, such as monitoring a temperature. There is already a rule set for this that you can use directly.
. There is no matching rule set. In that case you will have to create a new one.


=== Using existing rule sets

The rule sets supplied for the parameters of checks can be found in the `lib/check_mk/gui/plugins/wato/check_parameters/` directory. Let's take the file `memory_simple.py` as an example. This defines a rule set with the following section:
 
.lib/check_mk/gui/plugins/wato/check_parameters/memory_simple.py
[{python}]
----
rulespec_registry.register(
    CheckParameterRulespecWithItem(
        check_group_name="memory_simple",
        group=RulespecGroupCheckParametersOperatingSystem,
        item_spec=_item_spec_memory_simple,
        match_type="dict",
        parameter_valuespec=_parameter_valuespec_memory_simple,
        title=lambda: _("Main memory usage of simple devices"),
    ))
----

Here the important point for you is the keyword `check_group_name`, which is set here to `'memory_simple'`. This establishes the connection to the check plug-in. You do this when registering the check with the keyword `check_ruleset_name`, for example:

[{python}]
----
register.check_plugin(
    name = "foobar",
    service_name = "Foobar Sector %s",
    discovery_function = discover_foobar,
    check_function = check_foobar,
    check_ruleset_name="memory_simple",
    check_default_parameters={},
)
----

The definition of default parameters via the keyword `check_default_parameters` is also mandatory. These parameters apply to your check if the user has not yet created a rule. If there are no mandatory parameters, you can simply take the empty dictionary `{}` as the value.

We will see below how the value configured by the user arrives at the check function.


=== Defining your own rule set

If there is no suitable rule set (which is probably the usual situation), we will have to create a new one ourselves. To do this, we create a file in the `local/share/check_mk/web/plugins/wato` directory. The name of the file should be based on that of the check and, like all plug-in files, it must have the extension '.py'.

Let's look at the structure of such a file step by step. First come some import commands. If you want the texts in your file to be translatable into other languages, import the `+_+` (underscore) function. This is an identifier for all translatable texts. For example, you can code calling the function `+_("Threshold for warn")+` instead of `"Threshold for warn"`. The translation system in {CMK}, which is based on link:https://docs.python.org/3/library/gettext.html#module-gettext[gettext^], finds such texts and includes them in the list of texts to be translated. If you only build the check for yourself, you can do without it and do not need the following import command:

.local/share/check_mk/web/plugins/wato/foobar_parameters.py
[{python}]
----
from cmk.gui.i18n import _
----

Next we import the so-called _ValueSpecs_. A ValueSpec is a very practical and universal tool that uses {CMK} in many places. It is used to generate customized input masks, to display and validate the entered values and to convert them into Python data structures. In the following example, `Dictionary`, `Integer` and `TextInput` will be imported.

[{python}]
----
from cmk.gui.valuespec import (
    Dictionary,
    Integer,
    TextInput,
)
----

You will definitely need the `Dictionary`.
Since version {v20} of {CMK} it is mandatory that check parameters are Python dictionaries. Previously, it could also be a pair (a tuple of two numbers), e.g. Warn/Crit.

`Integer` is responsible for the input of a number without decimal places and `TextInput` for a Unicode text.

Next, symbols are imported that are needed for registration:

[{python}]
----
from cmk.gui.plugins.wato.utils import (
    CheckParameterRulespecWithItem,
    rulespec_registry,
    RulespecGroupCheckParametersOperatingSystem,
)
----

If your check does not have an item, import instead `CheckParameterRulespecWithoutItem`. About the `RulespecGroup`.... we will explain more on this below.

Now come the actual definitions. First we define an input field with which the user can specify the _item_ for the check. This is necessary for the rule condition and also for the manual creation of checks that are to function without discovery. We do this with `TextInput`. This is assigned a title via `title`, which is then usually displayed as a heading for the input field:

[{python}]
----
def _item_valuespec_foobar():
    return TextInput(title="fitting item name", help="inline help text")
----

You can freely choose the name of the function that returns this ValueSpec as it is only required at the point further down. So that it does not become visible beyond the module boundary, it should begin with an underscore.

Next comes the ValueSpec for entering the actual check parameter. For this, as well, we create a function that generates it. The `return Dictionary(...)` is mandatory. Within it, you create the list of sub-parameters for this check with `elements=[...]`. In our example there is only one -- the warning threshold for the free slots. This is required to be an integer, so we use `integer` here.

[{python}]
----
def _parameter_valuespec_foobar():
    return Dictionary(
        elements=[
            ("warning_lower", Integer(title=_("Warning below free slots"))),
        ],
    )
----

Last but not least, we now register a new rule set using the imported and self-defined items. For this purpose there is the `rulespec_registry.register()` function:

[{python}]
----
rulespec_registry.register(
    CheckParameterRulespecWithItem(
        check_group_name="foobar",
        group=RulespecGroupCheckParametersOperatingSystem,
        match_type="dict",
        item_spec=_item_valuespec_foobar,
        parameter_valuespec=_parameter_valuespec_foobar,
        title=lambda: _("Free slots for Foobar sectors"),
    ))
----

A few more notes on this:

* If your check does not use an item, the inner function is `CheckParameterRulespecWithoutItem`. The line `item_spec` is then omitted.
* As mentioned above, the `check_group_name` provides the link to the checks that are to use this rule. It may not be identical with an already existing rule, because this would overwrite the existing rule.
* The `group` determines in which category in the setup the rule set should appear. Most of these groups are defined in the file `~/lib/check_mk/gui/plugins/wato/utils/pass:[__init__].py`. There you will also find examples of how to create your own new group.
* The `match_type` is always `"dict"`. In older {CMK} versions there were also parameter rules with other types.
* `title` defines the title of the rule set, but is not given directly as text, but as an executable function which returns the text (hence the `lambda:`).

 
==== Testing

When you have created this file, you should first try out whether everything works so far and not immediately continue working with the check function. To do this, you must first restart the Apache for the site so that the new file will be read. This is performed using the command:

[{shell}]
----
{c-omd} omd restart apache
----

After that, the rule set should be found in the setup. Create a rule in this chain and try out different values. If this functions without errors, you can now use the check parameters in the check function.


=== Applying the rule to the check plug-in

In order for the rule to take effect, we must allow the check plug-in to accept check parameters and tell it which rule to use. To do this, the `check_default_parameters` entry must be present in the registration. In the simplest case, we pass an empty dictionary.

Secondly, we pass the `check_ruleset_name` to the registration function, i.e. the name we gave to the rule set above using `check_group_name`. This way {CMK} knows from which rule set the parameters are to be determined.

The whole thing will then look like this, for example:
 
[{python}]
----
register.check_plugin(
    name = "foobar",
    service_name = "Foobar Sector %s",
    discovery_function = discover_foobar,
    check_function = check_foobar,
    check_default_parameters={},
    check_ruleset_name="foobar",
)
----
 
Now {CMK} will try to pass parameters to the check function. For this to work, we need to extend the check function so that it expects the `params` argument as the second argument. This is inserted between `item` and `section` (If you build a check without an item, the `item` is of course omitted and `params` will be at the beginning):

[{python}]
----
def check_foobar(item, params, section):
----

It is highly recommended to now have the contents of the variable `params` printed out with a `print` command as a first test (or `pprint` if you want to have it a bit more convenient). Create different rules, and see which values arrive at `params`:

[{python}]
----
def check_foobar(item, params, section):
    print(params)
    for sector, used, slots in ...
----

*Very important*: When everything is ready, be sure to remove the `print` commands again! These can otherwise disrupt the internal communication in {CMK}.

Now we adapt our check function so that the parameter passed can produce its desired effect. We get the value with the usually chosen key (here `"warning_lower"`) from the parameters:

[{python}]
----
def check_foobar(item, params, section):
    warn = params["warning_lower"]
    for sector, used, slots in section:
        if sector == item:
            used = int(used)    # convert string to int
            slots = int(slots)  # convert string to int
            if used == slots:
                s = State.CRIT
            elif slots - used <= warn:
                s = State.WARN
            else:
                s = State.OK
            yield Result(
                state = s,
                summary = f"used {used} out of {slots} slots")
            return
----
 
If a rule has been configured, we can now monitor the "free slots" in our example. However, if no rule has been defined, this check function will crash: Since the default parameters of the plug-in are not filled, in the absence of a rule the plug-in will generate a `KeyError`.

We can fix this problem by inserting a suitable parameter during registration:

[{python}]
----
register.check_plugin(
    name = "foobar",
    service_name = "Foobar Sector %s",
    discovery_function = discover_foobar,
    check_function = check_foobar,
    check_default_parameters = {"warning_lower": 10},
    check_ruleset_name = "foobar",
)
----

You should always pass default values in this way (and not use the check plug-in to catch missing parameters), as these default parameters can also be displayed in the setup interface. For this purpose, there is e.g. the entry [.guihint]#Show check parameters# in the menu [.guihint]#Display# on the service configuration page for a host.

By the way, having a single value as a threshold is very uncommon in {CMK}. Since services can be in the states {OK}, {WARN}, {CRIT}, it is only logical to always define the parameters as `tuples` with two entries, i.e. as a pair of thresholds for {WARN} and {CRIT}. To do this, we adapt the rule set as follows:

[{python}]
----
def _parameter_valuespec_foobar():
    return Dictionary(
        elements=[
            ("warning_lower", Tuple(
                title=_("Levels on free slots"),
                elements=[
                    Integer(title=_("Warning below")),
                    Integer(title=_("Critical below")),
                ],
            )),
        ],
    )
----
 
Note that such a change of data type is an incompatible change: Existing rules can now no longer be loaded from the interface. And also the check function may run into problems if instead of an expected pair of numbers there is a single number in `params`. You can simply edit such rules. When you save them again, the new format will be used.


=== Further ValueSpecs

In {CMK} there are numerous ValueSpecs for all kinds of situations. Here are a few more useful ones:


==== Float

`Float` is like `Integer` but allows the input of numbers with decimal places.


==== Percentage

Often one does not want to indicate thresholds in absolute numbers, but in percentages. For this purpose there is the `Percentage` ValueSpec:

[{python}]
----
def _parameter_valuespec_foobar():
    return Dictionary(
        elements=[
            ("levels_percent", Tuple(
                title=_("Relative levels"),
                elements=[
                    Percentage(title=_("Warning at"), default_value=80),
                    Percentage(title=_("Critical at"), default_value=90)
                ],
            )),
        ],
    )
----

With this ValueSpec, the check plug-in would receive the parameters `{"levels_percent": (80.0, 90.0)}`.


==== MonitoringState

The `MonitoringState` is useful if you want to allow the user to select one of the states {OK}, {WARN}, {CRIT} and {UNKNOWN} for each of various situations. It provides the user with a drop-down list of just these four options, which are then converted to one of the numbers `0`, `1`, `2` or `3`.

Here you can set, for example, which status the service should have if no backup is configured or available:

[{python}]
----
def _parameter_valuespec_plesk_backups():
    return Dictionary(
        help=_("This check monitors backups configured for domains in plesk."),
        elements=[
            ("no_backup_configured_state",
             MonitoringState(title=_("State when no backup is configured"), default_value=1)),
            ("no_backup_found_state",
             MonitoringState(title=_("State when no backup can be found"), default_value=1)),
        ...
----

With this ValueSpec, the check plug-in would be passed the parameters ``{"no_backup_configured_state": 1, "no_backup_found_state": 1}` if in both cases the default of {WARN} (=1) was taken over. You can easily convert the number into a `State` object by passing it to the `State()` function:

[{python}]
----
    yield Result(
        state=State(params["no_backup_configured_state"]),
        summary="No backup is configured!",
    )
----


==== Age

The field `Age` allows the entry of an age, which is stored and transferred internally as a count of seconds:

[{python}]
----
def _parameter_valuespec_antivir_update_age():
    return Tuple(elements=[
        Age(title=_("Warning level for time since last update")),
        Age(title=_("Critical level for time since last update")),
    ],)
----


==== Filesize

The ValueSpec `Filesize` allows the input of file (or hard disk) sizes. Internally, the calculation is done with bytes, but the user may choose from KB, MB, GB or TB:

[{python}]
----
    Tuple(
        title=_("Maximum size of all files on backup space"),
        help=_("The maximum size of all files on the backup space. "
               "This might be set to the allowed quotas on the configured "
               "FTP server to be notified if the space limit is reached."),
        elements=[
            Filesize(title=_("Warning at")),
            Filesize(title=_("Critical at")),
        ],
    ),
----

The topic of ValueSpecs is extremely flexible and extensive and would go beyond the scope of this article. Please have a look at the examples of the rule definitions supplied by {CMK} in `lib/check_mk/gui/plugins/wato/check_parameters/`. There are more than 500 files with examples.
 

[#metrics]
== Customized presentation of metrics
 

=== The significance of metric definitions

In our example above, we have let the `foobar` plug-in generate the metric `fooslots`. Metrics are immediately visible in the {CMK} graphical interface without you having to do anything. A graph for each metric will be automatically generated in the service details.

However, there are a few limitations:

* A "Perf-O-Meter", i.e. the graphical bar-like preview of the measurement value, does not automatically appear when the service is displayed in the list view (e.g. in the view showing all services of a host).
* Matching metrics are not automatically combined in a single graph, but each appears separately.
* The metric does not have a proper title, but the internal variable name of the metric is shown.
* No unit is used that allows a meaningful representation (e.g. GB instead of individual bytes).
* A color is randomly selected.
To have a clear representation of your metrics in these aspects, you will need some more definitions in another file.


=== Using existing metric definitions

Before you do this, you should -- as with the rule set for the parameters -- first check whether {CMK} does not already come with a suitable metrics definition.  The predefined metrics definitions can be found in the `lib/check_mk/gui/plugins/metrics/` directory. For example, in the file `cpu.py` you will find a metric for the free space in a file system:

[{python}]
----
metric_info["util"] = {
    "title": _("CPU utilization"),
    "unit": "%",
    "color": "26/a",
}
----

If this is suitable for your plug-in, you only need to use the name `"util"` in your call to the `Metric()` class. Everything else will then be automatically derived from it.


[#ownmetricdefinitions]
=== Own metric definitions

If there is no suitable metric, simply create one yourself. In our example we want to define our own metric for our `fooslots`. To do this, we create a file in `local/share/check_mk/web/plugins/metrics`:

.local/share/check_mk/web/plugins/metrics/foobar_metric.py
[{python}]
----
from cmk.gui.i18n import _
from cmk.gui.plugins.metrics import metric_info

metric_info["fooslots"] = {
    "title": _("Used slots"),
    "unit": "count",
    "color": "15/a",
}
----

Here are a few pointers:

* The key (here `'fooslots'`) is the metric name and must match what the check function outputs.
* Importing and using the underscore for internationalization is optional, as already discussed in the rules.
* See the file `lib/check_mk/gui/plugins/metrics/unit.py` for the unit definitions.
* The color definition uses a palette. For each palette color there are `/a` and `/b`. These are two shades of the same color. In the existing definitions you will also find many direct color codes like `'#ff8800'`. These will gradually be phased out and all replaced by palette colors as these provide a more uniform look and are also easier to match to the interface themes.

This definition now ensures that the color, title and unit of the metric are displayed according to our requirements.


=== Graphs with multiple metrics

If you want to combine several metrics in one graph -- which is often very useful -- you need, simply in the same file, a graph definition. This is done via the global dictionary `graph_info`.

For example, let's assume our check has two metrics, `fooslots` and `fooslots_free`. The metric definitions would be, for example:

.local/share/check_mk/web/plugins/metrics/foobar_metric.py
[{python}]
----
from cmk.gui.i18n import _
from cmk.gui.plugins.metrics import (
    metric_info,
    graph_info,
)

metric_info["fooslots"] = {
    "title": _("Used slots"),
    "unit": "count",
    "color": "16/a",
}

metric_info["fooslots_free"] = {
    "title": _("Free slots"),
    "unit": "count",
    "color": "24/a",
}
----

Now we add a graph that draws these two metrics as lines:

[{python}]
----
graph_info["fooslots_combined"] = {
    "metrics": [
        ("fooslots", "line"),
        ("fooslots_free", "line"),
    ],
}
----

Notes on this:

* Unfortunately, there is no description of the possibilities for this definition in the manual yet. But you will find many examples in the files in the directory `lib/check_mk/gui/plugins/metrics`.
* Try `area` or `stack` instead of `line`.


[#perfometer]
=== Displaying the metrics in the Perf-O-Meter
 
If you would like to display a Perf-O-Meter in the service line in addition to our metric, you need another file, this time in the directory `local/share/check_mk/web/plugins/perfometer`.

Example:

.local/share/check_mk/web/plugins/perfometer/foobar_perfometer.py
[{python}]
----
from cmk.gui.plugins.metrics import perfometer_info

perfometer_info.append({
    "type": "logarithmic",
    "metric": "fooslots",
    "half_value": 5,
    "exponent": 2.0,
})
----

Perf-O-Meters are a bit trickier than graphs because they have no legend. And that's why it's difficult with the range of values. Since the poor Perf-O-Meter cannot know which readings are even possible and the space is very limited, many built-in check plug-ins use a logarithmic representation. This is also the case in our example, `half_value` is the measured value that is displayed exactly in the middle of the Perf-O-Meter. With a value of `5`, the bar would be half filled. And `exponent` describes the factor which is necessary so that another 10{nbsp}% of the range would be filled. So in this example, a reading of `10` would be displayed at 60{nbsp}% and one of `20` at 70{nbsp}%.

The advantage of this method is that when you have a list of services of the same type, you can quickly compare all Perf-O-Meters visually because they all have the same scale. And despite the very small representations, you can easily see the differences in both very small and large readings. The values are NOT to scale, however.

Alternatively, you can also use a linear Perf-O-Meter. This is always useful if there is a known maximum value. A typical situation would be measured values that represent percentages from 0 to 100. This would then look like this, for example:

[{python}]
----
perfometer_info.append({
    "type": "linear",
    "segments": ["fooslots_used_percent"],
    "total": 100.0,
})
----

There is another difference to the logarithmic representation -- here `segments` is a list and allows multiple metrics to be displayed side by side.

As always, you can find examples in the many plug-ins supplied by {CMK}. These are also in the files in the directory `lib/check_mk/gui/plugins/metrics`.


[#old_api]
== Notes for users of the old API

Are you already experienced in developing check plug-ins with the previous
API -- the one up to version {v16} of {CMK}?
Then you will find some notes about important changes summarized here.


=== saveint() and savefloat()

The two functions `saveint()` and `savefloat()` have been dropped.
As a reminder, `saveint(x)` returns `0` if `x` cannot be reasonably converted to a number, e.g. because it is an empty string or does not consist only of digits.

While there have been a few good use cases for this, it has been used incorrectly in the majority of cases, which in the past has resulted in many
xref:devel_check_plugins#errors[errors] being obscured.

In a situation in which you want to get a `0` on an empty string -- which is the most common 'good' use case of `saveint(x)` -- you can simply code the following:

[{python}]
----
foo = int(x) if x else 0
----

For `savefloat()` everything applies analogously.


[#parsefunction]
== Taming complex agent outputs using the parse function

The next step is the so-called _parse function_. This has the task of parsing the 'raw' agent data and putting it into a logically-tidy form that is easy to process in all subsequent steps. The convention is that this is named after the agent section and begins with `parse_`. It gets `string_table` as its only argument. Please note that you are not free to choose the argument here. It really must be called that.

For now, we write our parse function in such a way that we simply output the data it receives to the console. To do this, we simply use the `print` function (note: since Python 3, brackets are mandatory here):

[{python}]
----
def parse_linux_usbstick(string_table):
    print(string_table)
----

In order for this whole process to have any effect, we have to make our parse function and the new agent section known to {CMK}. To do this, we call up a registration function:

[{python}]
----
register.agent_section(
    name = "linux_usbstick",
    parse_function = parse_linux_usbstick,
)
----
 
Here it is important that the name of the section really does exactly match the section header in the agent output. Altogether, it now looks like this:

.local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
[{python}]
----
from .agent_based_api.v1 import *

def parse_linux_usbstick(string_table):
    print(string_table)
    return string_table

register.agent_section(
    name = "linux_usbstick",
    parse_function = parse_linux_usbstick,
)
----
 
From this point on, every plug-in that uses the section `linux_usbstick` gets the return value from the parse function. As a rule, this will be the check plug-in of the same name.

In a way, we have now built the simplest possible plug-in, which although it has no real use yet, we can at least test it.  To do this, we trigger a service detection (option `-I`) on the command line from the host whose agent we prepared earlier. If its output really contains a section `linux_usbstick`, then we should see our debug output:

[{shell}]
----
{c-omd} cmk -I myhost123
[['ata-APPLE_SSD_SM0512F_S1K5NYBF810191'], ['wwn-0x5002538655584d30']]
----
 
The output becomes somewhat clearer if we replace the simple `print` with a Pretty-print from the module `pprint`. This is highly recommended for all further debugging output:

.local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
[{python}]
----
from .agent_based_api.v1 import *
*import pprint*

def parse_linux_usbstick(string_table):
    *pprint.pprint(string_table)*
    return string_table

register.agent_section(
    name = "linux_usbstick",
    parse_function = parse_linux_usbstick,
)
----
 
It will look like this:

[{shell}]
----
{c-omd} cmk -I myhost123
[['ata-APPLE_SSD_SM0512F_S1K5NYBF810191'],
 ['wwn-0x5002538655584d30']]
----


=== Composing the parse function

If you look closely, you will see that these are nested lists. In the argument `string_table` you get a list which contains a list of _words_ _per line_ of the agent output. The lines are separated by sequences of spaces. Since our section contains only one word per line, the inner lists consist of only one entry each.

The following example makes the structure a little clearer:

.local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
[{python}]
----
from .agent_based_api.v1 import *
import pprint

def parse_linux_usbstick(string_table):
    print("Number of lines: %d" % len(string_table))
    print("Number of words in first line: %d" % len(string_table[0]))
    print("Length of first word: %d" % len(string_table[0][0]))
    return string_table

register.agent_section(
    name = "linux_usbstick",
    parse_function = parse_linux_usbstick,
)
----

The output will look like this:

[{shell}]
----
{c-omd} cmk -I myhost123
Number of lines: 3
Number of words in first line: 1
Length of first word: 36
----

For our example, we just need a simple list of device names, so we make our parse function unpack the single word from each line and package it into a nice new list:

[{python}]
----
def parse_linux_usbstick(string_table):
    parsed = []
    for line in string_table:
        parsed.append(line[0])
    pprint.pprint(parsed)
    return string_table
----
 
The debug output then looks like this (please look carefully, there are now only a single pair of square brackets):

[{python}]
----
['ata-APPLE_SSD_SM0512F_S1K5NYBF810191',
 'wwn-0x5002538655584d30']
----

For the parse function to be complete, we now need to remove the debug message and -- very importantly -- deliver the new result with `return`:

[{python}]
----
def parse_linux_usbstick(string_table):
    parsed = []
    for line in string_table:
        parsed.append(line[0])
    return parsed
----

Of course, from this point on, all of the relevant plug-ins must be able to work with the new data format.


[#outlook]
== The outlook for the future

There are many more aspects and topics around the development of own plug-ins. {CMK} has many interfaces for custom extensions and is therefore very flexible. We are working on progressively describing these interfaces in the manual.

Should you have any questions or difficulties, our professional support and also the free forum are of course at your disposal.


[#files]
== Files and directories

[cols=2]
|===
 
|`~/local/lib/check_mk/base/plugins/agent_based/` |Location for self-written check plug-ins.
|`~/local/share/check_mk/web/plugins/wato/` |Storage location for your check parameter rule sets. 
|`~/local/share/check_mk/web/plugins/metrics/` |Storage location for own metric definitions.
|`~/local/share/check_mk/web/plugins/perfometer/` |Storage location for own Perf-O-Meter definitions.
|`~/local/share/check_mk/mibs/` |Place SNMP MIB files here that are to be loaded automatically.
|`~/lib/check_mk/gui/plugins/wato/check_parameters` |Here you will find the rule set definitions for all check plug-ins included in {CMK}.
|`~/lib/check_mk/gui/plugins/wato/utils/pass:[__init__].py` |This file defines the groups of the setup interface in which you can store new rule sets.
|`~/lib/check_mk/gui/plugins/metrics/` |Here you will find the metric definitions for the supplied plug-ins.
|`~/lib/check_mk/gui/plugins/metrics/unit.py`  |The predefined units for the metrics are in this file.
|`/usr/lib/check_mk_agent/plugins/`  |This directory refers to a monitored Linux host. Here the {CMK} agent for Linux expects to find agent extensions (agent plug-ins).
|===









// This block is new
// start translation


////
// -*- coding: utf-8 -*-
// IGNORE 
include::global_attr.adoc[]
= Writing agent-based check plug-ins
:revdate: draft
:title: Writing agent-based check plug-ins
::description: Hier erfahren Sie, wie Sie agentenbasierte {CMK}-Plugins entwickeln können - mit allem was dazugehört, insbesondere mit der in der Version 2.0.0 neu entwickelten Check-API.

{related-start}
xref:devel_intro#[Developing extensions for {CMK}]
xref:devel_check_plugins_snmp#[SNMP-basierte Check-Plugins schreiben]
xref:wato_monitoringagents#[Monitoring agents]
xref:agent_linux#[Monitoring Linux]
xref:agent_windows#[Monitoring Windows]
xref:wato_services#[Understanding and configuring services]
xref:cmk_commandline#[{CMK} on the command line]
xref:mkps#[{CMK} extension packages (MKPs)]
{related-end}


[#intro]
== Einleitung

Check-Plugins sind in Python geschriebene Software-Module, die auf der {CMK}-xref:glossar#site[Instanz] ausgeführt werden und die xref:glossar#service[Services] eines xref:glossar#host[Hosts] erstellen und auswerten.

{CMK} umfasst über 2000 fertige Check-Plugins für alle nur denkbare Hardware und Software.
Diese werden vom {CMK}-Team gepflegt und jede Woche kommen neue dazu.
Daneben gibt es auf der link:https://exchange.checkmk.com[{CMK} Exchange^] weitere Plugins, die von unseren Anwendern beigesteuert werden.

Und trotzdem kann es immer wieder vorkommen, dass ein Gerät, eine Anwendung oder einfach nur eine bestimmte xref:glossar#metric[Metrik,] die für Sie wichtig ist, noch von keinem dieser Plugins erfasst wird 
-- vielleicht auch einfach deshalb, weil es sich dabei um etwas handelt, das in Ihrer Firma entwickelt wurde und es daher niemand anders haben kann.
Im Artikel zur Einführung in die xref:devel_intro#[Programmierung von Erweiterungen] für {CMK} erfahren Sie, welche Möglichkeiten Sie haben.

Dieser Artikel zeigt Ihnen, wie Sie echte Check-Plugins für den {CMK}-Agenten entwickeln können — mit allem was dazugehört.
Für SNMP-basierte Check-Plugins gibt es einen xref:devel_check_plugins_snmp#[eigenen Artikel.]


[#check_api_doc]
=== Die Check-API-Dokumentation

Für die Programmierung der Check-Plugins gibt es seit der {CMK}-Version {v20} eine neu entwickelte *Check-API.*
Wir zeigen Ihnen, wie Sie diese Check-API für die Plugin-Programmierung nutzen können.

Über die {CMK}-Benutzeroberfläche haben Sie jederzeit Zugriff auf die Dokumentation der Check-API: [.guihint]#Help > Developer resources > Check plugin API reference.#
Wählen Sie im neuen Browserfenster in der linken Navigationsleiste [.guihint]#BASE > Agent based API ("Check API")# aus:

[{image-border}]
image::devel_cpi_checkapi_doc.png[alt="Seite zum Einstieg in die Check-API-Dokumentation."]

*Hinweis* für Benutzer der bis zur Version {v16} gültigen Check-API:
Falls Sie noch Check-Plugins haben, die mit der alten API entwickelt wurden, sollten Sie diese bald auf die neue Check-API migrieren.
Zwar wird die alte Check-API für eine Übergangszeit weiterhin unterstützt -- aber auch diese Zeit wird einmal enden.
Den einmaligen Aufwand zur Migration machen die Vorteile der neuen Check-API wett,
denn diese ist konsistenter, logischer, besser dokumentiert und zukunftssicher.
Im link:https://checkmk.com/de/blog/migrating-check-plug-ins-to-checkmk-2-0[Blogpost zur Migration von Check-Plugins^] informieren wir Sie ausführlich über die notwendigen Schritte.


=== Voraussetzungen

Wenn Sie Lust haben, sich mit dem Programmieren von Check-Plugins zu befassen, benötigen Sie folgendes:

* Kenntnisse in der Programmiersprache Python.
* Erfahrung mit {CMK}, vor allem was das Thema Agenten und Checks betrifft.
* Übung mit Linux auf der Kommandozeile.


=== Begriffe

Zwar ist hier immer die Rede von einem Check-Plugin und davon, dieses zu schreiben.
Aber genau genommen benötigen Sie immer zwei Plugins, das xref:glossar#agent_plugin[Agentenplugin] auf dem überwachten Host und das xref:glossar#check_plugin[Check-Plugin] auf dem {CMK}-Server.
Beide müssen geschrieben und aufeinander abgestimmt werden.
Nur so funktionieren sie hinterher reibungsfrei.


[#agentplugin]
== Ein Agentenplugin schreiben

Wer sich für die Programmierung von Check-Plugins in {CMK} interessiert, hat mit großer Wahrscheinlichkeit auch schon einmal einen {CMK}-Server aufgesetzt.
Haben auch Sie dies bereits gemacht, haben Sie dabei als Einstieg vermutlich auch Ihren {CMK}-Server selbst als Host überwacht.

Im Folgenden gehen wir von einem beispielhaften Szenario aus, in dem {CMK}-Server und überwachter Host identisch sind.
So ist es uns möglich über xref:glossar#livestatus[Livestatus]-Abfragen vom Host Informationen über Host-Gruppen zu erhalten, die der {CMK}-Server zur Verfügung stellt.

Im beschriebenen Beispiel gehen wir von einem Unternehmen mit mehreren Standorten aus:

* Jeder dieser Standorte wird in {CMK} durch eine xref:glossar#host_group[Host-Gruppe] abgebildet.

* Jeder Standort hat sein eigenes Service-Team.

Damit bei Problemen jeweils das richtige Service-Team verständigt werden kann, gilt, dass jeder Host einem Standort -- also auch einer Host-Gruppe -- zugewiesen sein muss.
Das Ziel in diesem Beispiel ist nun, eine Prüfung aufzusetzen, mit der kontrolliert werden kann, ob für keinen Host vergessen wurde, eine Host-Gruppe zuzuweisen.

Das Ganze läuft in zwei Schritten:

. Informationen für das Monitoring aus dem Host auslesen.
Darum geht es in diesem Kapitel.

. Schreiben eines Check-Plugins in der {CMK}-Instanz, welches diese Daten auswertet.
Das zeigen wir im xref:write_check_plugin[nächsten Kapitel.]

Und los geht's ...


[#right_command]
=== Informationen auslesen und filtern

Am Anfang jeder Plugin-Programmierung steht: die Recherche!
Das bedeutet, dass Sie herausfinden müssen, wie Sie überhaupt an die Informationen kommen, die Sie für die Überwachung brauchen.

Für das gewählte Beispiel nutzen wir die Tatsache, dass der {CMK}-Server zugleich der Host ist.
Damit genügt zunächst ein xref:livestatus#[Abruf der Statusdaten via Livestatus,] also der in Tabellen organisierten Daten, die {CMK} über die überwachten Hosts und Services im flüchtigen Speicher vorhält.

Melden Sie sich als Instanzbenutzer an und fragen Sie die Informationen zu den Host-Gruppen mit folgendem Befehl ab: 

[{shell}]
----
{c-omd} lq "GET hostgroups"
action_url;alias;members;members_with_state;name;notes;notes_url;num_hosts;num_hosts_down;num_hosts_handled_problems;num_hosts_pending;num_hosts_unhandled_problems;num_hosts_unreach;num_hosts_up;num_services;num_services_crit;num_services_handled_problems;num_services_hard_crit;num_services_hard_ok;num_services_hard_unknown;num_services_hard_warn;num_services_ok;num_services_pending;num_services_unhandled_problems;num_services_unknown;num_services_warn;worst_host_state;worst_service_hard_state;worst_service_state
;Hamburg;myhost11,myhost22,myhost33;myhost11|0|1,myhost22|0|1,myhost33|0|1;Hamburg;;;3;0;0;0;0;0;3;123;10;0;10;99;0;14;99;0;24;0;14;0;2;2
;Munich;myhost1,myhost2,myhost3;myhost1|0|1,myhost2|0|1,myhost3|0|1;Munich;;;3;0;0;0;0;0;3;123;10;0;10;99;0;14;99;0;24;0;14;0;2;2
;check_mk;localhost;localhost|0|1;check_mk;;;1;0;0;0;0;0;1;66;0;0;0;4;0;1;4;61;1;0;1;0;1;1
----

Die erste Zeile der Ausgabe enthält die Spaltennamen der abgefragten Tabelle `hostgroups`.
Als Trennzeichen fungiert das Semikolon.
In der zweiten Zeile folgen dann die Inhalte sämtlicher Spalten, ebenfalls durch Semikolons getrennt.

Die Ausgabe ist bereits für dieses kleine Beispiel relativ unübersichtlich und enthält Informationen, die für unser Beispiel nicht relevant sind.
Generell sollten Sie zwar die Interpretation der Daten {CMK} überlassen.
Allerdings kann eine Vorfilterung auf dem Host den Umfang der zu übertragenden Daten reduzieren, wenn diese gar nicht gebraucht werden.
Also schränken Sie in diesem Fall die Abfrage auf die relevanten Spalten (`Columns`) ein -- auf die Namen der Host-Gruppen (`name`) und die in den Gruppen befindlichen Hosts (`members`):


[{shell}]
----
{c-omd} lq "GET hostgroups\nColumns: name members"
Hamburg;myhost11,myhost22,myhost33
Munich;myhost1,myhost2,myhost3
check_mk;localhost
----

Die Livestatus-Schnittstelle erwartet alle Befehle und Header in jeweils einer eigenen Zeile.
Die daher notwendigen Zeilenumbrüche machen Sie durch `\n` kenntlich.

In diesem Beispiel existieren aktuell drei Host-Gruppen: zwei Gruppen für die Standorte sowie die Gruppe `check_mk`.
Diese enthält einen Hosts namens `localhost`.

Die Host-Gruppe `check_mk` stellt eine Besonderheit innerhalb der Host-Gruppen dar.
Sie haben diese nämlich nicht selbst angelegt.
Und Sie können auch keinen Host aktiv in diese Gruppe aufnehmen.
Woher also stammt diese Host-Gruppe?
Da in {CMK} per Definition jeder Host einer Gruppe angehören muss, weist {CMK} jeden Host, den Sie keiner Gruppe zuweisen, der „speziellen“ Gruppe `check_mk` zu.

Sobald Sie einen Host einer Ihrer eigenen Host-Gruppen zuweisen, wird er aus der Gruppe `check_mk` entfernt.
Auch gibt es keinen Weg, einen Host erneut der Host-Gruppe `check_mk` zuzuweisen.

Genau diese Eigenschaften der Gruppe `check_mk` werden nun für unser Beispiel genutzt:
Da jeder Host einem Standort zugeordnet sein soll, müsste die Host-Gruppe `check_mk` leer sein.
Ist sie nicht leer, so besteht Handlungsbedarf, sprich darin befindliche Hosts müssen den Host-Gruppen und damit den Standorten zugeordnet werden.


[#command_in_agent]
=== Den Befehl in den Agenten einbauen

Bis jetzt haben Sie sich mit dem `lq`-Befehl als Instanzbenutzer die Informationen anzeigen lassen.
Das ist hilfreich, um sich einen Einblick in die Daten zu verschaffen.

Damit Sie diese Daten vom {CMK}-Server aus abrufen können, muss der neue Befehl jedoch Teil vom {CMK}-Agenten auf dem überwachten Host werden.
Theoretisch könnten Sie nun direkt den {CMK}-Agenten in der Datei `/usr/bin/check_mk_agent` editieren und diesen Teil einbauen.
Das hätte aber den Nachteil, dass Ihr neuer Befehl bei einem Software-Update des Agenten wieder verschwindet, weil die Datei ersetzt wird.

Besser ist es daher, ein xref:glossar#agent_plugin[Agentenplugin] zu erstellen.
Alles was Sie dafür brauchen, ist eine ausführbare Datei, die den Befehl enthält und im Verzeichnis `/usr/lib/check_mk_agent/plugins/` liegt.

Und noch eins ist wichtig:
Die Daten können nicht einfach so ausgegeben werden.
Sie brauchen noch einen *Sektions-Header* (_section header_).
Das ist eine speziell formatierte Zeile, die den Namen des neuen Agentenplugins enthält.
An diesem Sektions-Header kann {CMK} später erkennen, wo die Daten des Agentenplugins beginnen und die des vorherigen aufhören.
Am einfachsten ist es, wenn Sektions-Header und Check-Plugin den gleichen Namen tragen -- auch wenn dies nicht verpflichtend ist.

Also brauchen Sie jetzt erst einmal einen sinnvollen Namen für Ihr neues Check-Plugin.
Dieser Name darf nur Kleinbuchstaben (nur _a-z_, keine Umlaute, keine Akzente), Unterstriche und Ziffern enthalten und muss eindeutig sein.
Vermeiden Sie Namenskollisionen mit vorhandenen Check-Plugins.
Wenn Sie neugierig sind, welche Namen es schon gibt, können Sie diese in einer {CMK}-Instanz auf der Kommandozeile mit `cmk -L` auflisten lassen:

[{shell}]
----
{c-omd} cmk -L
3par_capacity               agent      HPE 3PAR: Capacity
3par_cpgs                   agent      HPE 3PAR: CPGs
3par_cpgs_usage             agent      HPE 3PAR: CPGs Usage
3par_hosts                  agent      HPE 3PAR: Hosts
3par_ports                  agent      HPE 3PAR: Ports
3par_remotecopy             agent      HPE 3PAR: Remote Copy
3par_system                 agent      HPE 3PAR: System
3par_volumes                agent      HPE 3PAR: Volumes
3ware_disks                 agent      3ware ATA RAID Controller: State of Disks
3ware_info                  agent      3ware ATA RAID Controller: General Information
3ware_units                 agent      3ware ATA RAID Controller: State of Units
acme_agent_sessions         snmp       ACME Devices: Agent Sessions
acme_certificates           snmp       ACME Devices: Certificates
----

Die Ausgabe zeigt nur die ersten Zeilen der sehr langen Liste. Durch die Verwendung von Präfixen ist die Zugehörigkeit vieler Check-Plugins hier bereits gut zu erkennen.
Auch für Ihre eigenen Check-Plugins empfiehlt sich daher die Verwendung von Präfixen.
Die zweite Spalte zeigt übrigens an, wie das jeweilige Check-Plugin seine Daten bezieht.

Ein für unser Beispiel passender Name für das neue Check-Plugin ist zum Beispiel `myhostgroups`.

Nun haben Sie alle Informationen zusammen, um das Skript mit dem Agentenplugin zu erstellen.
Legen Sie als `root`-Benutzer eine neue Datei `myhostgroups` im Verzeichnis `/usr/lib/check_mk_agent/plugins/` an:

./usr/lib/check_mk_agent/plugins/myhostgroups
[{file}]
----
#!/bin/bash

columns="name members"
site="mysite"

echo '<<<myhostgroups:sep(59)>>>'
su - ${site} lq "GET hostgroups\nColumns: ${columns}"
----

Was bedeutet das nun im Einzelnen?

Die erste Zeile enthält den „Shebang“ (das ist eine Abkürzung für _sharp_ und _bang,_ wobei Letzteres eine Abkürzung für das Ausrufezeichen ist), an dem Linux erkennt, dass es das Skript mit der angegebenen Shell ausführen soll.

Um das Skript erweiterbar zu halten, werden als nächstes zwei Variablen eingeführt:

* die Variable `columns`, die aktuell die Gruppennamen und die zugehörigen Mitglieder enthält,

* die Variable `site`, die den Namen der {CMK}-Instanz enthält.

Mit dem `echo`-Befehl geben Sie den Sektions-Header aus.
Da die Spalten der Tabelle mit dem Semikolon getrennt werden, legen Sie gleichzeitig mit dem Zusatz `sep(59)` fest, dass das Semikolon als Trennzeichen (_separator_) für die Daten in der Agentenausgabe genutzt wird.
59 steht für das link:https://de.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange#ASCII-Tabelle[ASCII^]-Zeichen Nummer 59, das Semikolon.
// TK: Link in en ist: https://en.wikipedia.org/wiki/ASCII#Printable_characters
Ohne diesen Zusatz würde als Standard das Leerzeichen (ASCII-Zeichen 32) als Trennzeichen verwendet werden.

Um den `lq`-Befehl, der Ihnen als Instanzbenutzer zur Verfügung steht, auch in einem Skript nutzen zu können, das vom `root`-Benutzer ausgeführt wird, stellen Sie ein `su` voran.

*Hinweis:* Es kann vorkommen, dass der Zugriff auf `lq` per `su` Probleme bereitet.
Sie können alternativ als `root`-Benutzer auch direkt auf Livestatus in der Shell mit `printf` oder `echo -e` über einen Unix-Socket zugreifen.
Im Artikel zu xref:livestatus#lql_shell[Livestatus] erfahren Sie, wie das geht.

Eines ist noch sehr wichtig, sobald Sie die Datei erstellt haben.
Machen Sie die Datei ausführbar:

[{shell}]
----
{c-root} chmod +x /usr/lib/check_mk_agent/plugins/myhostgroups
----

Sie können das Agentenplugin direkt von Hand ausprobieren, indem Sie den kompletten Pfad als Befehl eingeben:

[{shell-raw}]
----
{c-root} /usr/lib/check_mk_agent/plugins/myhostgroups
<<<myhostgroups:sep(59)>>>
Hamburg;myhost11,myhost22,myhost33
Munich;myhost1,myhost2,myhost3
check_mk;localhost
----

Host-Gruppen, die keine Hosts enthalten, werden hierbei nicht aufgeführt.


[#test_agent]
=== Agent ausprobieren

Test und Fehlersuche sind am wichtigsten, um zu einem funktionierenden Agentenplugin zu gelangen.
Am besten gehen Sie in drei Schritten vor:

. Agentenplugin solo ausprobieren.
Das haben Sie gerade im vorherigen Abschnitt gemacht.

. Agent als Ganzes lokal testen.

. Agent vom {CMK}-Server aus abrufen.

Das lokale Testen des Agenten ist sehr einfach.
Rufen Sie als `root` den Befehl `check_mk_agent` auf:

[{shell}]
----
{c-root} check_mk_agent
----

Irgendwo in der sehr langen Ausgabe muss die neue Sektion erscheinen.
Agentenplugins werden vom Agenten zum Schluss ausgegeben.

Durch Anhängen von `less` können Sie in der Ausgabe blättern (drücken Sie die Leertaste zum Blättern, `/` zum Suchen und `q` zum Beenden):

[{shell}]
----
{c-root} check_mk_agent | less
----

Oder Sie durchsuchen die Ausgabe nach den interessanten Zeilen.
So hat `grep` mit `-A` eine Option, nach jedem Treffer noch einige Zeilen mehr auszugeben.
Damit können Sie bequem die Sektion suchen und ausgeben:

[{shell-raw}]
----
{c-root} check_mk_agent | grep -A3 '^<<<myhostgroups'
<<<myhostgroups:sep(59)>>>
Hamburg;myhost11,myhost22,myhost33
Munich;myhost1,myhost2,myhost3
check_mk;localhost
----

Der dritte und letzte Test ist dann direkt von der {CMK}-Instanz aus.
Nehmen Sie den xref:intro_setup_monitor#linux[Host ins Monitoring] auf (zum Beispiel als `localhost`), melden Sie sich als Instanzbenutzer an und rufen Sie dann die Agentendaten mit `cmk -d` ab:

[{shell}]
----
{c-omd} cmk -d localhost | grep -A3 '^<<<myhostgroups'
----

Hier sollte die gleiche Ausgabe kommen wie beim vorherigen Befehl.

Wenn das funktioniert, ist Ihr Agent vorbereitet.
Und was haben Sie dafür gemacht?
Sie haben ein kurzes Skript unter dem Pfad `/usr/lib/check_mk_agent/plugins/myhostgroups` erzeugt und ausführbar gemacht.

Alles was nun folgt, geschieht nur noch auf dem {CMK}-Server:
Dort schreiben Sie das Check-Plugin.


[#write_check_plugin]
== Ein einfaches Check-Plugin schreiben

Das Vorbereiten des Agenten ist nur die halbe Miete.
Jetzt müssen Sie {CMK} noch beibringen, wie es mit den Informationen aus der neuen Agentensektion umgehen soll, welche Services es erzeugen soll, wann diese auf {WARN} oder {CRIT} gehen sollen usw.
All dies machen Sie durch die Programmierung eines Check-Plugins in Python.


[#scaffold]
=== Die Datei vorbereiten

Für Ihre eigenen Check-Plugins finden Sie ein Verzeichnis vorbereitet in der `local`-Hierarchie des xref:cmk_commandline#sitedir[Instanzverzeichnisses.]
Dieses lautet `~/local/lib/check_mk/base/plugins/agent_based/`.
Hier im Pfad meint `base` den Teil von {CMK}, der für das eigentlich Monitoring und die Benachrichtigungen zuständig ist.
Der Ordner `agent_based` beinhaltet alle Plugins, die sich auf den {CMK}-Agenten beziehen (also zum Beispiel nicht Benachrichtigungs-Plugins).
Am besten wechseln Sie zum Arbeiten dort hinein:

[{shell}]
----
{c-omd} cd local/lib/check_mk/base/plugins/agent_based
----

Das Verzeichnis gehört dem Instanzbenutzer und ist daher für Sie schreibbar.
Sie können Ihr Check-Plugin mit jedem auf dem Linux-System installierten Texteditor bearbeiten.

Legen Sie also die Datei `myhostgroups.py` für das Check-Plugin hier an.
Konvention ist, dass der Dateiname den Namen der Agentensektion wiedergibt.
_Pflicht_ ist, dass die Datei mit `.py` endet, denn ab Version {v20} von {CMK} handelt es sich bei den Check-Plugins immer um echte Python-Module.

Ein lauffähiges Grundgerüst (link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/check_plugin_simple_myhostgroups_bare_minimum.py[Download bei GitHub^]), das Sie im Folgenden Schritt für Schritt weiter ausbauen werden, sieht so aus:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
#!/usr/bin/env python3

from .agent_based_api.v1 import check_levels, Metric, register, Result, Service, State

def parse_myhostgroups(string_table):
    parsed = {}
    return parsed

def discover_myhostgroups(section):
    yield Service()

def check_myhostgroups(section):
    yield Result(state=State.OK, summary="Everything is fine")

register.agent_section(
    name = "myhostgroups",
    parse_function = parse_myhostgroups,
)

register.check_plugin(
    name = "myhostgroups",
    service_name = "Host group check_mk",
    discovery_function = discover_myhostgroups,
    check_function = check_myhostgroups,
)
----

Als erstes müssen Sie die für die Check-Plugins nötigen Funktionen und Klassen aus Python-Modulen importieren.
Die einfachste Methode dafür ist `import pass:[*]`, allerdings sollten Sie das vermeiden, da so verschleiert wird, welche Namensräume tatsächlich verfügbar gemacht wurden.

Für unser Beispiel wird also nur das importiert, was im weiteren Verlauf des Artikels genutzt wird:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
from .agent_based_api.v1 import check_levels, Metric, register, Result, Service, State
----


[#parsefunction]
=== Die Parse-Funktion schreiben

Die Parse-Funktion hat die Aufgabe, die „rohen“ Agentendaten zu „parsen“, das heißt zu analysieren und zu zerteilen, und in eine logisch aufgeräumte Form zu bringen, die für alle weiteren Schritte einfach zu verarbeiten ist.

Wie im Abschnitt zum xref:test_agent[Testen des Agenten] gezeigt, hat die vom Agentenplugin gelieferte Sektion die folgende Struktur:

[{shell-raw}]
----
<<<myhostgroups:sep(59)>>>
Hamburg;myhost11,myhost22,myhost33
Munich;myhost1,myhost2,myhost3
check_mk;localhost
----

{CMK} zerlegt bereits die Zeilen der vom Agentenplugin gelieferten Sektion anhand des Trennzeichens im Sektions-Header (im Beispiel `;`) in eine Liste von Zeilen, die ihrerseits wiederum Listen von Worten sind.
In {CMK} steht daher statt der Rohdaten des Agentenplugins die folgende Datenstruktur zur Verfügung:

[{python}]
----
[
    ['Hamburg', 'myhost11,myhost22,myhost33'],
    ['Munich', 'myhost1,myhost2,myhost3'],
    ['check_mk', 'localhost']
]
----

In der inneren Liste enthält das jeweils erste Element den Namen der Host-Gruppe und das zweite die Namen der der Gruppe angehörenden Hosts.

Diese Informationen können Sie zwar alle ansprechen, aber jeweils nur über ihre Position im Datensatz.
Sie müssten also immer angeben, die wievielte eckige Klammer und den wievielten Inhalt innerhalb der jeweiligen Klammer Sie brauchen.
Bei größeren Datenmengen gestaltet sich dies komplex und es wird immer schwieriger, den Überblick zu behalten.

An diesem Punkt bietet die Parse-Funktion durch die von ihr erzeugte Struktur deutliche Vorteile.
Durch sie wird der Code leichter lesbar, die Zugriffe werden performanter und Sie behalten viel einfacher den Überblick.
Sie transformiert die von Checkmk gelieferte Datenstruktur so, dass man jeden der einzelnen Werte wahlfrei durch einen Namen (oder Schlüssel) ansprechen kann und nicht darauf angewiesen ist, den Bereich (_array_) iterativ zu durchlaufen, um das zu finden, was man sucht:

[{python}]
----
{
    'Hamburg': {'members': 'myhost11,myhost22,myhost33'},
    'Munich': {'members': 'myhost1,myhost2,myhost3'},
    'check_mk': {'members': 'localhost'}
}
----

Konvention ist, dass die Parse-Funktion nach der Agentensektion benannt wird und mit `parse_` beginnt.
Sie bekommt als einziges Argument `string_table`.
Beachten Sie, dass Sie hier nicht frei in der Wahl des Arguments sind.
Es muss wirklich so heißen.

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
def parse_myhostgroups(string_table):
    # print(string_table)
    parsed = {}
    for line in string_table:
        parsed[line[0]] = {"members": line[1]}
    # print(parsed)
    return parsed
----

Mit `def` geben Sie in Python an, dass nachfolgend eine Funktion definiert wird.
`parsed = {}` erzeugt das _Dictionary_ mit der verbesserten Datenstruktur.
In unserem Beispiel wird jede Zeile Element für Element durchgegangen.
Aus jeder Zeile wird die Host-Gruppe gefolgt von den Mitgliedern der Host-Gruppe genommen und zu einem Eintrag für das Dictionary zusammengesetzt.

Mit `return parsed` wird dann das Dictionary zurückgegeben.

*Hinweis:* Im oben gezeigten Beispiel finden Sie zwei auskommentierte Zeilen.
Wenn Sie diese später beim xref:test[Testen des Check-Plugins] einkommentieren, werden Ihnen die Daten vor und nach der Ausführung der Parse-Funktion auf der Kommandozeile angezeigt.
So können Sie überprüfen, ob die Funktion auch wirklich das tut, was sie soll.


=== Die Agentensektion registrieren

Damit das Ganze auch etwas bewirken kann, müssen Sie die Parse-Funktion, und überhaupt die neue Agentensektion, bei {CMK} bekannt machen.
Dazu rufen Sie eine Registrierfunktion auf:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
register.agent_section(
    name = "myhostgroups",
    parse_function = parse_myhostgroups,
)
----

Hier ist es wichtig, dass der Name der Sektion wirklich exakt mit dem Sektions-Header in der Agentenausgabe übereinstimmt.
Von diesem Moment an bekommt jedes Check-Plugin, das die Sektion `myhostgroups` benutzt, den Rückgabewert der Parse-Funktion übergeben.
In der Regel wird das das gleichnamige Check-Plugin sein.
Aber auch andere Check-Plugins können dieses Sektion abonnieren, wie wir bei der xref:discovery[Erweiterung des Check-Plugins] noch zeigen werden.

Übrigens: Wenn Sie es ganz genau wissen wollen, können Sie an dieser Stelle einen Blick in die xref:check_api_doc[Check-API-Dokumentation] werfen.
Dort finden Sie die detaillierte Beschreibung dieser Registrierfunktion -- und auch der Funktionen und Objekte, die später im Artikel noch verwendet werden.

[{image-border}]
image::devel_cpi_checkapi_doc_agent_section.png[alt="Check-API-Dokumentation für die Registrierfunktion 'agent_section'."]


[#register_check_plug-in]
=== Das Check-Plugin registrieren

Damit {CMK} weiß, dass es ein neues Check-Plugin gibt, muss dieses registriert werden.
Dies geschieht durch den Aufruf der Funktion `register.check_plugin`.
Dabei müssen Sie immer mindestens vier Dinge angeben:

. `name`: Der Name des Check-Plugins.
Am einfachsten ist es, wenn Sie hier den gleichen Namen wie bei Ihrer neuen Agentensektion nehmen.
Damit weiß der später in der Check-Funktion definierte Check automatisch, welche Sektion er auswerten soll.

. `service_name`:
Der Name des Services wie er dann im Monitoring erscheinen soll.

. `discovery_function`:
Die Funktion zum Erkennen von Services dieses Typs (dazu gleich mehr).

. `check_funktion`:
Die Funktion zum Durchführen des eigentlichen Checks (auch dazu gleich mehr).

Für das Check-Plugin sieht das dann also so aus:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
register.check_plugin(
    name = "myhostgroups",
    service_name = "Host group check_mk",
    discovery_function = discover_myhostgroups,
    check_function = check_myhostgroups,
)
----

Versuchen Sie am besten noch nicht, das gleich auszuprobieren, denn Sie müssen die Funktionen `discover_myhostgroups` und `check_myhostgroups` vorher noch schreiben.
Und diese müssen im Quellcode _vor_ obiger Registrierung erscheinen.


[#discovery_function]
=== Die Discovery-Funktion schreiben

Eine Besonderheit von {CMK} ist die automatische Erkennung von zu überwachenden Services.
Damit dies klappt, muss jedes Check-Plugin eine Funktion definieren, welche anhand der Agentenausgabe erkennt, _ob_ ein Service dieses Typs bzw. _welche_ Services des Typs für den betreffenden Host angelegt werden sollen.

Die Discovery-Funktion wird immer dann aufgerufen, wenn für einen Host die Service-Erkennung durchgeführt wird.
Sie entscheidet dann ob, bzw. welche Services angelegt werden sollen.
Im Standardfall bekommt sie genau ein Argument mit dem Namen `section`.
Dieses enthält die Daten der Agentensektion in einem durch die xref:parsefunction[Parse-Funktion] aufbereiteten Format.

Daher implementieren Sie folgende simple Logik:
_Wenn_ die Agentensektion `myhostgroups` vorhanden ist, dann legen Sie auch einen passenden Service an.
Dann erscheint dieser automatisch auf allen Hosts, auf denen Ihr Agentenplugin ausgerollt ist.

Bei Check-Plugins, die pro Host nur einen Service erzeugen, benötigt man keine weiteren Angaben:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
def discover_myhostgroups(section):
    yield Service()
----

Die Discovery-Funktion muss für jeden anzulegenden Service mittels `yield` ein Objekt vom Typ `Service` zurückgeben (nicht mit `return`).
`yield` hat in Python die gleiche Aufgabe wie `return` – beide geben einen Wert an die aufrufende Funktion zurück.
Der entscheidende Unterschied besteht darin, dass sich bei einem `yield` gemerkt wird, wie weit die Funktion in einer Datenverarbeitung gekommen ist.
Beim nächsten Aufruf wird _nach_ der letzten `yield`-Anweisung weiter gemacht - und nicht wieder am Anfang begonnen.
Dadurch wird nicht nur der erste Treffer ausgelesen (wie es beim `return` der Fall wäre), sondern sukzessive alle Treffer (dieser Vorteil wird später in unserem Beispiel bei der xref:discovery[Service-Erkennung] noch relevant).


[#check_function]
=== Die Check-Funktion schreiben

Somit können Sie nun zur eigentlichen Check-Funktion kommen, welche anhand der aktuellen Agentenausgabe entscheidet, welchen Zustand der Service annehmen soll und weitere Informationen ausgeben kann.

Ziel der Check-Funktion ist es, eine Prüfung aufzusetzen, mit der kontrolliert werden kann, ob für keinen Host vergessen wurde, eine Host-Gruppe zuzuweisen.
Dazu wird überprüft, ob die Host-Gruppe `check_mk` Hosts enthält.
Wenn das der Fall ist, soll der Service den Zustand {CRIT} erhalten.
Wenn nicht, ist alles {OK} und der Zustand des Services auch.

Hier ist die Implementierung:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups(section):
    attr = section.get("check_mk")
    hosts = attr["members"] if attr else ""
    if hosts:
        yield Result(state=State.CRIT, summary=f"Default group is not empty; Current member list: {hosts}")
    else:
        yield Result(state=State.OK, summary="Everything is fine")
----

Und nun die Erklärung dazu:
Die Funktion `check_myhostgroups()` holt als erstes den zum Schlüssel `check_mk` gehörenden Wert in die Variable `attr`.
Dann wird der Schlüssel `hosts` mit dem `members`-Wert verknüpft, wenn dieser vorhanden ist.
Gibt es keine `members`, so bleibt `hosts` leer.

Jetzt folgt eine `if`-Abfrage für die eigentliche Auswertung:

* Enthält die Variable `hosts` Inhalte, ist also die Host-Gruppe `check_mk` nicht leer, so geht der Status des Services auf {CRIT} und es wird ein Hinweistext ausgegeben.
Dieser enthält zusätzlich eine Auflistung der Host-Namen aller Hosts, die sich in der Host-Gruppe `check_mk` befinden.
Für die Ausgabe des Textes mit Ausdrücken wird der Python link:https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals[F-String] verwendet, der so heißt, weil vor der String-Zeichenfolge der Buchstabe `f` steht.

* Ist die Variable `hosts` leer, sind also keine Hosts in der Host-Gruppe `check_mk`, so geht stattdessen der Status des Services auf {OK}.
Dann wird zudem ein passender Hinweistext ausgegeben.

Mit der Erstellung der Check-Funktion ist das Check-Plugin fertig.

Das link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/check_plugin_simple_myhostgroups.py[Check-Plugin^]
und auch das link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/agent_plugin_simple_myhostgroups[Agentenplugin^]
haben wir auf GitHub bereitgestellt.


[#test]
=== Das Check-Plugin testen und aktivieren

Test und Aktivierung werden auf der Kommandozeile mit dem Befehl `cmk` erledigt.

Probieren Sie zunächst die xref:wato_services#commandline[Service-Erkennung] mit der Option `-I` aus.
Durch Zugabe der Option `v` (für _verbose_) werden ausführliche Ausgaben angefordert.
Das `--detect-plugins` beschränkt die Befehlsausführung auf dieses Check-Plugin und durch `localhost` auf eben diesen Host:

[{shell},highlight=12-14]
----
{c-omd} cmk -vI --detect-plugins=myhostgroups localhost
Discovering services and host labels on: localhost
localhost:
+ FETCHING DATA
[TCPFetcher] Execute data source
[PiggybackFetcher] Execute data source
No piggyback files for 'localhost'. Skip processing.
No piggyback files for '127.0.0.1'. Skip processing.
+ ANALYSE DISCOVERED HOST LABELS
SUCCESS - Found no new host labels
+ ANALYSE DISCOVERED SERVICES
+ EXECUTING DISCOVERY PLUGINS (1)
  1 myhostgroups
SUCCESS - Found 1 services
----

Wie geplant, erkennt die Service-Erkennung einen neuen Service im Check-Plugin `myhostgroups`.

Jetzt können Sie den im Check-Plugin enthaltenen xref:cmk_commandline#execute_checks[Check ausprobieren:]

[{shell},highlight=7]
----
{c-omd} cmk --detect-plugins=myhostgroups -v localhost
+ FETCHING DATA
[TCPFetcher] Execute data source
[PiggybackFetcher] Execute data source
No piggyback files for 'localhost'. Skip processing.
No piggyback files for '127.0.0.1'. Skip processing.
Host group check_mk   [red]#Default group is not empty; Current member list: localhost#
[agent] Success, [piggyback] Success (but no data found for this host), execution time 1.3 sec | execution_time=1.330 user_time=0.010 system_time=0.000 children_user_time=0.000 children_system_time=0.000 cmk_time_agent=1.330
----

Durch Ausführung des Checks wird der Zustand des zuvor gefundenen Services bestimmt.

Wenn soweit alles wie erwartet abgelaufen ist, können Sie die Änderungen aktivieren.
Falls nicht, finden Sie im Kapitel zur xref:errors[Fehlerbehebung] Hinweise.

Aktivieren Sie zum Abschluss die Änderungen durch einen xref:cmk_commandline#commands_core[Neustart des Monitoring-Kerns:]

[{shell}]
----
{c-omd} cmk -R
Generating configuration for core (type nagios)...
Precompiling host checks...OK
Validating Nagios configuration...OK
Restarting monitoring core...OK
----

Im Monitoring von {CMK} finden Sie nun beim Host `localhost` den neuen Service [.guihint]#Host group check_mk:#

.Da die Host-Gruppe `check_mk` nicht leer ist, ist der Service {CRIT}
image::devel_cpi_service_simple.png[alt="Der vom Check-Plugin erzeugte neue Service im Monitoring."]

Wir gratulieren Ihnen zur erfolgreichen Erstellung des ersten Check-Plugins!


[#extend]
== Das Check-Plugin erweitern


[#prepare]
=== Vorbereitungen

Das gerade frisch fertiggestellte erste Check-Plugin soll nun schrittweise erweitert werden.
Bisher hat das Agentenplugin nur die Informationen über die Namen und die Mitglieder der Host-Gruppen geliefert.
Um etwa die Zustände der Hosts und der auf ihnen laufenden Services auswerten zu können, braucht es mehr Daten.


==== Agentenplugin erweitern

Sie werden zunächst das Agentenplugin _einmal_ erweitern, um all die Informationen einzusammeln, die für die Erweiterung des Check-Plugins in den nächsten Abschnitten benötigt werden.

Um herauszubekommen, welche Informationen {CMK} denn für Host-Gruppen so bietet, 
können Sie alle verfügbaren Spalten der Host-Gruppentabelle mit xref:livestatus#columns[folgendem Befehl] als Instanzbenutzer abfragen:

[{shell}]
----
{c-omd} lq "GET columns\nFilter: table = hostgroups\nColumns: name"
action_url
alias
members
members_with_state
name
notes
notes_url
num_hosts
...
----

Die Ausgabe geht noch weiter.
Fast 30 Spalten bietet die Tabelle -- und unter den meisten Spaltennamen kann man sich sogar etwas vorstellen.
Hier interessieren die folgenden Spalten:
Anzahl der Hosts pro Gruppe (Spalte `num_hosts`), Anzahl der Hosts im Zustand {UP} (`num_hosts_up`), Anzahl der Services aller Hosts in der Gruppe (`num_services`) und Anzahl der Services im Zustand {OK} (`num_services_ok`).

Jetzt müssen diese neuen Spalten nur noch vom Agenten geliefert werden.
Das erreichen Sie durch Erweiterung des im vorherigen Kapitel erstellten xref:agentplugin[Agentenplugins.]

Editieren Sie als root-Benutzer das Skript des Agentenplugins.
Da das Skript die konfigurierbaren Werte bereits in Variablen gesteckt hat, reicht es aus, nur die mit `columns` beginnende Zeile zu ändern und dort die zusätzlich abgerufenen vier Spalten einzutragen:

./usr/lib/check_mk_agent/plugins/myhostgroups
[{file},highlight=3]
----
#!/bin/bash

columns="name members num_hosts num_hosts_up num_services num_services_ok"
site="mysite"

echo '<<<myhostgroups:sep(59)>>>'
su - ${site} lq "GET hostgroups\nColumns: ${columns}"
----

Führen Sie zur Kontrolle das Skript aus:

[{shell-raw}]
----
{c-root} /usr/lib/check_mk_agent/plugins/myhostgroups
<<<myhostgroups:sep(59)>>>
Munich;myhost3,myhost2,myhost1;3;3;180;144
Hamburg;myhost22,myhost33,myhost11;3;2;132;105
check_mk;SQL-Server,localhost;2;2;95;83
----

Am Ende jeder Zeile stehen nun, durch Semikolon abgetrennt, die vier neuen Werte.

Mit dieser Änderung liefert das Agentenplugin nun andere Daten als vorher.
An dieser Stelle ist es wichtig, sich zu vergewissern, dass das Check-Plugin auch mit den geänderten Daten immer noch das tut, was es soll.


==== Parse-Funktion erweitern

Im Check-Plugin ist die Parse-Funktion für die Umwandlung der vom Agentenplugin gelieferten Daten verantwortlich.
Beim xref:parsefunction[Erstellen der Parse-Funktion] haben Sie nur zwei Spalten der Host-Gruppentabelle berücksichtigt.
Nun werden sechs statt zwei Spalten geliefert.
Die Parse-Funktion muss also fit gemacht werden, um auch die zusätzlichen vier Spalten zu verarbeiten.

Ändern Sie als Instanzbenutzer die Parse-Funktion in der Datei `myhostgroups.py`, die das Check-Plugin enthält:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python},highlight=3-10;11-14]
----
def parse_myhostgroups(string_table):
    parsed = {}
    column_names = [
        "name",
        "members",
        "num_hosts",
        "num_hosts_up",
        "num_services",
        "num_services_ok",
    ] 
    for line in string_table:
        parsed[line[0]] = {}
        for n in range(1, len(column_names)):
            parsed[line[0]][column_names[n]] = line[n]
    return parsed
----

Geändert wurde hier alles zwischen `parsed = {}` und `return parsed`.
Zuerst werden die zu verarbeitenden Spalten unter ihren Namen als Liste `column_names` definiert.
In der `for`-Schleife wird dann ein Dictionary aufgebaut, indem in jeder Zeile aus Spaltenname und ausgelesenem Wert die Schlüssel-Wert-Paare erzeugt werden.

Für die existierende xref:check_function[Check-Funktion] ist diese Erweiterung unkritisch, denn die Datenstruktur für die ersten beiden Spalten bleibt unverändert.
Es werden nur zusätzliche Spalten bereitgestellt, die in der Check-Funktion (noch) gar nicht ausgewertet werden.

Nun, da die neuen Daten verarbeitet werden können, werden Sie sie auch nutzen.


[#discovery]
=== Service-Erkennung

In unserem Beispiel haben Sie einen sehr einfachen Check gebaut, der auf einem Host einen Service erzeugt.
Ein sehr üblicher Fall ist aber auch, dass es von einem Check mehrere Services auf einem Host geben kann.

Das häufigste Beispiel dafür sind die Dateisysteme eines Hosts.
Das Check-Plugin mit dem Namen `df` legt pro Dateisystem auf dem Host einen Service an.
Um diese Services zu unterscheiden, wird der Mount-Punkt des Dateisystems (zum Beispiel `/var`) bzw. der Laufwerksbuchstabe (zum Beispiel `C:`) in den Namen des Services eingebaut.
Das ergibt dann als Service-Name zum Beispiel `Filesystem /var` oder `Filesystem C:`.
Das Wort `/var` bzw. `C:` wird hier als _Item_ bezeichnet.
Wir sprechen also auch von einem _Check mit Items._

Wenn Sie einen Check mit Items bauen möchten, müssen Sie folgende Dinge umsetzen:

* Die Discovery-Funktion muss für jedes der Items, die auf dem Host sinnvollerweise überwacht werden sollen, einen Service generieren.

* Im Service-Namen müssen Sie das Item mithilfe des Platzhalters `%s` einbauen (also zum Beispiel `"Filesystem %s"`).

* Die Check-Funktion wird pro Item einmal separat aufgerufen und bekommt dieses als Argument.
Sie muss dann aus den Agentendaten die für dieses Item relevanten Daten herausfischen.

Um dies praktisch auszuprobieren, werden Sie für jede existierende Host-Gruppe einen eigenen Service erzeugen.

Da das im xref:write_check_plugin[vorherigen Kapitel] erstellte Check-Plugin `myhostgroups` zur Überprüfung der Standardgruppe `check_mk` weiterhin funktionieren soll, bleibt dieses Check-Plugin so, wie es ist.
Für die Erweiterung erstellen Sie in der Datei `myhostgroups.py` ein neues Check-Plugin -- im ersten Schritt so wie xref:register_check_plug-in[zuvor] durch die Registrierung des Plugins.

*Wichtig:* Die neue Registrierung wird zusätzlich zur bereits vorhandenen vorgenommen, die in Kapitel 2 gezeigte bleibt unverändert enthalten!
Hier nur der *neue* Code:


.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
...

register.check_plugin(
    name = "myhostgroups_advanced",
    sections = ["myhostgroups"],
    service_name = "Host group %s",
    discovery_function = discover_myhostgroups_advanced,
    check_function = check_myhostgroups_advanced,
)
----

Damit man das neue vom alten Check-Plugin unterscheiden kann, erhält es mit `myhostgroups_advanced` einen eindeutigen Namen.
Der Parameter `sections` bestimmt die Sektionen der Agentenausgabe, die das Check-Plugin abonniert.
Mit `myhostgroups` wird hier festgelegt, dass das neue Check-Plugin die gleichen Daten nutzt wie das alte: die durch die Parse-Funktion aufbereitete Sektion des Agentenplugins.
Der Service-Name enthält jetzt den Platzhalter `%s`.
An dieser Stelle wird später dann von {CMK} der Name des Items eingesetzt.
In den letzten beiden Zeilen werden schließlich die Namen für die neue Discovery-Funktion und die neue Check-Funktion festgelegt, die beide noch geschrieben werden wollen.

Zuerst zur Discovery-Funktion, die jetzt die Aufgabe hat, die zu überwachenden Items zu ermitteln – auch diese wird zusätzlich zur vorhandenen eingetragen:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
def discover_myhostgroups_advanced(section):
    for group in section:
        if group != "check_mk":
            yield Service(item=group)
----

Wie xref:discovery_function[zuvor] bekommt die Discovery-Funktion das Argument `section`.
Mit einer Schleife werden die einzelnen Host-Gruppen durchlaufen.
Hier interessieren alle Host-Gruppen -- mit Ausnahme von `check_mk`, denn um diese spezielle Host-Gruppe kümmert sich bereits das existierende Check-Plugin `myhostgroups`.
Immer, wenn ein Item gefunden wurde, wird es mit `yield` zurück gegeben, wobei ein Objekt vom Typ `Service` erzeugt wird, das den Host-Gruppennamen als Item übergeben bekommt.

Wenn später der Host überwacht wird, dann wird die Check-Funktion für jeden Service -- und damit für jedes Item -- separat aufgerufen.
Womit Sie bereits bei der Definition der Check-Funktion für das neue Check-Plugin `myhostgroups_advanced` angekommen sind.
Die Check-Funktion bekommt zusätzlich zur Sektion das Argument `item` übergeben.
Die erste Zeile der Funktion sieht dann so aus:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups_advanced(item, section):
----

Der Algorithmus für die Check-Funktion ist einfach:
Wenn die Host-Gruppe existiert, wird der Service auf {OK} gesetzt und Anzahl und Namen der Hosts in der Gruppe aufgelistet.
Die komplette Funktion dazu:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups_advanced(item, section):
    attr = section.get(item)
    if attr:
        yield Result(state=State.OK, summary=f"{attr['num_hosts']} hosts in this group: {attr['members']}")
----

Das Check-Ergebnis wird geliefert, indem ein Objekt der Klasse `Result` per `yield` zurückgeben wird.
Dieses benötigt die Parameter `state` und `summary`.
Dabei legt `state` den Zustand des Services fest (im Beispiel `OK`) und `summary` den Text, der in dem [.guihint]#Summary# des Services angezeigt wird.
Er ist rein informativ und wird von {CMK} nicht weiter ausgewertet.
Mehr dazu erfahren Sie im xref:summary_details[nächsten Abschnitt.]

So weit, so gut.
Was passiert aber, wenn das gesuchte Item nicht gefunden wird?
Das kann passieren, wenn in der Vergangenheit ein Service für eine Host-Gruppe bereits erzeugt wurde, diese Host-Gruppe aber nun verschwunden ist
-- entweder weil die Host-Gruppe in {CMK} noch existiert, aber keinen Host mehr enthält, oder weil sie gleich ganz gelöscht wurde.
In beiden Fällen ist diese Host-Gruppe in der Agentenausgabe nicht (mehr) präsent.

Die gute Nachricht:
{CMK} kümmert sich darum!
Wird ein gesuchtes Item nicht gefunden, so erzeugt {CMK} _automatisch_ für den Service das Resultat `UNKNOWN - Item not found in monitoring data`.
Das ist so gewollt und gut so.
Wenn ein gesuchtes Item nicht gefunden wird, so können Sie Python einfach aus der Funktion herauslaufen und {CMK} seine Arbeit erledigen lassen.

{CMK} weiß nur, dass das Item, das vorher da war, nun weg ist.
Den Grund dafür kennt {CMK} nicht -- Sie aber schon.
Darum ist es legitim, Ihr Wissen nicht für sich zu behalten und diesen Fall in der Check-Funktion abzufangen und dabei eine hilfreiche Meldung ausgeben zu lassen.

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python},highlight=3-5]
----
def check_myhostgroups_advanced(item, section):
    attr = section.get(item)
    if not attr:
        yield Result(state=State.CRIT, summary="Group is empty or has been deleted")
        return
    
    yield Result(state=State.OK, summary=f"{attr['num_hosts']} hosts in this group: {attr['members']}")
----

Was hat sich geändert?
Der Fehlerfall wird jetzt zuerst abgehandelt.
Daher überprüfen Sie im `if`-Zweig, ob das Item _nicht_ existiert, setzen den Status auf {CRIT} und verlassen mit `return` die Funktion.
In allen anderen Fällen geben Sie, wie zuvor, {OK} zurück.

Damit haben Sie in der Check-Funktion den Fall der verschwundenen Host-Gruppen übernommen.
Statt {UNKNOWN} wird der zugehörige Service nun {CRIT} sein und die Information über die Ursache des kritischen Zustands beinhalten.

Damit ist das neue Check-Plugin als Erweiterung des alten fertiggestellt.
Das erweiterte link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/agent_plugin_advanced_myhostgroups[Agentenplugin^]
und die erweiterte Datei für die link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/check_plugin_advanced_myhostgroups_step01.py[Check-Plugins^]
finden Sie wieder auf GitHub.
Letztere enthält das einfache Check-Plugin `myhostgroups` aus dem xref:write_check_plugin[vorherigen Kapitel], die erweiterte Parse-Funktion und die Komponenten des neuen Check-Plugins `myhostgroups_advanced` mit der Registrierung, der Discovery-Funktion und der Check-Funktion.
Beachten Sie, dass die Funktionen immer vor dem Registrieren definiert werden müssen, damit es keine Fehler wegen nicht definierter Funktionsnamen gibt.

Da das neue Check-Plugin `myhostgroups_advanced` neue Services zur Verfügung stellt, müssen Sie eine Service-Erkennung für dieses Check-Plugin durchführen und die Änderungen aktivieren, um die Services im Monitoring zu sehen:

.Zwei neue Services im Monitoring
image::devel_cpi_service_advanced_01.png[alt="Die vom erweiterten Check-Plugin erzeugten zwei neuen Services im Monitoring."]

Gehen Sie dabei so vor, wie es im Kapitel für das xref:test[einfache Check-Plugin] beschrieben ist.

[#summary_details]
=== Summary und Details

Im Monitoring von {CMK} hat jeder Service neben dem Status -- {OK}, {WARN} usw. -- auch eine Zeile Text.
Diese steht in der Spalte [.guihint]#Summary# -- wie im vorherigen Screenshot zu sehen ist -- und hat also die Aufgabe einer knappen Zusammenfassung des Zustands.
Die Idee ist, dass dieser Text eine Länge von 60 Zeichen nicht überschreitet.
Das sorgt dann immer für eine übersichtliche Tabellendarstellung ohne störende Zeilenumbrüche.

Daneben gibt es noch das Feld [.guihint]#Details,# in dem alle Details zum Zustand des Services angezeigt werden, wobei alle Informationen des Summary auch in den Details enthalten sind.
Nach Anklicken des Services wird die Service-Seite geöffnet, in der neben vielen anderen auch die beiden Felder [.guihint]#Summary# und [.guihint]#Details# zu sehen sind.

Beim Aufruf von `yield Result(pass:[...])` können Sie bestimmen, welche Informationen so wichtig sind, dass sie im Summary angezeigt werden sollen, und bei welchen es genügt, dass diese in den Details erscheinen.

In unserem Beispiel haben Sie bisher immer einen Aufruf der folgenden Art verwendet:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
    yield Result(state=State.OK, summary=f"{attr['num_hosts']} hosts in this group: {attr['members']}")
----

Dieser führt dazu, dass der als `summary` festgelegte Text immer im [.guihint]#Summary# erscheint -- und zusätzlich auch in den [.guihint]#Details#.
Dies sollten Sie also nur für wichtige Informationen verwenden.
Enthält eine Host-Gruppe viele Hosts, kann die Liste sehr lang werden -- länger als die empfohlenen 60 Zeichen.
Ist eine Information eher untergeordnet, so können Sie mit `details` festlegen, dass der Text _nur_ in den Details erscheint:

[#summary_details_yield]
.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
    yield Result(
        state = State.OK,
        summary = f"{attr['num_hosts']} hosts in this group",
        details = f"{attr['num_hosts']} hosts in this group: {attr['members']}",
    )
----

Im obigen Beispiel wird die Liste der Hosts daher nur noch in den [.guihint]#Details# angezeigt.
Im [.guihint]#Summary# steht dann nur die Anzahl der Hosts in der Gruppe:

.Unterschiedliche Inhalte für Summary und Details im Monitoring
image::devel_cpi_service_summary_details.png[alt="Summary und Details in den Service-Details."]

[#notice]
Es gibt neben `summary` und `details` noch einen dritten Parameter.
Mit `notice` bestimmen Sie, dass ein Text für einen Service im Zustand {OK} _nur_ in den Details angezeigt wird -- aber zusätzlich im Summary für alle anderen Zustände.
Somit wird dann aus dem Summary sofort klar, warum der Service nicht {OK} ist.
Der Parameter `notice` ist nicht besonders sinnvoll, wenn Texte fest an Zustände gebunden sind, wie bisher in unserem Beispiel.

Zusammengefasst bedeutet das:

* Der Gesamttext für das Summary sollte bei Services, die {OK} sind, nicht länger als 60 Zeichen sein.
* Verwenden Sie immer entweder `summary` oder `notice` -- nicht beides und nicht keines davon.
* Fügen Sie bei Bedarf `details` hinzu, wenn der Text für die Details ein alternativer sein soll.


[#partial_results]
=== Mehrere Teilresultate pro Service

Um die Anzahl der Services auf einem Host nicht ins Unermessliche steigen zu lassen, sind in einem Service oft mehrere Teilresultate zusammengefasst.
So prüft zum Beispiel der Service [.guihint]#Memory# unter Linux nicht nur RAM- und Swap-Nutzung, sondern auch geteilten Speicher (_shared memory_), Page-Tabellen und alles Mögliche andere.

Die xref:check_api_doc[Check-API] bietet dafür eine sehr komfortable Schnittstelle.
So darf eine Check-Funktion einfach beliebig oft ein Ergebnis mit `yield` erzeugen.
Der Gesamtstatus des Services richtet sich dann nach dem schlechtesten Teilergebnis in der Reihenfolge {OK} → {WARN} → {UNKNOWN} → {CRIT}.

Nutzen Sie diese Möglichkeit, um in unserem Beispiel für jeden Service der Host-Gruppen zu dem bestehenden Resultat zwei weitere zu definieren.
Diese werten den Prozentsatz der Hosts im Zustand {UP} und der Services im Zustand {OK} aus.
Dabei nutzen Sie die xref:prepare[zuvor] in der Agentenausgabe und der Parse-Funktion festgelegten zusätzlichen Spalten der Host-Gruppentabelle.

Erweitern Sie die Check-Funktion nun sukzessive von oben nach unten:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups_advanced(item, section):
    attr = section.get(item)
    if not attr:
        yield Result(state=State.CRIT, summary="Group is empty or has been deleted")
        return

    members = attr["members"]
    num_hosts = int(attr["num_hosts"])
    num_hosts_up = int(attr["num_hosts_up"])
    num_services = int(attr["num_services"])
    num_services_ok = int(attr["num_services_ok"])
----

Der `if`-Zweig bleibt unverändert, das heißt auch die neuen Teilresultate gelten nur für Host-Gruppen, die auch existieren.
Anschließend definieren Sie fünf Variablen für die in der Sektion enthaltenen Spalten der Host-Gruppentabelle.
Dies erhöht zum einen im folgenden die Lesbarkeit und nebenbei können Sie für die vier Spalten, mit denen noch gerechnet werden soll, die ausgelesenen Strings mit `int()` in Zahlen umwandeln.

Auch das bisher einzig existierende Resultat bleibt (fast) unverändert:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
    yield Result(
        state = State.OK,
        summary = f"{num_hosts} hosts in this group",
        details = f"{num_hosts} hosts in this group: {members}",
    )
----

Nur der Zugriff im Python-„F-String“ auf den Ausdruck, der den Wert liefert, ist nun einfacher als xref:#summary_details_yield[zuvor], da das `attr` bereits in den Variablendefinitionen steckt.

Nun zum eigentlichen Kern der Erweiterung, der Definition eines Resultats, das die folgende Aussage umsetzt:
„Der Service der Host-Gruppe ist {WARN}, wenn 90{nbsp}% der Hosts {UP} sind, und {CRIT} bei 80{nbsp}% der Hosts.“
Dabei gilt die Konvention, dass der Check bereits beim _Erreichen_ der Schwelle -- und nicht erst beim Überschreiten -- auf {WARN} bzw. {CRIT} geht.
Für den Vergleich eines ermittelten Werts mit Schwellwerten stellt die Check-API die Hilfsfunktion `check_levels` bereit.

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
    hosts_up_perc = 100.0 * num_hosts_up / num_hosts
    yield from check_levels(
        hosts_up_perc, 
        levels_lower = (90.0, 80.0),
        label = "UP hosts",
        notice_only = True,
    )
----

In der ersten Zeile wird aus Gesamtzahl und Zahl der Hosts im Zustand {UP} der Prozentsatz berechnet und in der Variablen `hosts_up_perc` gespeichert.
Durch den einfachen Schrägstrich (`/`) wird eine Gleitkommadivison ausgeführt, die sicherstellt, das das Ergebnis ein Float-Wert ist.
Das ist sinnvoll, weil einige im weiteren Verlauf verwendete Funktionen Float als Eingabe erwarten.
// Gleitkommadivision: floating point division

In der zweiten Zeile wird dann das Ergebnis der Funktion `check_levels` als Objekt vom Typ `Result` zurückgegeben.
Die Funktion wird gefüttert mit dem gerade berechneten Prozentsatz als Wert (`hosts_up_perc`), den beiden unteren Schwellwerten (`levels_lower`), einer Bezeichnung, die der Ausgabe vorangestellt wird (`label`) und schließlich mit `notice_only=True`.

Der letzte Parameter nutzt den im xref:notice[vorherigen Abschnitt] für das Objekt `Result()` bereits vorgestellten Parameter `notice`.
Mit `notice_only=True` legen Sie fest, dass der Text für den Service nur dann im [.guihint]#Summary# angezeigt wird, wenn der Zustand nicht {OK} ist.
Allerdings werden Teilergebnisse, die zu einem {WARN} oder {CRIT} führen, sowieso _immer_ im Summary sichtbar werden -- unabhängig davon, welchen Wert `notice_only` hat.

Schließlich definieren Sie analog zum zweiten das dritte Resultat, das den Prozentsatz der Services im Zustand {OK} auswertet:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
    services_ok_perc = 100.0 * num_services_ok / num_services
    yield from check_levels(
        services_ok_perc,
        levels_lower = (90.0, 80.0),
        label = "OK services",
        notice_only = True,
    )
----

Damit ist die Check-Funktion komplett.

Der Service für eine Host-Gruppe wertet jetzt drei Resultate aus und zeigt aus diesen den schlechtesten Zustand im Monitoring an, wie im folgenden Beispiel:

.Das Summary zeigt den Text zum kritischen Zustand
image::devel_cpi_service_partial_results.png[alt="Das Summary zeigt den Text zum kritischen Zustand."]


[#metrics]
=== Metriken

Nicht immer, aber oft befassen sich Checks mit Zahlen.
Und sehr oft handelt es sich bei diesen Zahlen um gemessene oder berechnete Werte.
In unserem Beispiel sind die Zahl der Hosts in der Host-Gruppe (`num_hosts`) und die Zahl der Hosts im Zustand {UP} (`num_hosts_up`) die Messwerte.
Der Prozentsatz der Hosts im Zustand {UP} (`hosts_up_perc`) ist ein daraus berechneter Wert.
Wenn dann solch ein Wert im zeitlichen Verlauf dargestellt werden kann, wird er auch als xref:glossar#metric[Metrik] bezeichnet.

Mit seinem xref:graphing#[Graphing-System] hat {CMK} eine Komponente, um solche Zahlen zu speichern, auszuwerten und darzustellen.
Das geht dabei völlig unabhängig von der Berechnung der Zustände {OK}, {WARN} und {CRIT}.

Sie werden in diesem Beispiel die beiden berechneten Werte `hosts_up_perc` und `services_ok_perc` als Metriken definieren.
Metriken werden in der grafischen Oberfläche von {CMK} sofort sichtbar, ohne dass Sie etwas dafür tun müssen.
Pro Metrik wird automatisch ein Graph erzeugt.

Metriken werden von der Check-Funktion ermittelt und als zusätzliches Ergebnis zurückgegeben.
Am einfachsten ist es, der Funktion `check_levels()` im Aufruf die Metrikinformationen mitzugeben.

Zur Erinnerung folgt die Zeile mit dem Funktionsaufruf von `check_levels()` aus dem xref:partial_results[vorherigen Abschnitt:]

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
    yield from check_levels(
        hosts_up_perc, 
        levels_lower = (90.0, 80.0),
        label = "UP hosts",
        notice_only = True,
    )
----

Die beiden neuen Argumente für die Metrik sind `metric_name` und `boundaries`:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python},highlight=4;6]
----
    yield from check_levels(
        hosts_up_perc,
        levels_lower = (90.0, 80.0),
        metric_name = "hosts_up_perc",
        label = "UP hosts",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
----

Um es schön einfach und aussagekräftig zu halten, nehmen Sie als Namen der Metrik den Namen der Variabel, in der der Prozentsatz als Wert gespeichert ist.

Mit `boundaries` können Sie dem Graphing-System die Information über den möglichen Wertebereich mitgeben.
Damit ist der kleinste und größte mögliche Wert gemeint.
Bei einem Prozentsatz sind die Grenzen mit `0.0` und `100.0` nicht allzu schwer zu bestimmen.
Es sind sowohl Gleitkommazahlen (_Float_) als auch Ganzzahlen (_Integer_, die intern wiederum in Gleitkommazahlen umgewandelt werden) erlaubt, aber keine Strings.
Falls nur eine Grenze des Wertebereichs definiert ist, tragen Sie für die andere einfach `None` ein, also zum Beispiel `boundaries=(0.0, None)`.

Durch diese Erweiterung gibt die Funktion `check_levels` nun per `yield` zusätzlich zum `Result` auch noch ein Objekt vom Typ `Metric` zurück.

Analog können Sie jetzt auch die Metrik `services_ok_perc` definieren.
Die letzten Zeilen der Check-Funktion sehen dann so aus:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
    hosts_up_perc = 100.0 * num_hosts_up / num_hosts
    yield from check_levels(
        hosts_up_perc,
        levels_lower = (90.0, 80.0),
        metric_name = "hosts_up_perc",
        label = "UP hosts",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
    services_ok_perc = 100.0 * num_services_ok / num_services
    yield from check_levels(
        services_ok_perc,
        levels_lower = (90.0, 80.0),
        metric_name = "services_ok_perc",
        label = "OK services",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
----

Mit der so erweiterten Check-Funktion sind die beiden Graphen im Monitoring sichtbar.
In der Service-Übersicht zeigt nun das Symbol icon:icon_service_graph[alt="Symbol zur Anzeige der Graphen eines Services."], dass es Graphen zum Service gibt.
Wenn Sie mit der Maus auf das Symbol zeigen, werden die Graphen als Vorschau eingeblendet.

.Die Namen der Metriken werden als Titel der Graphen verwendet
image::devel_cpi_service_graphs.png[alt="Die Service-Übersicht mit 2 Graphen als Vorschau."]

Eine Übersicht aller Graphen inklusive Legende und mehr finden Sie in den Service-Details.

Was macht man aber, wenn der Wert für die gewünschte Metrik gar nicht mit der Funktion `check_levels()` definiert wurde?
Sie können selbstverständlich eine Metrik auch unabhängig von einem Funktionsaufruf festlegen.
Dazu dient das Objekt `Metric()`, welches Sie auch direkt über seinen Konstruktor erzeugen können.
Die alternative Definition einer Metrik für den Wert `hosts_up_perc` sieht so aus:

[{python}]
----
    yield Metric(
        name = "hosts_up_perc",
        value = hosts_up_perc,
        levels = (80.0, 90.0),
        boundaries = (0.0, 100.0),
    )
----

Die Argumente von `Metric()` sind sehr ähnlich zu denen im oben gezeigten Funktionsaufruf:
Verpflichtend sind die ersten beiden Argumente für den Metriknamen und den Wert.
Zusätzlich gibt es noch zwei optionale Argumente: `levels` für die Schwellwerte {WARN} und {CRIT} und `boundaries` für den Wertebereich.

*Wichtig:* Die Angabe von `levels` dient hier lediglich als Information für die Darstellung des Graphen.
Im Graphen werden die Schwellwerte üblicherweise als gelbe und rote Linien eingezeichnet.
Für die _Überprüfung_ ist die Funktion `check_levels` mit den dort festgelegten Schwellwerten verantwortlich.

Nutzen Sie nun die Möglichkeit, nicht nur die beiden berechneten Werte, sondern mit `Metric()` _alle_ Messwerte als Metriken zu definieren
-- in unserem Beispiel also die vier Messwerte aus der Host-Gruppentabelle.
Beschränken Sie sich dabei auf die beiden obligatorischen Angaben von Metrikname und Wert.
Die vier neuen Zeilen komplettieren die Erweiterung der Check-Funktion für Metriken:

[{python}]
----
    hosts_up_perc = 100.0 * num_hosts_up / num_hosts
    yield from check_levels(
        hosts_up_perc,
        levels_lower = (90.0, 80.0),
        metric_name = "hosts_up_perc",
        label = "UP hosts",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
    services_ok_perc = 100.0 * num_services_ok / num_services
    yield from check_levels(
        services_ok_perc,
        levels_lower = (90.0, 80.0),
        metric_name = "services_ok_perc",
        label = "OK services",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
    
    yield Metric(name="num_hosts", value=num_hosts)
    yield Metric(name="num_hosts_up", value=num_hosts_up)
    yield Metric(name="num_services", value=num_services)
    yield Metric(name="num_services_ok", value=num_services_ok)
----

Das erhöht schon einmal die Zahl der Graphen pro Service, bietet Ihnen aber zum Beispiel auch die Möglichkeit, mehrere Metriken in einem Graphen zu kombinieren.
Wir zeigen diese und andere Möglichkeiten im Abschnitt xref:metrics_advanced[Darstellung von Metriken anpassen] weiter unten.

In der Beispieldatei auf
link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/check_plugin_advanced_myhostgroups_step02.py[GitHub^]
finden Sie wieder die gesamte Check-Funktion.


[#rule_set]
=== Check-Parameter für Regelsätze

Im erweiterten Check-Plugin `myhostgroups_advanced` haben Sie den Zustand {WARN} erzeugt, wenn nur 90{nbsp}% der Hosts {UP} sind, und {CRIT} bei 80{nbsp}%.
Dabei sind die Zahlen `90` und `80` direkt in der Check-Funktion fest einprogrammiert oder, wie Programmierer sagen würden, _hart codiert._
In {CMK} ist man allerdings als Benutzer gewohnt, dass man solche Schwellwerte und andere Check-Parameter per xref:glossar#rule[Regel] konfigurieren kann.
Denn hat zum Beispiel eine Host-Gruppe nur vier Mitglieder, dann passen die beiden Schwellwerte von 90 und 80{nbsp}% nicht wirklich gut,
da bereits beim Ausfall des ersten Hosts der Prozentsatz auf 75{nbsp}% sinkt und der Zustand -- ohne Umweg über {WARN} -- direkt auf {CRIT} geht.

Daher soll das Check-Plugin nun so verbessert werden, dass es über die Setup-Oberfläche konfigurierbar ist.
Dazu benötigen Sie einen xref:glossar#rule_set[Regelsatz.]
Falls es in {CMK} bereits einen passenden Regelsatz gibt, dann können Sie diesen verwenden.
Da Check-Funktion und Regelsatz zusammenpassen müssen, wird dies in aller Regel nicht der Fall sein.
Weiter unten finden Sie mehr Informationen zu xref:reuse_ruleset[vorhandenen Regelsätzen.]

*Hinweis:* Beachten Sie, dass die in diesem Abschnitt vorgestellten Beispiele _nicht_ durch die Check-API abgedeckt sind.


[#new_ruleset]
==== Neuen Regelsatz definieren

Um einen neuen Regelsatz zu erstellen, legen Sie eine neue Datei im Verzeichnis `~/local/share/check_mk/web/plugins/wato` an.
Der Name der Datei sollte sich an dem des Check-Plugins orientieren und muss wie alle Plugin-Dateien die Endung `.py` haben.
Für unser Beispiel passt der Dateiname `myhostgroups_advanced_parameters.py`.

Sehen Sie sich den Aufbau so einer Datei Schritt für Schritt an.
Zunächst kommen einige Importbefehle.

Falls die Texte in Ihrer Datei, die auf der {CMK}-GUI angezeigt werden, in andere Sprachen übersetzbar sein sollen, importieren Sie `_` (Unterstrich):

.~/local/share/check_mk/web/plugins/wato/myhostgroups_advanced_parameters.py
[{python}]
----
from cmk.gui.i18n import _
----

Dies ist eine Funktion und fungiert als Markierung für alle übersetzbaren Texte.
Im Weiteren schreiben Sie dann zum Beispiel anstelle von `"Threshold for Warning"` ein `pass:[_]("Threshold for Warning")` für den Funktionsaufruf.
Das Übersetzungssystem von {CMK}, welches auf link:https://docs.python.org/3/library/gettext.html#module-gettext[gettext^] basiert,
findet solche Texte und übernimmt sie in die Liste der zu übersetzenden Texte auf.
Falls Sie den Check nur für sich selbst bauen, können Sie darauf und damit auch auf die `import`-Zeile verzichten.

Als nächstes importieren Sie sogenannte _ValueSpecs._
Ein ValueSpec ist ein sehr praktisches und universelles Werkzeug, das {CMK} an vielen Stellen verwendet.
Es dient dem Generieren von angepassten Eingabeformularen, der Darstellung und Validierung der eingegebenen Werte und der Umwandlung in Python-Datenstrukturen.

.~/local/share/check_mk/web/plugins/wato/myhostgroups_advanced_parameters.py
[{python}]
----
from cmk.gui.valuespec import (
    Dictionary,
    Percentage,
    TextInput,
    Tuple,
)
----

Das `Dictionary` benötigen Sie auf jeden Fall, denn seit {CMK}-Version {v20} werden Check-Parameter in Python-Dictionaries gespeichert.
`Percentage` ist für die Eingabe von Prozentwerten verantwortlich, `TextInput` für einen Unicode-Text und `Tuple` für eine geordnete, eindimensionale Menge von Objekten.
Sie werden auch häufiger `Float` (Gleitkommazahlen) und `Integer` (Ganzzahlen) verwenden.

Als nächstes werden noch Klassen und Funktionen importiert, die beim Registrieren benötigt werden:

.~/local/share/check_mk/web/plugins/wato/myhostgroups_advanced_parameters.py
[{python}]
----
from cmk.gui.plugins.wato.utils import (
    CheckParameterRulespecWithItem,
    rulespec_registry,
    RulespecGroupCheckParametersApplications,
)
----

Da Ihr Check-Plugin `myhostgroups_advanced` mehrere Services erzeugt, importieren Sie `CheckParameterRulespecWithItem`.
Falls Ihr Check keinen Service erzeugt, mit anderen Worten kein Item hat, importieren Sie stattdessen `CheckParameterRulespecWithoutItem`.
Zur `RulespecGroup` gibt es am Ende dieses Abschnitts noch Informationen.

Nun kommen die eigentlichen Definitionen.
Zunächst deklarieren Sie ein Eingabefeld, mit dem der Benutzer das _Item_ des Checks angeben kann.
Dieses Feld wird in der Bedingung der Regel angezeigt und erlaubt es den Benutzern, die Regel auf bestimmte Services einzuschränken.
Es ist auch für das manuelle Anlegen von Checks notwendig, welche ohne Discovery funktionieren sollen.

Das Feld erstellen Sie mit `TextInput`.
Es bekommt per `title` einen Titel zugewiesen, welcher dann in der Regel als Überschrift für das Eingabefeld angezeigt wird.
Wenn Sie ein Herz für Ihre Benutzer haben, geben Sie ihnen auch noch einen hilfreichen Text für die Inline-Hilfe mit:

.~/local/share/check_mk/web/plugins/wato/myhostgroups_advanced_parameters.py
[{python}]
----
def _item_valuespec_myhostgroups_advanced():
    return TextInput(
        title = "Host group name",
        help = "You can restrict this rule to certain services of the specified hosts.",
    )
----

Den Namen der Funktion, welche dieses ValueSpec zurückgibt, können Sie frei wählen, er wird nur bei der Registrierung weiter unten benötigt.
Damit die Funktion nicht über die Modulgrenze hinaus sichtbar wird, sollte der Name mit einem Unterstrich beginnen.

Als nächstes kommt das ValueSpec für die Eingabe der eigentlichen Check-Parameter.
Auch hierfür legen Sie eine Funktion an, welche das ValueSpec erzeugt.
Der Benutzer soll die beiden Schwellwerte für {WARN} und {CRIT} festlegen können und zwar getrennt für die Anzahl der Hosts im Zustand {UP} und der Services im Zustand {OK}:

.~/local/share/check_mk/web/plugins/wato/myhostgroups_advanced_parameters.py
[{python}]
----
def _parameter_valuespec_myhostgroups_advanced():
    return Dictionary(
        elements = [
            ("hosts_up_lower",
                Tuple(
                    title = _("Lower percentage threshold for host in UP status"),
                    elements = [
                        Percentage(title=_("Warning")),
                        Percentage(title=_("Critical")),
                    ],
                )
            ),
            ("services_ok_lower",
                Tuple(
                    title = _("Lower percentage threshold for services in OK status"),
                    elements = [
                        Percentage(title=_("Warning")),
                        Percentage(title=_("Critical")),
                    ],
                )
            ),
        ],
    )
----

Das `return Dictionary()` ist vorgeschrieben.
Innerhalb dessen legen Sie mit `elements=[]` die Liste der Parameter an, im Beispiel `hosts_up_lower` und `services_ok_lower`.
Beide Parameter werden jeweils durch ein _Tupel_ von zwei Werten für die {CRIT} und {WARN} Schwellwerte definiert.
Alle Schwellwerte sollen Prozentzahlen sein, also verwenden Sie hier `Percentage`.

*Hinweis:* Wenn Sie den Benutzern des Regelsatzes statt leerer Eingabefelder bereits Werte vorgeben wollen, können Sie das tun, indem Sie die `Percentage()` Funktion um das Argument `default_value` erweitern.
Für das Tupel `hosts_up_lower` aus dem eben gezeigten Beispiel sieht das dann so aus:

[{python}]
----
            ("hosts_up_lower", 
                Tuple(
                    title = _("Lower percentage threshold for host in UP status"),
                    elements = [
                        Percentage(title=_("Warning"), default_value=90.0), 
                        Percentage(title=_("Critical"), default_value=80.0),
                    ],
                )
            ),
----

Beachten Sie, dass diese in der GUI angezeigten Werte _nicht_ die Standardwerte sind, die weiter unten bei der xref:ruleset_defaults[Registrierung des Check-Plugins] per `check_default_parameters` gesetzt werden.
Wollen Sie die gleichen Standardwerte in der GUI anzeigen lassen, die auch für die Check-Funktion gelten, dann müssen Sie die Werte an beiden Stellen selbst konsistent halten.

Zu guter Letzt registrieren Sie jetzt mithilfe der importierten und selbst definierten Dinge den neuen Regelsatz.
Dazu gibt es die Funktion `rulespec_registry.register()`:

.~/local/share/check_mk/web/plugins/wato/myhostgroups_advanced_parameters.py
[{python}]
----
rulespec_registry.register(
    CheckParameterRulespecWithItem(
        check_group_name = "myhostgroups_advanced",
        group = RulespecGroupCheckParametersApplications,
        match_type = "dict",
        item_spec = _item_valuespec_myhostgroups_advanced,
        parameter_valuespec = _parameter_valuespec_myhostgroups_advanced,
        title = lambda: _("Host group status"),
    )
)
----

Dazu die folgenden Erklärungen:

* Falls Ihr Check kein Item verwendet, lautet die innere Funktion `CheckParameterRulespecWithoutItem`.
Die Zeile `item_spec` entfällt dann.

* Der `check_group_name` als Name des Regelsatzes stellt die Verbindung zu den Check-Plugins her.
Ein Check-Plugin, das diesen Regelsatz verwenden will, muss beim Registrieren diesen Namen als `check_ruleset_name` verwenden.
Der Name darf auf keinen Fall identisch sein mit einem bereits existierenden Regelsatz, weil dieser damit überschrieben würde.
Um dieser Gefahr aus dem Weg zu gehen, verwenden Sie am besten im Namen einen Präfix.

* Die `group` legt fest, wo im Setup der Regelsatz auftauchen soll.
Mit dem im Beispiel gewählten Wert finden Sie ihn unter [.guihint]#Setup > Services > Service monitoring rules# im ersten Kasten [.guihint]#Applications, Processes & Services.#
Die meisten dieser Gruppen sind in der Datei `~/lib/check_mk/gui/plugins/wato/utils/pass:[__init__].py` definiert.
Dort finden Sie auch Beispiele, wie Sie eine eigene neue Gruppe anlegen können.

* Der `match_type` ist immer `"dict"`.

* Als `item_spec` und `parameter_valuespec` geben Sie die Namen der beiden zuvor erstellten Funktionen ein.

* `title` legt den Titel des Regelsatzes fest, so wie er auch in der {CMK}-GUI erscheint.
Der Titel wird aber nicht direkt als Text, sondern als ausführbare Funktion angegeben, welche den Text zurückliefert (deswegen das `lambda:`).


[#test_ruleset]
==== Regelsatz testen

Wenn Sie die Datei für den Regelsatz angelegt haben, sollten Sie ausprobieren, ob alles soweit funktioniert -- noch ohne Verbindung zum Check-Plugin.
Dazu müssen Sie zuerst den Apache der Instanz neu starten, damit die neue Datei gelesen wird.
Das macht der Befehl:

[{shell}]
----
{c-omd} omd restart apache
----

Danach sollte der Regelsatz im Setup auf der oben genannten Seite zu finden sein.
Mit der Suchfunktion im Setup-Menü finden Sie den Regelsatz auch -- aber erst nach einem Neustart von Redis:

[{shell}]
----
{c-omd} omd restart redis
----

Der soeben definierte Regelsatz sieht in der GUI so aus:

image::devel_cpi_ruleset.png[alt="Der neu erstellte Regelsatz im Setup."]

In der Bedingung finden Sie das definierte Feld [.guihint]#Host group name# mit der Inline-Hilfe:

image::devel_cpi_ruleset_condition.png[alt="Das Feld zur Service-Auswahl in der Regelbedingung."]

Die Texte zum Umgang mit den regulären Ausrücken hat übrigens {CMK} Ihrem Regelsatz spendiert.

Legen Sie eine Regel an und probieren Sie verschiedene Werte aus, wie im obigen Screenshot gezeigt.
Wenn das ohne Fehler geht, können Sie die Check-Parameter jetzt in der Check-Funktion verwenden.


[#use_ruleset]
==== Regelsatz im Check-Plugin benutzen

Damit die Regel zum Greifen kommt, müssen Sie dem Check-Plugin erlauben, Check-Parameter entgegenzunehmen und ihm sagen, welche Regel benutzt werden soll.
Dazu fügen Sie zwei neue Zeilen in die Registrierungsfunktion ein:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python},highlight=7-8]
----
register.check_plugin(
    name = "myhostgroups_advanced",
    sections = ["myhostgroups"],
    service_name = "Host group %s",
    discovery_function = discover_myhostgroups_advanced,
    check_function = check_myhostgroups_advanced,
    check_default_parameters = {},
    check_ruleset_name = "myhostgroups_advanced",
)
----

Mit dem Eintrag `check_default_parameters` können Sie die Standardwerte setzen, die gelten, solange noch keine Regel angelegt ist.
Bei der Registrierung muss diese Zeile unbedingt vorhanden sein.
Im einfachsten Fall übergeben Sie ein leeres Dictionary `{}`.

Als zweites übergeben Sie der Registrierungsfunktion noch den `check_ruleset_name`, also den Namen, den Sie oben mittels `check_group_name` an den Regelsatz vergeben haben.
So weiß {CMK} aus welchem Regelsatz die Parameter bestimmt werden sollen.

Nun wird {CMK} versuchen, der Check-Funktion Parameter zu übergeben.
Damit das klappen kann, müssen Sie die Check-Funktion so erweitern, dass sie das Argument `params` erwartet, welches sich zwischen `item` und `section` schiebt:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups_advanced(item, params, section):
----

Falls Sie einen Check ohne Item bauen, entfällt das `item` und `params` steht am Anfang.

Es ist sehr empfehlenswert, sich jetzt als ersten Test den Inhalt der Variable `params` mit einem `print` ausgeben zu lassen:

[{python}]
----
def check_myhostgroups_advanced(item, params, section):
    print(params)
----

Bei der Ausführung des Check-Plugins sehen die beiden ausgedruckten Zeilen (für jeden Service eine) dann etwa so aus:

[{shell}]
----
{c-omd} cmk --detect-plugins=myhostgroups_advanced -v localhost
Parameters({'hosts_up_lower': (70.0, 60.0), 'services_ok_lower': (75.0, 65.0)})
Parameters({'hosts_up_lower': (70.0, 60.0), 'services_ok_lower': (75.0, 65.0)})
Parameters({'hosts_up_lower': (70.0, 60.0), 'services_ok_lower': (75.0, 65.0)})
----

*Wichtig:* Wenn alles fertig ist und funktioniert, entfernen Sie unbedingt die `print`-Befehle wieder.
Diese können die interne Kommunikation von {CMK} durcheinanderbringen.

Nun passen Sie Ihre Check-Funktion weiter an, so dass die übergebenen Parameter ihre Wirkung entfalten können.
Holen Sie sich die beiden Tupel mit dem in der Regel gewählten Namen aus den Parametern:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
def check_myhostgroups_advanced(item, params, section):
    hosts_up_lower = params["hosts_up_lower"]
    services_ok_lower = params["services_ok_lower"]
----

Weiter unten in der Check-Funktion werden dann die bisher hart kodierten Schwellwerte `(90, 80)` durch die Variablen `hosts_up_lower` und `services_ok_lower` ersetzt:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python},highlight=4;13]
----
    hosts_up_perc = 100.0 * num_hosts_up / num_hosts
    yield from check_levels(
        hosts_up_perc,
        levels_lower = (hosts_up_lower),
        metric_name = "hosts_up_perc",
        label="UP hosts",
        boundaries = (0, 100),
        notice_only = True,
    )
    services_ok_perc = 100.0 * num_services_ok / num_services
    yield from check_levels(
        services_ok_perc,
        levels_lower = (services_ok_lower),
        metric_name = "services_ok_perc",
        label = "OK services",
        boundaries = (0, 100),
        notice_only = True,
    )
----

Falls eine Regel konfiguriert ist, können Sie nun die Host-Gruppen des Beispiels mit den über die GUI gesetzten Schwellwerten überwachen.
Wenn allerdings keine Regel definiert ist, wird diese Check-Funktion abstürzen:
Da die Default-Parameter des Check-Plugins nicht befüllt sind, wird das Plugin bei Abwesenheit einer Regel einen `KeyError` erzeugen.

[#ruleset_defaults]
Dieses Problem kann aber behoben werden, wenn bei der Registrierung die Standardwerte gesetzt sind:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python},highlight=7]
----
register.check_plugin(
    name = "myhostgroups_advanced",
    sections = ["myhostgroups"],
    service_name = "Host group %s",
    discovery_function = discover_myhostgroups_advanced,
    check_function = check_myhostgroups_advanced,
    check_default_parameters = {"hosts_up_lower": (90, 80), "services_ok_lower": (90, 80)},
    check_ruleset_name = "myhostgroups_advanced",
)
----

Sie sollten Standardwerte immer auf diese Weise übergeben (und den Fall fehlender Parameter nicht im Check-Plugin abfangen), da diese Standardwerte auch in der Setup-Oberfläche angezeigt werden können.
Dazu gibt es zum Beispiel bei der Service-Erkennung eines Hosts, auf der Seite [.guihint]#Services of host#, im Menü [.guihint]#Display# den Eintrag [.guihint]#Show check parameters.#

*Hinweis:* Auf GitHub finden Sie sowohl die Datei mit dem
link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/check_plugin_advanced_myhostgroups_parameters.py[Regelsatz^]
als auch das um den Regelsatz erweiterte
link:https://github.com/Checkmk/checkmk-docs/blob/master/examples/devel_check_plugins/check_plugin_advanced_myhostgroups.py[Check-Plugin.^]


[#reuse_ruleset]
==== Vorhandenen Regelsatz verwenden

Unwahrscheinlich, doch nicht ausgeschlossen ist es, dass ein mit {CMK} ausgelieferter Regelsatz zu Ihrer Check-Funktion passt.
Das kann eigentlich nur dann der Fall sein, wenn der Check etwas prüft, für das {CMK} in gleicher Form bereits Check-Plugins hat, zum Beispiel das Überwachen einer Temperatur oder anderer mit Sensoren gemessener Werte.
Wenn aber so ein Regelsatz zu Ihrem Check-Plugin passt, dann können Sie sich die Erstellung eines eigenen Regelsatzes sparen.

Die ausgelieferten Regelsätze für Parameter von Checks finden Sie im Verzeichnis `~/lib/check_mk/gui/plugins/wato/check_parameters/`.

Nehmen Sie als Beispiel die Datei `memory_simple.py`.
Diese deklariert einen Regelsatz mit folgendem Abschnitt:

.~/lib/check_mk/gui/plugins/wato/check_parameters/memory_simple.py
[{python},highlight=3]
----
rulespec_registry.register(
    CheckParameterRulespecWithItem(
        check_group_name = "memory_simple",
        group = RulespecGroupCheckParametersOperatingSystem,
        item_spec = _item_spec_memory_simple,
        match_type = "dict",
        parameter_valuespec = _parameter_valuespec_memory_simple,
        title = lambda: _("Main memory usage of simple devices"),
    )
)
----

Entscheidend ist dabei, wie beim selbst geschriebenen Regelsatz, das Schlüsselwort `check_group_name`, welches hier auf `"memory_simple"` gesetzt ist.
Damit wird die Verbindung zum Check-Plugin hergestellt.
Das machen Sie beim Registrieren des Check-Plugins mit dem Schlüsselwort `check_ruleset_name`, zum Beispiel so:

[{python},highlight=6]
----
register.check_plugin(
    name = "foobar",
    service_name = "Foobar %s",
    discovery_function = discover_foobar,
    check_function = check_foobar,
    check_ruleset_name = "memory_simple",
    check_default_parameters = {},
)
----

Notwendig ist auch hier die Definition von Standardwerten über das Schlüsselwort `check_default_parameters`.


[#metrics_advanced]
== Darstellung von Metriken anpassen

Im xref:metrics[obigen Beispiel] haben Sie das Check-Plugin `myhostgroups_advanced` Metriken für alle gemessenen und berechneten Werte erzeugen lassen.
Dazu haben wir zwei Wege vorgestellt.
Zuerst wurden die Metriken der berechneten Werte als Bestandteil der Funktion `check_levels()` mit dem Argument `metric_name` erstellt, zum Beispiel so:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
    yield from check_levels(
        services_ok_perc,
        levels_lower = (services_ok_lower),
        metric_name = "services_ok_perc",
        label = "OK services",
        boundaries = (0.0, 100.0),
        notice_only = True,
    )
----

Dann haben wir die gemessenen Metriken direkt mit dem Objekt `Metric()` erzeugt -- für die Anzahl der Services im Zustand {OK} zum Beispiel so:

.~/local/lib/check_mk/base/plugins/agent_based/myhostgroups.py
[{python}]
----
    yield Metric(name="num_services_ok", value=num_services_ok)
----

Metriken werden in der grafischen Oberfläche von {CMK} zwar sofort sichtbar, ohne dass Sie etwas dafür tun müssen.
Allerdings gibt es dabei ein paar Einschränkungen:

* Es werden nicht automatisch passende Metriken in einem Graphen kombiniert, sondern jede erscheint einzeln.

* Die Metrik hat keinen richtigen Titel, sondern es wird der interne Variablenname der Metrik gezeigt.

* Es wird keine Einheit verwendet, die eine sinnvolle Darstellung erlaubt (zum Beispiel GB anstelle von einzelnen Bytes).

* Es wird zufällig eine Farbe ausgewählt.

* Es erscheint nicht automatisch ein „Perf-O-Meter“, also die grafische Vorschau der Metrik als Balken in der Service-Übersicht (zum Beispiel in der Ansicht, die alle Services eines Hosts darstellt).

Um die Darstellung Ihrer Metriken in diesen Belangen zu vervollständigen, benötigen Sie _Metrikdefinitionen._

*Hinweis:* Beachten Sie, dass die in diesem Kapitel vorgestellten Beispiele _nicht_ durch die Check-API abgedeckt sind.


[#reuse_metricdefinition]
=== Vorhandene Metrikdefinitionen verwenden

Bevor Sie eine neue Metrikdefinition erstellen, sollten Sie zunächst prüfen, ob {CMK} nicht bereits eine geeignete Definition mitbringt.
Die vordefinierten Metrikdefinitionen finden Sie im Verzeichnis `~/lib/check_mk/gui/plugins/metrics/`.

In der Datei `cpu.py` finden Sie beispielsweise die Metrik mit dem Namen `util` für die CPU-Auslastung (_CPU utilization_):

.~/lib/check_mk/gui/plugins/metrics/cpu.py
[{python}]
----
metric_info["util"] = {
    "title": _l("CPU utilization"),
    "unit": "%",
    "color": "26/a",
}
----

Falls Ihr Check-Plugin die CPU-Auslastung in Prozent misst, können Sie diese Metrikdefinition problemlos verwenden.
Sie müssen lediglich in Ihrer Check-Funktion `"util"` als den Namen für die Metrik einsetzen.
Alles andere leitet sich dann automatisch davon ab.


[#new_metricdefinition]
=== Neue Metrikdefinition erstellen

Falls keine passende Metrikdefinition dabei ist, legen Sie einfach selbst eine an.

Für unser Beispiel definieren Sie nun eine eigene Metrik für die Anzahl der Services im Zustand {OK}.
Dazu legen Sie eine Datei in `~/local/share/check_mk/web/plugins/metrics` an:

.~/local/share/check_mk/web/plugins/metrics/myhostgroups_advanced_metrics.py
[{python}]
----
from cmk.gui.i18n import _

from cmk.gui.plugins.metrics import metric_info

metric_info["num_services_ok"] = {
    "title": _("Services in OK status"),
    "unit": "count",
    "color": "15/a",
}
----

Hier die Erklärung dazu:

* Das Importieren und Verwenden des Unterstrichs (`_`) für die Internationalisierung ist optional, wie bereits bei der Erstellung von xref:new_ruleset[Regelsätzen] besprochen.

* Der Schlüssel (hier `"num_services_ok"`) ist der Metrikname und muss dem entsprechen, was die Check-Funktion ausgibt.
Wählen Sie einen eindeutigen Namen, so dass keine vorhandene Metrik „überschrieben“ wird.

* Der `title` ist die Überschrift im Metrikgraphen und ersetzt den bisher verwendeten internen Variablennamen.

* Welche Definitionen es für Einheiten (`unit`) gibt, erfahren Sie in der Datei `~/lib/check_mk/gui/plugins/metrics/unit.py`.

* Die Farbdefinition `color` verwendet eine Palette.
Zu jeder Palettenfarbe gibt es `/a` und `/b`.
Dies sind zwei Schattierungen der gleichen Farbe.
In den vorhandenen Metrikdefinitionen werden Sie auch viele direkte Farbkodierungen wie `"#ff8800"` finden.
Diese werden nach und nach abgeschafft und durch Palettenfarben ersetzt, da diese ein einheitlicheres Aussehen bieten und auch leichter an die Farbthemen der GUI angepasst werden können.

Diese Definition in der Metrikdatei sorgt jetzt dafür, dass Titel, Einheit und Farbe der Metrik angepasst dargestellt werden.

Analog zur Erstellung einer xref:test_ruleset[Regelsatzdatei] muss die Metrikdatei erst gelesen werden, bevor die Änderung in der GUI sichtbar ist.
Das macht der Neustart des Apache der Instanz:

[{shell}]
----
{c-omd} omd restart apache
----

Der Metrikgraph sieht dann in der {CMK}-GUI ungefähr so aus:

image::devel_cpi_new_metric.png[alt="Die neue Metrikdefinition in den Service-Details."]


[#graph_multiple_metrics]
=== Graph mit mehreren Metriken

Möchten Sie mehrere Metriken in einem Graphen kombinieren (was oft sehr sinnvoll ist), benötigen Sie eine Graphdefinition, die Sie der im vorherigen Abschnitt erstellten Metrikdatei hinzufügen können.
Dies geschieht über das globale Dictionary `graph_info`.

Für unser Beispiel sollen die beiden Metriken `num_services_ok` und `num_services` in einem Graphen dargestellt werden.
Die Metrikdefinitionen dazu sehen wie folgt aus:

.~/local/share/check_mk/web/plugins/metrics/myhostgroups_advanced_metrics.py
[{python}]
----
from cmk.gui.i18n import _

from cmk.gui.plugins.metrics import (
    metric_info,
    graph_info,
)

metric_info["num_services_ok"] = {
    "title": _("Services in OK status"),
    "unit": "count",
    "color": "15/a",
}

metric_info["num_services"] = {
    "title": _("Number of services"),
    "unit": "count",
    "color": "24/a",
}
----

Fügen Sie nun einen Graphen an, der diese beiden Metriken als Linien einzeichnet:

[{python}]
----
graph_info["num_services_combined"] = {
    "metrics": [
        ("num_services_ok", "line"),
        ("num_services", "line"),
    ],
}
----

Der erste Eintrag unter `metrics` legt fest, welche Metrik für den Titel des Graphen genommen wird. 
Das Resultat ist der kombinierte Graph in der {CMK}-GUI:

image::devel_cpi_graph_two_metrics.png[alt="Der Graph zeigt beide Metriken in den Service-Details."]


[#perfometer]
=== Metriken im Perf-O-Meter

Möchten Sie zu einer Metrik noch ein Perf-O-Meter in der Zeile der Service-Übersicht anzeigen?
Das könnte zum Beispiel so aussehen:

.Das Perf-O-Meter zeigt die absolute Zahl der Services
image::devel_cpi_perfometer_logarithmic.png[alt="Das Perf-O-Meter zeigt die Anzahl der Services im Status 'OK'."]

Um so ein Perf-O-Meter zu erstellen, benötigen Sie eine weitere Datei, diesmal im Verzeichnis `~/local/share/check_mk/web/plugins/perfometer`:

.~/local/share/check_mk/web/plugins/perfometer/myhostgroups_advanced_perfometer.py
[{python}]
----
from cmk.gui.plugins.metrics import perfometer_info

perfometer_info.append(
    {
        "type": "logarithmic",
        "metric": "num_services_ok",
        "half_value": 25,
        "exponent": 2.0,
    }
)
----

Perf-O-Meter sind etwas trickreicher als Graphen, da es keine Legende gibt.
Daher ist die Darstellung des Wertebereichs schwierig.
Da das Perf-O-Meter nicht wissen kann, welche Werte denn überhaupt möglich sind, und der Platz sehr begrenzt ist, verwenden viele eingebaute Check-Plugins eine logarithmische Darstellung.
Dies ist auch im obigen Beispiel der Fall:

* `type` wählt die Darstellungsform der Werte, hier die logarithmische Darstellung.

* `metric` bezeichnet den Namen der Metrik, hier die Anzahl der Services im Zustand {OK}.

* `half_value` ist der Messwert, welcher genau in der Mitte des Perf-O-Meters angezeigt wird. Bei einem Wert von `25` ist der Balken also halb gefüllt.

* `exponent` legt den Faktor fest, welcher notwendig ist, damit weitere 10{nbsp}% des Bereichs gefüllt werden.
Also würde im Beispiel ein Messwert von `50` den Balken bis 60{nbsp}% füllen, und einer von `100` bis 70{nbsp}%.

Der Vorteil dieser Methode:
Wenn Sie eine Liste von Services gleicher Art mit gleichartigen Perf-O-Metern ausstatten, können Sie die Perf-O-Meter untereinander optisch schnell vergleichen, da alle die gleiche Skala nutzen.
Und trotz der kleinen Darstellungsform können Sie sowohl bei sehr kleinen als auch bei sehr großen Werten die Unterschiede gut erkennen.
Dafür sind die Werte allerdings nicht maßstabsgetreu.

Das obige Perf-O-Meter zeigt zwar eine Metrik, aber nicht diejenige, die für den Zustand des Services verantwortlich ist.
Nicht die Anzahl der Services im Zustand {OK}, sondern ihr Prozentsatz bestimmt den Zustand des gezeigten Services der Host-Gruppe.

Um die Metrik des Prozentsatzes (`services_ok_perc`) darzustellen, können Sie ein lineares Perf-O-Meter verwenden.
Das ist immer dann sinnvoll, wenn es einen bekannten Maximalwert gibt.
Das sähe dann zum Beispiel in der Datei so aus:

.~/local/share/check_mk/web/plugins/perfometer/myhostgroups_advanced_perfometer.py
[{python}]
----
perfometer_info.append(
    {
        "type": "linear",
        "segments": ["services_ok_perc"],
        "total": 100.0,
    }
)
----

Und so in der GUI:

.Hier wird der Prozentsatz der Services dargestellt
image::devel_cpi_perfometer_linear.png[alt="Das Perf-O-Meter zeigt den Prozentsatz der Services im Status 'OK'."]

Das ist schon einmal eine Verbesserung.
Allerdings wird der Zustand des Services nicht nur durch den Prozentsatz der Services im Zustand {OK}, sondern auch durch den Prozentsatz der Hosts im Zustand {UP} bestimmt.
Um mehrere Metriken in einem Perf-O-Meter zu kombinieren, gibt es verschiedene Möglichkeiten.
Eine davon sieht so aus:

.~/local/share/check_mk/web/plugins/perfometer/myhostgroups_advanced_perfometer.py
[{python}]
----
perfometer_info.append(
    {
        "type": "dual",
        "perfometers": [
            {
                "type": "linear",
                "segments": ["hosts_up_perc"],
                "total": 100.0,
            },
            {
                "type": "linear",
                "segments": ["services_ok_perc"],
                "total": 100.0,
            },
        ],
    }
)
----

Dies sorgt dafür, dass sich die beiden Metriken den Balken des Perf-O-Meters teilen und nebeneinander angezeigt werden:

.Hier werden zwei Prozentsätze nebeneinander angezeigt
image::devel_cpi_perfometer_linear_combined.png[alt="Das Perf-O-Meter zeigt zwei Prozentsätze nebeneinander an."]

Auch zu diesem Thema finden Sie viele Beispiele in den von {CMK} ausgelieferten Check-Plugins -- in der Datei `~/lib/check_mk/gui/plugins/metrics/perfometers.py`.


[#format_numbers]
== Zahlen formatieren

Im [.guihint]#Summary# und den [.guihint]#Details# eines Services werden oft Zahlen ausgegeben.
Um Ihnen eine schöne und korrekte Formatierung möglichst einfach zu machen,
und auch um die Ausgaben von allen Check-Plugins zu vereinheitlichen, gibt es Hilfsfunktionen für die Darstellung von verschiedenen Arten von Größen.
All diese sind Unterfunktionen vom Modul `render` und werden folglich mit `render.` aufgerufen.
Zum Beispiel ergibt `render.bytes(2000)` den Text `1.95 KiB`.

All diesen Funktionen ist gemein, dass Sie ihren Wert in einer sogenannten _kanonischen_ oder natürlichen Einheit bekommen.
So muss man nie nachdenken und es gibt keine Schwierigkeiten oder Fehler bei der Umrechnung.
Beispielsweise werden Zeiten immer in Sekunden angegeben und Größen von Festplatten, Dateien etc. immer in Bytes und nicht in Kilobytes, Kibibytes, Blöcken oder sonstigem Durcheinander.

Verwenden Sie diese Funktionen auch dann, wenn Ihnen die Darstellung nicht so gut gefällt.
Immerhin ist diese dann für den Benutzer einheitlich.
Und zukünftige Versionen von {CMK} können die Darstellung möglicherweise ändern oder sogar konfigurierbar für den Benutzer machen, wie es zum Beispiel bereits bei der Anzeige der Temperatur der Fall ist.
Davon wird dann Ihr Check-Plugin auch profitieren.

Bevor Sie die `render`-Funktion in Ihrem Check-Plugin nutzen können, müssen Sie sie zusätzlich importieren:

[{python}]
----
from .agent_based_api.v1 import check_levels, Metric, register, render, Result, Service, State
----

Nach der ausführlichen Beschreibung aller Darstellungsfunktionen (Render-Funktionen) finden Sie eine xref:numbers_summary[Zusammenfassung] in Form einer übersichtlichen Tabelle.


=== Zeiten, Zeitspannen, Frequenzen

Absolute Zeitangaben (Zeitstempel) werden mit `render.date()` oder `render.datetime()` formatiert.
Die Angaben erfolgen immer als _Unix-Zeit,_ also in Sekunden ab dem 1. Januar 1970, 00:00:00 UTC -- dem Beginn der _Unix-Epoche._
Dies ist auch das Format, mit dem die Python-Funktion `time.time()` arbeitet.

Vorteil an dieser Darstellung ist, dass sich damit sehr einfach rechnen lässt, also zum Beispiel die Berechnung des Zeitraums, wenn Start- und Endzeit bekannt sind.
Die Formel ist dann einfach `duration = end - start`.
Und diese Berechnungen funktionieren unabhängig von der Zeitzone, Sommerzeitumstellungen oder Schaltjahren.

`render.date()` gibt nur das Datum aus, `render.datetime()` fügt noch die Uhrzeit hinzu.
Die Ausgabe erfolgt dabei gemäß der aktuellen Zeitzone desjenigen {CMK}-Servers, welcher den Check ausführt.
Beispiele:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.date(0)` |`Jan 01 1970`
|`render.datetime(0)` |`Jan 01 1970 01:00:00`
|`render.date(1700000000)` |`Nov 14 2023`
|`render.datetime(1700000000)` |`Nov 14 2023 23:13:20`
|===

Wundern Sie sich jetzt nicht, dass `render.date(0)` als Uhrzeit nicht `00:00`, sondern `01:00` ausgibt.
Das liegt daran, dass wir dieses Handbuch in der Zeitzone von Deutschland schreiben -- und die ist der Standardzeit UTC eine Stunde voraus (zumindest während der Normalzeit, denn der 1. Januar liegt ja bekanntlich nicht in der Sommerzeit).

Für Zeiträume (oder _Zeitspannen_) gibt es noch die Funktion `render.timespan()`.
Diese bekommt eine Dauer in Sekunden und gibt das menschenlesbar aus.
Bei größeren Zeitspannen werden Sekunden oder Minuten weggelassen.
Wenn Sie eine Zeitspanne in einem `TimeDelta`-Objekt vorliegen haben, lesen Sie aus diesem mit der Funktion `total_seconds()` die Zahl der Sekunden als Fließkommazahl aus.

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.timespan(1)` |`1 second`
|`render.timespan(123)` |`2 minutes 3 seconds`
|`render.timespan(12345)` |`3 hours 25 minutes`
|`render.timespan(1234567)` |`14 days 6 hours`
|===

Eine _Frequenz_ ist quasi der Kehrwert der Zeit.
Die kanonische Einheit ist _Hz_, was das gleiche bedeutet wie 1 / sec.
Einsatzgebiet ist zum Beispiel die Taktrate einer CPU:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.frequency(111222333444)` |`111 GHz`
|===


=== Bytes

Überall wo es um Arbeitsspeicher, Dateien, Festplatten, Dateisysteme und dergleichen geht, ist die kanonische Einheit das _Byte._
Da Computer so etwas meist in Zweierpotenzen organisieren, also zum Beispiel in Einheiten zu 512, 1024 oder 65 536 Bytes, hatte sich dabei von Beginn an eingebürgert,
dass ein _Kilobyte_ nicht 1000, und damit das Tausendfache der Einheit ist, sondern 1024 (2 hoch 10) Bytes.
Das ist zwar unlogisch, aber sehr praktisch, weil so meist runde Zahlen herauskommen.
Der legendäre Commodore C64 hatte eben 64 Kilobyte Speicher und nicht 65,536.

Leider kamen irgendwann Festplattenhersteller auf die Idee, die Größen ihrer Platten in 1000er-Einheiten anzugeben.
Da bei jeder Größenordnung der Unterschied zwischen 1000 und 1024 immerhin 2,4{nbsp}% ausmacht, und diese sich aufmultiplizieren,
wird so aus einer Platte der Größe 1 GB (1024 mal 1024 mal 1024) auf einmal 1,07 GB.
Das verkauft sich besser.

Diese lästige Verwirrung besteht bis heute und sorgt immer wieder für Fehler.
Als Linderung wurden von der internationalen elektrotechnischen Kommission (IEC) neue Präfixe auf Grundlage des Binärsystems festgelegt.
Demnach ist heute offiziell ein Kilobyte 1000 Bytes und ein _Kibibyte_ 1024 Bytes (2 hoch 10).
Außerdem soll man _Mebibyte,_ _Gibibyte_ und _Tebibyte_ sagen.
Die Abkürzungen lauten dann KiB, MiB, GiB und TiB.

{CMK} passt sich an diesen Standard an und hilft Ihnen mit mehreren angepassten Render-Funktionen dabei, dass Sie immer korrekte Ausgaben machen.
So gibt es speziell für Festplatten und Dateisysteme die Funktion `render.disksize()`, welche die Ausgabe in 1000er-Potenzen macht.

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.disksize(1000)` |`1.00 kB`
|`render.disksize(1024)` |`1.02 kB`
|`render.disksize(2000000)` |`2.00 MB`
|===

Bei der Größe von Dateien ist es oft üblich, die genaue Größe in Bytes _ohne Rundung_ anzugeben.
Dies hat den Vorteil, dass man so sehr schnell sehen kann, wenn sich eine Datei auch nur minimal geändert hat oder dass zwei Dateien (wahrscheinlich) gleich sind.
Hierfür ist die Funktion `render.filesize()` verantwortlich:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.filesize(1000)` |`1,000 B`
|`render.filesize(1024)` |`1,024 B`
|`render.filesize(2000000)` |`2,000,000 B`
|===

Wenn Sie eine Größe ausgeben möchten, die keine Festplatten- oder Dateigröße ist, dann verwenden Sie einfach das generische `render.bytes()`.
Hier bekommen Sie die Ausgabe in klassischen 1024er-Potenzen in der neuen offiziellen Schreibweise:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.bytes(1000)` |`1000 B`
|`render.bytes(1024)` |`1.00 KiB`
|`render.bytes(2000000)` |`1.91 MiB`
|===


=== Bandbreiten, Datenraten

Die Netzwerker haben ihre eigenen Begriffe und Arten, Dinge auszudrücken.
Und wie immer gibt sich {CMK} Mühe, in jeder Domäne die dort übliche Art zu kommunizieren, zu übernehmen.
Deswegen gibt es für Datenraten und Geschwindigkeiten gleich drei verschiedene Render-Funktionen.
Alle haben gemeinsam, dass die Raten in _Bytes pro Sekunde_ übergeben werden, selbst dann, wenn die Ausgabe in Bits erfolgt!

`render.nicspeed()` stellt die Maximalgeschwindigkeit einer Netzwerkkarte oder eines Switchports dar.
Da es keine Messwerte sind, muss auch nicht gerundet werden.
Obwohl kein Port einzelne Bits versenden kann, sind die Angaben aus historischen Gründen in Bits.

*Wichtig:* Trotzdem müssen Sie auch hier Bytes pro Sekunde übergeben!

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.nicspeed(12500000)` |`100 MBit/s`
|`render.nicspeed(100000000)` |`800 MBit/s`
|===

`render.networkbandwidth()` ist gedacht für eine tatsächlich gemessene Übertragungsgeschwindigkeit im Netzwerk.
Eingabewert ist wieder Bytes pro Sekunde:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.networkbandwidth(123)` |`984 Bit/s`
|`render.networkbandwidth(123456)` |`988 kBit/s`
|`render.networkbandwidth(123456789)` |`988 MBit/s`
|===

Wo es nicht ums Netzwerk geht und dennoch Datenraten ausgegeben werden, sind wieder Bytes üblich.
Prominentester Fall sind IO-Raten von Festplatten.
Dafür gibt es die Funktion `render.iobandwidth()`, die in {CMK} mit 1000er-Potenzen arbeitet:

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.iobandwidth(123)` |`123 B/s`
|`render.iobandwidth(123456)` |`123 kB/s`
|`render.iobandwidth(123456789)` |`123 MB/s`
|===


=== Prozentsätze

Die Funktion `render.percent()` stellt einen Prozentsatz dar -- auf zwei Nachkommastellen gerundet.
Sie ist insofern eine Ausnahme zu den anderen Funktionen, als hier nicht der eigentlich natürliche Wert -- also das Verhältnis -- übergeben wird, sondern wirklich die Prozentzahl.
Wenn also etwas zum Beispiel zur Hälfte voll ist, müssen Sie nicht `0.5` sondern `50` übergeben.

Weil es manchmal interessant sein kann zu wissen, ob ein Wert beinahe Null oder exakt Null ist, werden Werte durch Anfügen eines „<“ Zeichens markiert,
die größer als Null, aber kleiner als 0,01 sind.

[cols="50,~",options="header"]
|===
|Aufruf |Ausgabe 
|`render.percent(0.004)` |`<0.01%`
|`render.percent(18.5)` |`18.50%`
|`render.percent(123)` |`123.00%`
|===


[#numbers_summary]
=== Zusammenfassung

Hier folgt zum Abschluss die Übersicht über alle Render-Funktionen:

[cols="20,20,~,20",options="header"]
|===
|Funktion |Eingabe |Beschreibung |Beispielausgabe 
|`date()` |Unix-Zeit |Datum |`Nov 14 2023`
|`datetime()` |Unix-Zeit |Datum und Uhrzeit |`Nov 14 2023 23:13:20`
|`timespan()` |Sekunden |Dauer / Alter |`3 hours 25 minutes`
|`frequency()` |Hz |Frequenz (z. B. Taktrate) |`111 GHz`
|`disksize()` |Bytes |Größe einer Festplatte, Basis 1000 |`1,234 GB`
|`filesize()` |Bytes |Größe einer Datei, volle Genauigkeit |`1,334,560 B`
|`bytes()` |Bytes |Größe in Bytes, Basis 1024 |`23,4 KiB`
|`nicspeed()` |Bytes pro Sekunde |Geschwindigkeit von Netzwerkkarten |`100 MBit/s`
|`networkbandwidth()` |Bytes pro Sekunde |Übertragungsgeschwindigkeit |`23.50 GBit/s`
|`iobandwidth()` |Bytes pro Sekunde |IO-Bandbreiten |`124 MB/s`
|`percent()` |Prozentzahl |Prozentsatz, sinnvoll gerundet |`99.997%`
|===


[#errors]
== Fehler beheben

Die korrekte Behandlung von Fehlern nimmt (leider) einen großen Teil der Programmierarbeit ein.
Dabei ist die gute Nachricht, dass Ihnen die Check-API hinsichtlich der Fehlerbehandlung bereits viel Arbeit abnimmt.
Bei einigen Arten von Fehlern ist es daher richtig, diese gar nicht selbst zu behandeln.

Wenn Python in eine Situation kommt, die in irgendeiner Form _unerwartet_ ist, reagiert es mit einer sogenannten Ausnahme (_Exception_).
Hier sind ein paar Beispiele:

* Sie konvertieren mit `int()` einen String in eine Zahl, aber der String enthält keine Zahl, zum Beispiel `int("foo")`.
* Sie greifen mit `bar[4]` auf das fünfte Element von `bar` zu, aber das hat nur vier Elemente.
* Sie rufen eine Funktion auf, die es nicht gibt.

Um entscheiden zu können, wie Sie Fehler angehen, ist es zunächst wichtig, die exakte Stelle im Code zu kennen, an der ein Fehler auftritt.
Hierfür können Sie sowohl die GUI als auch die Kommandozeile verwenden -- je nachdem, wo Sie gerade arbeiten.


[#error_exception_gui]
=== Exceptions und Absturzberichte in der GUI

Tritt eine Exception im Monitoring oder während der Service-Erkennung im Setup auf, enthält das [.guihint]#Summary# Hinweise auf den eben erstellten Absturzbericht (_crash report_).
Das sieht dann zum Beispiel so aus:

image::devel_cpi_service_crash_report.png[alt="Ein Service, dessen Check-Plugin abgestürzt ist."]

Durch einen Klick auf das Icon icon:icon_crash[alt="Symbol für ein abgestürztes Check-Plugin."] wird eine Seite mit Details angezeigt, auf der Sie:

* die Datei angezeigt bekommen, in der der Absturz stattgefunden hat,
* alle Informationen über den Absturz erhalten, wie die Auflistung der aufgetretenen Fehler im Programm (_Traceback_), aktuelle Werte lokaler Variablen, Agentenausgabe und vieles mehr sowie
* den Report zu uns ({comfull}) als Feedback einsenden können.

Der Traceback hilft Ihnen als Programmierer zu entscheiden, ob ein Fehler im Programm vorliegt (beispielsweise der Aufruf einer nicht vorhandenen Funktion) oder Agentendaten vorliegen, die nicht wie erwartet verarbeitet werden konnten.
Im ersten Fall werden Sie den Fehler beheben wollen, im zweiten Fall ist es häufig sinnvoll, nichts zu tun.

Das Einsenden des Reports ist natürlich nur für Check-Plugins sinnvoll, die offiziell Teil von {CMK} sind.
Falls Sie eigene Plugins Dritten zugänglich machen, können Sie Ihre Anwender bitten, Ihnen die Daten zukommen zu lassen.


[#error_exception_cli]
=== Exceptions auf der Kommandozeile ansehen

Wenn Sie Ihr Check-Plugin auf der Kommandozeile ausführen, erhalten Sie keinen Hinweis auf die ID des erzeugten Absturzberichts.
Sie sehen nur die zusammengefasste Fehlermeldung:

[{shell}]
----
{c-omd} cmk --detect-plugins=myhostgroups_advanced localhost
Error in agent based plugin myhostgroups: invalid syntax (myhostgroups.py, line 11)
----

Hängen Sie die Option `--debug` als zusätzlichen Aufrufparameter an, dann bekommen Sie den Traceback des Python-Interpreters:

[{shell}]
----
{c-omd} cmk --debug --detect-plugins=myhostgroups_advanced localhost
Traceback (most recent call last):
  File "/omd/sites/mysite/bin/cmk", line 97, in <module>
    errors = config.load_all_agent_based_plugins(
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/omd/sites/mysite/lib/python3/cmk/base/config.py", line 1673, in load_all_agent_based_plugins
    errors = agent_based_register.load_all_plugins()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/omd/sites/mysite/lib/python3/cmk/base/api/agent_based/register/__init__.py", line 48, in load_all_plugins
    raise exception
  File "/omd/sites/mysite/lib/python3/cmk/utils/plugin_loader.py", line 49, in load_plugins_with_exceptions
    importlib.import_module(full_name)
  File "/omd/sites/mysite/lib/python3.11/importlib/__init__.py", line 126, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<frozen importlib._bootstrap>", line 1206, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1178, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1149, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 690, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 936, in exec_module
  File "<frozen importlib._bootstrap_external>", line 1074, in get_code
  File "<frozen importlib._bootstrap_external>", line 1004, in source_to_code
  File "<frozen importlib._bootstrap>", line 241, in _call_with_frames_removed
  File "/omd/sites/mysite/local/lib/python3/cmk/base/plugins/agent_based/myhostgroups.py", line 11
    parsed =
            ^
SyntaxError: invalid syntax
----

Tritt der Fehler beim Aufruf mit `--debug` beim nächsten Mal nicht mehr auf, zum Beispiel, weil eine neue Agentenausgabe bereitsteht, können Sie die letzten Absturzberichte auch im Dateisystem einsehen:

[{shell}]
----
{c-omd} ls -lhtr ~/var/check_mk/crashes/check/ | tail -n 5
drwx------ 1 mysite mysite 44 Sep  3 05:15 f47550fc-4a18-11ee-a46c-001617122312/
drwx------ 1 mysite mysite 44 Sep  3 05:17 38657652-4a19-11ee-a46c-001617122312/
drwx------ 1 mysite mysite 44 Sep  3 09:31 9e716690-4a3c-11ee-9eaf-001617122312/
drwx------ 1 mysite mysite 44 Sep  3 10:40 479b20ea-4a46-11ee-9eaf-001617122312/
drwx------ 1 mysite mysite 44 Sep  4 14:11 fdec3ef6-4b2c-11ee-9eaf-001617122312/
----

In jedem dieser Ordner liegen zwei Dateien:

. `crash.info` enthält ein Python-Dictionary mit Traceback und vielen weiteren Informationen. Oft genügt der Blick in die Datei mit dem Pager.
. `agent_output` enthält die vollständige Agentenausgabe, die zum Zeitpunkt des Absturzes aktuell war.

[#custom_debug]
=== Eigene Debug-Ausgabe

In den oben gezeigten Beispielen verwenden wir die Funktion `print()`, um für Sie als Entwickler den Inhalt von Variablen oder die Struktur von Objekten auszugeben.
Wir weisen zudem darauf hin, dass diese Debug-Ausgaben wieder entfernt werden müssen.

Alternativ zur Entfernung können Sie Ihre Debug-Ausgabe auch nur ausgeben lassen, wenn das Check-Plugin in der Konsole im Debug-Modus aufgerufen wird.
Dafür importieren Sie das Debug-Objekt aus der {CMK}-Werkzeugkiste und gegebenenfalls die Formatierungshilfe `pprint()`.
Sie können nun Debug-Ausgaben abhängig vom Wert des Debug-Objektes vornehmen:

[{python}]
----
from cmk.utils import debug

from pprint import pprint

def check_mystuff(section):
    if debug.enabled():
        pprint(section)
----

Beachten Sie, dass verbleibende Debug-Ausgaben sparsam verwendet und auf Hinweise beschränkt sein sollten, die den späteren Benutzern bei der Fehlersuche helfen.
Offensichtliche und abzusehende Fehler des Benutzers (zum Beispiel, dass die Inhalte der Agentensektion darauf hindeuten, dass das Agentenplugin falsch konfiguriert ist) sollten Sie mit dem Zustand {UNKNOWN} und aussagekräftigen Hinweisen im Summary beantworten.

[#error_invalid_agent]
=== Ungültige Agentenausgabe

Die Frage ist, wie Sie reagieren sollen, wenn die Ausgaben vom Agenten nicht die Form haben, die Sie eigentlich erwarten -- egal ob vom {CMK}-Agenten oder per xref:devel_check_plugins_snmp#[SNMP] erhalten.
Angenommen, Sie erwarten pro Zeile immer drei Worte.
Was sollen Sie tun, falls nur zwei kommen?

Nun, wenn das ein _erlaubtes und bekanntes_ Verhalten des Agenten ist, dann müssen Sie das natürlich abfangen und mit einer Fallunterscheidung arbeiten.
Falls das aber eigentlich nicht sein darf, dann tun Sie am besten so, als ob die Zeile immer aus drei Worten besteht, also zum Beispiel mit folgender Parse-Funktion:

[{python}]
----
def parse_foobar(string_table):
    for foo, bar, baz in string_table:
        # ...
----

Sollte jetzt mal eine Zeile dabei sein, die nicht aus genau drei Worten besteht, wird eine Exception erzeugt und Sie bekommen den gerade erwähnten sehr hilfreichen Absturzbericht.

Falls Sie auf Schlüssel in einem Dictionary zugreifen, die gelegentlich erwartbar fehlen, kann es natürlich sinnvoll sein, darauf entsprechend zu reagieren.
Das kann erfolgen, indem _Sie_ den Service auf {CRIT} oder {UNKNOWN} setzen und im Summary einen Hinweis auf die nicht auswertbare Agentenausgabe unterbringen.
In jedem Fall ist es besser, Sie verwenden hierfür die `get()`-Funktion des Dictionaries als die `KeyError` Exception abzufangen.
Denn `get()` liefert bei Nichtvorhandensein des Schlüssels ein Objekt vom Typ `None` oder einen optional als zweiten Parameter zu übergebenden Ersatz:

[{python}]
----
def check_foobar(section):
    foo = section.get("bar")
    if not foo:
        yield Result(state=State.CRIT, summary="Missing key in section: bar")
        return
    # ...
----

[#error_missing_item]
=== Fehlende Items

Was ist, wenn der Agent korrekte Daten ausgibt, aber das Item fehlt, das überprüft werden soll?
Also zum Beispiel auf diese Art:

[{python}]
----
def check_foobar(item, section):
    # Try to access the item as key in the section:
    foo = section.get(item)
    if foo:
        yield Result(state=State.OK, summary="Item found in monitoring data")
    # If foo is None, nothing is yielded here
----

Ist das gesuchte Item nicht dabei, so wird die Schleife durchlaufen und Python fällt am Ende der Funktion einfach hinten raus, ohne dass ein Resultat per `yield` zurückgegeben wurde.
Und das ist genau das Richtige!
Denn daran erkennt {CMK}, dass das zu überwachende Item fehlt und erzeugt mit {UNKNOWN} den richtigen Status und einen passenden Standardtext dazu.


[#error_spool]
=== Test mit Spool-Dateien

Wenn Sie bestimmte Agentenausgaben simulieren wollen, sind xref:spool_directory#[Spool-Dateien] sehr hilfreich.
Diese können Sie nutzen, um sonst schwer nachzustellende Grenzfälle zu testen.
Oder Sie verwenden direkt die Agentenausgabe, welche zu einem Absturzbericht geführt hat, zur Prüfung von Änderungen an einem Check-Plugin.

Deaktivieren Sie zunächst Ihr reguläres Agentenplugin, beispielsweise indem Sie ihm die Ausführungsberechtigung entziehen.
Erstellen Sie dann eine Datei im Verzeichnis `/var/lib/check_mk_agent/spool`, welche die von Ihrem Check-Plugin erwartete Agentensektion (oder _erwarteten Agentensektionen_) inclusive Sektions-Header enthält und auf Newline endet.
Beim nächsten Aufruf des Agenten wird dann der Inhalt der Spool-Datei statt der Ausgabe des Agentenplugins übertragen.


[#performance]
=== Alte Check-Plugins werden bei vielen Services langsam

Bei einigen Check-Plugins, die Items nutzen, ist es auf größeren Servern durchaus möglich, dass einige hundert Services erzeugt werden.
Wenn keine eigene Parse-Funktion verwendet wird, hat dies zur Folge, dass für jedes der hunderten Items die gesamte Liste von hunderten Zeilen durchlaufen werden muss.
Die zum Suchen benötigte Zeit steigt also im Quadrat mit der Zahl der Listenelemente, bei hunderten Services bedeutet das zigtausende Vergleiche.
Ist dagegen die geschachtelte Liste in ein Dictionary überführt, steigt der Aufwand für die Suche eines Elements nur linear mit der Größe des Dictionaries. 

Im Python-Wiki finden Sie eine link:https://wiki.python.org/moin/TimeComplexity[Übersicht der Kosten^] für die Suche in verschiedenen Datentypen, inklusive Erläuterung und _O-Notation._
Mit der Parse-Funktion reduzieren die Komplexität der Suche von _O(n)_ auf _O(1)_.

Da ältere Versionen dieses Artikels keinen Gebrauch von der Parse-Funktion gemacht haben, sollten Sie derartige Check-Plugins identifizieren und diese auf Verwendung einer Parse-Funktion umschreiben.


[#files]
== Dateien und Verzeichnisse

[cols="45,~",options="header"]
|===
|Pfad |Bedeutung
|`~/local/lib/check_mk/base/plugins/agent_based/` |Ablageort für selbst geschriebene Check-Plugins.
|`~/local/share/check_mk/web/plugins/wato/` |Ablageort für Ihre Regelsätze für Check-Parameter.
|`~/local/share/check_mk/web/plugins/metrics/` |Ablageort für eigene Metrikdefinitionen.
|`~/local/share/check_mk/web/plugins/perfometer/` |Ablageort für eigene Definitionen von Perf-O-Metern.
|`~/lib/check_mk/gui/plugins/wato/check_parameters/` |Hier finden Sie die Regelsatzdefinitionen von allen mitgelieferten Check-Plugins von {CMK}.
|`~/lib/check_mk/gui/plugins/wato/utils/pass:[__init__].py` |In dieser Datei sind die Gruppen der Setup-Oberfläche definiert, in welchen Sie neue Regelsätze ablegen können.
|`~/lib/check_mk/gui/plugins/metrics/`  |Hier finden Sie die Metrikdefinitionen der mitgelieferten Plugins.
|`~/lib/check_mk/gui/plugins/metrics/unit.py`  |In dieser Datei stehen die vordefinierten Einheiten für Metriken.
|`/usr/lib/check_mk_agent/plugins/` |Dieses Verzeichnis bezieht sich auf einen überwachten Linux-Host. Hier erwartet der {CMK}-Agent für Linux Erweiterungen des Agenten (Agentenplugins).
|===
////
// end translation
