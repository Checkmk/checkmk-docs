include::global_attr.adoc[]
= The HW/SW Inventory
:revdate: 2021-12-08
:title: The HW/SW Inventory
:description: Use the HW/SW Inventory to identify the hardware equipment, installed software and more on the hosts monitored by {CMK}.

{related-start}
xref:agent_linux#[Monitoring Linux]
xref:agent_windows#[Monitoring Windows]
{related-end}


[#intro]
== Introduction

In addition to the conventional monitoring -- i.e. the monitoring of status, log and measurement data -- {CMK} includes another completely different function virtually free of charge:
the _Hardware/Software Inventory_ (or _HW/SW Inventory_ for short).
This can automatically identify elements on your hosts, such as, for example:

* Which software packages -- and which versions of these -- are installed on a server?
* What kind of RAM components does a server have?
* Which BIOS version is installed on the motherboard?
* The serial numbers of the installed hard disks.
* Whether any ports on a switch not been used for a while (and which are thus probably free)?
* ... and much more

The data obtained in this way are displayed per host in a structured tree, and in various other xref:views#[views], and are also available via an API.
Here is a small example with CPU data:

.CPU data in the inventory path [.guihint]#hardware.cpu#
image::inventory_example_main.png[alt="Expanded inventory with CPU data."]

With the Hardware/Software Inventory you can perform a variety of tasks, such as:

* Provide data on installed software for a license management system
* Determine type designations for spare parts orders (RAM, hard disks, fans)
* Provide general hardware and software data for regular import into CMDBs, so that these are based on current data
* Track changes to hardware or software, e.g., to determine when a specific BIOS update was performed
* Be informed if something has changed in the hardware or software
* To identify servers that have not yet had a specific service pack installed

The most important advantage over other comparable systems is obvious -- you can simply utilise {CMK}'s existing infrastructure and save yourself the effort of rolling out and administering another software environment.
You just roll out a single additional agent plug-in.
This is not even necessary with SNMP devices because the inventory scanner also supports SNMP and simply fetches the data over this route.

And besides, {CMK} does not need to hide behind other inventory scanners.
As with our check plug-ins, we are constantly working to expand the data scanning.
Each {CMK} version brings new plug-ins for the inventory scanner, and the information that can be collected is becoming more detailed and extensive.


[#config]
== Installation

Installing the HW/SW Inventory is performed in two steps.
The prerequisite is that the {CMK} agent has already been installed on the hosts (if these are not being monitored via SNMP):

. Switch on inventory for the desired hosts
. Roll out the inventory agent plug-in on these hosts


[#activate]
=== Activating the inventory for the desired hosts


==== Creating the rule

As always, if you want to configure something for specific hosts this is also possible with the help of a xref:wato_rules#[rule].
This rule set can be found under [.guihint]#Setup > Hosts > HW/SW inventory rules > Do hardware/software inventory.#
Of course it is even easier using the rule search with the word `inventory`.
Do not confuse this with the [.guihint]#Hardware/Software-Inventory (Linux, Windows, Solaris, AIX)# rule set which is for the xref:inventory_plugin[agent plug-in], as weâ€™ll see later.

In the [.guihint]#Do hardware/software inventory# rule set, some rules that refer to host xref:labels#[labels] are already active by default. 
If the hosts you want have such a label, the service for HW/SW inventory is already set up.
If not, you need to create a new rule. 

Create a new rule for the hosts for which you want to activate the inventory.
There you will find several settings:

.By default, all options are disabled and are not required
image::inventory_do_inventory_default.png[alt="Dialog for inventory options."]

For now simply leave everything as preset.
The various options that you will see here are discussed below.

At the next xref:wato#activate_changes[activation of changes] the rule you have just created will, for each host, generate an xref:active_checks#[active check] that collects all of the inventory data for that host -- be it from the data that is received from a normal {CMK} agent, or through additional SNMP queries.
The new service [.guihint]#Check_MK HW/SW Inventory# can be found on the hosts in the service list, and it will look something like this:

.Without agent plug-in only some default entries are reported
image::inventory_list_first_item.png[alt="Status display of a fresh inventory service."]

Please do not be concerned that the check found only a few items -- this is because we have not rolled out the plug-in yet.


==== Defining the interval

Inventory data is something that rarely changes, and recognizing a change is usually not time-critical anyway.
Because of this it makes sense to use an adjusted interval during which the inventory check is performed rather than simply
using the usual one-minute interval -- mainly because the processing of the inventory data in the active check requires significantly more computing time than that for a normal service.

{CMK} sites _as standard_ have a rule in the [.guihint]#Setup > Service monitoring rules > Service Checks > Normal check interval for service checks# rule set which sets the interval to one day for all services with the name [.guihint]#Check_MK HW/SW Inventory#:

.A daily inventory is sufficient in practice, for testing purposes shorter periods are suitable.
image::inventory_interval.png[alt="The rule for setting the interval."]

Of course if you find once a day insufficient, you can also customize this rule -- e.g., to four or eight hours.
Naturally there is also always the option of setting it differently using multiple rules for different hosts.


[#inventory_plugin]
=== Rolling out the inventory agent plug-in on these hosts

The most important step is to install the agent plug-in for the inventory on the relevant hosts.
You can do this either manually or with the xref:wato_monitoringagents#bakery[Agent Bakery] (only {EE}).


==== Manual installation

For a manual installation you first need the plug-in.
This can be found in the {EE} via [.guihint]#Setup > Agents > Windows, Linux, Solaris, AIX > Related# page, and in the {RE} directly under [.guihint]#Setup > Agents.#
In all editions, there you will find menu entries for the various operating systems.
Depending on the operating system, use the following plug-in in the [.guihint]#Plugins# box:

[cols="50,~"]
|===
|Operating system |Plug-in 

|Windows |`mk_inventory.vbs`
|Linux |`mk_inventory.linux`
|AIX |`mk_inventory.aix`
|Solaris |`mk_inventory.solaris`
|===

You can also find these files on the command line in the {CMK} site in the
`share/check_mk/agents/plugins` (Linux/Unix) subdirectory, or in `share/check_mk/agents/windows/plugins` (Windows).

Copy the plug-in to the destination hosts in the correct directory for plug-ins.
For the Windows agent it is `C:\ProgramData\checkmk\agent\plugins`.
For details see the xref:agent_windows#plugins[Windows agent article].

For Linux and Unix the directory is `/usr/lib/check_mk_agent/plugins`.
Please make sure that the file is executable (`chmod +x`).
For details see the xref:agent_linux#plugins[Linux agent articles].

The important thing is that the agent is called by {CMK}, usually once a minute.
The inventory agent plug-in, however, requires more processing time than normal plug-ins because, for example, it must search for installed software in many directories.
It also generates significantly larger amounts of data.
This is why it has been designed to only generate and deliver new data every four hours (14400 seconds).

So if for some important reason you have specified a _shorter_ interval than four hours for your inventory check, you will only actually get new data every four hours.
If you really want to collect more data, in such a case you will need to alter the default calculation interval.

For Windows replace the number directly in the plug-in file.
Search for the number`14400` and replace it with a different number of seconds.
The location where this is found looks like this (detail):

.mk_inventury.vbs
[{file}]
----
Dim delay
Dim exePaths
Dim regPaths

'These three lines are set in the agent bakery
delay = 14400
exePaths = Array("")
regPaths =
Array("Software\Microsoft\Windows\CurrentVersion\Uninstall","Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall")
----

With Linux and Unix this works a bit differently.
For this purpose create a configuration file `/etc/check_mk/mk_inventory.cfg` with the following line (here in the example with 7200 seconds):

./etc/check_mk/mk_inventury.cfg
[{file}]
----
INVENTORY_INTERVAL=7200
----

One more note:
The inventory agent plug-in _itself_ dictates that it runs only every four hours.
Therefore *do not use* the mechanism from the agent for asynchronously running plug-ins at longer intervals.
Install the plug-in in the simple, usual way for direct execution.


==== Configuration using the Agent Bakery

{cee-only}
Of course if you use the xref:wato_monitoringagents#bakery[Agent Bakery] to configure your agents, things are much more straightforward.
There is only one rule set named [.guihint]#Hardware/Software-Inventory (Linux, Windows, Solaris, AIX)# independent of the operating system.
This rule set controls the rolling-out of the necessary plug-in as well as its configuration.
It can be found at [.guihint]#Setup > Agents > Windows, Linux, Solaris, AIX > Agents > Agent rules#:

.You can include portable programs directly via directories
image::inventory_agent_rule.png[alt="Input mask with options for the inventory agent plug-in."]

For Windows, in addition to the interval you can also specify paths in which to search for executable `.EXE` files when it comes to finding the software installed on the system.
You can also configure the paths in the Windows registry, which should be taken into account as an indicator for installed software.


=== Testing

If you have rolled out the plug-in correctly, you should find significantly more records the next time you run the hostâ€™s inventory check.
The result will then look like this:

.You will find so few entries only on freshly set up systems
image::inventory_list_entries.png[alt="Status display of an inventory service with a running agent plug-in."]


[#operating]
== Working with the inventory data

Inventory data is of course available for each individual host, partly as a tree and partly as a table representation.
How exactly these work and how you can access them is shown below.
However, there are also views, especially searches, that affect your entire host landscape.
You can access these via the [.guihint]#Inventory# entry in the [.guihint]#Monitor# menu:

.Global views of the inventory data
image::inventory_monitor_menu.png[alt="Inventory entries in the Monitor menu."]


=== Tree-structured display

The hostsâ€™ inventory data is displayed on the one hand in a tree-structured display per host, and on the other hand in table-form.
You can open the tree diagram, for example, in a host view via the menu item [.guihint]#Host > Inventory > Inventory of host.#

Alternatively, in views that list hosts, you can invoke the icon:icon_menu[] menu of a host and in turn invoke the icon:icon_inventory[] inventory from it:

.Inventory access from a list of hosts
image::inventory_host_contextmenu.png[alt="Context menu for viewing the inventory of a host."]

In both cases you end up with the tree view of the hostâ€™s inventory data.
Starting from the three basic categories icon:icon_hardware[] [.guihint]#Hardware#, icon:icon_networking[] [.guihint]#Networking# and icon:icon_software[] [.guihint]#Software#, you can expand and collapse the treeâ€™s sub-branches:

[#internal_paths]
.A very small part of the inventory tree 
image::inventory_example_main.png[alt="Expanded inventory with CPU information."]

In the image above you can see behind the individual entries the internal paths in brackets, which you can display using [.guihint]#Display > Modify display options# and the [.guihint]#Show internal tree paths# option:

image::inventory_show_internal_paths.png[alt="Option for displaying inventory paths."]

You will then see the internal designations in the inventory, so for example the internal path for the [.guihint]#Processor# section is called [.guihint]#hardware.cpu#.
The designations for the CPU model and architecture -- [.guihint]#model# and [.guihint]#arch# -- can be found below in the CPU data.

You can use these internal designations to enable only individual paths xref:wato_user#visibility[for contact groups].
Users of a contact group assigned only the hardware.cpu, model and arch entries shown above will then see only a trimmed-down inventory:

image::inventory_restricted_internal_path.png[alt="Inventory with selected records."]


=== Tabular displays

Many of the inventory data are individual values under very specific paths in the tree, e.g. the [.guihint]#Hardware > System > Manufacturer > Apple Inc.# entry.
But there are also places in the tree with tables of similar objects.
A very important one is, for instance, the [.guihint]#icon:icon_software[] Software > icon:icon_packages[] Packages# table:

.The package list is very detailed and heavily cropped here in the picture
image::inventory_packages.png[alt="Software packages in the inventory tree."]

The special thing about this part of the inventory data is that you can call the packages in a separate view via [.guihint]#Host > Inventory > Software packages#. 
There you will then find icon:icon_filter[] filters specifically for searching in packages (heavily shortened in the image):

.The filter for the host name is already prefilled
image::inventory_packages_search.png[alt="Filter list for software packages."]

You can also search in software packages on multiple hosts.
The corresponding view can be found in the xref:user_interface#monitor_menu[Monitor] menu under [.guihint]#Monitor > Inventory > Search Software packages# or in the [.guihint]#Views# snap-in of the xref:user_interface#sidebar[sidebar] under [.guihint]#Inventory.# 
All other table views for the inventory are also listed there, including further searches, for example for specific Oracle data.

Please note that many general filters to the hosts are not available by default in the views.
These are obtained when you edit the view and add additional host filters.

Further things you can do with the views:

* Include them in xref:reporting#[reports]
* Export them as PDF or as CSV
* Integrate them with xref:dashboards#[dashboards]

Incidentally, you can also include such inventory data in views that are _not_ table-like.
There is a column type for each well-known path in the inventory tree, which you can add to views of hosts.
An example of this is the predefined example view [.guihint]#CPU inventory of all hosts#.
This is a table of hosts that displays additional data from the inventory per host.
Here is an example of one of the column definitions that adds a column to the table of the number of physical CPUs in the host:

.Inventory data is available to all views
image::inventory_cpus.png[alt="Dialog for including columns with inventory data in views."]


[#history]
== Inventory data history

Once you have set up the HW/SW inventory for a host, {CMK} will record every change in the inventory data and also store its history.
You can find these in views with inventory data via [.guihint]#Host > Inventory > Inventory history of host.#

Here is an excerpt from a history.
In the table you can see some IP data that has changed since the last check:

.Changes in the inventory are immediately visible in the history
image::inventory_history.png[alt="History of entries in the inventory."]

If you wish, you can be informed whenever a change occurs in the software or hardware.
This is done via the status of the service [.guihint]#Check_MK HW/SW Inventory#.
To do this edit the rule that you created at the very beginning of this article (in the [.guihint]#Do hardware/software inventory# rule set).
There, for the value of the rule you will find a number of settings that affect the history.
The following example sets up the service {WARN} if changes occur in software or hardware:

.A good way to become aware of shadow IT on workstations
image::inventory_do_inventory_warn.png[alt="Dialog for state change of the inventory check."]

The next time the inventory check detects changes, it will go to {WARN}.
It will then look like this:

.Warnings in the service list of a single host
image::inventory_list_warn.png[alt="Inventory check with warning about detected changes."]

At the next execution of the check, and if in the meantime nothing has changed, this resets automatically to {OK}.
By manually triggering the execution you also have a way to manually reset the service to {OK} if you do not want to wait for the next normal periodic execution.


[#statusdata]
== Status data

The tree of inventory data can be automatically updated with the latest suitable status data.
This is very useful in some cases.
An example of this is the _Oracle tablespaces._
The actual inventory data contains only relatively static info such as the SID, the name and the type.
Current status data can supplement this with information on the current size, free space, etc.

If you want to see status data in your tree (and there's nothing wrong with that), you only have to activate activate the corresponding option in the rule that you created xref:activate[at the beginning] under [.guihint]#Do hardware/software inventory#:

.Status data expand monitoring, in some cases considerably
image::inventory_do_inventory_status.png[alt="Dialog for activating the status data."]

By the way, a change in the status data will _not_ precipitate changes in the xref:inventory#history[history]!
This would almost always lead to constant changes and render this function useless.
xref:inventory#statusdata[Status data] are not stored in files, but like the results of checks are held directly in the main memory of the monitoring kernel.


[#external]
== External access to the data

=== Access via special Web-API

You can export the hostâ€™s HW/SW inventory data via an inventory web API.
The URL for this is `host_inv_api.py?host=` followed by the host name.
Example:

`\http://mycmkserver01/mysite/check_mk/host_inv_api.py?host=myhost123`

The output format in this case is Python source code.
If you prefer JSON, just append a `&output_format=json` to it:

`\http://mycmkserver01/mysite/check_mk/host_inv_api.py?host=myhost123&output_format=json`

The result will look something like this:

.myhost123.json
[{file}]
----
{
    "result": {
        "hardware": {
            "chassis": {
                "manufacturer": "Apple Inc.",
                "type": "Notebook"
            },
            "cpu": {
                "arch": "x86_64",
                "cache_size": 6291456,
                "cores": 4,
                "cores_per_cpu": 4,
                "cpus": 1,
                "max_speed": 2500000000.0,
                "model": "Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz",
                "threads": 8,
                "threads_per_cpu": 8,
                "vendor": "intel",
                "voltage": 1.1
            },
... usw...

    },
    "result_code": 0
}
----

If you enter the URL in the line of your browser, this will work immediately because you are already logged in to {CMK} there.
From a script the best way to authenticate is as an xref:wato_user#automation[automation user].


=== Access via a file

Alternatively, you can simply read the files that {CMK} generates itself.
These files are in python format and are located in the `var/check_mk/inventory` directory.
For each host there is a file in an uncompressed version (for example, `myhost123`), and a compressed version (for example, `myhost123.gz`).

////
[#external]
== Externer Zugriff auf die Daten

=== Zugriff via eigener Web-API

Sie kÃ¶nnen die HW/SW-Inventurdaten eines Hosts Ã¼ber eine Inventur-eigene Web-API exportieren.

*Hinweis:* Die hier erwÃ¤hnte Web-API ist *nicht* die (abgekÃ¼ndigte) {CMK} Web-API. Diese Inventur-eigene Web-API ist von der AbkÃ¼ndigung nicht betroffen.

Die URL dazu lautet

`\http://myserver/mysite/check_mk/host_inv_api.py?host=myhost`

Das Ausgabeformat in diesem Fall ist Python-Quellcode. Wenn Sie JSON bevorzugen, dann hÃ¤ngen Sie ein `&output_format=json` an die URL an:

`\http://myserver/mysite/check_mk/host_inv_api.py?host=myhost&output_format=json`

Das Ergebnis sieht in gekÃ¼rzter Form etwa so aus:

.myhost.json
[{file}]
----
result: 
    Attributes: {}
    Nodes:
        hardware:
            Attributes: {}
            Nodes:
                memory:
                    Attributes:
                        Pairs: 
                            total_ram_usable: 16495783936
                            total_swap: 1027600384
                            total_vmalloc: 35184372087808
                        Nodes: {}
                        Table: {}
                Table: {}
 ... usw. ...
result_code: 0
----

Analog kÃ¶nnen Sie die Ausgabe auch in XML anfordern:

`\http://myserver/mysite/check_mk/host_inv_api.py?host=myhost&output_format=xml`

Geben Sie die jeweilige URL in die Adressleiste Ihres Browsers ein, sehen Sie sofort ein Ergebnis, weil Sie bereits bei {CMK} angemeldet sind.
Die HW/SW-Inventurdaten finden Sie in der Ausgabedatei im Abschnitt nach dem SchlÃ¼ssel _result_.
Von einem Skript aus authentifizieren Sie sich am besten als xref:wato_user#automation[Automationsbenutzer.]

Im Fehlerfall, z. B. wenn der angegebene Host nicht gefunden wurde, wird der _result code_ auf 1 gesetzt und eine entsprechende Fehlermeldung ausgegeben:

`{"result": "Found no inventory data for this host.", "result_code": 1}`

//SP: Ergebnis der Raw Edition. Bei der Enterprise Edition bekomme ich stattdessen leere Angaben mit einem Fehlercode 0. 

==== Mehrere Hosts abfragen

Sie kÃ¶nnen auch die HW/SW-Inventurdaten mehrerer Hosts in einer Ausgabe abfragen. Erweitern Sie dafÃ¼r die Abfrage auf alle gewÃ¼nschten Hosts:

`\http://myserver/mysite/check_mk/host_inv_api.py?request={"hosts": ["myhost", "myhost2"]}&output_format=json`

Das Ergebnis dieser Abfrage sieht dann fast genauso aus wie die obige Ausgabe. Auf der obersten Ebene werden jedoch die Namen der Hosts als SchlÃ¼ssel verwendet. Die Angaben zu den Hosts folgen dann darunter in den VerzeichnisbÃ¤umen:

[{file},highlight=2;25]
----
result:
    myhost:
        Attributes: {}
        Nodes:
            hardware:
                Attributes: {}
                Nodes:
                    memory:
                        Attributes:
                            Pairs:
                                total_ram_usable: 16495783936
                                total_swap: 1027600384
                                total_vmalloc: 35184372087808
                            Nodes: {}
                            Table: {}
                    Table:
            networking:
                Attributes:
                    Pairs:
                        available_ethernet_ports: 1
                        hostname: "MyServer"
                        total_ethernet_ports: 3
                        total_interfaces: 4
... usw. ...                          
    myhost2:
        Attributes: {}
        Nodes: {}
        Table: {}
result_code: 0
----

Werden zu einem Host keine Inventurdaten gefunden, dann hat der Host einen leeren Inventureintrag anstelle der Fehlermeldung.

==== Abfrage auf spezifische Daten einschrÃ¤nken

Nun wollen Sie aber vielleicht nicht alle Inventurdaten abfragen, sondern suchen nur gezielt nach einzelnen Informationen. Dann geben Sie sogenannte xref:internal_paths[_Inventurpfade_] an, um die gewÃ¼nschten Angaben zu definieren. Sie bekommen dann nur von denjenigen Hosts Informationen angezeigt, die diese Pfade / Informationen haben.

Um zum Beispiel fÃ¼r Ihren Host nur die Angaben zu Gesamtspeicher und Auslagerungsspeicher zu sehen, verwenden Sie diese URL:

`\http://myserver/mysite/check_mk/host_inv_api.py?host=myhost&request={"paths":[".hardware.memory.total_ram_usable", ".hardware.memory.total_swap"]}&output_format=json`

Sie bekommen die gewÃ¼nschten Angaben zurÃ¼ck:

[{file}]
----
result: 
    Attributes: {}
    Nodes:
        hardware:
            Attributes: {}
            Nodes:
                memory:
                    Attributes:
                        Pairs:
                            total_ram_usable: 16495783936
                            total_swap: 1027600384
                        Nodes: {}
                        Table: {}
                Table: {}
        Table: {}
result_code: 0
----


=== Zugriff via Datei

Alternativ kÃ¶nnen Sie auch einfach die Dateien auslesen, die {CMK} selbst erzeugt.
Diese liegen im Python-Format im Verzeichnis `var/check_mk/inventory` vor.
FÃ¼r jeden Host gibt es dort eine Datei in unkomprimierter (z.B. `myhost`) und eine in komprimierter Variante (z.B. `myhost.gz`).
////

[#distributed]
== Inventory in distributed environments

{cee-only}
In the {EE} HW/SW Inventory also works in xref:distributed_monitoring#[distributed environments].
Here the inventory data are first determined by the local sites and stored locally under `var/check_mk/inventory`. 

The xref:distributed_monitoring#livestatusproxy[Livestatus proxy daemon] will periodically transfer all updated inventory data from the remote site to the central site, and also store it under `var/check_mk/inventory`.
This is important because this data is too large to pick up live when queried at this moment.

As soon as the central site makes queries about inventory data, these files are read and then merged with current status data, which is then retrieved from the remote sites via xref:livestatus#[Livestatus].

In short -- you do not have to worry about anything.

{cre-only}
There is no Livestatus proxy in the {RE} -- therefore the HW/SW inventory is incomplete in the central site's GUI and shows only the status data.
You can aid yourself by transferring the files in the `var/check_mk/inventory` directory to the central site regularly with a script or similar.
It is sufficient to copy the files _without_ the `.gz` file extension.
For efficient data transmission `rsync`, for example, is suitable.


== Files and directories

=== Directories on the {CMK} server

[cols="45,~",options="header"]
|===
|Path |Description 
|`share/check_mk/agents/plugins/` |Agent plug-ins for Linux and Unix
|`share/check_mk/agents/windows/plugins/` |Agent plug-ins for Windows
|`var/check_mk/inventory/` |Inventory data from individual hosts as Python files (compressed and uncompressed)
|===


=== Directories on the monitored hosts

[cols="45,~",options="header"]
|===
|Path |Description 
|`C:\ProgramData\checkmk\agent\plugins\` |Storage location for the Windows agentâ€™s inventory plug-in
|`/usr/lib/check_mk_agent/plugins/` |Storage location for the inventory plug-in for the Linux/Unix agent
|`/etc/check_mk/mk_inventory.cfg` |Configuration for the inventory plug-in for the Linux/Unix agent
|===

