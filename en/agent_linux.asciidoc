include::global_attr.adoc[]
= Monitoring Linux
:revdate: draft
:title: Monitoring Linux - The new agent for Linux in detail
:description: The Linux agent of {CMK} version 2.1.0 adds the Agent Controller and new features to the agent script. You can learn how to use the agent here.

{related-start}
xref:agent_linux_legacy#[Monitoring Linux in legacy mode]
xref:wato_monitoringagents#[Monitoring agents]
xref:agent_deployment#[Automatic Agent Updates]
{related-end}


////
Hints for translation:
At the beginning of this article, their is an (outdated) Deepl translated text, that will be displayed for our readers as long as you are not finished.
You can delete it right away.
The German text to be translated is commented out at the end of this file (starting at line 1075.
////


_In order to quickly provide you the new information for {CMK} version {v21}, we have had this draft machine translated for now. Update and language revision will follow later._


[#intro]
== The new agent

[{image-left}]
image::linux.png[alt="Linux-Logo.",width=120]
You can monitor Linux systems particularly well with {CMK}.
This is not so much because the {CMK} development team feels "at home" on Linux, but rather because Linux is a very open system and provides numerous well documented and easy to query interfaces for detailed monitoring.

Since most of the interfaces per se are not accessible via the network, the installation of a monitoring agent is inevitable.
Therefore {CMK} has its own agent for monitoring Linux. 
This is a simple shell script that is minimalistic, transparent and secure.

In the {CMK} version {v21} there is now a new Linux agent.
More precisely, the *Agent Script* `check_mk_agent` is joined by a new component: the *Agent Controller*.
The Agent Controller precedes the agent script, queries it and communicates with the {CMK} server in its place.
To do this, it registers with the *Agent Receiver*, which is also a new process running on the {CMK} server.

The new Linux agent thus on the one hand takes over the agent script, and thus its advantages.
On the other hand, it supplements the script in such a way that new functions can be added, such as TLS encryption of the communication, data compression -- and also reversal of the communication direction.
This means that in addition to the registered, encrypted and compressed *pull mode*, an equally *push mode* is possible.
More about this in the next chapter.

While push mode will be a feature of the next {CMK} version for the new {CMK} Plus Edition (CPE), TLS encryption and compression will be available for all {CMK} editions starting with version {v21} -- as long as both {CMK} server and agent have version {v21}.

The Agent Controller is started as a background process (_daemon_) by the init system `systemd`, so the agent requires a Linux distribution with `systemd`.
How to find out if the prerequisite is fulfilled for your Linux distribution can be found in the chapter xref:install[Installation.]

However, the new agent also supports a so-called *legacy mode* to be executable under Linux distributions without `systemd`.
In this mode the new agent works like the old one, i.e. without Agent Controller and therefore without registration at the {CMK} server.
For this case you can find all information in the article xref:agent_linux_legacy#[Monitor Linux in Legacy Mode].
There you will also learn how to set up the agent on Linux systems where neither an RPM nor a DEB package can be installed.

The article you are reading covers installation, configuration and extensions of the new Linux agent *with* Agent Controller.


[#architecture]
== Architecture of the agent

With the new agent, more software components are involved in communication than before.
Therefore, we briefly introduce the components and their interaction.
The architecture is identical for the Linux agent and the xref:agent_windows#agent_architecture[Windows agent].
Only the technical implementation is specific to the operating systems.

.Interaction of the software components
[{image-border}]
image::agent_linux_communication_flow.png[alt="Illustration of the communication between agent and site."]

The *Agent Script* `check_mk_agent` is and remains responsible for collecting the monitoring data.
For data collection, it calls existing system commands in order.
To also obtain those information that require `root` privileges to obtain, `check_mk_agent` is executed under `root`.

The agent script is:

* minimalist, because it makes do with minimal resources of RAM, CPU, disk space and network.
* secure, because it does not allow any access from the network.
* easily extensible, because you can write plug-ins in any programming or scripting language and have them executed by the agent script.
* transparent, because it is a shell script where you can see what commands it calls.

The *Agent Controller* `cmk-agent-ctl` is the new component of the agent and is responsible for transporting the data collected by the agent script.
It is run under the `cmk-agent` user, which has limited privileges, e.g. no login shell, and is used only for data transfer.
The `cmk-agent` user is created during the installation of the agent package.
The Agent Controller is started as a daemon of `systemd` and is coupled to it as a service.
It listens on TCP port 6556 for incoming connections of the {CMK} site and queries the agent script via a Unix socket (a `systemd` unit).

So why is the Agent Controller needed -- so far it worked very well without it?
Well, the new software architecture of the agent is the prerequisite for offering new features that cannot be implemented with the minimalistic design of the agent script, such as encryption of the communication via Transport Layer Security (TLS), data compression and reversal of the communication direction.
Previously, it was always the {CMK} server that initiated the communication and requested the data from the agent -- in what is known as pull mode.

With the Agent Controller, the push mode can now additionally be realized, in which the initiative comes from the agent.
Push mode is required for cloud-based configuration and in some compartmentalized networks.
In both cases, the {CMK} server cannot access the network where the hosts to be monitored are located.
Therefore, the agent periodically sends the data to the {CMK} server on its own.
Agent Controller and Agent Receiver are already prepared for push mode, although this mode will be available only with the next {CMK} version for the new {CMK} Plus Edition (CPE).

The *Agent Receiver* `agent-receiver` is a new component of the {CMK} server and the general endpoint for the Agent Controller communication, e.g. for connection registration.It also receives the data sent by the Agent Controller in push mode.
In pull mode, data is exchanged with the xref:cmc_differences.html#fetcher_checker[{CMK} fetchers] of the site.

All new features are implemented through the Agent Controller and Agent Receiver, i.e. {CMK} server and agent must have version {v21}.
Here, the first step is to register the Agent Controller with the Agent Receiver of the {CMK} site, with which a trust relationship is established.
During the registration, the TLS encryption of the communication is already set up.


[#install]
== Installation

{CMK} offers you various ways for installing the Linux agent -- from manual installation of the software package to fully automatic deployment including update function.
Some of them are only available in {EE}:

[cols="40,50,~,~",options="header"]
|===
|Method |Description |CRE |CEE
|Supplied RPM/DEB package |Simple installation of a standard agent with manual configuration via configuration files. 
The installation routine checks and configures `systemd` and `xinetd` in all editions -- in this order. |X |X
|RPM/DEB package from xref:glossar#agent_bakery [Agent Bakery] |Configuration via GUI, individual configuration per host possible. | |X
|xref:agent_deployment#[Automatic update] |The package from the Agent Bakery is installed for the first time by hand or by script and from then on automatically updated. | |X
|===


[#prerequisites]
=== Prerequisites

For the installation of the Agent Controller to work, this requires a Linux distribution with `systemd`, more precisely `systemd` in a version 220 or newer.

There is a good chance that this prerequisite is met on your host, as since 2015 most Linux distributions have adopted `systemd` as their init system, replacing other init systems such as SysVinit, e.g. SUSE Linux Enterprise Server from version 12, openSUSE from version 12.1, Red Hat Enterprise Linux from version 7, Fedora from version 15, Debian from version 8 and Ubuntu from version 15.04.
Unfortunately, comparing the version number alone does not bring certainty, since `systemd` may be missing even on a current Linux system if it has "only" been updated for years.

Therefore, check on the host on which the agent is to be installed whether `systemd` is running and in which version:  

[{shell-raw}]
----
{c-root} systemctl --version
systemd 245 (245.4-4ubuntu3.15)
----

If `systemd` is installed and running in the correct version as shown by the command output above, install the agent package and then run xref:registration[registration] to work with the agent in pull mode.

If `systemd` is not running, or only in a version that is too old, you can still install the agent as described in the rest of this chapter, and then use it in legacy mode.
In this case, you should still first read the xref:agent_linux_legacy#install[installation chapter] in the article for the Linux agent in legacy mode, since this mode requires a superserver such as `xinetd` to monitor ports and start the agent script.
Verification and, if necessary, installation of a superserver like `xinetd` should be done before installing the agent.


[#download]
=== Downloading the RPM/DEB package

You install the Linux agent by installing the RPM or the DEB package.
Whether you need RPM or DEB depends on the Linux distribution you want to install the package on:

[cols="10,10,~",options="header"]
|===
|Package |Extension |Install on
|RPM |`.rpm` |Red Hat Enterprise Linux, Fedora, CentOS, openSUSE, SLES, derivatives thereof
|DEB |`.deb` |Debian, Ubuntu, all other DEB-based distributions
|===

Before installation you have to get the package and bring it to the host (for example with `scp` or WinSCP) where the agent should run.
 

[#download_gui]
==== Getting package via {CMK} GUI

In the {CRE} you can find the Linux packages of the agent via [.guihint]#Setup > Agents > Linux#.
In the {EE}, you first get to the xref:wato_monitoringagents#bakery[Agent Bakery] in the [.guihint]#Setup# menu via [.guihint]#Agents > Windows, Linux, Solaris, AIX#, where you will find the baked packages.
From there, the [.guihint]#Related > Linux, Solaris, AIX files# menu item will take you to the list of agent files:

.On the download page you will find the RPM and DEB packages
image::agent_linux_agent_files.png[alt="Download page with the RPM/DEB packages."]

Everything you need can be found right in the first box named [.guihint]#Packaged Agents#:
The ready RPM and DEB packages for installing the Linux agent with default settings.


==== Getting package via HTTP

Sometimes downloading to a machine and then copying to the target machine using `scp` or WinSCP is very cumbersome.
You can also download the package from the {CMK} server directly to the target system via HTTP.
For this purpose, the downloads of the agent files are deliberately _without login_.
After all, the files do not contain any secrets.
Everyone can download and install {CMK} by himself and thus access the files.

The easiest way to do this is with `wget`.
You can get the URL from the browser.
If you already know the name of the package, you can easily compose the URL yourself.
Just put `/mysite/check_mk/agents/` in front of the filename, in the following example for the RPM package:

[{shell-raw}]
----
{c-root} wget http://mycmkserver/mysite/check_mk/agents/check-mk-agent-2.1.0b1-1.noarch.rpm
----

*Tip:* RPM even has a built-in `wget`.
Here you can download and xref:install_package[installation] with one command:

[{shell-raw}]
----
{c-root} rpm -U http://mycmkserver/mysite/check_mk/agents/check-mk-agent-2.1.0b1-1.noarch.rpm
----


==== Getting package via REST API

The xref:rest_api#[REST-API] of {CMK} provides the following ways to download agent packages from the {CMK} server:

* Downloading the provided agent.
* Downloading a baked agent by host name and operating system.
* Downloading a baked agent by hash of the agent and operating system.

Also via REST API you have the possibility to fetch the package from the {CMK} server directly to the target machine.
For example, the Linux agent's supplied DEB package can be fetched using the following `curl` command:

[{shell}]
----
{c-root} curl -OJG "http://mycmkserver/mysite/check_mk/api/1.0/domain-types/agent/actions/download/invoke" \
--header 'Accept: application/octet-stream' \
--header 'Authorization: Bearer automation myautomationsecret' \
--data-urlencode 'os_type=linux_deb'
----

This is just a simple example to demonstrate how this one REST API endpoint works to download the agent.
Details on this and other REST API endpoints can be found in the API documentation, which can be accessed in {CMK} via [.guihint]#Help > Developer resources > REST API documentation#.


[#install_package]
=== Installing the package

After fetching the RPM or DEB package and -- if necessary -- copying it to the host to be monitored using `scp`, WinSCP or other means, the installation is done with one command.

The installation of the RPM package is done under `root` with the command `rpm -U`:

[{shell}]
----
{c-root} rpm -U check-mk-agent-2.1.0b1-1.noarch.rpm
----

By the way, the `-U` option stands for "update", but it can also do an initial installation correctly.
This also means that you can use this command to update an already installed agent to the new version -- and use it for updates of the agent package in the future.

The installation of the DEB package -- and an update -- is done under `root` with the command `dpkg -i`:

[{shell}]
----
{c-root} dpkg -i check-mk-agent_2.1.0b1-1_all.deb
(Reading database ... 769314 files and directories currently installed.)
Preparing to unpack .../check-mk-agent_2.1.0b1-1_all.deb ...
Unpacking check-mk-agent (2.1.0b1-1) ...
Setting up check-mk-agent (2.1.0b1-1) ...

Deploying systemd units: check-mk-agent.socket check-mk-agent-async.service cmk-agent-ctl-daemon.service check-mk-agent@.service
Deployed systemd
Creating/updating cmk-agent user account (new) ...
Reloading xinetd
Activating systemd unit 'check-mk-agent.socket'...
Created symlink /etc/system/system/sockets.target.wants/check-mk-agent.socket → /lib/system/system/check-mk-agent.socket.
Activating systemd unit 'check-mk-agent-async.service'....
Created symlink /etc/systemd/system/multi-user.target.wants/check-mk-agent-async.service → /lib/systemd/system/check-mk-agent-async.service.
Activating systemd unit 'cmk-agent-ctl-daemon.service'...
Created symlink /etc/systemd/system/multi-user.target.wants/cmk-agent-ctl-daemon.service → /lib/systemd/system/cmk-agent-ctl-daemon.service.
----

Here, the package was installed for the first time on a previously agentless host.
The `cmk-agent` user was created and `systemd` was configured.


=== Installing with the Agent Bakery

{cee-only}
With the xref:wato_monitoringagents#bakery[Agent Bakery], the {CEE} have a software module for automatic packaging of customized agents.
A detailed description of this can be found in the general chapter about the xref:wato_monitoringagents#[agents].
Installation of the baked packages is done exactly as described for the included packages xref:install_package[above].


=== Automatic update
{cee-only}
If you use the Agent Bakery, you can set up automatic updates of the agent.
These are described in an xref:agent_deployment#[separate article].


[#post_install]
=== What happens after the installation?

If the Agent Controller could be set up with `systemd` during the installation, the next step is the xref:registration[registration], which sets up TLS encryption so that the encrypted agent output can be decrypted by the {CMK} server and displayed in monitoring.

There is a special feature when updating, i.e. when an already installed agent package has been updated to the new {v21} agent.
With such an update the agent switches to the unencrypted *legacy pull mode*, so that the {CMK} server is not cut off from the monitoring data and can continue to display it.
In the monitoring it looks like this:

.Warning in {CMK} Monitoring that TLS is not used yet
image::agent_linux_service_legacy_pull_mode.png[alt="The WARN state of the 'Check_MK' service due to lack of encryption."]

The {CMK} site detects from the agent output that the Agent Controller is present and thus TLS encryption is possible -- but not yet enabled.
The [.guihint]#Check_MK Agent# service changes to the {WARN} state and remains so until you register it after updating the agent.
After registration, only encrypted pull mode is used for communication.
The legacy pull mode is turned off and remains so.

The case is different if the Agent Controller could not register as a daemon with `systemd` during the installation.
Then the registration is not possible and the only communication path remains the *legacy mode*.
For legacy mode, the installation routine tries to configure a superserver like `xinetd` to monitor ports and start the agent script.
In this case, continue reading in the article xref:agent_linux_legacy#[Monitor Linux in legacy mode].


[#uninstall]
=== Uninstalling

Like the installation, the uninstallation of the agent is done with the package manager of the operating system.
Specify the name of the installed package here, not the filename of the original RPM/DEB file. 

To find out which DEB package is installed:

[{shell}]
----
{c-root} dpkg -l | grep check-mk-agent
ii check-mk-agent 2.1.0b1-1 all Checkmk Agent for Linux
----

The uninstallation of the DEB package is then done with `dpkg --purge`:

[{shell}]
----
{c-root} dpkg --purge check-mk-agent
(Reading database ... 769345 files and directories currently installed.)
Removing check-mk-agent (2.1.0b1-1) ...
Removing systemd units: check-mk-agent.socket, check-mk-agent-async.service, cmk-agent-ctl-daemon.service, check-mk-agent@.service
Deactivating systemd unit 'check-mk-agent.socket'...
Deactivating systemd unit 'check-mk-agent-async.service'...
Deactivating systemd unit 'cmk-agent-ctl-daemon.service'...
Reloading xinetd
Purging configuration files for check-mk-agent (2.1.0b1-1) ...
----

To find out which RPM package is installed:

[{shell}]
----
{c-root} rpm -qa | grep check-mk
----

Uninstalling the RPM package is done under `root` with the command `rpm -e`.


[#registration]
== Registration

=== Overview and requirements

During a new installation of the {CMK} agent, the host to be included in the monitoring cannot yet exchange data with the {CMK} server.
The reason is that a mutual trust relationship is missing - trust and encryption is mandatory from {CMK} {v21}.
How to establish this is shown in this chapter.
When updating the agent, the procedure is basically the same, even though unencrypted communication between {CMK} and the host in monitoring is possible here first.
In this case the service [.guihint]#Check_MK Agent# shows you in the state {WARN} that a change to encrypted communication is advised.

The registration and thus the establishment of the mutual trust relationship is done under a {CMK} user with access to the xref:rest_api#[REST API.]
For this purpose, the xref:glossar#automation_user[automation user] is a good choice, which is created automatically with every {CMK} Installation and whose password you can dice out.


=== Adding the host to monitoring

First create the new host via [.guihint]#Setup > Hosts > Add host# and then add it to monitoring by xref:glossar#activate_changes[Activate changes].

*Note:* In the host's properties in Setup, in the [.guihint]#Monitoring agents# box, you will find the [.guihint]#Checkmk agent connection mode# option, which offers pull mode and push mode as choices.
In {CMK} version {v21} only pull mode is supported. The push mode is a feature of the next {CMK} version for the new {CMK} Plus Edition (CPE).
The selection option is provided only to be prepared in case of a later upgrade or downgrade between {CMK} editions.


=== Registering host with server

Registration is done with the Agent Controller `cmk-agent-ctl`, which provides a command interface for configuring connections.
You can use the command `cmk-agent-ctl help` to get help on the options.

Now go to the host which should be registered.
Here, with `root` privileges, make a request to the {CMK} xref:glossar#site[site]:

[{shell}]
----
{c-root} cmk-agent-ctl register --hostname mynewhost \
    --server cmkserver --site mysite \
    --user automation --password test23
----

The host name behind the `--hostname` option must be specified exactly as it was before when creating it in Setup.
The `--server` and `--site` options specify the name of the {CMK} server and site.
The server name may also be the IP address, the site name (here `mysite`) corresponds to the one you see in the URL path of the web interface. 
The options are completed by the name and password of the automation user.
If you omit the `--password` option, the password will be requested interactively.

If the given values were correct, you will be asked to confirm the identity of the {CMK} site to which you want to connect.
We have shortened the server certificate to be confirmed for clarity:

[{shell}]
----
Attempting to register at cmkserver:8000/mysite. Server certificate details:

PEM-encoded certificate:
---BEGIN CERTIFICATE---
MIIC6zCCAdOgAwIBAgIUXbSE8FXQfmFqoRNhG9NpHhlRJ40wDQYJKoZIhvcNAQEL
[...]
nS+9hN5ILfRI+wkdrQLC0vkHVY8hGIEq+xTpG/Pxw==
---END CERTIFICATE---

Issued by:
	Site 'mysite' local CA
Issued to:
	localhost
Validity:
	From Thu, 10 Feb 2022 15:13:22 +0000
	To Tue, 13 Jun 3020 15:13:22 +0000

Do you want to establish this connection? [Y/n]
> #Y#
----

Confirm with `Y` to complete the process.

If no error message is displayed, the encrypted connection is established.
All data is transmitted in compressed form via this connection.


=== Checking trust relationship

The command `cmk-agent-ctl status` now shows exactly one trust relationship with the {CMK} server:

[{shell-raw}]
----
{c-root} cmk-agent-ctl status
Connection: 12.34.56.78:8000/mysite
	UUID: d38e7e53-9f0b-4f11-bbcf-d19617971595
	Local:
		Connection type: pull-agent
		Certificate issuer: Site 'mysite' local CA
		Certificate validity: Mon, 21 Feb 2022 11:23:57 +0000 - Sat, 24 Jun 3020 11:23:57 +0000
	Remote:
		Connection type: pull-agent
		Registration state: operational
		Host name: mynewhost
----

Afterwards you can perform a xref:glossar#service_discovery[service-discovery] on the {CMK} server, add the found services to the monitoring and finally activate the changes again.

*Note:* There can only ever be one trust relationship between host and site.
For example, if you register the already registered host `mynewhost` under a different name (`mynewhost2`) but with the same IP address, then the new connection replaces the existing one.
The connection from `mynewhost` to the site will be disconnected and no more agent data will be supplied for the host for monitoring.


=== Deregistering a host

On a host connected to the {CMK} server, you can revoke the trust relationship with this command:

[{shell}]
----
{c-root} cmk-agent-ctl delete d38e7e53-9f0b-4f11-bbcf-d19617971595
----

The Universally Unique Identifier (UUID) to be specified is the one that is output with the `cmk-agent-ctl status` command. 

On the {CMK} server, for each connection of a host that is in monitoring, there exists a soft link with the UUID pointing to the folder containing the agent output:

[{shell-raw}]
----
{c-omd} cd ~/var/agent-receiver/received-outputs
{c-omd} ls -l d38e7e53-9f0b-4f11-bbcf-d19617971595
lrwxrwx 1 mysite mysite 67 Feb 23 07:18 d38e7e53-9f0b-4f11-bbcf-d19617971595 -> /omd/sites/mysite/tmp/check_mk/data_source_cache/push-agent/mynewhost
----

If you delete this softlink, the host will need to be re-registered.


=== Registering on behalf

For easier registration of multiple hosts, any host on which the agent is installed can perform registration on behalf of others.
This involves exporting a JSON file, which can then be transferred to the target host and imported there.
Again, as before, the host registered in the job must already be set up in the site.

First, the registration is performed on any host in the monitoring as a substitute.
Here, of course, the {CMK} server is a good choice, as it is usually the first host to be included in the monitoring.
As with the example above, you can pass the password by option or be asked for it interactively if you omit the `--password` option.
We redirect the JSON output to a file in the example:

[{shell}]
----
{c-root} cmk-agent-ctl proxy-register \
    --hostname mynewhost3 \
    --server cmkserver --site mysite \
    --user automation > /tmp/mynewhost3.json
----

Now we transfer the file `/tmp/mynewhost3.json` to the host we registered for and import the file:

[{shell}]
----
{c-root} cmk-agent-ctl import /tmp/mynewhost3.json
----


[#test]
== Testing and error diagnosis

Once you have installed and registered the agent, you are probably wondering how to test out if you did everything correctly.
All the possibilities that exist from the {CMK} server are described in the general chapter about xref:wato_monitoringagents#diagnostics[agents].
But of course there are more diagnostic possibilities when logged in directly on the monitored host itself.

As the new agent introduces the two components Agent Controller on the host and Agent Receiver on the {CMK} server, the number of places where something can go wrong increases.
We work our way from the agent script to the Agent Controller to the {CMK} site.


[#script_output]
=== Output of the agent script

The agent script is a simple shell script that obtains data about your system and outputs it as loosely formatted text.
You can call it directly on the command line.
Since the output can be somewhat long, `less` is very handy here, which you can exit in the output with the Q key:

[{shell-raw}]
----
{c-root} check_mk_agent | less
<<check_mk>>
Version: 2.1.0b1
AgentOS: linux
Hostname: mynewhost
AgentDirectory: /etc/check_mk
DataDirectory: /var/lib/check_mk_agent
SpoolDirectory: /var/lib/check_mk_agent/spool
PluginsDirectory: /usr/lib/check_mk_agent/plugins
LocalDirectory: /usr/lib/check_mk_agent/local
AgentController: cmk-agent-ctl 0.1.0
----

This way you can test if all desired data is included in the output - for example, if all installed plug-ins provide data.

By the way, you do not have to be `root` to call the agent.
However, the output may then be missing some information that requires `root` privileges to obtain (e.g. multipath information and the output of `ethtool`).


=== Agent script in debug mode

To prevent possible error output from non-functioning plug-ins or commands from "contaminating" the actual data, the agent script generally suppresses the standard error channel.
If you are looking for a specific problem, you can re-enable it by calling the agent script in a special debug mode.
You do this with the `-d` option.
This will also print all shell commands that the script executes.

To work with `less` here, you have to combine standard output and error channel with `2>&1`:

[{shell}]
----
{c-root} check_mk_agent -d 2>&1 | less
----


=== Agent Controller in dump mode

The Agent Controller provides its own subcommand `dump` which displays the full agent output as it arrives in the monitoring:

[{shell-raw}]
----
{c-root} cmk-agent-ctl dump | less
<<check_mk>>
Version: 2.1.0b1
AgentOS: linux
Hostname: mynewhost
----

This allows you to verify that the data from the agent script has arrived at the Agent Controller. 
This output does not yet prove that the agent is also reachable over the network.


=== Connection test from outside

If it is ensured that locally the agent script and the installed plug-ins are executed correctly, you can check next from the {CMK} server via `netcat` (or `nc`) whether port 6556 is reachable:

[{shell}]
----
{c-omd} echo | nc 10.76.23.189 6556
16
----

The output `16` indicates that the connection establishment was successful and now the TLS handshake can take place.
Since everything else here is TLS encrypted, no detailed check is possible.

*Note:* If the communication between agent and {CMK} server is _still_ unencrypted (as in legacy pull mode) or is and remains unencrypted (as in xref:agent_linux_legacy#[legacy mode]), you will get the full unencrypted agent output with this command instead of the `16`.


=== Test with the {CMK} command line

Instead of using `nc`, you can use the {CMK} command line tool to request and display the complete agent output.
The `--debug -v` options add some debugging information. 

[{shell-raw}]
----
{c-omd} cmk --debug -v -d mynewhost
----

Eventually, the output will only contain a debug trace like this:

[{shell-raw}]
----
[TCPFetcher] Execute data source
Traceback (most recent call last):
  File "/omd/sites/mysite/lib/python3/cmk/core_helpers/tcp.py", line 194, in _wrap_tls
    return ctx.wrap_socket(self._socket, server_hostname=str(controller_uuid))
  File "/omd/sites/mysite/lib/python3.9/ssl.py", line 500, in wrap_socket
    return self.sslsocket_class._create(
  File "/omd/sites/mysite/lib/python3.9/ssl.py", line 1040, in _create
    self.do_handshake()
  File "/omd/sites/mysite/lib/python3.9/ssl.py", line 1309, in do_handshake
    self._sslobj.do_handshake()
ssl.SSLError: [SSL: TLSV1_ALERT_ACCESS_DENIED] tlsv1 alert access denied (_ssl.c:1129)
[...]
cmk.utils.exceptions.MKFetcherError: Error establishing TLS connection
----

In this case, you should first use `root` privileges on the new host to determine the status of the connection:

[{shell-raw}]
----
{c-root} cmk-agent-ctl status
----

If this command shows a correct registry on the {CMK} server, a simple restart of the Agent Controller daemon will suffice in many cases:

[{shell-raw}]
----
{c-root} systemctl restart cmk-agent-ctl-daemon
----


[#security]
== Security

=== Preliminary consideration

Security is an important criterion for any software, here monitoring must not make an exception.
Since the monitoring agent is installed on every monitored server, a security problem here would have particularly serious consequences.

That's why security was taken into account already during the design of {CMK} and since the first days of {CMK} there is an ironclad principle:
_The agent does not read data from the network. Period._ 
This certainly rules out the possibility of an attacker injecting any commands or script components through the 6556 monitoring port.


=== Transport Layer Security (TLS)

For an attacker, however, even a process list can be a first approach to draw conclusions about worthwhile targets.
Therefore, transport encryption between agent and {CMK} server with Transport Layer Security (TLS) is mandatory starting with {CMK} version {v21}.
Here, the {CMK} server "pings" the monitored host, which then establishes the TLS connection to the {CMK} server and transmits the agent output over it. 
Since only {CMK} servers with which a trust relationship exists can initiate this data transfer, there is no risk of data falling into the wrong hands.


=== Restricting access via IP addresses

Since only authorized {CMK} servers can retrieve data and unauthorized servers fail after a few bytes of handshake, the risk of a _Denial of Service (DoS)_ attack is very low.
For this reason, no further access restriction is currently planned.
Of course you can block port 6556 against unauthorized access via `iptables`.
A possibly existing rule to restrict access to certain IP addresses, which is transferred to clients via Bakery, is ignored by the Agent Controller.


=== Disabling built-in encryption

Especially when updating the agent, xref:agent_linux_legacy#encryption[built-in (symmetric) encryption] may be active, performed by the agent script itself.
If TLS encryption and built-in encryption are active at the same time, then the entropy of the transmitted data is so high that compression, which is active as of version {v21}, will not save any transmitted data - and will burden the CPUs of both the host and the {CMK} server with additional further encryption and decryption steps.

For this reason, you should disable the built-in encryption promptly after switching to TLS.
Under {CRE} you can do this by renaming the configuration file `/etc/check_mk/encryption.cfg`.

{cee-only} In the {CEE}, you can change existing rules to _Use TLS encryption_ in [.guihint]#Setup > Agents > Access to agents > Encryption (Linux, Windows)# in the [.guihint]#Encryption (Linux, Windows)# section and then xref:agent_deployment#[rebake] the agent packages.
After the next automatic agent update, the agent script encryption is disabled, but guaranteed encryption by the Agent Controller.
Note that after the automatic agent update, only registered hosts can provide monitoring data.


[#disabled_sections]
== Disabling sections

The output of the {CMK} agent is divided into sections.
Each of these sections contains related information and is usually simply the output of a diagnostic command.
Sections always start with a section header.
This is a line enclosed in `<<<` and `>>>`.

Except for {CMK}'s own sections, you can individually disable any of the 30+ sections that the agent generates by default.
Specifically, this means that the corresponding commands will not be executed by the agent at all, possibly saving computation time.
Other reasons for disabling could be that you are simply not interested in certain information from a certain group of hosts, or that a particular host is providing erroneous values and you want to suspend retrieval of that data for a short time.

As a user of one of the {CEE}, you can simply create a rule via [.guihint]#Setup > Agents > Windows, Linux, Solaris, AIX > Agent rules > Disabled sections (Linux agent)# which will then be taken into account by the xref:glossar#agent_bakery[Agent Bakery].

.In the {EE} you can disable sections by rule
image::agent_linux_disabled_sections.png[alt="List of agent rules for the Linux agent."]

In the rule, you will find a separate checkbox for each section that can be disabled.
For each checkbox selected, you will then find -- after the newly baked agent has been installed on the selected hosts -- a separate entry in the Agent Bakery `/etc/check_mk/exclude_sections.cfg` configuration file.
For example, if you were to select `Running processes` and `Systemd services`, the appropriate configuration file would look like this:

./etc/check_mk/exclude_sections.cfg
[{file}]
----
MK_SKIP_PS=yes
MK_SKIP_SYSTEMD=yes
----

Users of {CRE} can manually create the above `/etc/check_mk/exclude_sections.cfg` file and enter there the sections that should be disabled.
All sections that can be disabled are listed in the `~/share/check_mk/agents/cfg_examples/exclude_sections.cfg` file.


[#plugins]
== Extending the agent by plug-ins

=== What are agent plug-ins?

The agent script `/usr/bin/check_mk_agent` contains a whole set of sections which provide monitoring data for various check plug-ins which are then automatically found by the service discovery.
This includes all important monitoring of the operating system.

In addition, there is the possibility to extend the agent with _agent plug-ins_.
These are small scripts or programs that are called by the agent and extend it with additional sections with additional monitoring data.
The {CMK} project provides a number of such plug-ins, which -- if installed and configured correctly -- automatically provide new services in the service discovery.

Why aren't these plug-ins simply hard-coded into the agent?
For each of the plug-ins, there is one of the following reasons:

* The plug-in is written in a programming language other than shell and therefore cannot be implemented inline (example: `mk_logwatch`).
* The plug-in needs a configuration anyway, without which it would not work (example: `mk_oracle`).
* The plug-in is so special that it is not needed by most users (example: `plesk_domains`).


[#manualplugins]
=== Manual installation

The included plug-ins for Linux and Unix can all be found on the {CMK} server under `share/check_mk/agents/plugins`.
They are also available from the agents download page in the Setup menu (as described in the xref:download_gui[installation] chapter) in the [.guihint]#Plugins# box:

.The beginning of the long list of available agent plug-ins
image::agent_linux_files_agent_plugins.png[alt="Download page with agent plug-ins."]

For all agent plug-ins we provide, there are matching check plug-ins that can evaluate their data and generate services.
These are already installed, so that newly found services are immediately recognized and can be configured.

*Note:* Before you install a plug-in on the host, take a look at the corresponding file.
Often you will find important information there about the correct use of the plug-in.

The actual installation is then simple:
Copy the file to `/usr/lib/check_mk_agent/plugins`.
Make sure that it is executable.
If not, use a `chmod 755`.
The agent will not run the plug-in otherwise.
Especially if you do not transfer the files via `scp` but fetch them via HTTP from the download page, the execution permission will be lost.

As soon as the plug-in is executable and in the correct directory, it will be called automatically by the agent and a new section will be created in the agent output.
This usually has the same name as the plug-in.
Complex plug-ins (e.g. `mk_oracle`) even create a whole set of new sections.


[#pluginconfig]
=== Configuration

Some plug-ins need a configuration file in `/etc/check_mk/` to work.
For others, a configuration is optional and allows special features or customizations.
Still others just work that way.
You have several sources to get information:

* The documentation for the associated check plug-ins in your {CMK} site, which you can access via [.guihint]#Setup > Services > Catalog of check plugins#.
* Comments in the plug-in itself (often very helpful!).
* An appropriate article in this manual (e.g. about monitoring xref:monitoring_oracle#[Oracle]).


[#async_plugins]
=== Asynchronous execution

Just like xref:mrpe[MRPE], you can also have plug-ins executed asynchronously.
This is very useful if the plug-ins have a long runtime and the obtained state data does not need to be regenerated every minute anyway.

Asynchronous execution is not configured via a file.
Instead, you create a subdirectory under `/usr/lib/check_mk_agent/plugins` whose name is a number: a number of seconds.
Plug-ins in this directory are not only executed asynchronously, but at the same time you specify a minimum waiting time with the number of seconds before the plug-in should be executed again.
If the agent is queried again before the time expires, it uses cached data from the last time the plug-in was executed.
This allows you to configure a longer interval for the plug-in than the typical one minute.

The following example shows how to change the `my_foo_plugin` plug-in from synchronous execution to asynchronous execution with an interval of 5 minutes (or 300 seconds):

[{shell}]
----
{c-root} cd /usr/lib/check_mk_agent/plugins
{c-root} mkdir 300
{c-root} mv my_foo_plugin 300
----

*Note:* Note that some plug-ins already implement asynchronous execution on their own.
This includes `mk_oracle`.
Install such plug-ins directly after `/usr/lib/check_mk_agent/plugins`.


[#install_plugins_using_bakery]
=== Installation via the Agent Bakery

{cee-only}
In the {CEE}, the included plug-ins can be configured via the xref:glossar#agent_bakery[Agent Bakery].
This takes care of both the installation of the plug-in itself and the correct creation of the configuration file, should one be needed.

Each plug-in is configured via an agent rule.
You can find the appropriate rule sets in [.guihint]#Setup > Agents > Windows, Linux, Solaris, AIX > Agent rules > Agent Plugins#:

.List of rules for the agent plug-ins in the {EE}
image::agent_linux_rules_agent_plugins.png[alt="Page with rules for configuring agent plug-ins in the {EE}."]


=== Manual execution

Since agent plug-ins are executable programs, you can run them manually for testing and diagnostic purposes.
However, there are plug-ins that need certain environment variables set by the agent to find their configuration file, for example.
Set these before executing by hand:

[{shell-raw}]
----
{c-root} export MK_LIBDIR=/usr/lib/check_mk_agent
{c-root} export MK_CONFDIR=/etc/check_mk
{c-root} export MK_VARDIR=/var/lib/check_mk_agent
{c-root} /usr/lib/check_mk_agent/plugins/mk_foobar
<<foobar>>
FOO BAR BLUBB 17 47 11
----

Some plug-ins also know special call options for debugging.
Just take a look at the plug-in file.


[#e2e_monitoring]
== Including classic (Nagios) check plug-ins

[#mrpe]
=== Running plug-ins via MRPE

There are two good reasons to use Nagios plug-ins also under {CMK}.
If you migrated your monitoring from a Nagios based solution to {CMK}, you can continue to use older check plug-ins for which there is no {CMK} counterpart yet.
In many cases these are self-written plug-ins in Perl or Shell. 

The second reason for using Nagios plug-ins is true end-to-end monitoring.
Let's assume you have your {CMK} server, a web server and a database server distributed over a large data center.
In such a case, the response times of the database server measured from the {CMK} server are not very meaningful.
It is far more important to know these values for the connection between the web server and the database server.

The {CMK} agent provides a simple mechanism to meet both of these requirements:
_MK's Remote Plug-in Executor_ or _MRPE_ for short.
The name is deliberately an analogy to Nagios' _NRPE_, which performs the same task there.

The MRPE is built into the agent and is configured with a simple text file, which you create as `/etc/check_mk/mrpe.cfg`.
There you specify one plug-in call per line -- along with the name you want {CMK} to use for the service it automatically creates for it.
Here is an example:

./etc/check_mk/mrpe.cfg
[{file}]
----
Foo_Application /usr/local/bin/check_foo -w 60 -c 80
Bar_Extender /usr/local/bin/check_bar -s -X -w 4:5
----

Now, if you run the agent locally, you will find a new section per plug-in called `+<<mrpe>>+` which contains the name, exit code and output of the plug-in.
You can check this with the following handy `grep` command:

[{shell-raw}]
----
{c-root} check_mk_agent | grep -A1 '^...mrpe'
<<mrpe>>
(check_foo) Foo_Application 0 OK - Foo server up and running.
<<mrpe>>
(check_bar) Bar_Extender 1 WARN - Bar extender overload 6.012|bar_load=6.012
----

The `0` and `1` in the output represent the exit codes of the plug-ins and follow the classic scheme:
`0` = {OK}, `1` = {WARN}, `2` = {CRIT} and `3` = {UNKNOWN}.

The rest is now done automatically by {CMK}.
Once you invoke service discovery for the host, the two new services will show up as xref:wato_services#available[available].
It will look like this:

.One service is detected for each of the two MRPE plug-ins
image::agent_linux_mrpe_checks.png[alt="List of detected services for the plug-ins set up via MRPE."]

By the way, due to the syntax of the file, the name cannot contain spaces.
However, using the same syntax as in URLs, you can replace a space with `%20` (ASCII code 32 for space is hexadecimal 20):

./etc/check_mk/mrpe.cfg
[{file}]
----
Foo%20Application /usr/local/bin/check_foo -w 60 -c 80
Bar%20Extender /usr/local/bin/check_bar -s -X -w 4:5
----


=== Asynchronous execution

Note that all plug-ins you list in `mrpe.cfg` are executed synchronously in order.
Therefore, the plug-ins should not have too much execution time.
If one plug-in hangs, the execution of all others will be delayed.
This can cause the complete querying of the agent by {CMK} to time out and the host can no longer be reliably monitored.

If you really need longer running plug-ins, you should switch them to asynchronous execution and thus avoid the problem.
To do this, set a time in seconds that a calculated result should be valid, e.g. `300` for five minutes.
To do this, set `(interval=300)` in `mrpe.cfg` after the service name:

./etc/check_mk/mrpe.cfg
[{file}]
----
Foo_Application (interval=300) /usr/local/bin/check_foo -w 60 -c 80
Bar_Extender /usr/local/bin/check_bar -s -X -w 4:5
----

This has several effects:

* The plug-in runs in a background process and no longer slows down the execution of the agent.
* Because the agent does not wait for execution, the result is not delivered until the _next_ call to the agent.
* At the earliest after 300 seconds the plug-in is executed again.
Until then, the old result is reused.

So you can run tests that need a bit more computing time in larger intervals without having to configure anything on the {CMK} server.


=== MRPE with the Agent Bakery

{cee-only}
Users of {EE} can also configure MRPE with the xref:glossary#agent_bakery[Agent Bakery].
Responsible for this is the ruleset [.guihint]#Setup > Agents > Windows, Linux Solaris, AIX > Agent Rules > Generic Options > Execute MRPE checks#.
There you can configure the same things as described above.
The file `mrpe.cfg` will then be generated automatically by the Bakery.

.MRPEs can be configured conveniently by rule in the {EE}
image::agent_linux_mrpe_rule.png[alt="Rule for MRPE configuration in the Agent Bakery."]


==== Baking the plug-ins

You can also have the check plug-ins themselves delivered with the package.
This then makes the agent complete and does not require manual installation of any additional files.
The whole thing goes like this:

. Create the directory `local/share/check_mk/agents/custom` on the {CMK} server.
. Create a subdirectory there -- e.g. `my_mrpe_plugins`.
. Again, create the subdirectory `bin` in it.
. Copy your plug-ins into the `bin` folder.
. Create a rule in [.guihint]#Setup > Agents > Windows, Linux, Solaris, AIX > Agent rules > Generic Options > Deploy custom files with agent# .
. Select `my_mrpe_plugins`, save and bake!

The check plug-ins will now be installed into the default `bin` directory of your agent.
By default this is `/usr/bin`.
So when configuring the MRPE checks, use `/usr/bin/check_foo` instead of `/usr/local/bin/check_foo`.


[#hw_monitoring]
== Monitoring hardware

To monitor a Linux server as completely as possible, the hardware is of course also part of the monitoring.
The monitoring is done partly directly with the {CMK} agent, partly also via special xref:plugins[plug-ins].
In addition, there are still cases where you can implement monitoring via SNMP or even via a separate management board.


=== Monitoring of SMART values

Modern hard disks almost always have _S.M.A.R.T._ (Self-Monitoring, Analysis and Reporting Technology).
This system continuously records data about the state of the HDD or SSD and {CMK} can retrieve these values with the plug-in `smart` and evaluate the most important of them.
For the plug-in to work after installation, the following requirements must be met:

* The package `smartmontools` must be installed. You can install it on all modern distributions via the respective package manager.
* If the hard disks are connected to a RAID controller and this controller allows access to the SMART values, the respective tool must be installed for this. Supported are `tw_cli` (3ware) and `megacli` (LSI).

If these requirements are met and the plug-in is installed, the data is automatically read and appended to the output of the agent.
In {CMK} you can then activate the xref:wato_services#available[new services] directly:

.SMART services found by service discovery
image::agent_linux_smart_stats.png[alt="List of SMART services found in service discovery."]

If -- as seen in the screenshot -- `cmd_timeout` occurs occasionally, switch the plug-in to asynchronous execution at intervals of a few minutes.


=== Monitoring using IPMI

IPMI (Intelligent Platform Management Interface) is a hardware management interface that also allows hardware monitoring.
{CMK} uses `freeipmi` to access the hardware directly without a network.
`freeipmi` is installed from the package sources and is then ready to use, so that the data is already transmitted the next time {CMK} is called.

If `freeipmi` is not available or there are other reasons not to install it, `ipmitool` can also be used.
`ipmitool` is often already present on the system and only needs to be supplied with an IPMI device driver, such as that provided by the `openipmi` package.
Again, you do not need to do anything else after that.
The data will be collected automatically by {CMK}.

For error diagnosis you can also run the tools manually in a shell of the host.
If you have installed the package `freeipmi`, you can control the function with this:

[{shell}]
----
{c-root} ipmi-sensors Temperature
32 Temperature_Ambient 20.00_C_(1.00/42.00) [OK]
96 Temperature_Systemboard 23.00_C_(1.00/65.00) [OK]
160 Temperature_CPU_1 31.00_C_(1.00/90.00) [OK]
224 Temperature_CPU_2 NA(1.00/78.00) [Unknown]
288 Temperature_DIMM-1A 54.00_C_(NA/115.00) [OK]
352 Temperature_DIMM-1B 56.00_C_(NA/115.00) [OK]
416 Temperature_DIMM-2A NA(NA/115.00) [Unknown]
480 Temperature_DIMM-2B NA(NA/115.00) [Unknown]
----

If `ipmitool` has been installed, you can check the output of the data with the following command:

[{shell}]
----
{c-root} ipmitool sensor list
UID_Light 0.000 unspecified ok na na 0.000 na na na
Int._Health_LED 0.000 unspecified ok na na 0.000 na na na
Ext._Health_LED 0.000 unspecified ok na na 0.000 na na na
Power_Supply_1 0.000 unspecified nc na na 0.000 na na na
Fan_Block_1 34.888 unspecified nc na na 75.264 na na na
Fan_Block_2 29.792 unspecified nc na na 75.264 na na na
Temp_1 39,000 degrees_C ok na na -64,000 na na na
Temp_2 16,000 degrees_C ok na na -64,000 na na na na
Power_Meter 180.000 Watts cr na na 384.00
----


=== Manufacturer-specific tools

Many large server manufacturers also offer their own tools to read out the hardware information and provide it via SNMP.
The following requirements apply to be able to retrieve this data and provide {CMK}:

* An SNMP server is set up on the Linux host.
* The manufacturer's tool is installed (e.g. Dell's _OpenManage_ or Supermicro's _SuperDoctor_).
* The host is configured in {CMK} for monitoring via SNMP *in addition* to the {CMK} agent.
See the article on xref:snmp#snmp_cmk_agent[monitoring with SNMP] to learn how.

The new services for hardware monitoring supported by this are then automatically detected.
No further plug-ins are needed.


=== Additional monitoring via management board

You can configure a management board for each host and fetch additional data via SNMP.
The services recognized thereby are assigned then likewise to the Host.

The setup of the management board is very simple.
Just enter the protocol, the IP address and the access data for SNMP in the properties of the host and save the new settings:

.Configure the management board for SNMP in the properties of the host in the Setup
image::agent_linux_snmp_management_board.png[alt="The configuration of the management board for SNMP in the properties of the host."]

In service discovery, the newly discovered services are then enabled as usual.


[#files]
== Files and directories

=== Paths on the monitored host

[cols="45,~",options="header"]
|===
|Path |Meaning
|`/usr/bin` |Installation location of the agent script `check_mk_agent` and the Agent Controller `cmk-agent-ctl` on the target system.
|`/usr/lib/check_mk_agent` |Base directory for extensions to the agent.
|`/usr/lib/check_mk_agent/plugins` |Directory for plug-ins which should be automatically executed by the agent and extend its output with additional monitoring data. Plug-ins can be written in any available programming language.
|`/usr/lib/check_mk_agent/local` |Directory for custom xref:localchecks#[local checks].
|`/var/lib/check_mk_agent` |Base directory for agent data.
|`/var/lib/check_mk_agent/cache` |Here cache data of individual sections is stored and appended back to the agent on each execution as long as the cache data is valid.
|`/var/lib/check_mk_agent/job` |Directory for monitored jobs. These will be appended to the agent output on each execution.
|`/var/lib/check_mk_agent/spool` |Contains data created e.g. by cronjobs which have their own section. These are also appended to the agent output.
|`/var/agent-receiver/received-outputs` |Contains for each connection its UUID as a soft link pointing to the folder containing the agent output.
|`/etc/check_mk` |Storage of configuration files for the agent.
|`/etc/check_mk/mrpe.cfg` |Configuration file for xref:mrpe[MRPE] -- for running classic Nagios compatible check plug-ins.
|`/etc/check_mk/encryption.cfg` |Configuration for xref:agent_linux_legacy#encryption[built-in encryption] of agent data.
|`/etc/check_mk/exclude_sections.cfg` |Configuration file for the xref:disabled_sections[disabling certain sections] of the agent.
|===


=== Paths on the {CMK} server

[cols="45,~",options="header"]
|===
|Path |Meaning
|`local/share/check_mk/agents/custom` |Base directory for custom files to be delivered with a baked agent.
|`share/check_mk/agents/cfg_examples/exclude_sections.cfg` |Example configuration file for disabling sections.
|===



////
[#intro]
== Der neue Agent

[{image-left}]
image::linux.png[alt="Linux-Logo.",width=120]
Linux-Systeme können Sie mit {CMK} besonders gut überwachen.
Das liegt weniger daran, dass sich das {CMK}-Entwicklerteam auf Linux „zuhause“ fühlt, sondern vielmehr daran, dass Linux ein sehr offenes System ist und zahlreiche gut dokumentierte und einfach abzufragende Schnittstellen für eine detaillierte Überwachung bereitstellt.

Da die meisten der Schnittstellen per se nicht über das Netzwerk erreichbar sind, ist die Installation eines Monitoring-Agenten unumgänglich.
Deswegen hat {CMK} einen eigenen Agenten für die Überwachung von Linux. 
Dieser ist ein simples Shellskript, das minimalistisch, transparent und sicher ist.

In der {CMK}-Version {v21} gibt es nun einen neuen Linux-Agenten.
Präziser gesagt, wird dem *Agentenskript* `check_mk_agent` eine neue Komponente zur Seite gestellt: der *Agent Controller*.
Der Agent Controller ist dem Agentenskript vorgeschaltet, fragt dieses ab und kommuniziert an dessen Stelle mit dem {CMK}-Server.
Dazu registriert er sich am *Agent Receiver*, einem ebenfalls neuen Prozess, der auf dem {CMK}-Server läuft.

Der neue Linux-Agent übernimmt also zum einen das Agentenskript, und damit dessen Vorteile.
Zum anderen ergänzt er das Skript so, dass neue Funktionen hinzugefügt werden können wie die TLS-Verschlüsselung der Kommunikation, Datenkomprimierung -- und auch die Umkehrung der Kommunikationsrichtung.
Das bedeutet, dass zusätzlich zum registrierten, verschlüsselten und komprimierten *Pull-Modus* ein ebensolcher *Push-Modus* möglich wird.
Mehr dazu im nächsten Kapitel.

Während der Push-Modus ein Feature der nächsten {CMK}-Version für die neue {CMK} Plus Edition (CPE) sein wird, ist TLS-Verschlüsselung und Komprimierung ab Version {v21} für alle {CMK}-Editionen verfügbar -- sofern sowohl {CMK}-Server als auch Agent Version mindestens {v21} haben.

Der Agent Controller wird als Hintergrundprozess (_Daemon_) vom init-System `systemd` gestartet, daher setzt der Agent eine Linux-Distribution mit `systemd` voraus.
Wahrscheinlich wird diese Voraussetzung auf Ihrem Host erfüllt sein, da seit 2015 die meisten Linux-Distributionen `systemd` als init-System übernommen haben.

Allerdings beherrscht der Agent auch einen sogenannten *Legacy-Modus*, um Linux-Systeme zu unterstützen mit einer anderen Rechnerarchitektur als x86_64, ohne RPM- bzw. DEB-Paketmanagement und ohne init-System `systemd`.
In diesem Legacy-Modus arbeitet der neue wie der alte Agent, d.h. ohne Agent Controller und damit auch ohne Registrierung am {CMK}-Server.

Der Artikel, den Sie gerade lesen, behandelt Installation, Konfiguration und Erweiterungen des Linux-Agenten *mit* Agent Controller.
Er zeigt Ihnen aber auch, wie Sie herausfinden können, ob der Agent auf Ihrem Linux-System ohne Agent Controller im Legacy-Modus eingerichtet werden muss.
Im Artikel xref:agent_linux_legacy#[Linux überwachen im Legacy-Modus] finden Sie dann dazu alle Informationen.


[#architecture]
== Architektur des Agenten

Mit dem in der {v21} eingeführten neuen Agenten sind mehr Software-Komponenten als zuvor in die Kommunikation involviert.
Daher stellen wir die Komponenten und ihr Zusammenspiel kurz vor.
Die Architektur ist beim Linux-Agenten und beim xref:agent_windows#agent_architecture[Windows-Agenten] identisch.
Nur die technische Realisierung ist spezifisch für die Betriebssysteme.

.Zusammenspiel der Software-Komponenten
[{image-border}]
image::agent_linux_communication_flow.png[alt="Illustration der Kommunikation zwischen Agent und Instanz."]

Das *Agentenskript* `check_mk_agent` ist und bleibt zuständig für die Sammlung der Monitoring-Daten.
Für die Datensammlung ruft es der Reihe nach vorhandene Systembefehle auf.
Um auch diejenigen Informationen zu erhalten, zu deren Beschaffung `root`-Rechte erforderlich sind, wird `check_mk_agent` unter `root` ausgeführt.

Das Agentenskript ist:

* minimalistisch, denn es begnügt sich mit minimalen Ressourcen an RAM, CPU, Plattenplatz und Netzwerk.
* sicher, denn es erlaubt keinerlei Zugriffe aus dem Netzwerk.
* leicht erweiterbar, denn Sie können Plugins in einer beliebigen Programmier- oder Skriptsprache schreiben und vom Agentenskript ausführen lassen.
* transparent, denn es ist ein Shellskript, in dem Sie sehen können, welche Befehle es aufruft.

Der *Agent Controller* `cmk-agent-ctl.exe` ist die Komponente des Agenten, die für den Transport der vom Agentenskript gesammelten Daten zuständig ist.
Er wird unter dem Benutzer `cmk-agent` ausgeführt, der nur beschränkte Rechte besitzt, z.B. keine Login-Shell hat und nur zur Datenübertragung genutzt wird.
Der Benutzer `cmk-agent` wird während der Installation des Agentenpakets angelegt.
Der Agent Controller wird als Daemon von `systemd` gestartet und ist als Service an diesen gekoppelt.
Er lauscht am TCP-Port 6556 auf eingehende Verbindungen der {CMK}-Instanz und fragt das Agentenskript über einen Unix-Socket (einer `systemd` Unit) ab.

Wozu wird nun der Agent Controller gebraucht -- bisher funktionierte es doch auch sehr gut ohne ihn?
Nun, die Software-Architektur des Agenten ist die Voraussetzung dafür, neue Funktionen anzubieten, die mit dem minimalistischen Design des Agentenskripts nicht umsetzbar sind, wie beispielsweise die Verschlüsselung der Kommunikation per Transport Layer Security (TLS), Datenkomprimierung und die Umkehrung der Kommunikationsrichtung.
Bisher war es stets der {CMK}-Server, der die Kommunikation initiierte und die Daten vom Agenten abfragte -- im sogenannten Pull-Modus.

Mit dem Agent Controller wird die Voraussetzung geschaffen, zukünftig zusätzlich den Push-Modus zu realisieren, in dem die Initiative vom Agenten ausgeht.
Der Push-Modus ist für eine Cloud-basierte Konfiguration und in einigen abgeschotteten Netzwerken erforderlich.
In beiden Fällen kann der {CMK}-Server nicht auf das Netzwerk zugreifen, in dem sich die zu überwachenden Hosts befinden.
Daher sendet der Agent von sich aus regelmäßig die Daten an den {CMK}-Server.
Agent Controller und Agent Receiver sind bereits für den Push-Modus vorbereitet, auch wenn dieser Modus erst mit der nächsten {CMK}-Version für die neue {CMK} Plus Edition (CPE) verfügbar sein wird.

Der *Agent Receiver* `agent-receiver` ist die Komponente des {CMK}-Servers, die als genereller Endpunkt für die Kommunikation des Agent Controllers dient, z.B. für die Registrierung der Verbindung.
Er wird auch zukünftig die vom Agent Controller im Push-Modus gesendeten Daten empfangen.
Im Pull-Modus erfolgt der Datenaustausch mit den xref:cmc_differences.html#fetcher_checker[{CMK}-Fetchern] der Instanz.

TLS-Verschlüsselung und Datenkomprimierung werden über den Agent Controller und den Agent Receiver realisiert, d.h. {CMK}-Server und Agent müssen mindestens Version {v21} haben.
Dabei ist nach der Installation der erste Schritt die Registrierung des Agent Controller beim Agent Receiver der {CMK}-Instanz, mit der ein Vertrauensverhältnis hergestellt wird.
Bei der Registrierung wird bereits die TLS-Verschlüsselung der Kommunikation eingerichtet.


[#install]
== Installation

{CMK} bietet Ihnen für die Installation des Linux-Agenten verschiedene Wege -- von der manuellen Installation des Software-Pakets bis hin zum vollautomatischen Deployment inklusive Updatefunktion.
Manche davon stehen nur in den {EE} zur Verfügung:

[cols="40,50,~,~",options="header"]
|===
|Methode |Beschreibung |CRE |CEE
|Mitgeliefertes RPM/DEB-Paket |Einfache Installation eines Standard-Agenten mit manueller Konfiguration über Konfigurationsdateien. 
Die Installationsroutine überprüft und konfiguriert in allen Editionen `systemd` und `xinetd` -- in dieser Reihenfolge. |X |X
|RPM/DEB-Paket aus der xref:glossar#agent_bakery[Agentenbäckerei] |Konfiguration über die GUI, individuelle Konfiguration pro Host möglich. | |X
|xref:agent_deployment#[Automatisches Updaten] |Das Paket aus der Agentenbäckerei wird erstmalig von Hand oder per Skript installiert und von da an automatisch aktualisiert. | |X
|===


[#download]
=== Download des RPM/DEB-Pakets

Sie installieren den Linux-Agenten durch Installation des RPM- oder des DEB-Pakets.
Ob Sie RPM oder DEB benötigen, hängt von der Linux-Distribution ab, auf der Sie das Paket installieren möchten:

[cols="10,10,~",options="header"]
|===
|Paket |Endung |Installation auf
|RPM |`.rpm` |Red Hat Enterprise Linux (RHEL) basierte Systeme, SLES, Fedora, openSUSE, Derivate davon
|DEB |`.deb` |Debian, Ubuntu, alle anderen DEB-basierten Distributionen
|===

Vor der Installation müssen Sie das Paket holen und auf den Host bringen (zum Beispiel mit `scp` oder WinSCP), auf dem der Agent laufen soll.
 

[#download_gui]
==== Paket per {CMK}-GUI holen

In der {CRE} finden Sie die Linux-Pakete des Agenten über [.guihint]#Setup > Agents > Linux#.
In den {CEE} gelangen Sie im [.guihint]#Setup#-Menü über [.guihint]#Agents > Windows, Linux, Solaris, AIX# zunächst in die xref:wato_monitoringagents#bakery[Agentenbäckerei], wo Sie die gebackenen Pakete finden.
Von dort aus kommen Sie mit dem Menüeintrag [.guihint]#Related > Linux, Solaris, AIX files# zur Liste der Agentendateien:

.Auf der Download-Seite finden Sie die RPM- und DEB-Pakete
image::agent_linux_agent_files.png[alt="Download-Seite mit den RPM/DEB-Paketen."]

Alles was Sie brauchen, finden Sie gleich im ersten Kasten mit dem Namen [.guihint]#Packaged Agents#:
die fertigen RPM- und DEB-Pakete für die Installation des Linux-Agenten mit Standardeinstellungen.


==== Paket per HTTP holen

Manchmal ist der Download auf einen Rechner und das anschließende Kopieren auf den Zielrechner mit `scp` oder WinSCP sehr umständlich.
Sie können das Paket vom {CMK}-Server auch direkt per HTTP auf das Zielsystem laden.
Für diesen Zweck sind die Downloads der Agentendateien bewusst _ohne Anmeldung_ möglich.
Immerhin enthalten die Dateien keine Geheimnisse.
Jeder kann sich {CMK} selbst herunterladen und installieren und so auf die Dateien zugreifen.

Am einfachsten geht das mit `wget`.
Die URL können Sie über den Browser ermitteln.
Wenn Sie den Namen des Pakets bereits kennen, können Sie die URL einfach selbst zusammensetzen.
Setzen Sie `/mysite/check_mk/agents/` vor den Dateinamen, im folgenden Beispiel für das RPM-Paket:

[{shell-raw}]
----
{c-root} wget http://mycmkserver/mysite/check_mk/agents/check-mk-agent-2.1.0b1-1.noarch.rpm
----

*Tipp:* RPM hat sogar ein eingebautes `wget`.
Hier können Sie Download und xref:install_paket[Installation] mit einem Kommando durchführen:

[{shell-raw}]
----
{c-root} rpm -U http://mycmkserver/mysite/check_mk/agents/check-mk-agent-2.1.0b1-1.noarch.rpm
----


==== Paket per REST-API holen

Die xref:rest_api#[REST-API] von {CMK} bietet die folgenden Möglichkeiten Agentenpakete vom {CMK}-Server herunterzuladen:

* Herunterladen des mitgelieferten Agenten.
* Herunterladen eines gebackenen Agenten nach Host-Name und Betriebssystem.
* Herunterladen eines gebackenen Agenten nach Hash des Agenten und Betriebssystems.

Auch per REST-API haben Sie die Möglichkeit, das Paket vom {CMK}-Server direkt auf den Zielrechner zu holen.
Das mitgelieferte DEB-Paket des Linux-Agenten lässt sich beispielsweise mit dem folgenden `curl`-Kommando holen:

[{shell}]
----
{c-root} curl -OJG "http://mycmkserver/mysite/check_mk/api/1.0/domain-types/agent/actions/download/invoke" \
--header 'Accept: application/octet-stream' \
--header 'Authorization: Bearer automation myautomationsecret' \
--data-urlencode 'os_type=linux_deb'
----

Hierbei handelt es sich nur um ein einfaches Beispiel, um die Funktionsweise dieses einen REST-API-Endpunkts zum Herunterladen des Agenten zu demonstrieren.
Details zu diesem und anderen REST-API-Endpunkten finden Sie in der API-Dokumentation, die Sie in {CMK} über [.guihint]#Help > Developer resources > REST API documentation# aufrufen können.


[#install_paket]
=== Paket installieren

Nachdem Sie das RPM- oder das DEB-Paket geholt und -- falls nötig -- mit `scp`, WinSCP oder anderen Mitteln auf den zu überwachenden Host kopiert haben, ist die Installation mit einem Kommando erledigt.

Die Installation des RPM-Pakets erfolgt unter `root` mit dem Befehl `rpm -U`:

[{shell}]
----
{c-root} rpm -U check-mk-agent-2.1.0b1-1.noarch.rpm
----

Die Option `-U` steht übrigens für „Update“, kann aber auch eine Erstinstallation korrekt durchführen.
Das bedeutet auch, dass Sie mit diesem Befehl einen bereits installierten Agenten auf die aktuelle Version updaten können -- und ihn auch zukünftig für Updates des Agentenpakets nutzen können.

Die Installation des DEB-Pakets -- und ein Update -- erfolgt unter `root` mit dem Befehl `dpkg -i`:

[{shell}]
----
{c-root} dpkg -i check-mk-agent_2.1.0b1-1_all.deb
(Reading database ... 739920 files and directories currently installed.)
Preparing to unpack .../check-mk-agent_2.1.0b5-1_all.deb ...
Unpacking check-mk-agent (2.1.0b5-1) ...
Setting up check-mk-agent (2.1.0b5-1) ...

Deploying systemd units: check-mk-agent.socket check-mk-agent-async.service cmk-agent-ctl-daemon.service check-mk-agent@.service
Deployed systemd
Creating/updating cmk-agent user account ...

WARNING: The agent controller is operating in an insecure mode! To secure the connection run `cmk-agent-ctl register`.

Reloading xinetd
Activating systemd unit 'check-mk-agent.socket'...
Created symlink /etc/systemd/system/sockets.target.wants/check-mk-agent.socket → /lib/systemd/system/check-mk-agent.socket.
Activating systemd unit 'check-mk-agent-async.service'...
Created symlink /etc/systemd/system/multi-user.target.wants/check-mk-agent-async.service → /lib/systemd/system/check-mk-agent-async.service.
Activating systemd unit 'cmk-agent-ctl-daemon.service'...
Created symlink /etc/systemd/system/multi-user.target.wants/cmk-agent-ctl-daemon.service → /lib/systemd/system/cmk-agent-ctl-daemon.service.
----

Hier wurde das Paket auf einem zuvor agentenlosen Host erstmalig installiert.
Der Benutzer `cmk-agent` wurde erstellt und `systemd` konfiguriert.
Auf die dazwischen angezeigte Warnung zum `insecure mode`, also dem Legacy-Pull-Modus, gehen wir xref:post_install[gleich] ein.


=== Installation mit der Agentenbäckerei

{cee-only}
Die {CEE} verfügen mit der xref:wato_monitoringagents#bakery[Agentenbäckerei] über ein Software-Modul zum automatischen Paketieren von individuell angepassten Agenten.
Eine ausführliche Beschreibung dazu finden Sie im allgemeinen Kapitel über die xref:wato_monitoringagents#[Agenten].
Die Installation der gebackenen Pakete geschieht genauso wie es für die mitgelieferten Pakete xref:install_paket[oben] beschrieben ist.


=== Automatisches Update
{cee-only}
Wenn Sie die Agentenbäckerei verwenden, können Sie automatische Updates des Agenten einrichten.
Diese werden in einem xref:agent_deployment#[eigenen Artikel] beschrieben.


[#post_install]
=== Wie geht es weiter nach der Installation?

Falls der Agent Controller bei der Installation mit `systemd` konfiguriert werden konnte, ist der nächste Schritt die xref:registration[Registrierung], mit der die TLS-Verschlüsselung eingerichtet wird, so dass die verschlüsselte Agentenausgabe vom {CMK}-Server entschlüsselt und im Monitoring angezeigt werden kann.

Eine Besonderheit gibt es, falls der Agent mit Agent Controller erstmalig installiert wurde.
Dann schaltet der Agent in den unverschlüsselten *Legacy-Pull-Modus*, damit der {CMK}-Server nicht von den Monitoring-Daten abgeschnitten wird und diese weiterhin anzeigen kann.
Das betrifft sowohl eine Neuinstallation als auch das Update eines Agenten der Version {v20} und älter.

Einen Hinweis auf den aktivierten Legacy-Pull-Modus erhalten Sie bereits in der Kommandoausgabe bei der xref:install_paket[Installation des Agenten.]
Im Monitoring sieht das dann etwa so aus:

.Warnung im {CMK}-Monitoring, dass TLS noch nicht genutzt wird
image::agent_linux_service_legacy_pull_mode.png[alt="Der WARN-Zustand des 'Check_MK' Services wegen fehlender Verschlüsselung."]

Die {CMK}-Instanz erkennt an der Agentenausgabe, dass der Agent Controller vorhanden und damit die TLS-Verschlüsselung möglich ist -- aber noch nicht eingeschaltet ist.
Der Service [.guihint]#Check_MK Agent# wechselt in den Zustand {WARN} und bleibt es solange, bis Sie die Registrierung nach dem Update des Agenten durchgeführt haben.
Nach der Registrierung wird nur noch im verschlüsselten Pull-Modus kommuniziert.
Der Legacy-Pull-Modus wird abgeschaltet und bleibt es auch.

Anders liegt der Fall, wenn der Agent Controller sich während der Installation nicht als Daemon bei `systemd` registrieren konnte.
Dann ist die Registrierung nicht möglich und der einzige Kommunikationsweg verbleibt der *Legacy-Modus*.
Im nächsten Kapitel können Sie durch xref:test_environment[Test von Agent Controller und Systemumgebung] feststellen, ob Sie mit der Registrierung fortsetzen können.


[#registration]
== Registrierung

=== Übersicht und Voraussetzungen

Der Host, der ins Monitoring aufgenommen werden soll, kann noch keine verschlüsselten Daten mit dem {CMK}-Server austauschen.
Der Grund ist, dass ein gegenseitiges Vertrauensverhältnis fehlt – Vertrauen und Verschlüsselung sind ab {CMK} {v21} Pflicht.
Wie Sie das herstellen, zeigt dieses Kapitel.

Die Registrierung und damit die Herstellung des gegenseitigen Vertrauensverhältnisses erfolgt unter einem {CMK}-Benutzer mit Zugriff auf die xref:rest_api#[REST-API.]
Dafür bietet sich der xref:glossar#automation_user[Automationsbenutzer] an, der bei jeder {CMK}-Installation automatisch angelegt wird und dessen Passwort Sie auswürfeln können.

Die Registrierung mit dem Agent Controller setzt ein Linux-System voraus mit einem init-System `systemd` ab Version 220 und einer x86_64-Rechnerarchitektur.
In Abschnitt xref:test_environment[Agent Controller und Systemumgebung testen] erfahren Sie, wie Sie diese Voraussetzungen überprüfen.


=== Host ins Setup aufnehmen

Erstellen Sie zunächst den neuen Host über [.guihint]#Setup > Hosts > Add host.#
Ein Host muss in der xref:glossar#configuration_environment[Konfigurationsumgebung] existieren, bevor er registriert werden kann.


[#test_environment]
=== Agent Controller und Systemumgebung testen

Der Agent mit Agent Controller setzt eine Linux-Distribution mit `systemd` voraus, präziser `systemd` in einer Version 220 oder neuer.

Die Chance ist groß, dass diese Voraussetzung auf Ihrem Host erfüllt ist, da seit 2015 die meisten Linux-Distributionen `systemd` als init-System übernommen und damit andere init-Systeme wie SysVinit ersetzt haben, z.B. SUSE Linux Enterprise Server ab Version 12, openSUSE ab Version 12.1, Red Hat Enterprise Linux ab Version 7, Fedora ab Version 15, Debian ab Version 8 und Ubuntu ab Version 15.04.
Leider bringt der Vergleich der Versionsnummer alleine keine Gewissheit, da `systemd` auch auf einem aktuellen Linux-System fehlen kann, wenn dieses Jahre lang „nur“ aktualisiert wurde.

Prüfen Sie daher auf dem Host, auf dem der Agent installiert werden soll, ob und in welcher Version `systemd` läuft:  

[{shell-raw}]
----
{c-root} systemctl --version
systemd 245 (245.4-4ubuntu3.15)
----

Die obige Kommandoausgabe zeigt, dass `systemd` in der richtigen Version installiert ist.
Falls `systemd` nicht, oder nur in einer zu alten Version läuft, kann der Agent Controller nicht verwendet werden.
Schließen Sie die Einrichtung ab wie im Artikel xref:agent_linux_legacy#[Linux überwachen im Legacy-Modus] beschrieben.

Prüfen Sie nun, ob der Agent Controller gestartet werden kann:

[{shell}]
----
{c-root} cmk-agent-ctl --version
----

Als Ausgabe sollte die Versionsnummer zu sehen sein, beispielsweise:

[{shell}]
----
cmk-agent-ctl 0.1.0
----

In seltenen Fällen erscheint die folgende Fehlermeldung:

[{shell}]
----
bash: /usr/bin/cmk-agent-ctl: cannot execute binary file: Exec format error
----

Ursache hierfür ist, dass Ihr Linux eine andere Rechnerarchitektur als _x86_64_ nutzt, zum Beispiel das ältere _32-Bit x86_ oder _ARM_.
In diesem Fall kann der Agent Controller nicht verwendet werden.
Schließen Sie die Einrichtung ab wie im Artikel xref:agent_linux_legacy#[Linux überwachen im Legacy-Modus] beschrieben.

Im nächsten Schritt gilt es herauszufinden, welches Programm auf Port 6556 auf Anfragen wartet:

[{shell-raw}]
----
{c-root} ss -tulpn | grep 6556
tcp	LISTEN	0	1024	0.0.0.0:6556	0.0.0.0:*	users:(("cmk-agent-ctl",pid=1861810,fd=9))
----

Hier ist es `cmk-agent-ctl`, die Voraussetzungen für verschlüsselte Kommunikation sind erfüllt.
Steht innerhalb der Klammer stattdessen `systemd`, `xinetd` oder `inetd`, sind die Voraussetzungen für die Verwendung des Agent Controllers nicht gegeben.
Schließen Sie auch in diesem Fall die Einrichtung wie im Artikel xref:agent_linux_legacy#[Linux überwachen im Legacy-Modus] beschrieben, ab.


=== Host beim Server registrieren

Die Registrierung erfolgt mit dem Agent Controller `cmk-agent-ctl`, der für die Konfiguration der Verbindungen eine Kommandoschnittstelle bietet.
Sie können sich mit dem Kommando `cmk-agent-ctl help` die Hilfe zu den Optionen anzeigen lassen.

Begeben Sie sich nun zum Host, der registriert werden soll.
Hier ist mit `root`-Rechten eine Anfrage an die {CMK}-xref:glossar#site[Instanz] zu stellen:

[{shell}]
----
{c-root} cmk-agent-ctl register --hostname mynewhost \
    --server cmkserver --site mysite \
    --user automation --password test23
----

Dabei ist der Host-Name hinter der Option `--hostname` exakt so anzugeben, wie zuvor beim Erstellen im Setup.
Die Optionen `--server` und `--site` geben den Namen des {CMK}-Servers und der Instanz an.
Der Server-Name darf auch die IP-Adresse sein, der Instanzname (hier `mysite`) entspricht demjenigen, den Sie im URL-Pfad der Weboberfläche sehen. 
Komplettiert werden die Optionen durch Name und Passwort des Automationsbenutzers.
Wenn Sie die Option `--password` auslassen, wird das Passwort interaktiv abgefragt.

Waren die angegebenen Werte korrekt, werden Sie aufgefordert, die Identität der {CMK}-Instanz zu bestätigen, zu der Sie die Verbindung herstellen wollen.
Das zu bestätigende Server-Zertifikat haben wir aus Gründen der Übersichtlichkeit stark verkürzt:

[{shell}]
----
Attempting to register at cmkserver:8000/mysite. Server certificate details:

PEM-encoded certificate:
---BEGIN CERTIFICATE---
MIIC6zCCAdOgAwIBAgIUXbSE8FXQfmFqoRNhG9NpHhlRJ40wDQYJKoZIhvcNAQEL
[...]
nS+9hN5ILfRI+wkdrQLC0vkHVYY8hGIEq+xTpG/Pxw==
---END CERTIFICATE---

Issued by:
	Site 'mysite' local CA
Issued to:
	localhost
Validity:
	From Thu, 10 Feb 2022 15:13:22 +0000
	To   Tue, 13 Jun 3020 15:13:22 +0000

Do you want to establish this connection? [Y/n]
> #Y#
----

Bestätigen Sie mit `Y`, um den Vorgang abzuschließen.

Falls keine Fehlermeldung angezeigt wird, ist die verschlüsselte Verbindung hergestellt.
Über diese Verbindung werden alle Daten komprimiert übertragen.


=== Vertrauensverhältnis überprüfen

Das Kommando `cmk-agent-ctl status` zeigt nun genau ein Vertrauensverhältnis zum {CMK}-Server:

[{shell-raw}]
----
{c-root} cmk-agent-ctl status
Connection: 12.34.56.78:8000/mysite
	UUID: d38e7e53-9f0b-4f11-bbcf-d19617971595
	Local:
		Connection type: pull-agent
		Certificate issuer: Site 'mysite' local CA
		Certificate validity: Mon, 21 Feb 2022 11:23:57 +0000 - Sat, 24 Jun 3020 11:23:57 +0000
	Remote:
		Connection type: pull-agent
		Registration state: operational
		Host name: mynewhost
----

*Hinweis:* Es kann stets nur ein Vertrauensverhältnis zwischen Host und Instanz geben.
Wenn Sie beispielsweise den bereits registrierten Host `mynewhost` unter anderem Namen (`mynewhost2`), aber mit der gleichen IP-Adresse registrieren, dann ersetzt die neue Verbindung die bestehende.
Die Verbindung von `mynewhost` zur Instanz wird gelöst und für den Host werden keine Agentendaten mehr für das Monitoring geliefert.


=== Im Auftrag registrieren

Zur leichteren Registrierung mehrerer Hosts kann ein beliebiger Host, auf dem der Agent installiert ist, eine Registrierung im Auftrag anderer durchführen.
Dabei wird eine JSON-Datei exportiert, die dann auf den Ziel-Host übertragen und dort importiert werden kann.
Auch hier gilt wie zuvor: Der im Auftrag registrierte Host muss in der Instanz bereits eingerichtet sein.

Zunächst wird auf einem beliebigen im Setup befindlichen Host die Registrierung stellvertretend durchgeführt.
Hier bietet sich natürlich der {CMK}-Server an, der in der Regel als erster Host eingerichtet wird.
Wie beim Beispiel oben gilt, dass Sie das Passwort per Option übergeben können oder interaktiv danach gefragt werden, wenn Sie die Option `--password` weglassen.
Die JSON-Ausgabe leiten wir im Beispiel in eine Datei um:

[{shell}]
----
{c-root} cmk-agent-ctl proxy-register \
    --hostname mynewhost3  \
    --server cmkserver --site mysite \
    --user automation > /tmp/mynewhost3.json
----

Nun übertragen wir die Datei `/tmp/mynewhost3.json` auf den Host, für den wir die Registrierung durchgeführt haben, und importieren die Datei:

[{shell}]
----
{c-root} cmk-agent-ctl import /tmp/mynewhost3.json
----


=== Host ins Monitoring aufnehmen

Sobald die Registrierung fertiggestellt ist, führen Sie im Setup des {CMK}-Servers einen xref:wato_monitoringagents#diagnosticpage[Verbindungstest] und eine xref:wato_services#discovery[Service-Erkennung] durch. 
Anschließend nehmen Sie die gefundenen Services ins Monitoring auf, indem Sie als letzten Schritt xref:wato#activate_changes[die Änderungen aktivieren.]

Falls der Verbindungstest fehlschlägt, finden Sie im xref:test[folgenden Kapitel] Informationen zu Test und Fehlerdiagnose.


=== Host deregistrieren

Die Registrierung eines Hosts können Sie auch wieder rückgängig machen.
Auf einem Host, der mit dem {CMK}-Server verbunden ist, können Sie das Vertrauensverhältnis mit diesem Kommando widerrufen:

[{shell}]
----
{c-root} cmk-agent-ctl delete d38e7e53-9f0b-4f11-bbcf-d19617971595
----

Der anzugebende Universally Unique Identifier (UUID) ist derjenige, der beim Kommando `cmk-agent-ctl status` ausgegeben wird. 

Auf dem {CMK}-Server existiert für jede Verbindung eines Hosts, der sich im Monitoring befindet, ein Softlink mit der UUID, welcher auf den Ordner mit der Agentenausgabe zeigt:

[{shell-raw}]
----
{c-omd} cd ~/var/agent-receiver/received-outputs
{c-omd} ls -l d38e7e53-9f0b-4f11-bbcf-d19617971595
lrwxrwxrwx 1 mysite mysite 67 Feb 23 07:18 d38e7e53-9f0b-4f11-bbcf-d19617971595 -> /omd/sites/mysite/tmp/check_mk/data_source_cache/push-agent/mynewhost
----

Wenn Sie diesen Softlink löschen, ist eine erneute Registrierung des Hosts erforderlich.


[#test]
== Test und Fehlerdiagnose

Ein modulares System kann an vielen Stellen nicht wie vorgesehen funktionieren.
Da mit dem Agenten in der {v21} die beiden Komponenten Agent Controller auf dem Host und Agent Receiver auf dem {CMK}-Server eingeführt wurden, steigt die Zahl der Stellen, an denen etwas schief gehen kann.

Bei der Fehlersuche ist daher eine strukturierte Vorgehensweise sinnvoll.
Selbstverständlich können Sie die hier beschriebene schrittweise Analyse auch nutzen, die Datenerhebung und Kommunikation von {CMK} näher kennenzulernen. 

Alle Möglichkeiten, die es vom {CMK}-Server aus gibt, sind im allgemeinen Kapitel über die Agenten xref:wato_monitoringagents#diagnostics[beschrieben].
Aber natürlich gibt es noch weitere Diagnosemöglichkeiten, wenn man direkt auf dem überwachten Host selbst eingeloggt ist.

Wir arbeiten uns im Folgenden vom Agentenskript über den Agent Controller und den TCP-Port 6556 bis zur {CMK}-Instanz durch.
In den meisten Fällen können Sie nach Korrektur eines Fehlers die Diensteerkennung erneut starten und die Aufnahme ins Monitoring abschließen.


[#script_output]
=== Ausgabe des Agentenskripts

Das Agentenskript ist ein einfaches Shellskript, welches Daten über Ihr System beschafft und als lose formatierten Text ausgibt.
Sie können es direkt auf der Kommandozeile aufrufen.
Da die Ausgabe etwas länger sein kann, ist der Pager `less` zum Scrollen der Ausgabe hier sehr praktisch.
Sie können Ihn mit der Taste Q verlassen:

[{shell-raw}]
----
{c-root} check_mk_agent | less
<<<check_mk>>>
Version: 2.1.0b1
AgentOS: linux
Hostname: mynewhost
AgentDirectory: /etc/check_mk
DataDirectory: /var/lib/check_mk_agent
SpoolDirectory: /var/lib/check_mk_agent/spool
PluginsDirectory: /usr/lib/check_mk_agent/plugins
LocalDirectory: /usr/lib/check_mk_agent/local
AgentController: cmk-agent-ctl 0.1.0
----

So ermitteln Sie, ob in der Ausgabe alle gewünschten Daten enthalten sind – beispielsweise, ob alle installierten Plugins die erwartete Ausgabe liefern.

Sie müssen übrigens nicht unbedingt `root` sein, um den Agenten aufzurufen.
Allerdings werden dann in der Ausgabe einige Informationen fehlen, zu deren Beschaffung `root`-Rechte erforderlich sind (z.B. Multipath-Informationen und die Ausgaben von `ethtool`).


=== Agentenskript im Debug-Modus

Damit eventuelle Fehlerausgaben von nicht funktionierenden Plugins oder Befehlen nicht die eigentlichen Daten „verunreinigen“, unterdrückt das Agentenskript generell den Standardfehlerkanal (STDERR).
Sind Sie auf der Suche nach einem bestimmten Problem, können Sie diesen wieder aktivieren, indem Sie das Agentenskript in einem speziellen Debug-Modus aufrufen.
Das machen Sie mit der Option `-d`.
Dabei werden auch sämtliche Shellbefehle ausgegeben, die das Skript ausführt.

Damit Sie hier mit `less` arbeiten können, müssen Sie Standardausgabe (STDOUT) und Fehlerkanal mit `2>&1` zusammenfassen:

[{shell}]
----
{c-root} check_mk_agent -d 2>&1 | less
----


=== Agent Controller im Dump-Modus

Der Agent Controller stellt ein eigenes Subkommando `dump` bereit, das die vollständige Agentenausgabe anzeigt, wie sie im Monitoring ankommt:

[{shell-raw}]
----
{c-root} cmk-agent-ctl dump | less
<<<check_mk>>>
Version: 2.1.0b1
AgentOS: linux
Hostname: mynewhost
----

So können Sie überprüfen, ob die Daten vom Agentenskript beim Agent Controller angekommen sind.
Diese Ausgabe beweist noch nicht, dass der Agent auch über das Netzwerk erreichbar ist.

In einigen Fällen sieht die Ausgabe wie folgt aus:

[{shell-raw}]
----
ERROR [cmk_agent_ctl] Error collecting monitoring data.

Caused by:
    No such file or directory (os error 2)
----

Dies ist der Fall, wenn der Agent Controller Daemon nicht im Hintergrund läuft – beispielsweise unmittelbar nach einem Update.
Starten Sie diesen Hintergrundprozess neu:

[{shell-raw}]
----
{c-root} systemctl restart cmk-agent-ctl-daemon
----

Schlägt `cmk-agent-ctl dump` erneut fehl, prüfen Sie, ob und wenn, welches Programm an Port 6556 lauscht:

[{shell-raw}]
----
{c-root} ss -tulpn | grep 6556
tcp	LISTEN	0	1024	0.0.0.0:6556 0.0.0.0:*	users:(("cmk-agent-ctl",pid=1861810,fd=9))
----

Ist die Ausgabe leer oder innerhalb der Klammer steht ein anderer Befehl als `cmk-agent-ctl`, sind die Systemvoraussetzungen für die Nutzung des Agent Controllers nicht erfüllt.
Schließen Sie in diesem Fall die Einrichtung ab wie im Artikel xref:agent_linux_legacy#[Linux überwachen im Legacy-Modus] beschrieben.

=== Verbindungstest von außen

Ist sichergestellt, dass lokal das Agentenskript und die mitinstallierten Plugins korrekt ausgeführt werden, können Sie als nächstes vom {CMK}-Server per `netcat` (oder `nc`) prüfen, ob Port 6556 erreichbar ist:

[{shell}]
----
{c-omd} echo | nc 10.76.23.189 6556
16
----

Die Ausgabe `16` zeigt an, dass die Verbindungsaufnahme erfolgreich war und nun der TLS-Handshake stattfinden kann.
Da alles weitere hier TLS verschlüsselt stattfindet, ist keine detaillierte Prüfung möglich.

Schlägt der Verbindungstest von außen fehl, liegt dies meist an der Firewall-Einstellung.
Konfigurieren Sie `iptables` oder `nftables` in diesem Fall so, dass Zugriff auf TCP Port 6556 vom {CMK}-Server aus möglich ist.

*Hinweis:* Falls die Kommunikation zwischen Agent und {CMK}-Server _noch_ unverschlüsselt ist (wie im Legacy-Pull-Modus) oder unverschlüsselt ist und auch bleibt (wie im xref:agent_linux_legacy#[Legacy-Modus]), erhalten Sie mit diesem Kommando statt der `16` die komplette unverschlüsselte Agentenausgabe.

Bleibt die Ausgabe auch nach Registrierungsversuch unverschlüsselt, verwenden Sie `grep`, um den Status aus der Ausgabe zu ermitteln:

[{shell-raw}]
----
{c-omd} echo | nc 10.76.23.189 6556 | grep -A1 cmk_agent_ctl_status
<<<cmk_agent_ctl_status:sep(0)>>>
{"version":"0.1.0","ip_allowlist":[],"allow_legacy_pull":false, ... }
----

Ist die Variable `allow_legacy_pull` auf `false` gesetzt, erlaubt der Agent Controller selbst keine Klartextausgabe, aber für TCP Port 6556 ist ein anderer Dienst, beispielsweise `xinetd` zuständig.
Dies ist gelegentlich Zustand nach Update eines Systems, das die Voraussetzungen für die Verwendung des Agent Controller nicht erfüllt.
Führen Sie in diesem Fall zuerst eine Deregistrierung durch und schließen Sie dann die Einrichtung ab wie im Artikel xref:agent_linux_legacy#[Linux überwachen im Legacy-Modus] beschrieben.

=== Test mit der {CMK}-Kommandozeile

Statt mit `nc` können Sie mit dem {CMK}-Kommandozeilentool die komplette Agentenausgabe anfordern und sich anzeigen lassen.
Die Optionen `--debug -v` fügen noch einige Debugging-Informationen hinzu. 

[{shell-raw}]
----
{c-omd} cmk --debug -v -d mynewhost
----

Eventuell enthält die Ausgabe lediglich einen Debug Trace wie folgt:

[{shell-raw}]
----
[TCPFetcher] Execute data source
Traceback (most recent call last):
  File "/omd/sites/mysite/lib/python3/cmk/core_helpers/tcp.py", line 194, in _wrap_tls
    return ctx.wrap_socket(self._socket, server_hostname=str(controller_uuid))
  File "/omd/sites/mysite/lib/python3.9/ssl.py", line 500, in wrap_socket
    return self.sslsocket_class._create(
  File "/omd/sites/mysite/lib/python3.9/ssl.py", line 1040, in _create
    self.do_handshake()
  File "/omd/sites/mysite/lib/python3.9/ssl.py", line 1309, in do_handshake
    self._sslobj.do_handshake()
ssl.SSLError: [SSL: TLSV1_ALERT_ACCESS_DENIED] tlsv1 alert access denied (_ssl.c:1129)
[...]
cmk.utils.exceptions.MKFetcherError: Error establishing TLS connection
----

In diesem Fall sollten Sie zunächst mit `root`-Rechten auf dem neuen Host den Status der Verbindung ermitteln:

[{shell-raw}]
----
{c-root} cmk-agent-ctl status
----

Zeigt dieses Kommando eine korrekte Registrierung am {CMK}-Server, genügt in vielen Fällen ein einfacher Neustart des Agent Controller Daemons:

[{shell-raw}]
----
{c-root} systemctl restart cmk-agent-ctl-daemon
----


[#security]
== Absicherung

=== Vorüberlegung

Sicherheit ist ein wichtiges Kriterium für jegliche Software, hier darf Monitoring keine Ausnahme machen.
Da der Monitoring-Agent auf jedem überwachten Server installiert wird, hätte hier ein Sicherheitsproblem besonders gravierende Auswirkungen.

Deswegen wurde schon beim Design von {CMK} auf Sicherheit Wert gelegt und es gilt seit den ersten Tagen von {CMK} ein eherner Grundsatz:
_Der Agent liest keine Daten vom Netzwerk. Punkt._ 
Somit ist mit Sicherheit ausgeschlossen, dass ein Angreifer über den Überwachungsport 6556 irgendwelche Befehle oder Skriptbestandteile einschleusen kann.


=== Transport Layer Security (TLS)

Für einen Angreifer kann jedoch bereits eine Prozessliste ein erster Ansatz sein, Rückschlüsse auf lohnenswerte Ziele zu ziehen.
Daher ist die Transportverschlüsselung zwischen Agent und {CMK}-Server mit Transport Layer Security (TLS) ab {CMK}-Version {v21} obligatorisch.
Hierbei "pingt" der {CMK}-Server den überwachten Host an, der daraufhin die TLS-Verbindung zum {CMK}-Server aufbaut und darüber die Agentenausgabe überträgt. 
Da nur {CMK}-Server, zu denen ein Vertrauensverhältnis besteht, diese Datenübertragung initiieren können, besteht schon einmal kein Risiko, dass Daten in die falschen Hände gelangen.


=== Zugriff über IP-Adressen beschränken

Da nur authorisierte {CMK}-Server Daten abrufen können und nicht berechtigte Server nach einigen Bytes Handshake scheitern, ist die Gefahr einer _Denial of Service (DoS)_ Attacke sehr gering.
Aus diesem Grund ist aktuell keine weitere Zugriffsbeschränkung vorgesehen.
Selbstverständlich können Sie Port 6556 per `iptables` gegen unberechtigten Zugriff sperren.
Eine möglicherweise vorhandene und per Bakery auf Clients übertragene Regel zur Einschränkung des Zugriffs auf bestimmte IP-Adressen wird vom Agent Controller ignoriert.


=== Eingebaute Verschlüsselung abschalten

Insbesondere bei einem Update des Agenten kann es sein, dass die xref:agent_linux_legacy#encryption[eingebaute (symmetrische) Verschlüsselung] aktiv ist, die vom Agentenskript selbst durchgeführt wird.
Sind TLS-Verschlüsselung und eingebaute Verschlüsselung gleichzeitig aktiv, dann ist die Entropie der übertragenen Daten so hoch, dass die ab Version {v21} aktive Komprimierung keine Ersparnis der übertragenen Daten bringt – und die CPUs sowohl des Hosts als auch des {CMK}-Servers mit zusätzlichen weiteren Ver- und Entschlüsselungsschritten belasten.

Aus diesem Grund sollten Sie die eingebaute Verschlüsselung zeitnah nach dem Wechsel auf TLS deaktivieren.
In der {CRE} erreichen Sie das, indem Sie die Konfigurationsdatei `/etc/check_mk/encryption.cfg` umbenennen.

{cee-only} In den {CEE} können Sie vorhandene Regeln unter [.guihint]#Setup > Agents > Access to agents > Encryption (Linux, Windows)# im Abschnitt  [.guihint]#Encryption (Linux, Windows)# auf _Use TLS encryption_ umstellen und anschließend die Agentenpakete xref:agent_deployment#[neu backen].
Nach dem nächsten automatischen Agenten-Update ist die Verschlüsselung des Agentenskriptes abgeschaltet, aber durch den Agent Controller die Verschlüsselung garantiert.
Beachten Sie, dass nach dem automatischen Agenten-Update nur noch registrierte Hosts Monitoring-Daten liefern können.


[#disabled_sections]
== Sektionen deaktivieren

Die Ausgabe des {CMK}-Agenten ist in Sektionen unterteilt.
Jede dieser Sektionen enthält zusammengehörige Informationen und ist meist einfach die Ausgabe eines Diagnosebefehls.
Sektionen beginnen immer mit einem Sektions-Header.
Dies ist eine Zeile, die in `<<<` und `>>>` eingeschlossen ist.

Bis auf die {CMK} eigenen Sektionen, können Sie jede der über 30 Sektionen, die der Agent standardmäßig erzeugt, einzeln deaktivieren.
Konkret bedeutet dies, dass die entsprechenden Befehle durch den Agenten überhaupt nicht ausgeführt werden und ggf. Rechenzeit eingespart werden kann.
Andere Gründe für die Deaktivierung könnten sein, dass Sie sich für bestimmte Informationen einer gewissen Gruppe von Hosts schlicht nicht interessieren, oder dass ein bestimmter Host fehlerhafte Werte liefert und Sie den Abruf dieser Daten kurzzeitig aussetzen wollen.

Als Nutzer einer der {CEE} können Sie über [.guihint]#Setup > Agents > Windows, Linux, Solaris, AIX > Agent rules > Disabled sections (Linux agent)# einfach eine Regel anlegen, welche dann von der xref:glossar#agent_bakery[Agentenbäckerei] berücksichtigt wird.

.In den {EE} können Sie Sektionen per Regel deaktivieren
image::agent_linux_disabled_sections.png[alt="Liste der Agentenregeln für den Linux-Agenten."]

In der Regel finden Sie für jede deaktivierbare Sektion eine eigene Checkbox.
Für jede angewählte Checkbox finden Sie dann -- nachdem der neu gebackene Agent auf den ausgewählten Hosts installiert wurde -- in der Konfigurationsdatei der Agentenbäckerei `/etc/check_mk/exclude_sections.cfg` einen eigenen Eintrag.
Würden Sie in der Regel beispielsweise die beiden Optionen `Running processes` und `Systemd services` auswählen, sähe die passende Konfigurationsdatei wie folgt aus:

./etc/check_mk/exclude_sections.cfg
[{file}]
----
MK_SKIP_PS=yes
MK_SKIP_SYSTEMD=yes
----

Nutzer der {CRE} können die oben genannte Datei `/etc/check_mk/exclude_sections.cfg` manuell anlegen und dort die Sektionen eintragen, die deaktiviert werden sollen.
Alle deaktivierbaren Sektionen sind in der Datei `~/share/check_mk/agents/cfg_examples/exclude_sections.cfg` aufgelistet.


[#plugins]
== Agent um Plugins erweitern

=== Was sind Agentenplugins?

Das Agentenskript `/usr/bin/check_mk_agent` enthält eine ganze Reihe von Sektionen, welche Überwachungsdaten für diverse Check-Plugins liefern, die dann von der Service-Erkennung automatisch gefunden werden.
Dazu gehören alle wichtigen Überwachungen des Betriebssystems.

Darüber hinaus gibt es die Möglichkeit, den Agenten um _Agentenplugins_ zu erweitern.
Das sind kleine Skripte oder Programme, die vom Agenten aufgerufen werden und diesen um weitere Sektionen mit zusätzlichen Monitoring-Daten erweitern.
Das {CMK}-Projekt liefert eine ganze Reihe solcher Plugins mit aus, welche -- wenn sie korrekt installiert und konfiguriert sind -- in der Service-Erkennung automatisch neue Services liefern.

Warum sind diese Plugins nicht einfach in den Agenten fest integriert?
Für jedes der Plugins gibt es einen der folgenden Gründe:

* Das Plugin ist in einer anderen Programmiersprache als Shell geschrieben und kann daher nicht inline realisiert werden (Beispiel: `mk_logwatch`).
* Das Plugin benötigt sowieso eine Konfiguration, ohne die es nicht funktionieren würde (Beispiel: `mk_oracle`).
* Das Plugin ist so speziell, dass es von den meisten Anwendern nicht benötigt wird (Beispiel: `plesk_domains`).


[#manualplugins]
=== Manuelle Installation

Die mitgelieferten Plugins für Linux und Unix finden Sie alle auf dem {CMK}-Server unter `share/check_mk/agents/plugins`.
Auch über die Download-Seite der Agenten im Setup-Menü (wie im Kapitel xref:download_gui[Installation] beschrieben) sind diese im Kasten [.guihint]#Plugins# verfügbar:

.Der Anfang der langen Liste verfügbarer Agentenplugins
image::agent_linux_files_agent_plugins.png[alt="Download-Seite mit den Agentenplugins."]

Zu allen von uns mitgelieferten Agentenplugins existieren die passenden Check-Plugins, welche deren Daten auswerten und Services erzeugen können.
Diese sind bereits mitinstalliert, so dass neu gefundene Services sofort erkannt und konfiguriert werden können.

*Hinweis:* Bevor Sie ein Plugin auf dem Host installieren, werfen Sie einen Blick in die entsprechende Datei.
Oft finden Sie dort wichtige Hinweise zur korrekten Verwendung des Plugins.

Die eigentliche Installation ist dann einfach:
Kopieren Sie die Datei nach `/usr/lib/check_mk_agent/plugins`.
Achten Sie dabei darauf, dass diese ausführbar ist.
Falls nicht, verwenden Sie ein `chmod 755`.
Der Agent wird das Plugin sonst nicht ausführen.
Insbesondere, wenn Sie die Dateien nicht per `scp` übertragen sondern per HTTP von der Download-Seite holen, geht die Ausführungsberechtigung verloren.

Sobald das Plugin ausführbar ist und im richtigen Verzeichnis liegt, wird es vom Agenten automatisch aufgerufen und es entsteht eine neue Sektion in der Agentenausgabe.
Diese trägt üblicherweise den gleichen Namen wie das Plugin.
Komplexe Plugins (z.B. `mk_oracle`) erzeugen sogar eine ganze Reihe an neuen Sektionen.


[#pluginconfig]
=== Konfiguration

Manche Plugins brauchen eine Konfigurationsdatei in `/etc/check_mk/`, damit sie funktionieren können.
Bei anderen ist eine Konfiguration optional und ermöglicht besondere Features oder Anpassungen.
Wieder andere funktionieren einfach so.
Sie haben verschiedene Quellen, um an Informationen zu kommen:

* Die Dokumentation der zugehörigen Check-Plugins in Ihrer {CMK}-Instanz, welche Sie über [.guihint]#Setup > Services > Catalog of check plugins# erreichen.
* Kommentare im Plugin selbst (oft sehr hilfreich!).
* Einen passenden Artikel in diesem Handbuch (z.B. über das Überwachen von xref:monitoring_oracle#[Oracle])


[#async_plugins]
=== Asynchrone Ausführung

Ebenso wie bei xref:mrpe[MRPE] können Sie auch Plugins asynchron ausführen lassen.
Das ist sehr nützlich, wenn die Plugins eine lange Laufzeit haben und die gewonnenen Statusdaten ohnehin nicht jede Minute neu erzeugt werden brauchen.

Die asynchrone Ausführung wird nicht über eine Datei konfiguriert.
Stattdessen erzeugen Sie unter `/usr/lib/check_mk_agent/plugins` ein Unterverzeichnis, dessen Name eine Zahl ist: eine Anzahl von Sekunden.
Plugins in diesem Verzeichnis werden nicht nur asynchron ausgeführt, sondern gleichzeitig geben Sie mit der Sekundenzahl eine Mindestwartezeit vor, bevor das Plugin erneut ausgeführt werden soll.
Wird der Agent vor Ablauf der Zeit erneut abgefragt, verwendet er zwischengespeicherte Daten von der letzten Ausführung des Plugins.
Damit können Sie ein größeres Intervall für das Plugin konfigurieren, als die typische eine Minute.

Folgendes Beispiel zeigt, wie das Plugin `my_foo_plugin` von synchroner Ausführung auf eine asynchrone Ausführung mit einem Intervall von 5 Minuten (oder 300 Sekunden) umgestellt wird:

[{shell}]
----
{c-root} cd /usr/lib/check_mk_agent/plugins
{c-root} mkdir 300
{c-root} mv my_foo_plugin 300
----

*Hinweis:* Beachten Sie, dass einige Plugins bereits von sich aus eine asynchrone Ausführung umsetzen.
Dazu gehört `mk_oracle`.
Installieren Sie solche Plugins direkt nach `/usr/lib/check_mk_agent/plugins`.


[#install_plugins_using_bakery]
=== Installation über die Agentenbäckerei

{cee-only}
In den {CEE} können die mitgelieferten Plugins über die xref:glossar#agent_bakery[Agentenbäckerei] konfiguriert werden.
Diese sorgt sowohl für die Installation des Plugins selbst als auch für die korrekte Erstellung der Konfigurationsdatei, falls eine notwendig sein sollte.

Jedes Plugin wird über eine Agentenregel konfiguriert.
Sie finden die passenden Regelsätze in [.guihint]#Setup > Agents > Windows, Linux, Solaris, AIX > Agent rules > Agent Plugins#:

.Liste mit Regeln für die Agentenplugins in den {EE}
image::agent_linux_rules_agent_plugins.png[alt="Seite mit den Regeln zur Konfiguration der Agentenplugins in den {EE}."]


=== Manuelle Ausführung

Da Agentenplugins ausführbare Programme sind, können Sie diese zu Test-und Diagnosezwecken auch von Hand ausführen.
Es gibt allerdings Plugins, welche bestimmte vom Agenten gesetzte Umgebungsvariablen brauchen, um z.B. ihre Konfigurationsdatei zu finden.
Setzen Sie diese vor der Ausführung von Hand:

[{shell-raw}]
----
{c-root} export MK_LIBDIR=/usr/lib/check_mk_agent
{c-root} export MK_CONFDIR=/etc/check_mk
{c-root} export MK_VARDIR=/var/lib/check_mk_agent
{c-root} /usr/lib/check_mk_agent/plugins/mk_foobar
<<<foobar>>>
FOO BAR BLA BLUBB 17 47 11
----

Einige Plugins kennen auch spezielle Aufrufoptionen zum Debuggen.
Werfen Sie einfach einen Blick in die Plugin-Datei.


[#e2e_monitoring]
== Einbinden von klassischen (Nagios-) Check-Plugins

[#mrpe]
=== Plugins über MRPE ausführen

Es gibt zwei gute Gründe, Nagios-Plugins auch unter {CMK} zu nutzen.
Wenn Sie Ihr Monitoring von einer Nagios basierten Lösung auf {CMK} migriert haben, können Sie ältere Check-Plugins, zu denen es noch kein {CMK}-Pendant gibt, zunächst weiternutzen.
In vielen Fällen sind das selbst geschriebene Plugins in Perl oder Shell. 

Der zweite Grund für die Verwendung von Nagios-Plugins ist echtes End-to-End-Monitoring.
Nehmen wir an, Sie haben Ihren {CMK}-Server, einen Webserver und einen Datenbankserver über ein großes Rechenzentrum verteilt.
In so einem Fall sind die Antwortzeiten des Datenbankservers vom {CMK}-Server aus gemessen wenig aussagekräftig.
Weit wichtiger ist es, diese Werte für die Verbindung zwischen Web- und Datenbankserver zu kennen.

Der {CMK}-Agent bietet einen einfachen Mechanismus, diesen beiden Anforderungen gerecht zu werden:
_MK's Remote Plugin Executor_ oder kurz _MRPE_.
Der Name ist bewusst eine Analogie zum _NRPE_ von Nagios, der dort die gleiche Aufgabe übernimmt.

Der MRPE ist im Agenten fest eingebaut und wird mit einer einfachen Textdatei konfiguriert, welche Sie als `/etc/check_mk/mrpe.cfg` selbst anlegen.
Dort geben Sie pro Zeile einen Pluginaufruf an -- zusammen mit dem Namen, den {CMK} für den Service verwenden soll, den es dafür automatisch erzeugt.
Hier ist ein Beispiel:

./etc/check_mk/mrpe.cfg
[{file}]
----
Foo_Application /usr/local/bin/check_foo -w 60 -c 80
Bar_Extender /usr/local/bin/check_bar -s -X -w 4:5
----

Wenn Sie jetzt den Agenten lokal laufen lassen, finden Sie pro Plugin eine neue Sektion mit dem Titel `+<<<mrpe>>>+`, welche Name, Exitcode und Ausgabe des Plugins enthält.
Das können Sie mit folgendem praktischen `grep`-Befehl überprüfen:

[{shell-raw}]
----
{c-root} check_mk_agent | grep -A1 '^...mrpe'
<<<mrpe>>>
(check_foo) Foo_Application 0 OK - Foo server up and running
<<<mrpe>>>
(check_bar) Bar_Extender 1 WARN - Bar extender overload 6.012|bar_load=6.012
----

Die `0` bzw. `1` in der Ausgabe stehen für die Exitcodes der Plugins und folgen dem klassischen Schema:
`0` = {OK}, `1` = {WARN}, `2` = {CRIT} und `3` = {UNKNOWN}.

Den Rest macht jetzt {CMK} automatisch.
Sobald Sie die Service-Erkennung für den Host aufrufen, werden die beiden neuen Services als xref:wato_services#available[verfügbar] angezeigt.
Das sieht dann so aus:

.Für die beiden MRPE Plugins wird je ein Service erkannt
image::agent_linux_mrpe_checks.png[alt="Liste der erkannten Services für die per MRPE eingerichtetetn Plugins."]

Übrigens: Aufgrund der Syntax der Datei darf der Name keine Leerzeichen enthalten.
Sie können aber mithilfe der gleichen Syntax wie in URLs ein Space durch `%20` ersetzen (ASCII-Code 32 für Space ist Hexadezimal 20):

./etc/check_mk/mrpe.cfg
[{file}]
----
Foo%20Application /usr/local/bin/check_foo -w 60 -c 80
Bar%20Extender /usr/local/bin/check_bar -s -X -w 4:5
----


=== Asynchrone Ausführung

Beachten Sie, dass alle Plugins, die Sie in `mrpe.cfg` aufführen, der Reihe nach synchron ausgeführt werden.
Die Plugins sollten daher keine allzu große Ausführungszeit haben.
Wenn ein Plugin hängt, verzögert sich die Ausführung aller weiteren.
Das kann dazu führen, dass das komplette Abfragen des Agenten durch {CMK}-in einen Timeout läuft und der Host nicht mehr zuverlässig überwacht werden kann.

Wenn Sie wirklich länger laufende Plugins benötigen, sollten Sie diese auf asynchrone Ausführung umstellen und das Problem damit vermeiden.
Dabei legen Sie eine Zeit in Sekunden fest, die ein berechnetes Ergebnis Gültigkeit haben soll, z.B. `300` für fünf Minuten.
Setzen Sie dazu in `mrpe.cfg` nach dem Servicenamen den Ausdruck `(interval=300)`:

./etc/check_mk/mrpe.cfg
[{file}]
----
Foo_Application (interval=300) /usr/local/bin/check_foo -w 60 -c 80
Bar_Extender /usr/local/bin/check_bar -s -X -w 4:5
----

Das hat mehrere Auswirkungen:

* Das Plugin wird in einem Hintergrundprozess ausgeführt und bremst nicht mehr die Ausführung des Agenten.
* Weil der Agent die Ausführung nicht abwartet, wird das Ergebnis erst beim _nächsten_ Aufruf des Agenten geliefert.
* Frühestens nach 300 Sekunden wird das Plugin neu ausgeführt.
Bis dahin wird das alte Ergebnis wiederverwendet.

Damit können Sie also Tests, die etwas mehr Rechenzeit benötigen, auch in größeren Intervallen ausführen, ohne dass Sie dazu am {CMK}-Server etwas konfigurieren müssen.


=== MRPE mit der Agentenbäckerei

{cee-only}
Nutzer der {EE} können MRPE auch mit der xref:glossar#agent_bakery[Agentenbäckerei] konfigurieren.
Zuständig dafür ist der Regelsatz [.guihint]#Setup > Agents > Windows, Linux Solaris, AIX > Agent Rules > Generic Options > Execute MRPE checks#.
Dort können Sie die gleichen Dinge wie oben beschrieben konfigurieren.
Die Datei `mrpe.cfg` wird dann von der Bäckerei automatisch generiert.

.MRPEs können in den {EE} bequem per Regel konfiguriert werden
image::agent_linux_mrpe_rule.png[alt="Regel zur MRPE-Konfiguration in der Agentenbäckerei."]


==== Backen der Plugins

Auch die Check-Plugins selbst können Sie mit dem Paket ausliefern lassen.
Damit ist der Agent dann komplett und braucht keine manuelle Installation von weiteren Dateien.
Das Ganze geht so:

. Erzeugen Sie auf dem {CMK}-Server das Verzeichnis `local/share/check_mk/agents/custom`.
. Erzeugen Sie dort ein Unterverzeichnis -- z.B. `my_mrpe_plugins`.
. Erzeugen Sie wiederum darin das Unterverzeichnis `bin`.
. Kopieren Sie Ihre Plugins in den `bin`-Ordner.
. Legen Sie eine Regel in [.guihint]#Setup > Agents > Windows, Linux, Solaris, AIX > Agent rules > Generic Options > Deploy custom files with agent# an.
. Wählen Sie `my_mrpe_plugins` aus, speichern Sie und backen Sie!

Die Check-Plugins werden jetzt in das Standard-`bin`-Verzeichnis Ihres Agenten installiert.
Per Default ist das `/usr/bin`.
Bei der Konfiguration der MRPE-Checks verwenden Sie dann also `/usr/bin/check_foo` anstelle von `/usr/local/bin/check_foo`.


[#hw_monitoring]
== Hardware überwachen

Zu einer möglichst vollständigen Überwachung eines Linux-Servers gehört natürlich auch die Hardware.
Die Überwachung geschieht teils direkt mit dem {CMK}-Agenten, teils auch über spezielle xref:plugins[Plugins].
Außerdem gibt es noch Fälle, in denen man per SNMP oder sogar über ein separates Managementboard eine Überwachung umsetzen kann.


=== Überwachung der SMART-Werte

Moderne Festplatten verfügen fast immer über _S.M.A.R.T._ (Self-Monitoring, Analysis and Reporting Technology).
Dieses System zeichnet kontinuierlich Daten zum Zustand der HDD oder SSD auf und {CMK} kann mit dem Plugin `smart` diese Werte abrufen und die wichtigsten davon auswerten.
Damit das Plugin nach der Installation auch funktioniert, müssen folgende Voraussetzungen erfüllt sein:

* Das Paket `smartmontools` muss installiert sein. Sie können es auf allen modernen Distributionen über den jeweiligen Paketmanager installieren.
* Falls die Festplatten an einen RAID-Controller angeschlossen sind und dieser Zugriff auf die SMART-Werte erlaubt, muss das jeweilige Tool dazu installiert sein. Unterstützt werden `tw_cli` (3ware) und `megacli` (LSI).

Sind diese Voraussetzungen erfüllt und ist das Plugin installiert, werden die Daten automatisch ausgelesen und der Ausgabe des Agenten angehängt.
In {CMK} können Sie die xref:wato_services#available[neuen Services] dann auch direkt aktivieren:

.Von der Service-Erkennung gefundene SMART-Services
image::agent_linux_smart_stats.png[alt="Liste gefundener SMART-Services in der Service-Erkennung."]

Sollte -- wie im Screenshot zu sehen -- gelegentlich `cmd_timeout` auftreten, stellen Sie das Plugin auf asynchrone Ausführung im Abstand einiger Minuten um.


=== Überwachung mit Hilfe von IPMI

IPMI (Intelligent Platform Management Interface) ist eine Schnittstelle zum Hardware-Management, welche auch die Überwachung der Hardware ermöglicht.
{CMK} nutzt dafür `freeipmi`, um direkt und ohne Netzwerk auf die Hardware zuzugreifen.
`freeipmi` wird aus den Paketquellen installiert und ist danach sofort einsatzbereit, so dass die Daten schon beim nächsten Aufruf von {CMK} übermittelt werden.

Falls `freeipmi` nicht verfügbar ist, oder andere Gründe gegen eine Installation sprechen, kann auch `ipmitool` verwendet werden.
`ipmitool` ist oft bereits auf dem System vorhanden und muss lediglich mit einem IPMI Gerätetreiber versorgt werden, wie ihn z.B. das Paket `openipmi` zur Verfügung stellt.
Auch hier müssen Sie danach nichts weiter tun.
Die Daten werden von {CMK} automatisch erfasst.

Zur Fehlerdiagnose können Sie die Tools auch händisch in einer Shell des Hosts ausführen.
Haben Sie das Paket `freeipmi` installiert, können Sie die Funktion hiermit kontrollieren:

[{shell}]
----
{c-root} ipmi-sensors Temperature
32 Temperature_Ambient 20.00_C_(1.00/42.00) [OK]
96 Temperature_Systemboard 23.00_C_(1.00/65.00) [OK]
160 Temperature_CPU_1 31.00_C_(1.00/90.00) [OK]
224 Temperature_CPU_2 NA(1.00/78.00) [Unknown]
288 Temperature_DIMM-1A 54.00_C_(NA/115.00) [OK]
352 Temperature_DIMM-1B 56.00_C_(NA/115.00) [OK]
416 Temperature_DIMM-2A NA(NA/115.00) [Unknown]
480 Temperature_DIMM-2B NA(NA/115.00) [Unknown]
----

Wenn `ipmitool` installiert wurde, können Sie die Ausgabe der Daten mit folgendem Befehl prüfen:

[{shell}]
----
{c-root} ipmitool sensor list
UID_Light 0.000 unspecified ok na na 0.000 na na na
Int._Health_LED 0.000 unspecified ok na na 0.000 na na na
Ext._Health_LED 0.000 unspecified ok na na 0.000 na na na
Power_Supply_1 0.000 unspecified nc na na 0.000 na na na
Fan_Block_1 34.888 unspecified nc na na 75.264 na na na
Fan_Block_2 29.792 unspecified nc na na 75.264 na na na
Temp_1 39.000 degrees_C ok na na -64.000 na na na
Temp_2 16.000 degrees_C ok na na -64.000 na na na
Power_Meter 180.000 Watts cr na na 384.00
----


=== Herstellerspezifische Tools

Viele große Server-Hersteller bieten auch eigene Tools an, um die Hardware-Informationen auszulesen und über SNMP bereitzustellen.
Es gelten dabei die folgenden Voraussetzungen, um diese Daten abrufen und {CMK} bereitstellen zu können:

* Auf dem Linux-Host ist ein SNMP-Server eingerichtet.
* Das Tool des Herstellers ist installiert (z.B. Dells _OpenManage_ oder Supermicros _SuperDoctor_).
* Der Host ist in {CMK} für die Überwachung per SNMP *zusätzlich* zum {CMK}-Agenten konfiguriert.
Im Artikel zur xref:snmp#snmp_cmk_agent[Überwachung mit SNMP] erfahren Sie, wie das geht.

Die dadurch unterstützten neuen Services für die Hardware-Überwachung werden dann automatisch erkannt.
Es werden keine weiteren Plugins benötigt.


=== Zusätzliche Überwachung über das Managementboard

Man kann zu jedem Host ein Managementboard konfigurieren und zusätzliche Daten per SNMP holen.
Die dadurch erkannten Services werden dann ebenfalls dem Host zugeordnet.

Die Einrichtung des Managementboards ist dabei sehr einfach.
Geben Sie in den Eigenschaften des Hosts lediglich das Protokoll, die IP-Adresse und die Zugangsdaten für SNMP an und speichern Sie die neuen Einstellungen ab:

.In den Eigenschaften des Hosts im Setup wird das Managementboard für SNMP konfiguriert 
image::agent_linux_snmp_management_board.png[alt="Die Konfiguration des Managementboards für SNMP in den Eigenschaften des Hosts."]

In der Service-Erkennung werden die neu erkannten Services dann wie gewohnt aktiviert.


[#uninstall]
== Deinstallation

Wie die xref:install[Installation] erfolgt auch die Deinstallation des Agenten mit dem Paketmanager des Betriebssystems.
Geben Sie hier den Namen des installierten Pakets an, nicht den Dateinamen der ursprünglichen RPM/DEB-Datei. 

So finden Sie heraus, welches DEB-Paket installiert ist:

[{shell}]
----
{c-root} dpkg -l | grep check-mk-agent
ii  check-mk-agent          2.1.0b1-1          all          Checkmk Agent for Linux
----

Die Deinstallation des DEB-Pakets erfolgt dann mit `dpkg --purge`:

[{shell}]
----
{c-root} dpkg --purge check-mk-agent
(Reading database ... 739951 files and directories currently installed.)
Removing check-mk-agent (2.1.0b5-1) ...
Removing systemd units: check-mk-agent.socket, check-mk-agent-async.service, cmk-agent-ctl-daemon.service, check-mk-agent@.service
Deactivating systemd unit 'check-mk-agent.socket'...
Deactivating systemd unit 'check-mk-agent-async.service'...
Deactivating systemd unit 'cmk-agent-ctl-daemon.service'...
Reloading xinetd
Purging configuration files for check-mk-agent (2.1.0b5-1) ...
----

So finden Sie heraus, welches RPM-Paket installiert ist:

[{shell}]
----
{c-root} rpm -qa | grep check-mk
----

Die Deinstallation des RPM-Pakets erfolgt unter `root` mit dem Befehl `rpm -e`.


[#files]
== Dateien und Verzeichnisse

=== Pfade auf dem überwachten Host

[cols="45,~",options="header"]
|===
|Pfad |Bedeutung
|`/usr/bin/` |Installationsverzeichnis für das Agentenskript `check_mk_agent` und des Agent Controllers `cmk-agent-ctl` auf dem Zielsystem.
|`/usr/lib/check_mk_agent` |Basisverzeichnis für Erweiterungen des Agenten.
|`/usr/lib/check_mk_agent/plugins` |Verzeichnis für Plugins, welche automatisch vom Agenten ausgeführt werden sollen und dessen Ausgabe um zusätzliche Überwachungsdaten erweitern. Plugins können in jeder verfügbaren Programmiersprache geschrieben werden.
|`/usr/lib/check_mk_agent/local` |Verzeichnis für eigene xref:localchecks#[lokale Checks].
|`/var/lib/check_mk_agent` |Basisverzeichnis für Daten des Agenten.
|`/var/lib/check_mk_agent/cache` |Hier werden Cache-Daten einzelner Sektionen abgelegt und dem Agenten, solange die Cache-Daten gültig sind, bei jeder Ausführung wieder angehängt.
|`/var/lib/check_mk_agent/job` |Verzeichnis für überwachte Jobs. Diese werden der Agentenausgabe bei jeder Ausführung angehängt.
|`/var/lib/check_mk_agent/spool` |Enthält Daten, die z.B. von Cronjobs erstellt werden und eine eigene Sektion beinhalten. Diese werden ebenfalls der Agentenausgabe angehängt.
|`/var/lib/check_mk_agent/registered_connections.json` |Enthält eine Liste der mit dem Agent Controller registrierten Verbindungen.
|`/var/agent-receiver/received-outputs` |Enthält für jede Verbindung deren UUID als Softlink, der auf den Ordner mit der Agentenausgabe zeigt.
|`/etc/check_mk` |Ablage von Konfigurationsdateien für den Agenten.
|`/etc/check_mk/mrpe.cfg` |Konfigurationsdatei für xref:mrpe[MRPE] -- für die Ausführung von klassischen Nagios-kompatiblen Check-Plugins.
|`/etc/check_mk/encryption.cfg` |Konfiguration für die xref:agent_linux_legacy#encryption[eingebaute Verschlüsselung] der Agentendaten.
|`/etc/check_mk/exclude_sections.cfg` |Konfigurationsdatei für die xref:disabled_sections[Deaktivierung bestimmter Sektionen] des Agenten.
|===


=== Pfade auf dem {CMK}-Server

[cols="45,~",options="header"]
|===
|Pfad |Bedeutung
|`local/share/check_mk/agents/custom` |Basisverzeichnis für eigene Dateien, die mit einem gebackenen Agenten ausgeliefert werden sollen.
|`share/check_mk/agents/cfg_examples/exclude_sections.cfg` |Beispielhafte Konfigurationsdatei für das Deaktivieren von Sektionen.
|===
////
