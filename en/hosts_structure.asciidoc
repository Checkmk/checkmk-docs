// -*- coding: utf-8 -*-
include::global_attr.adoc[]
= Host structuring
:revdate: draft
:title: Host structuring
:description: Scalability is part of the basic {CMK} design. You can learn about the options for structuring hosts here.

{related-start}
xref:hosts_setup#[Host administration]
{related-end}


[#intro]
== Introduction

_This article is currently a draft version._
_At present, it essentially contains only the chapters on parents and host groups that were previously included in the xref:hosts_setup#[Host administration] article._
_When this article has been completed, it should provide an overview of the various structuring elements in {CMK} and explain their similarities and differences._
_You should then have all the information at hand to set up the structure that is appropriate for your operational environment._


[#folder]
== Folders and inheritances

[#folder_structure]
=== Structuring with folders

Everyone who works with computers is familiar with files and folders.
In {CMK} this well-known principle has been adopted for the structuring of hosts, which are stored in folders.
Only the [.guihint]#Main# folder -- the folder tree's root -- is predefined.
Below (within) this main folder, you can create your own folder structure with as many subfolders as desired, visualized as a so-called host tree. Commonly used criteria for building the host tree are location, technology and organizational structure.
You can access the [.guihint]#Main# folder by selecting [.guihint]#Setup > Hosts > Hosts#. 

Via folders, attributes can be *inherited* by subfolders and the hosts they contain.
See the xref:hosts_setup#inheritance[Host administration] article for details on how inheritance works.
Inherited are the folder attributes, i.e. the folder properties displayed in the [.guihint]#Setup# on the [.guihint]#Folder properties# page such as monitoring agents and permissions -- but also other structuring elements such as host tags, labels, or parents.
Many of the folder properties can also be found in the host properties on the [.guihint]#Properties of host# page.
Inheritance is especially useful for attributes that are common to many hosts, such as whether the host should be monitored by {CMK} agent or by SNMP.
Another advantage with inheriting folder attributes is that you can prepare folders to hold any hosts that will be added in the future.
Just drop the new host into the appropriate folder and all predefined attributes will be automatically correct for the new host.

In order to take full advantage of inheritance, it has proven useful to first think about an organizational system and then fill this system with content.
Thus, you first create the structure of the folders and their hierarchy, and you then sort your hosts into the appropriate folders.

This is all the more important the larger the environment and the more numerous the hosts.
Once a folder structure has been set up, it can be later modified and folders can be renamed without any problems.
Care must be taken, however:
Moving a host to another folder may change its attributes  without you being aware of it -- i.e. the target folder may have different attributes from the source folder.

Only in rare scenarios can a folder structure alone represent the complexity of real systems however.
If you want (or need) to organize your hosts according to _many different criteria_, the host tags described in the xref:host_tags[next chapter] can additionally come in handy.


[#folder_monitoring]
=== The folder structure in monitoring

The tree structure generated by the folders is also visible in the xref:glossar#monitoring_environment[monitoring environment].


[#filter_bar]
[discrete]
=== The filter bar

Firstly, in the xref:glossar#view[view]'s filter bar, there is the [.guihint]#Folder# filter, which allows you to restrict the current view to the hosts below a specific folder.

As the following image shows, further filters are also available for other structuring elements such as host tags, labels and host groups.

.In the filter bar you have access to various structuring elements
image::hosts_filterbar.png[alt="Table view with filter bar and selected filters for structuring elements.",width=60%]


[#tree_of_folders]
[discrete]
=== Tree of folders

Secondly, in the xref:user_interface.html#sidebar[sidebar], the [.guihint]#Tree of folders# snap-in provides the same selection options as the xref:user_interface#monitor_menu[Monitor menu], but can additionally limit the display to one folder:

.The [.guihint]#Tree of folders# snap-in displays the folder structure at the very bottom
image::hosts_treeoffolders_snapin.png[alt="Tree of folders snap-in.",width=50%]


[#host_tags]
== Host tags


[#labels]
== Labels


[#parents]
== Parents


[#parents_structure]
=== Structuring using parents

You have already learned what parents are and how they work in the xref:monitoring_basics#parents[Basic principles of monitoring] article.


[#parents_create_manual]
=== Creating parents manually

To define a parent for a single host, do the following:
Select [.guihint]#Setup > Hosts > Hosts# and click the desired host to display its properties.
In the [.guihint]#Basic settings# box, enter the parent by its name or IP address.
As soon as a parent has been specified, a further input field for an additional parent appears:

.Multiple parents can also be specified during manual assignment
image::hosts_properties_parents.png[alt="Dialog with the properties of a host for setting the parents."]

*Important*: Specify only direct parent hosts.

In a similar way, parents can also be specified in the properties of folders and thus inherited by the hosts the folders contain, as described in the earlier chapter on xref:folder[Folders and inheritances].


[#parents_scan]
=== Specifying parents using a scan

When setting up a new monitoring system, and from the start creating a well organized structure with folders and parents, you will probably be fine with parent inheritance via folders.
You can also set up parents automatically via the [.guihint]#Parent scan# however.

Using the IP protocol on the network layer of the OSI model (layer 3), using `traceroute`, the scan searches for the final gateway upstream of a host.
If such a gateway is found and its IP address belongs to one of your monitored hosts, it is set as the parent.
If `traceroute` does not get any information from the _hops_ preceding the targeted host, the latest successful hop is used.

However, if no gateway is found among the monitored hosts, {CMK} creates an artificial 'ping-only host' by default in the [.guihint]#Parents# folder which is created at the same time.

However, this default setting can also produce undesirable results. As an example, let's take a typical, small network with the address range _192.168.178.0/24._
If a host with an address from a different address range -- which cannot be pinged -- is now added to the monitoring, the scan will try the route via the router,  and will find only the network provider's node there.
And so, for example, a telecom server from the WAN area could then be set as the parent for this host.
To avoid this you can deactivate the corresponding option before the scan.

If you want to scan a folder with new hosts for parents, do the following:
First open the desired folder and select [.guihint]#Hosts > Detect network parent hosts# from the menu to open the scan configuration.
By the way, instead of scanning an entire folder, you can also just scan a subset of hosts by selecting them in advance in the first column of the list.

.The scan provides numerous options for configuration
image::hosts_parent_scan.png[alt="Dialog with scan configuration for the parents."]

To completely rescan all hosts in all subfolders, regardless of any manually set parents, select the [.guihint]#Include all subfolders# and [.guihint]#Scan all hosts# options.
In the [.guihint]#Performance# section, you can tailor the scan duration, which can take quite a long time if you have many hosts.

Under [.guihint]#Creation of gateway hosts# you determine whether, how and under which alias newly found parent hosts are created.
Disable this function if you want to limit parents to monitored hosts.

Now click [.guihint]#Start#.
You can watch the output of the scan in real time while it is being performed.

You will then see the configured parents and, if applicable, a new [.guihint]#Parents# folder in [.guihint]#Main# (if you specified this before the scan).

.In the [.guihint]#Setup# the parents are displayed in a separate column
image::hosts_parents_list.png[alt="List of hosts with display of the parents."]

This completes the scan.


[#parents_monitoring]
=== Parents in monitoring

After a scan has been performed and the changes have been activated, the parent-child relationships are visualized as a topology map, which you can access via [.guihint]#Monitor > Overview > Parent / Child topology#:

.Display of the parent-child relationships in monitoring
image::hosts_parents_topology.png[alt="Network topology mapped from parent-child relationships.",width=55%]

*Tip:* If the results from the scan do not seem plausible in some places, a manual call to `traceroute` can sometimes be helpful for tracing the individual hops.


[#host_groups]
== Host groups


[#host_groups_using]
=== Working with host groups

Host groups allow you to collect a number of hosts together for display in a monitoring view.
For example, you can display all Linux servers, Windows servers, and certain application servers together by setting up a host group for each of these server types.

A host group is populated using a rule. 
In this rule's conditions, you can access folders, host tags, and labels, as usual.
Host groups themselves do *not* by default appear as selection criteria in rules because they are not used for configuration, rather they are used for views.


[#host_groups_create]
=== Creating host groups

You can find the host groups under [.guihint]#Setup > Hosts > Host groups#.

You create a new host group via the [.guihint]#Add group# button.
The creation is a simple process and is limited to the assignment of a unique name -- which cannot be changed later -- and an alias:

.With a name and an alias, the host group is now configured
image::hosts_hostgroups_properties.png[alt="Dialog with the properties of a host group."]


[#host_groups_include_hosts]
=== Adding hosts to host groups

To add hosts to host groups, use the [.guihint]#Assignment of hosts to host groups# xref:glossar#rule_set[rule set], which can be found at [.guihint]#Setup > Hosts > Host monitoring rules#.
Create a new rule.

First, in the [.guihint]#Assignment of hosts to host groups# box, select the host group to which hosts should be assigned, such as the `My Linux servers` group in the example:

.The already created host groups are presented for selection
image::hosts_hostgroups_rule_assignment.png[alt="Dialog for selecting the host group in a rule."]

Next, in the [.guihint]#Conditions# box, attend to the filter or _the filters_ to delimit the group -- since filters can be combined, of course.
You can filter hosts by folders, host tags, host labels, or specify specific hosts.
If, in the host group, you want to include hosts with two tags from the same host tag group, you must create two separate rules.
In general, group assignments are cumulative.
Hosts can be in multiple groups and groups can be populated by multiple rules.

In the following example, we use the host label `cmk/os_family:linux` automatically assigned by {CMK} to add the Linux servers to the host group:

.Folders, host tags, and host labels, among others, are provided for specifying the condition
image::hosts_hostgroups_rule_conditions.png[alt="Dialog for setting the conditions for assignment to the host group."]

Afterwards you will still need to activate the changes as usual.


[#host_groups_monitoring]
=== Host groups in monitoring


[discrete]
==== Overview of the host groups

In monitoring, you can conveniently check the result of your assignments in the [.guihint]#Setup#.
The existing host groups will be listed under [.guihint]#Monitor > Overview > Host groups#:

.Host groups in monitoring
image::hosts_hostgroups_view.png[alt="View of host groups."]

Clicking on a host group's name will take you to a complete view of the hosts in that group.

Away from this overview you can use host groups in various places,
such as for creating views and NagVis maps, and as filters in rules for notifications and alert handlers.


[discrete]
==== Views

The only important thing when creating xref:glossar#view[views] (via [.guihint]#Customize > Visualization > Views#) is to select a [.guihint]#Datasource# that uses host groups, e.g. [.guihint]#Host groups#.

In the [.guihint]#Monitor# menu you can find ready-made views, for example [.guihint]#Host groups#, which we have already shown in the previous section.


[discrete]
==== NagVis maps

You can access xref:nagvis#[NagVis maps] with the xref:user_interface#sidebar[sidebar]'s [.guihint]#NagVis maps# snap-in.
In a NagVis map you get as a result for example the summary for a host group via hover menu over a single icon:

.Go to the NagVis maps via the sidebar's [.guihint]#NagVis maps# snap-in
image::hosts_hostgroups_nagvis.png[alt="Display a host group in a NagVis map."]


[discrete]
==== Notifications and alert handlers

In the xref:glossar#rule_set[rule sets] for xref:glossar#notification[notifications] and xref:alert_handlers#[alert handlers], the host groups are available as filters under the [.guihint]#Conditions#:

.Selection of host groups in in a notification rule
image::hosts_hostgroups_notifications_rule.png[alt="Dialog for selecting host groups in a notification rule."]
